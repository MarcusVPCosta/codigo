from __future__ import annotations


class ANOVA ():
  """Classe utilizada para apresentar os resultados da execução da técnica
 estatística conhecida como ANOVA (Análise da Variância).<BR>
 <BR>
 Para mais informações, consulte os comentários no método
 {@link Tabela#getANOVA(int,int) getANOVA}.<BR>"""

  def getF(self) -> float:
    """Retorna a razão entre MSB (Mean Square Between) e MSE (Mean Square Error). Quanto
 maior é esta razão, maior é a nossa crença em que as médias das amostras não são
 iguais (isto é, maior a probabilidade de rejeitar a hipótese "nula")."""

    pass


  def getGrausLiberdadeDenominador(self) -> int:
    """Retorna a quantidade de graus de liberdade no denominador, o que corresponde à fórmula (N-k),
 onde k é a quantidade de níveis encontrados no fator (isto é, a quantidade de amostras analisadas)
 e N é o tamanho da população."""

    pass


  def getGrausLiberdadeNumerador(self) -> int:
    """Retorna a quantidade de graus de liberdade no numerador, o que corresponde à fórmula (k-1),
 onde k é a quantidade de níveis encontrados no fator (isto é, a quantidade de amostras analisadas)."""

    pass


  def getMSB(self) -> float:
    """Retorna o valor "MSB" (do inglês: Mean Square Between), que é estimado a partir da
 variância calculada sobre as médias amostrais."""

    pass


  def getMSE(self) -> float:
    """Retorna o valor "MSE" (do inglês: Mean Square Error), que é estimado a partir da
 média calculada sobre as variâncias amostrais."""

    pass


  def getMediaAmostra(self, n) -> float:
    """Retorna a média amostral considerada para uma determinada amostra."""

    pass


  def getNomeAmostra(self, n) -> str:
    """Retorna o nome de identificação da n-ésima amostra considerada na ANOVA."""

    pass


  def getPosicaoAmostra(self, nome) -> int:
    """Retorna o número da posição onde foram armazenados neste objeto os dados correspondentes
 a uma determinada amostra.<BR>
 OBS: é feita distinção de maiúsculas/minúsculas."""

    pass


  def getProbabilidade(self) -> float:
    """Retorna a probabilidade com que aceitamos a hipótese "nula" de que as médias
 das amostras são iguais entre si (diferentes por uma pequena variação justificada pelo acaso).<BR>
 Ou seja, quanto menor é este valor, maior é a nossa certeza de REJEIÇÂO da hipótese "nula" (ou seja,
 que as médias das amostras NÃO são todas iguais entre si).<BR>
 Este valor é calculado a partir da razão F (MSB/MSE), considerando a área sob a curva de distribuição
 de probabilidade F, considerando os graus de liberdade obtidos a partir dos dados."""

    pass


  def getQtdNiveis(self) -> int:
    """Retorna a quantidade de níveis associadas ao fator considerado na ANOVA.<BR>
 Isto é, a quantidade de amostras consideradas."""

    pass


  def getSomaQuadradosDenominador(self) -> float:
    """Retorna a soma dos quadrados residual (erro)."""

    pass


  def getSomaQuadradosNumerador(self) -> float:
    """Retorna a soma dos quadrados dos dados condicionados ao fator (amostras)."""

    pass


  def getSumario(self) -> Tabela:
    """Retorna uma tabela de "sumário" contendo diversos valores calculados pela ANOVA."""

    pass


  def getTamanhoAmostra(self, n) -> int:
    """Retorna o tamanho da n-ésima amostra considerada na ANOVA."""

    pass


  def getTamanhoPopulacao(self) -> int:
    """Retorna a quantidade de elementos existentes na população (isto é, a totalização de todas as amostras)."""

    pass


  def getVarianciaAmostra(self, n) -> float:
    """Retorna a variância amostral considerada para uma determinada amostra."""

    pass


  def isHipoteseRejeitada(self) -> bool:
    """Indica se há diferença significativa entre as médias amostrais.<BR>
 Em outras palavras, indica que "rejeitamos" a hipótese "nula" associada a esta técnica.<BR>
 Para efeitos deste resultado, comparamos a probabilidade "p" com o valor geralmente utilizado
 de 0.05 (5%)."""

    pass

class Agregador ():
  """Classe utilizada por linguagem de scripting para facilitar a agregação de
 dados conforme variados critérios.<BR>
 <BR>
 <B>Observação</B>: não confundir com o objeto TabelaUsuario, que é utilizado
 para representar um conjunto de dados que foram importados pelo usuário para
 o ContÁgil a partir de uma origem genérica (DW, arquivo, etc.).<BR>
 <BR>
 Através desta classe é possível escolher quaisquer conjunto de critérios (ou
 até mesmo nenhum critério) para somar ou contar quaisquer outros conjuntos de
 valores.<BR>
 <BR>
 Este objeto está acessível para a linguagem de script através do nome
 "agregar".<BR>
 <BR>
 Você pode também jogar o conteúdo de um objeto "Agregador" para um arquivo
 TEXTO ou EXCEL. Consulte as classes "ArquivoCSV" e "ArquivoExcel" para saber
 como.<BR>
 <BR>
 Por exemplo:<BR>
 <BR>
 <CODE> // Obtém um objeto para agregação<BR>
 a = agregar.novo();<BR>
 <BR> // Soma o valor (100) para o critério definido pela dupla: 1 +
 "VERMELHO"<BR>
 a.para(1, "VERMELHO").soma(100);<BR>
 <BR> // Soma o valor (50) para o critério definido pela dupla: 1 + "VERMELHO"<BR>
 a.para(1, "VERMELHO").soma(50);<BR>
 <BR> // Soma o valor (200) para o critério definido pela dupla: 2 +
 "VERMELHO"<BR>
 a.para(2, "VERMELHO").soma(200);<BR>
 <BR> // Soma o valor (200) para o critério definido pela dupla: 2 + "AZUL"<BR>
 a.para(2, "AZUL").soma(300);<BR>
 <BR> // Incrementa o contador para o critério definido pelo critério
 numérico: 123<BR>
 a.para(123).conta();<BR>
 <BR> // Incrementa o contador para o critério definido pelo critério
 numérico: 123<BR>
 a.para(123).conta();<BR>
 <BR> // Incrementa o contador para o critério definido pelo critério
 numérico: 123<BR>
 a.para(123).conta();<BR>
 </CODE> <BR>
 No final de todas as execuções acima, o resultado será o seguinte:<BR>
 Para o critério definido pela dupla 1 + "VERMELHO", a soma é de 150<BR>
 Para o critério definido pela dupla 2 + "VERMELHO", a soma é 200<BR>
 Para o critério definido pela dupla 2 + "AZUL", a soma é 300<BR>
 Para o critério definido pelo valor singular 123, a contagem é de 3<BR>
 O mesmo objeto de agregação concluiu com 4 critérios diferentes<BR>
 <BR>
 Importante: quando se utiliza o critério de múltiplos parâmetros (por
 exemplo, "VERMELHO" + 1), não são realizados os cálculos para os critérios
 parciais. Por exemplo, ao contar as ocorrências de "VERMELHO" e "1" não se
 consideram de forma isolada as ocorrências de apenas "VERMELHO" e apenas "1".<BR>
 Para computar essas outras ocorrências é necessário explicitamente realizar
 chamadas a essas outras situações. por exemplo:<BR>
 <BR>
 <CODE> a.para("VERMELHO",1).soma(2); // Soma 2 para o critério definido pela
 dupla VERMELHO e 1<BR>
 a.para("VERMELHO").soma(2); // Soma 2 para o critério definido por VERMELHO
 apenas<BR>
 a.para(1).soma(2); // Soma 2 para o critério definido por 1 apenas<BR>
 a.para("VERMELHO").getSoma(); // Vai retornar 2, e não 4, pois não se
 considera a primeira soma realizada, que incluía mais um critério<BR>
 </CODE> <BR>
 Para somar ou contar sem utilizar qualquer critério, basta chamar diretamente
 o método.<BR>
 Exemplo:<BR>
 <BR>
 <CODE> // Soma um valor sem agregar por qualquer critério particular<BR>
 a.soma(123);<BR>
 </CODE> <BR>
 Pode-se também contar distintamente, o que equivale a incrementar o contador
 apenas para as ocorrências diferentes de critério, sem contar duas vezes o
 mesmo critério.<BR>
 Exemplo:<BR>
 <BR>
 <CODE> // Conta uma vez<BR>
 a.contaDistintamente("VERMELHO");<BR>
 <BR> // Conta de novo, mas sem efeito prático, pois trata-se da mesma
 ocorrência do critério anterior<BR>
 a.contaDistintamente("VERMELHO");<BR>
 <BR> // Conta de novo, mas desta vez incrementa o contador, pois 123 é
 diferente de "VERMELHO"<BR>
 a.contaDistintamente(123);<BR>
 </CODE> <BR>
 Pode-se também aninhar agregações dentro de agregações.<BR>
 Exemplo:<BR>
 <BR>
 <CODE> // Agrega primeiro por um critério e depois por outro, e daí conta<BR>
 a.para("VERMELHO").para(123).conta();<BR>
 </CODE> <BR>
 A construção acima é diferente de fazer:<BR>
 <BR>
 <CODE> // Agrega pela dupla "VERMELHO" + 123<BR>
 a.para("VERMELHO",123).conta();<BR>
 </CODE> <BR>
 No primeiro caso existem dois níveis de agregação (o primeiro nível é somente
 por um critério, e o segundo nível é também somente um critério), ao passo
 que no segundo caso existe somente um único nível de agregação o qual engloba
 uma "dupla" como critério.<BR>
 <BR>
 <CODE> // Para apagar as contagens e somas, basta chamar a função "apaga()",
 assim:<BR>
 a.apaga();<BR>
 <BR> // Ou também assim (para apagar somente para um determinado critério):<BR>
 a.para("VERMELHO").apaga();<BR>
 </CODE> <BR>
 <BR>
 Para obter o resultado das agregações, deve-se utilizar as funções
 "getXXX()". Por exemplo:<BR>
 <BR>
 <CODE> // Obtém a contagem de VERMELHOS<BR>
 a.para("VERMELHO").getContagem();<BR>
 <BR> // Obtém o somatório para o critério definido pela dupla "VERMELHO" +
 123<BR>
 a.para("VERMELHO",123).getSoma();<BR>
 <BR> // Obtém o somatório total considerando todas as agregações<BR>
 a.getSomaTotal();<BR>
 <BR> // Obtém outras estatísticas para o mesmo critério<BR>
 a.para("VERMELHO",123).getMedia();<BR>
 a.para("VERMELHO",123).getMaximo();<BR>
 a.para("VERMELHO",123).getMinimo();<BR>
 a.para("VERMELHO",123).getDesvioPadrao();<BR>
 </CODE> <BR>
 <BR>
 Para obter uma relação de todos os critérios utilizados nas agregações,
 executar:<BR>
 <BR>
 a.getCriterios();<BR>
 <BR>
 Por exemplo:<BR>
 <BR>
 <CODE> // Percorre a lista de critérios e para cada um retorna o contador<BR>
 for (Criterio c : a.getCriterios()) System.out.println(c + " = " +
 a.para(c).getContagem());<BR>
 </CODE> <BR>
 OBS: Esta classe é THREAD-SAFE (isto é, o mesmo objeto pode ser compartilhado
 por execuções paralelas simultâneas)."""

  def apaga(self) -> None:
    """Apaga todos os contadores e somatórios neste nível de agregação"""

    pass


  def apaga(self, crit) -> None:
    """Apaga as agregações feitas com base em um determinado critério."""

    pass


  def conta(self, incremento) -> None:
    """Incrementa o contador interno neste nível de agregação pela quantidade
 que é passada como parâmetro."""

    pass


  def conta(self) -> None:
    """Incrementa o contador interno neste nível de agregação. Para contar de
 forma distinta as ocorrências sem repetição, deve-se utilizar o método
 alternativo contaDistintamente()."""

    pass


  def conta(self, criterios, rotulo, incremento) -> None:
    """Incrementa o contedor interno após agregar conforme determinados
 critérios.<BR>
 Esta função tem o mesmo efeito que executar:<BR>
 <CODE> para(criterios).para(rotulo).conta();<BR>
 </CODE>"""

    pass


  def conta(self, criterios, rotulo) -> None:
    """Incrementa o contedor interno após agregar conforme determinados
 critérios.<BR>
 Esta função tem o mesmo efeito que executar:<BR>
 <CODE> para(criterios).para(rotulo).conta();<BR>
 </CODE>"""

    pass


  def contaDistintamente(self, args) -> None:
    """Incrementa o contador interno neste nível de agregação mas de modo a
 considerar apenas uma única vez o critério passado como parâmetros"""

    pass


  def contaDistintamente(self, arg1, arg2, arg3) -> None:
    """Incrementa o contador interno neste nível de agregação mas de modo a
 considerar apenas uma única vez o critério passado como parâmetros"""

    pass


  def contaDistintamente(self, rotulo, distincao) -> None:
    """Incrementa o contedor interno após agregar para um determinado rótulo.<BR>
 A contagem é feita de forma a contabilizar "distintamente" conforme determinados critérios de "distinção".<BR>
 Esta função tem o mesmo efeito que executar:<BR>
 <CODE> para(rotulo).contaDistintamente(distincao);<BR>
 </CODE>"""

    pass


  def contaDistintamente(self, arg1, arg2) -> None:
    """Incrementa o contador interno neste nível de agregação mas de modo a
 considerar apenas uma única vez o critério passado como parâmetros"""

    pass


  def contemAgregacao(self, crit) -> bool:
    """Verifica se houve alguma chamada de uma função totalizadora (soma) com o
 critério de agregação passado como parâmetro, ou alguma contagem efetuada
 sobre esta agregação."""

    pass


  def contemAgregacaoAlgumNivel(self, crit) -> bool:
    """Verifica se houve alguma chamada de uma função totalizadora (soma) com o
 critério de agregação passado como parâmetro, ou alguma contagem efetuada
 sobre esta agregação, considerando nesta análise quaisquer sub-agregações
 neste objeto (isto é, caso tenham sido encadeados diversos
 "para...para...para").<BR>
 Note que este resultado pode divergir do resultado da função
 {@link Agregador#contemAgregacao(Criterio) contemAgregacao} pela razão de
 serem verificados os sub-níveis na função contemAgregacaoAlgumNivel (a
 função contemAgregacao procura apenas neste nível direto de agregação)."""

    pass


  def contemElementoDistinto(self, arg1) -> bool:
    """Verifica se nesta agregação há alguma ocorrência do elemento passado como
 parâmetro (isto é, se já houve uma chamada preliminar à função
 contaDistintamente na qual tenha sido passado este mesmo valor como
 parâmetro)."""

    pass


  def contemElementoDistinto(self, crit) -> bool:
    """Verifica se nesta agregação há alguma ocorrência do elemento passado como
 parâmetro (isto é, se já houve uma chamada preliminar à função
 contaDistintamente na qual tenha sido passado este mesmo valor como
 parâmetro)."""

    pass


  def contemElementoDistinto(self, arg1, arg2) -> bool:
    """Verifica se nesta agregação há alguma ocorrência do elemento passado como
 parâmetro (isto é, se já houve uma chamada preliminar à função
 contaDistintamente na qual tenha sido passado este mesmo valor como
 parâmetro)."""

    pass


  def contemValores(self) -> bool:
    """Retorna a indicação de que algum valor foi considerado nesta agregação
 (via método "soma()" ou via método "setValor()").<BR>
 OBS: Se o objeto foi utilizado apenas para contar, é retornado "false"."""

    pass


  def getAgregacaoSemCriterio(self, removerCriterio) -> Agregador:
    """Retorna uma nova agregação sobre os dados já agregados, de tal modo que
 um dos critérios é "removido".<BR>
 Por exemplo, digamos que uma estrutura de agregação foi montada
 considerando dois critérios de agregação: MES e CNPJ.<BR>
 Ou seja, esta estrutura pode ter sido "construída" através de execuções
 sucessivas do tipo: agregar.para(MES,CNPJ).soma(VALOR)<BR>
 Nesta estrutura os dados estão agregados para cada "dupla" de MES + CNPJ.<BR>
 Digamos agora que estamos interessados em obter uma nova estrutura de
 agregação, de tal maneira a desconsiderar a diferença quanto ao CNPJ. Ou
 seja, digamos que estamos interessados em manter a agregação somente pelo
 MES.<BR>
 Neste caso basta executar o método getAgregacaoSemCriterio(2), onde "2"
 indica que queremos remover o "segundo critério" (neste caso seria o
 CNPJ).<BR>
 O resultado disso é um novo objeto Agregador (isto é, o objeto original
 não é alterado) onde os dados estão agregados somente pelo MES.<BR>
 Se estivéssemos interessados em obter uma nova estrutura de agregação
 pelo CNPJ e não pelo MES, bastaria executar o método
 getAgregacaoSemCriterio(1), onde o "1" indica que queremos remover o
 "primeiro critério" (neste exemplo seria o MES), mantendo somente a
 diferenciação pelo CNPJ.<BR>
 Se estivéssemos interessados em remover os dois critérios de agregação,
 chamaríamos o método getAgregacaoSemCriterio(0), onde o "0" indica que
 queremos remover "todos" os critérios.<BR>
 OBS: se o parâmetro "removerCriterio" é um número superior à quantidade
 de critérios efetivamente utilizados, então a estrutura retornada é igual
 à estrutura de agregação original (isto é, nada é "retirado"). Por
 exemplo, se agregamos os dados por "duplas" MES + CNPJ, e executamos o
 método getAgregacaoSemCriterio(3), o número "3" não significa nada neste
 exemplo, pois temos somente 2 critérios de agregação (MES e CNPJ).<BR>"""

    pass


  def getAssimetria(self, criterios, rotulo) -> float:
    """Retorna o coeficiente de assimetria (calculado a partir dos momentos de
 ordem 3, não se tratando do coeficiente de Pearson) obtido até agora
 neste nível de agregação."""

    pass


  def getAssimetria(self) -> float:
    """Retorna o coeficiente de assimetria (calculado a partir dos momentos de
 ordem 3, não se tratando do coeficiente de Pearson) obtido até agora
 neste nível de agregação."""

    pass


  def getAssimetria(self, criterios) -> float:
    """Retorna o coeficiente de assimetria (calculado a partir dos momentos de
 ordem 3, não se tratando do coeficiente de Pearson) obtido até agora
 neste nível de agregação. Este método é equivalente a executar o método
 "para" (com parâmetros) seguido do método getAssimetria (sem parâmetros).<BR>"""

    pass


  def getContagem(self) -> long:
    """Retorna a contagem obtida até agora neste nível de agregação, o que
 inclui a contagem realizada pelo método conta() e pelo método
 contaDistintamente()"""

    pass


  def getContagemTotal(self) -> long:
    """Retorna a contagem total de elementos considerando este nível de
 agregação em diante."""

    pass


  def getContagemTotal(self, criterios) -> long:
    """Retorna a contagem total obtida para determinado critério de agregação.<BR>
 Este método equivale a executar o método "para" (com parâmetros) seguido
 do método "getContagemTotal" sem parâmetros.<BR>"""

    pass


  def getCriterioInexato(self, argumentos, heuristica, minCaracteresIguais) -> Criterio:
    """Faz uma pesquisa sobre o objeto de agregação de forma inexata. Isto é, permite localizar algum critério de agregação
 ainda que seu conteúdo não seja exatamente igual àquele que foi indicado no parâmetro. Para isso, utiliza uma dentre
 algumas 'heurísticas' de comparação inexata.<BR>
 <BR> 
 Note que este método pode retornar um critério de agregação muito diferente daquele pesquisado, contanto que seja o mais próximo dentre os critérios existentes.<BR>
 Se quiser restringir a resposta de modo a não retornar algo muito diferente, informe no parâmetro 'minCaracteresIguais' a quantidade mínima
 de caracteres que devem coincidir. Por exemplo, se este parâmetro é igual a 3, a resposta deste método poderá ser algum texto igual ou semelhante, contanto
 que no mínimo 3 caracteres sejam iguais em qualquer parte do texto encontrado.<BR>
 <BR>
 Se o parâmetro 'minCaracteresIguais' é igual a 0, não há restrição alguma.<BR>
 <BR>
 HEURÍSTICAS IMPLEMENTADAS:<BR>
 ===========================================================<BR>
 A seguir passamos a apresentar as heurísticas atualmente implementadas por este método:<BR>
 <BR>
 LEVENSHTEIN<BR>
 -----------------------------------------------------------<BR>
 Utiliza o critério conhecido como 'distância de Levenshtein' (<A HREF="http://pt.wikipedia.org/wiki/Dist%C3%A2ncia_Levenshtein">http://pt.wikipedia.org/wiki/Dist%C3%A2ncia_Levenshtein</A>).<BR>
 Para cada texto utilizado como critério de agregação, faz uma comparação com o texto correspondente indicado no parâmetro deste método.<BR>
 Em cada comparação é calculada uma 'distância' que é tanto menor quanto mais semelhantes forem os textos comparados. Se forem iguais, a distância é 0.<BR>
 Considera aquele critério cuja distância ao critério pesquisado seja a menor dentre todas apuradas.<BR>
 Em situação envolvendo diferentes 'palavras' no texto pesquisado, a ordem das palavras é relevante (isto é, uma mera inversão na ordem das palavras pode ser considerada como uma grande divergência em relação ao texto pesquisado).<BR> 
 <BR>
 LEVENSHTEIN2<BR>
 -----------------------------------------------------------<BR>
 Trata-se de uma derivação do critério 'Levenshtein' comentado acima, com a diferença que aqui a ordem das palavras contidas no mesmo texto não é relevante.<BR>
 Cada texto é inicialmente quebrado em palavras individuais, utilizando o espaço em branco como critério
 de separação de palavras. Depois, é feito o produto cartesiano entre palavras do primeiro
 texto com palavras do segundo texto e sobre cada 'par' deste produto cartesiano é calculada
 a distância de '<B>LEVENSHTEIN</B>' somente sobre as palavras do par. Feito isso, considera-se
 a soma das menores distâncias.<BR>
 Ex: Se o texto1 é constituído pelas palavras W1 e W2 e o texto2 é constituído pelas palavras W3 e W4,
 calcula-se as distâncias <B>LEVENSHTEIN</B> entre os pares d13 = (W1,W3), d14 = (W1,W4), d23 = (W2,W3), d24 = (W2,W4).<BR>
 Depois, toma-se o menor valor min(d13,d14) e soma com o menor valor min(d23,d24).<BR>
 ATENÇÃO: Esta heurística pode resultar em um tempo de processamento muito superior àquela obtida com o primeiro método.<BR>
 <BR>"""

    pass


  def getCriterios(self) -> list:
    """Retorna a relação de critérios adotados neste nível de agregação. Cada
 objeto da lista é um objeto Criterio que define qualquer quantidade de
 critérios simultâneos."""

    pass


  def getCriteriosComValorMaximo(self) -> Criterio:
    """Procura neste objeto de agregação e em todos os demais subníveis de agregação internos a este pela
 ocorrência do maior valor.<BR>
 Cada objeto de agregação (objeto do tipo {@link Criterio Criterio}) indica o 'caminho' para se chegar no maior valor.<BR>
 Se houver mais de um critério de agregação com o mesmo valor máximo, a lista retornada indica todos eles.<BR>
 Caso contrário, a lista retornada indica um único critério."""

    pass


  def getCriteriosComValorMinimo(self) -> Criterio:
    """Procura neste objeto de agregação e em todos os demais subníveis de agregação internos a este pela
 ocorrência do menor valor.<BR>
 Cada objeto de agregação (objeto do tipo {@link Criterio Criterio}) indica o 'caminho' para se chegar no menor valor.<BR>
 Se houver mais de um critério de agregação com o mesmo valor mínimo, a lista retornada indica todos eles.<BR>
 Caso contrário, a lista retornada indica um único critério."""

    pass


  def getCriteriosOrdenados(self) -> list:
    """Retorna a mesma relação de critérios obtidos pela função
 {@link Agregador#getCriterios() getCriterios}, mas de tal forma que os
 elementos da lista estão ordenados conforme a forma natural de ordenação
 para cada componente de cada critério (por exemplo, se os critérios são
 do tipo TEXTO, ordena-se em ordem alfabética crescente)."""

    pass


  def getCurtose(self) -> float:
    """Retorna o coeficiente de curtose (calculado a partir do momento de ordem
 4, subtraindo o resultado por 3 para fins de comparação com a curva
 normal) obtido até agora neste nível de agregação."""

    pass


  def getCurtose(self, criterios) -> float:
    """Retorna o coeficiente de curtose (calculado a partir do momento de ordem
 4, subtraindo o resultado por 3 para fins de comparação com a curva
 normal) obtido até agora neste nível de agregação. Este método é
 equivalente a executar o método "para" (com parâmetros) seguido do método
 getCurtose (sem parâmetros).<BR>"""

    pass


  def getCurtose(self, criterios, rotulo) -> float:
    """Retorna o coeficiente de curtose (calculado a partir do momento de ordem
 4, subtraindo o resultado por 3 para fins de comparação com a curva
 normal) obtido até agora neste nível de agregação."""

    pass


  def getDesvioPadrao(self) -> float:
    """Retorna o desvio padrão obtido até agora neste nível de agregação."""

    pass


  def getDesvioPadrao(self, criterios) -> float:
    """Retorna o desvio padrão obtido em determinado critério de agregação.<BR>
 Este método é equivalente a executar o método "para" (com parâmetros)
 seguido do método getDesvioPadrao (sem parâmetros).<BR>"""

    pass


  def getDesvioPadrao(self, criterios, rotulo) -> float:
    """Retorna o desvio padrão obtido em determinado critério de agregação e
 determinado rótulo.<BR>"""

    pass


  def getElementosDistintos(self) -> list:
    """Retorna a relação de critérios contabilizados de forma distinta (isto é,
 passados como parâmetros à função contaDistintamente()). Cada objeto da
 lista é um objeto Criterio que define qualquer quantidade de critérios
 simultâneos."""

    pass


  def getElementosDistintosOrdenados(self) -> list:
    """Retorna a mesma relação de critérios obtidos pela função
 {@link Agregador#getElementosDistintos() getElementosDistintos}, mas de
 tal forma que os elementos da lista estão ordenados conforme a forma
 natural de ordenação para cada componente de cada critério (por exemplo,
 se os critérios são do tipo TEXTO, ordena-se em ordem alfabética
 crescente)."""

    pass


  def getMaiorElementoDistinto(self) -> Criterio:
    """Dada uma relação de objetos que foram contabilizados de forma distinta
 (isto é, passados como parâmetros à função contaDistintamente()), retorna
 o "maior" deles.<BR>
 Para isso considera-se a ordem alfanumérica em conteúdos do tipo texto,
 ordem numérica em conteúdos do tipo numérico, e ordem cronológica em
 conteúdos do tipo data ou mês. Outros tipos de objetos (tais como aqueles
 definidos pelo ContÁgil) podem ser ordenados de outra forma.<BR>"""

    pass


  def getMaximo(self, criterios, rotulo) -> float:
    """Retorna o máximo obtido com um determinado critério de agregação e
 determinado rótulo.<BR>"""

    pass


  def getMaximo(self) -> float:
    """Retorna o máximo obtido até agora neste nível de agregação."""

    pass


  def getMaximoRecursivo(self, criterios, rotulo) -> float:
    """Retorna o máximo obtido com um determinado critério de agregação e
 determinado rótulo.<BR>
 Caso não encontre o critério de agregação solicitado, este método realiza
 buscas adicionais procurando pela combinação de critérios que satisfazem
 a maior parte dos critérios indicados no parâmetro, dando preferência para
 os primeiros critérios indicados.<BR>
 Por exemplo, digamos que foram feitas agregações de valores em dois níveis (ANO e MARCA), 
 conforme ilustrado a seguir:<BR>
 ANO=2010<BR>
 ------> MARCA=ALFA<BR>
 ------------------> VALOR=100<BR>
 ------> MARCA=BETA<BR>
 ------------------> VALOR=200<BR>
 ANO=2011<BR>
 ------> MARCA=ALFA<BR>
 ------------------> VALOR=400<BR>
 ------> MARCA=GAMMA<BR>
 ------------------> VALOR=500<BR>
 <BR>
 Considerando o exemplo acima, teremos as seguintes respostas para as seguintes
 consultas:<BR>
 <BR>
 getMaximoRecursivo([2010,"ALFA"],"VALOR") -> 100  (o maior valor para ANO=2010 e MARCA=ALFA é 100).<BR>
 getMaximoRecursivo([2011,"ALFA"],"VALOR") -> 400  (o maior valor para ANO=2011 e MARCA=ALFA é 400).<BR>
 getMaximoRecursivo([2011],"VALOR") -> 500  (o maior valor para ANO=2011, independentemente de MARCA, é 500).<BR>
 getMaximoRecursivo([],"VALOR") -> 500  (o maior valor, independentemente de ANO e MARCA, é 500).<BR>
 getMaximoRecursivo([2010,"OMEGA"],"VALOR") -> 200  (o maior valor para ANO=2010, ignorando a marca "OMEGA" porque ela não existe, é 200).<BR>
 <BR>
 OBS: não é possível 'saltar' critérios de agregação. No exemplo hipotético acima não é possível pesquisar o valor máximo para uma MARCA específica
 independentemente do ANO. Se isso for desejável, o objeto de agregação deve ser rearranjado de modo que o critério de agregação MARCA anteceda
 o critério de agregação ANO.<BR>"""

    pass


  def getMaximoTotal(self) -> float:
    """Retorna o máximo obtido deste nível de agregação em diante (isto é,
 considerando todas as agregações existentes a partir deste nível)."""

    pass


  def getMaximoTotal(self, criterios) -> float:
    """Retorna o máximo obtido com um determinado critério de agregação.<BR>
 Este método é equivalente a executar o método "para" (com parâmetros)
 seguido do método getMaximoTotal (sem parâmetros).<BR>"""

    pass


  def getMedia(self, criterios) -> float:
    """Retorna a média obtida em determinado critério de agregação.<BR>
 Este método é equivalente a executar o método "para" (com parâmetros)
 seguido do método getMedia (sem parâmetros).<BR>"""

    pass


  def getMedia(self) -> float:
    """Retorna a média obtida até agora neste nível de agregação."""

    pass


  def getMedia(self, criterios, rotulo) -> float:
    """Retorna a média obtida em determinado critério de agregação e um
 determinado rótulo.<BR>"""

    pass


  def getMenorElementoDistinto(self) -> Criterio:
    """Dada uma relação de objetos que foram contabilizados de forma distinta
 (isto é, passados como parâmetros à função contaDistintamente()), retorna
 o "menor" deles.<BR>
 Para isso considera-se a ordem alfanumérica em conteúdos do tipo texto,
 ordem numérica em conteúdos do tipo numérico, e ordem cronológica em
 conteúdos do tipo data ou mês. Outros tipos de objetos (tais como aqueles
 definidos pelo ContÁgil) podem ser ordenados de outra forma.<BR>"""

    pass


  def getMinimo(self) -> float:
    """Retorna o mínimo obtido até agora neste nível de agregação."""

    pass


  def getMinimo(self, criterios, rotulo) -> float:
    """Retorna o mínimo obtido com um determinado critério de agregação e
 determinado rótulo.<BR>"""

    pass


  def getMinimoRecursivo(self, criterios, rotulo) -> float:
    """Retorna o mínimo obtido com um determinado critério de agregação e
 determinado rótulo.<BR>
 Caso não encontre o critério de agregação solicitado, este método realiza
 buscas adicionais procurando pela combinação de critérios que satisfazem
 a maior parte dos critérios indicados no parâmetro, dando preferência para
 os primeiros critérios indicados.<BR>
 Por exemplo, digamos que foram feitas agregações de valores em dois níveis (ANO e MARCA), 
 conforme ilustrado a seguir:<BR>
 ANO=2010<BR>
 ------> MARCA=ALFA<BR>
 ------------------> VALOR=100<BR>
 ------> MARCA=BETA<BR>
 ------------------> VALOR=200<BR>
 ANO=2011<BR>
 ------> MARCA=ALFA<BR>
 ------------------> VALOR=400<BR>
 ------> MARCA=GAMMA<BR>
 ------------------> VALOR=500<BR>
 <BR>
 Considerando o exemplo acima, teremos as seguintes respostas para as seguintes
 consultas:<BR>
 <BR>
 getMinimoRecursivo([2010,"ALFA"],"VALOR") -> 100  (o menor valor para ANO=2010 e MARCA=ALFA é 100).<BR>
 getMinimoRecursivo([2011,"ALFA"],"VALOR") -> 400  (o menor valor para ANO=2011 e MARCA=ALFA é 400).<BR>
 getMinimoRecursivo([2011],"VALOR") -> 400  (o menor valor para ANO=2011, independentemente de MARCA, é 400).<BR>
 getMinimoRecursivo([],"VALOR") -> 100  (o menor valor, independentemente de ANO e MARCA, é 100).<BR>
 getMinimoRecursivo([2010,"OMEGA"],"VALOR") -> 100  (o menor valor para ANO=2010, ignorando a marca "OMEGA" porque ela não existe, é 100).<BR>
 <BR>
 OBS: não é possível 'saltar' critérios de agregação. No exemplo hipotético acima não é possível pesquisar o valor mínimo para uma MARCA específica
 independentemente do ANO. Se isso for desejável, o objeto de agregação deve ser rearranjado de modo que o critério de agregação MARCA anteceda
 o critério de agregação ANO.<BR>"""

    pass


  def getMinimoTotal(self, criterios) -> float:
    """Retorna o mínimo obtido com um determinado critério de agregação.<BR>
 Este método é equivalente a executar o método "para" (com parâmetros)
 seguido do método getMinimoTotal (sem parâmetros).<BR>"""

    pass


  def getMinimoTotal(self) -> float:
    """Retorna o mínimo obtido deste nível de agregação em diante (isto é,
 considerando todas as agregações existentes a partir deste nível)."""

    pass


  def getQuantidadeAgregacoes(self) -> int:
    """Retorna a quantidade de agregações realizadas em chamadas à função de
 agregação "para(...)"."""

    pass


  def getSoma(self, criterios, rotulo) -> float:
    """Examina a agregação conforme um determinado critério de agregação e então
 retorna a soma associada a um determinado rótulo.<BR>
 Este método equivale a executar: para(criterios).getSoma(rotulo)<BR>"""

    pass


  def getSoma(self) -> float:
    """Retorna a soma obtida até agora neste nível de agregação."""

    pass


  def getSoma(self, rotulo) -> float:
    """Retorna a soma relacionada a um determinado rótulo (isto é, caso tenha
 sido chamada a função soma(rotulo,valor) durante a fase de preenchimento
 dos dados).<BR>
 Esta função é equivalente a chamar: para(rotulo).getSoma()."""

    pass


  def getSomaTotal(self, criterios) -> float:
    """Examina a agregação conforme um determinado critério de agregação e então
 retorna a soma obtida neste nível de agregação em diante (isto é,
 considerando todas as agregações existentes a partir deste nível).<BR>
 Este método equivale a executar: para(criterios).getSomaTotal()<BR>"""

    pass


  def getSomaTotal(self) -> float:
    """Retorna a soma obtida deste nível de agregação em diante (isto é,
 considerando todas as agregações existentes a partir deste nível)."""

    pass


  def getSubAgregados(self) -> list:
    """Retorna a relação de estruturas do tipo {@link Agregador Agregador},
 cada qual correspondendo a um conjunto de informações que foi agregada
 conforme algum {@link Criterio Criterio}."""

    pass


  def getSubnivelRecursivo(self, criterios) -> Agregador:
    """Retorna o subnível de agregação conforme o critério de agregação.<BR>
 Caso não encontre o critério de agregação solicitado, este método realiza
 buscas adicionais procurando pela combinação de critérios que satisfazem
 a maior parte dos critérios indicados no parâmetro, dando preferência para
 os primeiros critérios indicados.<BR>
 Por exemplo, digamos que foram feitas agregações de valores em dois níveis (ANO e MARCA), 
 conforme ilustrado a seguir:<BR>
 ANO=2010<BR>
 ------> MARCA=ALFA<BR>
 ------------------> VALOR=100<BR>
 ------> MARCA=BETA<BR>
 ------------------> VALOR=200<BR>
 ANO=2011<BR>
 ------> MARCA=ALFA<BR>
 ------------------> VALOR=400<BR>
 ------> MARCA=GAMMA<BR>
 ------------------> VALOR=500<BR>
 <BR>
 Considerando o exemplo acima, teremos as seguintes respostas para as seguintes
 consultas:<BR>
 <BR>
 getSubnivelRecursivo([2010,"ALFA"]) -> obtém o último nível de agregação contendo o VALOR 100 (o subnível para ANO=2010 e MARCA=ALFA é 100).<BR>
 getSubnivelRecursivo([2011,"ALFA"]) -> obtém o último nível de agregação contendo o VALOR 400  (o subnível para ANO=2011 e MARCA=ALFA é 400).<BR>
 getSubnivelRecursivo([2011]) -> obtém o nível de agregação contendo marcas ALFA e GAMMA para o ANO=2011<BR>
 getSubnivelRecursivo([]) -> obtém este mesmo objeto de agregação (isto é, referencia a si mesmo)<BR>
 getSubnivelRecursivo([2010,"OMEGA"]) -> obtém o nível de agregação contendo marcas ALFA e GAMMA para o ANO=2010, tendo em vista que não encontrou a marca "OMEGA"<BR>
 <BR>
 OBS: não é possível 'saltar' critérios de agregação. No exemplo hipotético acima não é possível pesquisar o subnível de agregação para uma MARCA específica
 independentemente do ANO. Se isso for desejável, o objeto de agregação deve ser rearranjado de modo que o critério de agregação MARCA anteceda
 o critério de agregação ANO.<BR>"""

    pass


  def getTabela(self) -> Tabela:
    """Converte o objeto Agregador em um objeto {@link Tabela Tabela}.<BR>
 As linhas da tabela se referem à quantidade de critérios diferentes que
 foram utilizados na agregação dos dados.<BR>
 As colunas de cada linha apresentam os critérios considerados e também os
 valores que foram agregados.<BR>
 Na última coluna de cada linha apresenta-se a SOMA dos valores agregados
 para cada critério de agregação.<BR>
 Caso existam agregações aninhadas (isto é, diversos métodos "para"
 montados um sobre outros), são incluídas colunas a mais na tabela para
 considerar a união dos critérios de agregação.<BR>
 Pode-se alterar o conteúdo da Tabela gerada por esta função.<BR>
 Observação: os objetos Agregador e Tabela são independentes entre si.
 Qualquer alteração em um não afeta o outro.<BR>
 Este método NÃO retorna o resultado das "contagens" (isto é, o resultado da execução
 do método "contar"). Para obter as "contagens", utilize o método {@link Agregador#getTabelaQuantidades() getTabelaQuantidades}."""

    pass


  def getTabelaMaximos(self) -> Tabela:
    """Converte o objeto Agregador em um objeto {@link Tabela Tabela}.<BR>
 As linhas da tabela se referem à quantidade de critérios diferentes que
 foram utilizados na agregação dos dados.<BR>
 As colunas de cada linha apresentam os critérios considerados e também os
 valores que foram agregados.<BR>
 Na última coluna de cada linha apresenta-se o valor MÁXIMO dos valores
 agregados para cada critério de agregação.<BR>
 Caso existam agregações aninhadas (isto é, diversos métodos "para"
 montados um sobre outros), são incluídas colunas a mais na tabela para
 considerar a união dos critérios de agregação.<BR>
 Pode-se alterar o conteúdo da Tabela gerada por esta função.<BR>
 Observação: os objetos Agregador e Tabela são independentes entre si.
 Qualquer alteração em um não afeta o outro.<BR>"""

    pass


  def getTabelaMedia(self) -> Tabela:
    """Converte o objeto Agregador em um objeto {@link Tabela Tabela}.<BR>
 As linhas da tabela se referem à quantidade de critérios diferentes que
 foram utilizados na agregação dos dados.<BR>
 As colunas de cada linha apresentam os critérios considerados e também os
 valores que foram agregados.<BR>
 Na última coluna de cada linha apresenta-se o valor MÉDIO dos valores
 agregados para cada critério de agregação.<BR>
 Caso existam agregações aninhadas (isto é, diversos métodos "para"
 montados um sobre outros), são incluídas colunas a mais na tabela para
 considerar a união dos critérios de agregação.<BR>
 Pode-se alterar o conteúdo da Tabela gerada por esta função.<BR>
 Observação: os objetos Agregador e Tabela são independentes entre si.
 Qualquer alteração em um não afeta o outro.<BR>"""

    pass


  def getTabelaMinimos(self) -> Tabela:
    """Converte o objeto Agregador em um objeto {@link Tabela Tabela}.<BR>
 As linhas da tabela se referem à quantidade de critérios diferentes que
 foram utilizados na agregação dos dados.<BR>
 As colunas de cada linha apresentam os critérios considerados e também os
 valores que foram agregados.<BR>
 Na última coluna de cada linha apresenta-se o valor MÍNIMO dos valores
 agregados para cada critério de agregação.<BR>
 Caso existam agregações aninhadas (isto é, diversos métodos "para"
 montados um sobre outros), são incluídas colunas a mais na tabela para
 considerar a união dos critérios de agregação.<BR>
 Pode-se alterar o conteúdo da Tabela gerada por esta função.<BR>
 Observação: os objetos Agregador e Tabela são independentes entre si.
 Qualquer alteração em um não afeta o outro.<BR>"""

    pass


  def getTabelaQuantidades(self) -> Tabela:
    """Converte o objeto Agregador em um objeto {@link Tabela Tabela}.<BR>
 As linhas da tabela se referem à quantidade de critérios diferentes que
 foram utilizados na agregação dos dados.<BR>
 As colunas de cada linha apresentam os critérios considerados e também os
 valores que foram agregados.<BR>
 Na última coluna de cada linha apresenta-se a CONTAGEM TOTAL ou DISTINTA
 dos valores agregados para cada critério de agregação.<BR>
 Caso existam agregações aninhadas (isto é, diversos métodos "para"
 montados um sobre outros), são incluídas colunas a mais na tabela para
 considerar a união dos critérios de agregação.<BR>
 Pode-se alterar o conteúdo da Tabela gerada por esta função.<BR>
 Observação: os objetos Agregador e Tabela são independentes entre si.
 Qualquer alteração em um não afeta o outro.<BR>"""

    pass


  def getValor(self, criterios, rotulo) -> Object:
    """Idem à ação {@link Agregador#getValor() getValor}, mas com dois
 parâmetros adicionais que permitem a escolha de um critério de agregação
 e de um rótulo opcional.<BR>
 Esta ação equivale a executar: para(criterios).para(rotulo).getValor()"""

    pass


  def getValor(self) -> Object:
    """Método de uso genérico que pode ser utilizado para retornar o valor que
 foi armazenado em uma chamada anterior do método
 {@link Agregador#setValor(Object) setValor}.<BR>
 Apenas um único valor é retornado por esta função.<BR>"""

    pass


  def incorporaOutroAgregador(self, outro) -> None:
    """Incorpora neste objeto de agregação os dados obtidos em outro objeto de
 agregação.<BR>
 Ou seja, os valores "somados" e os "contadores" do outro objeto são
 acrescentados a este objeto, como se este objeto tivesse sido utilizado
 na agregação dos outros dados também."""

    pass


  def isVazio(self) -> bool:
    """Retorna TRUE se não há agregações e nem elementos contados. Retorna FALSE
 se há agregações e/ou elementos contados."""

    pass


  def novo(self) -> Agregador:
    """Cria um novo objeto de agregação"""

    pass


  def novoAgregador(self) -> Agregador:
    """Cria um novo objeto de agregação"""

    pass


  def para(self, arg1, arg2, arg3, arg4, arg5, arg6) -> Agregador:
    """Estabelece um critério de agregação com base nos argumentos passados como
 parâmetros"""

    pass


  def para(self, arg1, arg2, arg3, arg4) -> Agregador:
    """Estabelece um critério de agregação com base nos argumentos passados como
 parâmetros"""

    pass


  def para(self, arg1, arg2) -> Agregador:
    """Estabelece um critério de agregação com base nos argumentos passados como
 parâmetros"""

    pass


  def para(self, arg1, arg2, arg3) -> Agregador:
    """Estabelece um critério de agregação com base nos argumentos passados como
 parâmetros"""

    pass


  def para(self, arg1, arg2, arg3, arg4, arg5) -> Agregador:
    """Estabelece um critério de agregação com base nos argumentos passados como
 parâmetros"""

    pass


  def para(self, argumentos) -> Agregador:
    """Estabelece um critério de agregação com base nos argumentos passados como
 parâmetros"""

    pass


  def para(self, crit) -> Agregador:
    """Função comum para estabelecer um critério de agregação onde a quantidade
 de parâmetros é variável"""

    pass


  def setValor(self, criterios, rotulo, valor) -> None:
    """Idem à ação {@link Agregador#setValor(Object) setValor}, mas com dois
 parâmetros adicionais que permitem a escolha de um critério de agregação
 e de um rótulo opcional.<BR>
 Esta ação equivale a executar:
 para(criterios).para(rotulo).setValor(valor)"""

    pass


  def setValor(self, valor) -> None:
    """Método de uso genérico que permite armazenar um valor qualquer neste
 objeto de agregação.<BR>
 Note que outro valor foi informado em uma execução anterior do mesmo
 método neste objeto de agregação, o valor anterior é sobrescrito por este
 (não acumula valores, ao contrário das demais funções deste objeto de
 agregação.<BR>
 Note também que é possível armazenar outros valores sem substituição caso
 para cada um deles seja executado o método
 {@link Agregador#para(Criterio) para}, de modo a definir os critérios em
 que o valor é armazenado.<BR>
 O valor armazenado pode ser obtido pela função
 {@link Agregador#getValor() getValor}.<BR>
 Esta função é útil quando se pretende armazenar um único valor em um
 determinado nível de agregação.<BR>
 Ex:<BR>
 <CODE> agregar.para("um nivel").para("segundo nivel").setValor("um
 valor");<BR>
 <BR>
 var resultado = agregar.para("um nivel").para("segundo
 nivel").getValor();<BR>
 </CODE> O "valor" que foi armazenado com esta função não é retornado por
 nenhuma das demais funções que retornam objetos "Criterio" (isto é, não é
 retornado por
 {@link Agregador#getMenorElementoDistinto() getMenorElementoDistinto},
 nem por {@link Agregador#getCriterios() getCriterios}, nem por diversas
 outras funções}.<BR>"""

    pass


  def soma(self, valor) -> None:
    """Soma um determinado valor neste nível de agregação"""

    pass


  def soma(self, criterios, valor) -> None:
    """Soma um determinado valor após agregar conforme determinados critérios.<BR>
 Esta função tem o mesmo efeito que executar:<BR>
 <CODE> para(criterios).soma(valor);<BR>
 </CODE>"""

    pass


  def soma(self, rotulo, valor) -> None:
    """Soma um determinado valor e associa esta soma a um determinado "rótulo".
 Esta função é equivalente a chamar: para(rotulo).soma(valor)"""

    pass


  def soma(self, criterios, rotulo, valor) -> None:
    """Soma um determinado valor após agregar conforme determinados critérios.<BR>
 Esta função tem o mesmo efeito que executar:<BR>
 <CODE> para(criterios).soma(rotulo,valor);<BR>
 </CODE>"""

    pass


  def soma(self, rotulo, valor) -> None:
    """Soma um determinado valor e associa esta soma a um determinado "rótulo".
 Esta função é equivalente a chamar: para(rotulo).soma(valor)"""

    pass


  def soma(self, valor) -> None:
    """Soma um determinado valor neste nível de agregação"""

    pass


  def toString(self) -> str:
    pass

class ArquivoCSV ():
  """Classe que implementa diversas operações relativas a um arquivo CSV.<BR>
 Dependendo de como o objeto foi obtido, é possível ler ou escrever no
 arquivo.<BR>
 Se o objeto foi obtido por uma função de criação (por exemplo,
 GerenciadorArquivos.criarCSV()), apenas as funções de escrita estão
 disponíveis. As demais funções geram erros na execução do script.<BR>
 Depois que um arquivo é aberto, seja para escrita, seja para leitura, após
 sua utilização ele deve ser "fechado". Caso isso não seja feito, consome-se
 memória e recursos do sistema operacional de forma indesejável e o arquivo
 fica travado para outras operações (por exemplo, um arquivo que não foi
 fechado não pode ser excluído).<BR>
 Caso o arquivo tenha sido aberto para escrita, e caso o caractere de
 separação seja diferente de vírgula ou de ponto (pode ser "ponto e vírgula"),
 então os valores com casas decimais são escritos com a vírgula separando os
 decimais e pontos separando os milhares. Os valores que representam números
 inteiros (sem casas decimais) apresentam pontos separando os milhares.<BR>
 Caso o arquivo tenha sido aberto para escrita, e caso o caractere de
 separação seja vírgula, então os valores com casas decimais são escritos com
 o ponto separando os decimais e nada separando os milhares.<BR>
 Caso o arquivo tenha sido aberto para escrita, e caso o caractere de
 separação seja ponto, então os valores com casas decimais são escritos com a
 vírgula separando os decimais e nada separando os milhares. Os valores que
 representam números inteiros (sem casas decimais) não apresentam nada
 separando os milhares.<BR>
 Exemplo de utilização:<BR>
 <CODE> arquivo = arquivos.criarCSV(null,"TESTE"); // Cria um arquivo
 TESTE.TXT com "ponto e vírgula" para separar os campos<BR>
 arquivo.escreveCampo(123); // Escreve o primeiro campo no arquivo, que
 corresponde ao número 123<BR>
 arquivo.escreveCampo("VERMELHO"); // Escreve o segundo campo no arquivo, que
 corresponde ao texto, separando com ponto e vírgula<BR>
 arquivo.escreveLinha(); // Conclui a primeira linha do arquivo.<BR>
 arquivo.escreveLinhas(456,"AZUL"); // Escreve a segunda linha do arquivo com
 o número 456 e o texto "AZUL", separando eles por ponto e vírgula.<BR>
 arquivo.fechar(); // Fecha o arquivo<BR>
 </CODE>
 
 DICA: Se o arquivo for aberto para LEITURA e se não houver necessidade de ler
 todas as linhas do arquivo, e se o arquivo pode ser muito grande,
 recomenda-se que não se utilize a função
 {@link ArquivoCSV#getQtdLinhas() getQtdLinhas}, mas em seu lugar se utilizem
 somente chamadas às funções {@link ArquivoCSV#getLinha(int) getLinha} e
 outras funções análogas (para obter campos das poucas linhas desejadas).
 Tendo em vista que o ContÁgil não carrega todo o arquivo em memória, na
 medida que mais linhas vão sendo lidas do arquivo, há necessidade de se
 conhecer a posição inicial de todas as linhas que antecedem cada uma delas
 (isso decorre do fato de que não se pode presumir que todas as linhas do
 arquivo possuem o mesmo tamanho).<BR>
 Por outro lado, se for necessário acessar todas as linhas do arquivo, daí sim
 pode-se utilizar a função {@link ArquivoCSV#getQtdLinhas() getQtdLinhas} caso
 for desejável.<BR>
 Se o arquivo é pequeno, tanto faz qual função é utilizada.<BR>
 Por exemplo, supondo que o arquivo tenha 1 GB de tamanho, e que seja
 necessário ler somente as primeiras 10 linhas do arquivo, recomenda-se fazer
 um LOOP para as 10 primeiras linhas (isto é, o argumento da função
 {@link ArquivoCSV#getLinha(int) getLinha} variando de 1 a 10), interrompendo
 quando o resultado da função for NULL (o que representa final do arquivo
 antes de concluir as 10 linhas, o que seria pouco provável em um arquivo com
 1 GB). É possível fazer isso sem utilizar a função
 {@link ArquivoCSV#getQtdLinhas() getQtdLinhas}, desta forma:<BR>
 <CODE> for (i=0; i<10; i++) // Percorre até no máximo 10 linhas do arquivo<BR> {<BR>
 &nbsp;&nbsp;&nbsp;linha = arquivo.getLinha(i);<BR>
 &nbsp;&nbsp;&nbsp;if (!linha) break; // Hipótese em que o arquivo terminou
 antes de concluir as 10 linhas<BR>
 &nbsp;&nbsp;&nbsp;// Senão, faz alguma coisa com a linha...<BR> }<BR>
 </CODE> OBS: O exemplo acima é apenas uma de várias possibilidades.<BR>"""

  def escreveCampo(self, conteudo) -> None:
    """Adiciona um campo ao arquivo CSV com o conteúdo apresentado.<BR>
 Caso esta funçao seja chamada sucessivas vezes, automaticamente é
 acrescentado o caractere de separação de colunas entre um conteúdo e
 outro.<BR>"""

    pass


  def escreveContagem(self, agregador) -> None:
    """Adiciona o conteúdo de um objeto "Agregador" apenas com relação ao que
 foi "contado".<BR>
 Caso o agregador tenha alguma "contagem" (seja via função "conta()", seja
 via função "contaDistintamente()"), apresenta em uma coluna própria o
 conteúdo da contagem.<BR>"""

    pass


  def escreveDistintos(self, agregador) -> None:
    """Adiciona o conteúdo de um objeto "Agregador" apenas com relação ao que
 foi contado de forma "distinta".<BR>
 Caso tenha sido feito um "contaDistintamente" no objeto de agregação,
 cada elemento distinto é apresentado em uma linha distinta do arquivo, e
 para cada linha repetem-se os mesmos critérios de agregação anteriores."""

    pass


  def escreveLinha(self, campo1, campo2, campo3, campo4) -> None:
    """Adiciona uma linha ao arquivo CSV com os conteúdos apresentados,
 incluindo automaticamente um caractere de separação de colunas entre
 eles.<BR>
 Automaticamente acrescentam-se os caracteres de "nova linha" (códigos ASC
 13 e 10) ao final de cada linha.<BR>
 Trata-se de um método análogo a executar:<BR>
 arquivo.escreveCampo(campo1);<BR>
 arquivo.escreveCampo(campo2);<BR>
 arquivo.escreveCampo(campo3);<BR>
 arquivo.escreveCampo(campo4);<BR>
 arquivo.escreveLinha();<BR>
 Para incluir mais de quatro campos na linha, utilize a forma
 "escreveCampo()" para os vários campos ao invés de utilizar esta função."""

    pass


  def escreveLinha(self) -> None:
    """Adiciona uma linha ao arquivo CSV sem incluir novas informações nesta
 linha.<BR>
 Automaticamente acrescentam-se os caracteres de "nova linha" (códigos ASC
 13 e 10) ao final da linha."""

    pass


  def escreveLinha(self, campo1, campo2) -> None:
    """Adiciona uma linha ao arquivo CSV com os conteúdos apresentados,
 incluindo automaticamente um caractere de separação de colunas entre
 eles.<BR>
 Automaticamente acrescentam-se os caracteres de "nova linha" (códigos ASC
 13 e 10) ao final de cada linha.<BR>
 Trata-se de um método análogo a executar:<BR>
 arquivo.escreveCampo(campo1);<BR>
 arquivo.escreveCampo(campo2);<BR>
 arquivo.escreveLinha();<BR>"""

    pass


  def escreveLinha(self, campo1, campo2, campo3) -> None:
    """Adiciona uma linha ao arquivo CSV com os conteúdos apresentados,
 incluindo automaticamente um caractere de separação de colunas entre
 eles.<BR>
 Automaticamente acrescentam-se os caracteres de "nova linha" (códigos ASC
 13 e 10) ao final de cada linha.<BR>
 Trata-se de um método análogo a executar:<BR>
 arquivo.escreveCampo(campo1);<BR>
 arquivo.escreveCampo(campo2);<BR>
 arquivo.escreveCampo(campo3);<BR>
 arquivo.escreveLinha();<BR>"""

    pass


  def escreveLinha(self, conteudo) -> None:
    """Adiciona uma linha ao arquivo CSV com o conteúdo apresentado (ou seja,
 não há separação de colunas, a menos que o conteúdo já contenha o texto
 incluindo o caracter utilizado na separação).<BR>
 Automaticamente acrescentam-se os caracteres de "nova linha" (códigos ASC
 13 e 10) ao final de cada linha."""

    pass


  def escreveLinha(self, criterio) -> None:
    """Adiciona os elementos que compõem o critério (que podem ser múltiplos),
 separando-os pelo caractere de separação de colunas.<BR>
 Automaticamente acrescentam-se os caracteres de "nova linha" (códigos ASC
 13 e 10) ao final de cada linha.<BR>"""

    pass


  def escreveLista(self, lista) -> None:
    """Adiciona uma lista ao arquivo, sendo que cada elemento da lista é escrito
 em uma linha diferente do arquivo. Apenas uma coluna é preenchida, cujo
 conteúdo varia conforme o tipo de elemento que está na lista."""

    pass


  def escreveTabela(self, tabela) -> None:
    """Adiciona o conteúdo integral de um objeto "Tabela". Ou seja, copia todas
 as suas linhas e suas colunas.<BR>"""

    pass


  def escreveTudo(self, agregador) -> None:
    """Adiciona o conteúdo integral de um objeto "Agregador". Ou seja, coloca em
 uma mesma linha todos os critérios de agregação e seus respectivos
 valores.<BR>
 Caso o agregador tenha alguma "contagem" (seja via função "conta()", seja
 via função "contaDistintamente()"), apresenta em uma coluna própria o
 conteúdo da contagem.<BR>
 Caso tenha sido feito um "contaDistintamente" no objeto de agregação,
 cada elemento distinto é apresentado em uma linha distinta do arquivo, e
 para cada linha repetem-se os mesmos critérios de agregação anteriores.<BR>
 OBS: Esta função escreve todo o conteúdo do Agregador no arquivo, o que
 inclui informações de naturezas distintas (tais como somas e contagens).
 Caso seja desejável escrever apenas as somas, ou apenas as contagens,
 utilize as funções alternativas (escreveContagem, escreveValores e
 escreveDistintos).<BR>"""

    pass


  def escreveValores(self, array) -> None:
    """Adiciona o conteúdo de um vetor, cada item em um campo diferente"""

    pass


  def escreveValores(self, agregador) -> None:
    """Adiciona o conteúdo de um objeto "Agregador" apenas com relação ao que
 foi "somado".<BR>
 Ou seja, coloca em uma mesma linha todos os critérios de agregação e seus
 respectivos valores.<BR>"""

    pass


  def escreveValores(self, lista) -> None:
    """Adiciona o conteúdo de uma lista, cada item em um campo diferente."""

    pass


  def fechar(self) -> None:
    """Fecha o arquivo, o que significa que nenhuma operação subsequente de
 escrita ou leitura poderá ser realizada utilizando este mesmo objeto.
 Porém, o mesmo arquivo pode ser lido posteriormente se for obtido um novo
 objeto Arquivo para ele.<BR>
 A operação de "fechar" um arquivo deve SEMPRE ser realizada após todas as
 operações de escrita ou leitura sobre o mesmo objeto. Se isso não for
 feito, o arquivo permanece "aberto", o que impede outras operações do
 sistema operacional (tais como a exclusão do arquivo ou movê-lo de
 diretório).<BR>
 OBS: O ContÁgil sempre fecha todos os arquivos que foram abertos pelo
 script, seja para escrita ou para leitura, ao final da execução do
 script.<BR>"""

    pass


  def getCampo(self, linha, campo) -> str:
    """Retorna o conteúdo de um determinado campo da linha.<BR>
 OBS: Se o arquivo foi aberto para escrita, gera erro."""

    pass


  def getCampos(self, linha) -> list:
    """Retorna o conteúdo de uma linha na forma de uma lista de String, cada uma
 referente a um campo da linha.<BR>
 OBS: Se o arquivo foi aberto para escrita, gera erro."""

    pass


  def getFormatoNumerico(self) -> str:
    """Retorna o valor que foi definido em {@link ArquivoCSV#setFormatoNumerico(String) setFormatoNumerico}."""

    pass


  def getQtdCampos(self, linha) -> int:
    """Retorna a quantidade de campos existentes em uma determinada linha do
 arquivo, caso o arquivo tenha sido aberto para leitura (se foi aberto
 para escrita, gera erro).<BR>"""

    pass


  def getSeparador(self) -> char:
    """Retorna a indicação do caractere que é utilizado como separador dos campos neste arquivo."""

    pass


  def getTabelaConvertida(self, linhaCabecalho, linhaDados, configuracaoColunas) -> TabelaConvertida:
    """Converte o conteúdo do arquivo CSV em uma tabela.<BR>
 Este método é diferente do método getTabela porque aqui existe um
 tratamento preliminar sobre os dados do arquivo. Por exemplo, a ordem das
 colunas pode variar no arquivo, mas a ordem das colunas da tabela
 retornada por este método segue rigorosamente a mesma ordem definida no
 parâmetro "configuracaoColunas" do método. Este método se encarrega de
 procurar no arquivo onde estão essas colunas.<BR>
 Além disso, outra diferença com relação ao método getTabela refere-se à
 formatação dos campos. O método getTabela retorna tudo como sendo
 "texto", ao passo que este método permite alguma conversão de formato
 (por exemplo, se uma determinada coluna for configurada como sendo
 CNPJ14, o sistema faz uma conversão de modo a tratar os números como
 sendo CNPJ de 14 dígitos, independentemente de haver caracteres de
 formatação ou não).<BR>
 Os formatos previstos são aqueles enumerados na documentação do método
 {@link Tabela#setFormato(int, String) setFormato}.<BR>
 <BR>
 Exemplo de utilização (em JavaScript):<BR>
 <CODE> arq = arquivos.abrirCSV(null,"C:\\UM_ARQUIVO.TXT"); // Abre um
 arquivo<BR>
 <BR> // Transforma o conteúdo do arquivo em uma tabela contendo 3 colunas
 (a quantidade real de colunas no<BR> // arquivo não interessa). Os nomes
 das colunas são, respectivamente, "Coluna1", "Coluna2" e "Coluna3". A<BR> //
 primeira coluna é obtida procurando na linha 1 do arquivo pelo campo que
 possui a palavra "CNPJ". Por exemplo, se<BR> // o segundo campo contém o
 texto "Cód CNPJ", considera-se que a segunda coluna do arquivo é a coluna
 que deve ser<BR> // transportada para a "Coluna1" da tabela resultante.
 Se há mais de um campo na linha 1 apresentando a palavra "CNPJ",<BR> //
 considera o primeiro deles.<BR> // Para a "Coluna2" procura pelo campo
 que contém o texto "Dia Emis". Por exemplo, se a linha 1 apresenta o
 texto "Dia Emissão"<BR> // na coluna 5, esta coluna é considerada para
 preencher a "Coluna2" da tabela resultante.<BR> // Por fim, considera
 para a "Coluna3" aquela coluna do arquivo cujo campo da linha 1 contém a
 palavra "Nome".<BR> // Depois que as colunas foram localizadas, seus
 dados são formatados da seguinte forma, respectivamente: formato CNPJ de
 14<BR> // dígitos, formato DATA e formato TEXTO.<BR>
 tab = arq.getTabelaConvertida(1,2,["Coluna1","CNPJ","CNPJ14",
 "Coluna2","Dia Emis","DATA", "Coluna3","Nome","TEXTO"]);<BR>
 </CODE> Atenção: o conteúdo completo da tabela deve caber na memória. Se
 você está lidando com arquivos muito grandes, este método pode não ser
 recomendável."""

    pass


  def isAceitaQuebraLinhaInterna(self) -> bool:
    """Flag que indica se pode ou não admitir quebras de linhas internas aos campos. Nesta hipótese espera
 encontrar aspas duplas antes e depois do conteúdo que inclui quebra de linha. O padrão é FALSO, isto é,
 qualquer 'quebra de linha' indica que são linhas distintas de dados, mesmo que a quebra de linha
 ocorra em conteúdo dentro de aspas duplas."""

    pass


  def isAcrescentaAspas(self) -> bool:
    """Flag que indica se deve ou não deve incluir aspas duplas ao redor de conteúdo
 que inclua o caractere separador como parte integrante. O padrão é incluir. Isto é,
 se algum método de escrita (como {@link ArquivoCSV#escreveLinha(Object) escreveLinha}, por exemplo)
 tentar inserir um texto cujo conteúdo inclua o caractere que é utilizado como separação (ex: vírgula),
 o conteúdo é automaticamente encapsulado entre aspas duplas para indicar que se trata de um só
 campo (e não de diferentes campos separados internamente).<BR>
 Se este flag for definido como FALSO, este comportamento automático não ocorre. Isto é, um conteúdo
 que contenha o caractere de separação é escrito desta forma no arquivo de saída, sem incluir de forma
 automática as aspas duplas ao seu redor (a menos que o conteúdo já inclua as aspas duplas de forma explícita)."""

    pass


  def isDesconsideraAspas(self) -> bool:
    """Parâmetro que afeta LEITURA e ESCRITA de arquivos.<BR>
 Na LEITURA, parâmetro que indica se deve ou não desconsiderar aspas ao redor dos valores.<BR>
 O padrão é não desconsiderar. Isto é, se algum campo do arquivo estiver apresentado
 entre aspas, as aspas são consideradas como parte do conteúdo do campo.<BR>
 Caso este parâmetro seja "TRUE" (VERDADEIRO), as aspas são ignoradas (isto é, são
 removidas do conteúdo durante a leitura do arquivo).<BR>
 Na ESCRITA, caso este parâmetro seja "FALSE" (FALSO), faz com que aspas sejam incluídas em duplicidade
 caso apareçam aspas no meio do conteúdo. Caso este parâmetro seja "TRUE" (VERDADEIRO), ignora a presença
 das aspas no meio de contéudo e com isso não insere outras aspas em duplicidade (isto é, permanecem as aspas
 conforme estão no conteúdo).<BR>
 As aspas não são excluídas caso a leitura não seja feita campo a campo (por exemplo,
 caso seja utilizado um método que retorna o conteúdo completo do arquivo, nenhuma manipulação
 é feita)."""

    pass


  def isDesconsideraPrimeiroCampoVazio(self) -> bool:
    """Parâmetro que indica se deve ou não desconsiderar o primeiro campo de cada linha caso
 ele seja vazio. O padrão é não desconsiderar o primeiro campo vazio (isto é, se o primeiro campo
 da linha é vazio, ele é considerado como parte da linha).<BR>
 A opção "desconsiderar" pode ser útil caso exista dúvida se a linha se inicia ou não
 com o caractere de separação. Por exemplo, arquivos do SPED contém campos separados
 com o caractere de barra vertical. No entanto, alguns arquivos do SPED podem se apresentar
 com o caractere sempre presente na primeira posição da linha, ao passo que outros podem se
 apresentar sem este caractere na primeira posição da linha. Se o caractere está presente na
 primeira posição da linha, é como se o primeiro campo da linha fosse "vazio" e o segundo campo
 da linha fosse o conteúdo à direita do caractere, daí em diante. Se esta opção for setada para
 "desconsiderar" o primeiro campo "vazio" da linha, então o primeiro campo passa a ser o segundo, neste
 exemplo. Note que fazendo desta forma o mesmo código fica compatível tanto nas situações em que o
 arquivo do SPED se inicia com o caractere de separação como também com as situações onde não se inicia.<BR>
 Note que este parâmetro afeta apenas o primeiro campo "vazio". Se o primeiro campo da linha não é vazio ou se
 há outros campos vazios além do primeiro, tais campos não são afetados por esta opção."""

    pass


  def readExternal(self, in) -> None:
    """Carrega o arquivo que contém os dados."""

    pass


  def setAceitaQuebraLinhaInterna(self, aceitaQuebraLinhaInterna) -> None:
    """Flag que indica se pode ou não admitir quebras de linhas internas aos campos. Nesta hipótese espera
 encontrar aspas duplas antes e depois do conteúdo que inclui quebra de linha. O padrão é FALSO, isto é,
 qualquer 'quebra de linha' indica que são linhas distintas de dados, mesmo que a quebra de linha
 ocorra em conteúdo dentro de aspas duplas."""

    pass


  def setAcrescentaAspas(self, acrescentarAspas) -> None:
    """Parâmetro que afeta ESCRITA de arquivos.<BR>
 Flag que indica se deve ou não deve incluir aspas duplas ao redor de conteúdo
 que inclua o caractere separador como parte integrante. O padrão é incluir. Isto é,
 se algum método de escrita (como {@link ArquivoCSV#escreveLinha(Object) escreveLinha}, por exemplo)
 tentar inserir um texto cujo conteúdo inclua o caractere que é utilizado como separação (ex: vírgula),
 o conteúdo é automaticamente encapsulado entre aspas duplas para indicar que se trata de um só
 campo (e não de diferentes campos separados internamente).<BR>
 Se este flag for definido como FALSO, este comportamento automático não ocorre. Isto é, um conteúdo
 que contenha o caractere de separação é escrito desta forma no arquivo de saída, sem incluir de forma
 automática as aspas duplas ao seu redor (a menos que o conteúdo já inclua as aspas duplas de forma explícita).<BR>
 <BR>
 Qualquer alteração neste flag afeta apenas a escrita neste ponto em diante. Isto é, o script pode em uma parte
 considerar a inclusão automática de aspas e em outra parte não considerar."""

    pass


  def setDesconsideraAspas(self, desconsideraAspas) -> None:
    """Parâmetro que afeta LEITURA e ESCRITA de arquivos.<BR>
 Na LEITURA, parâmetro que indica se deve ou não desconsiderar aspas ao redor dos valores.<BR>
 O padrão é não desconsiderar. Isto é, se algum campo do arquivo estiver apresentado
 entre aspas, as aspas são consideradas como parte do conteúdo do campo.<BR>
 Caso este parâmetro seja "TRUE" (VERDADEIRO), as aspas são ignoradas (isto é, são
 removidas do conteúdo durante a leitura do arquivo).<BR>
 Na ESCRITA, caso este parâmetro seja "FALSE" (FALSO), faz com que aspas sejam incluídas em duplicidade
 caso apareçam aspas no meio do conteúdo. Caso este parâmetro seja "TRUE" (VERDADEIRO), ignora a presença
 das aspas no meio de contéudo e com isso não insere outras aspas em duplicidade (isto é, permanecem as aspas
 conforme estão no conteúdo).<BR>
 As aspas não são excluídas caso a leitura não seja feita campo a campo (por exemplo,
 caso seja utilizado um método que retorna o conteúdo completo do arquivo, nenhuma manipulação
 é feita)."""

    pass


  def setDesconsideraPrimeiroCampoVazio(self, desconsideraPrimeiroCampoVazio) -> None:
    """Parâmetro que indica se deve ou não desconsiderar o primeiro campo de cada linha caso
 ele seja vazio. O padrão é não desconsiderar o primeiro campo vazio (isto é, se o primeiro campo
 da linha é vazio, ele é considerado como parte da linha).<BR>
 A opção "desconsiderar" pode ser útil caso exista dúvida se a linha se inicia ou não
 com o caractere de separação. Por exemplo, arquivos do SPED contém campos separados
 com o caractere de barra vertical. No entanto, alguns arquivos do SPED podem se apresentar
 com o caractere sempre presente na primeira posição da linha, ao passo que outros podem se
 apresentar sem este caractere na primeira posição da linha. Se o caractere está presente na
 primeira posição da linha, é como se o primeiro campo da linha fosse "vazio" e o segundo campo
 da linha fosse o conteúdo à direita do caractere, daí em diante. Se esta opção for setada para
 "desconsiderar" o primeiro campo "vazio" da linha, então o primeiro campo passa a ser o segundo, neste
 exemplo. Note que fazendo desta forma o mesmo código fica compatível tanto nas situações em que o
 arquivo do SPED se inicia com o caractere de separação como também com as situações onde não se inicia.<BR>
 Note que este parâmetro afeta apenas o primeiro campo "vazio". Se o primeiro campo da linha não é vazio ou se
 há outros campos vazios além do primeiro, tais campos não são afetados por esta opção."""

    pass


  def setFormatoNumerico(self, padrao) -> None:
    """Define o padrão a ser utilizado na representação de valores com casas decimais. Pode-se
 escolher um dos seguintes:<BR>
 AUTOMÁTICO -> utiliza o padrão brasileiro, onde a vírgula é utilizada como separador de casas decimais, exceto apenas quando
 a vírgula já está sendo utilizada como caractere de separação de campos (colunas).<BR>
 BRASILEIRO -> utiliza o padrão brasileiro, onde a vírgula é utilizada como separador de casas decimais.<BR>
 INTERNACIONAL -> utiliza o padrão internacional americano, onde o ponto é utilizado como separador de casas decimais."""

    pass


  def setSeparador(self, separador) -> None:
    """Altera a definição do caractere que é utilizado como separador dos campos neste arquivo."""

    pass


  def writeExternal(self, out) -> None:
    """Persiste somente o nome do arquivo que contém os dados."""

    pass

class ArquivoCompactado ():
  """Classe que implementa diversas operações relativas a um arquivo compactado utilizando as bibliotecas do 7-Zip. .<BR>
 Exemplos:<BR>
 <CODE> // Abre o arquivo TESTE.ZIP que está na pasta do projeto.<BR>
 zip = arquivos.abrirZIP(null,"TESTE");<BR> 
 // Faz um LOOP para cada arquivo encontrado dentro do arquivo ZIP<BR>
 while (arq = zip.proximo())<BR> {<BR>
 &nbsp;&nbsp;&nbsp;// extrai arquivo encontrado dentro do ZIP para pasta do usuário<BR>
 &nbsp;&nbsp;&nbsp;arquivo = zip.extraiAtual(null,null);<BR> }<BR>
 // Extrai tudo para diretório c:/tmp<BR>
 zip.extraiTudo("c:/tmp");<BR>
 
 </CODE>"""

  def abrir(self) -> None:
    pass


  def criar(self, ext, arquivos) -> None:
    pass


  def escreveArquivos(self, arquivos) -> None:
    """Adiciona arquivos no arquivo compactado (SEVEN_ZIP, ZIP, GZIP, TAR ou BZIP2).
 O arquivo é reaberto após o update e a posição do arquivo atual é reiniciada."""

    pass


  def extraiAtual(self, diretorio, nomeArquivo) -> Arquivo:
    """Extrai o conteúdo do arquivo interno que foi obtido na última execução da
 função {@link ArquivoCompactado#proximo() proximo}. Ou seja, para cada arquivo
 retornado naquela função, pode-se obter extrair conteúdo através desta
 função, salvando-o como um novo arquivo externo.<BR>
 Se o arquivo compactado foi aberto mas não houve uma chamada à
 função {@link ArquivoCompactado#proximo() proximo}, esta função retorna NULL.<BR>"""

    pass


  def extraiTudo(self, nomeDiretorioDestino) -> None:
    """Faz a descompactação completa do conteúdo deste arquivo compactado para um diretório de destino.<BR>
 Ao contrário de {@link ArquivoCompactado#extraiAtual(String, String) extraiAtual}, esta função não requer a execução prévia da função
 {@link ArquivoCompactado#proximo() proximo}."""

    pass


  def fechar(self) -> None:
    """Fecha o arquivo compactado."""

    pass


  def isFechado(self) -> bool:
    pass


  def proximo(self) -> Arquivo:
    """Retorna o próximo arquivo da lista de arquivos compactados. Se não há mais arquivos a
 serem percorridos (isto é, se a lista já acabou), retorna NULL.<BR>"""

    pass

class ArquivoExcel ():
  """Classe que implementa diversas operações relativas a um arquivo EXCEL.<BR>
 Dependendo de como o objeto foi obtido, é possível ler ou escrever no
 arquivo.<BR>
 Se o objeto foi obtido por uma função de criação (por exemplo,
 GerenciadorArquivos.criarExcel()), as funções de escrita estão
 disponíveis, além das funções de leitura. O mesmo ocorre se o arquivo foi aberto para edição.<BR>
 Se o objeto foi obtido por uma função de apenas leitura (por exemplo,
 GerenciadorArquivos.abrirExcel()), as funções de escrita geram erro.<BR>
 Pode-se trabalhar tanto com arquivos do formato antigo do Excel (extensão
 XLS) como também com arquivos no formato criado após o Microsoft Office 2007
 (extensão XLSX).<BR>
 Depois que um arquivo é aberto, seja para escrita, seja para leitura, após
 sua utilização ele deve ser "fechado". Caso isso não seja feito, consome-se
 memória e recursos do sistema operacional de forma indesejável e o arquivo
 fica travado para outras operações (por exemplo, um arquivo que não foi
 fechado não pode ser excluído).<BR>
 Exemplo de utilização:<BR>
 <CODE> arquivo = arquivos.criarExcel(null,"TESTE"); // Cria um arquivo
 TESTE.XLS<BR>
 arquivo.escreveCelula(1,2,123); // Escreve na célula da linha 1, coluna 2, o
 número 123<BR>
 arquivo.escreveCelula(1,3,"VERMELHO"); // Escreve na célula da linha 1,
 coluna 3, o valor "VERMELHO"<BR>
 arquivo.escreveCelulaData(2,3,"31/01/2002"); // Escreve na célula da linha 2,
 coluna 3, a data 31/01/2002<BR>
 arquivo.fechar(); // Fecha o arquivo<BR>
 </CODE>"""

  def addReferenciaExterna(self, nomeArquivo) -> None:
    """Adiciona uma referência externa (útil quando fórmula em um arquivo
 faz referência a outros arquivos).<BR>
 OBS: atualmente este método se aplica somente a LEITURA de arquivos
 Excel, não a ESCRITA.<BR>
 Por exemplo, digamos que o arquivo ARQUIVO_1.XLS possui em uma de suas células
 a fórmula:
 <PRE>
 =A1 + [ARQUIVO_2.XLS]Plan1!B1
 </PRE>
 Esta fórmula indica que o conteúdo da célula A1 de ARQUIVO_1.XLS deve ser somado
 com o conteúdo da célula B1 da planilha Plan1 de ARQUIVO_2.XLS.<BR>
 Para que essa fórmula seja corretamente interpretada através do script, é necessário
 que o método {@link #addReferenciaExterna(String) addReferenciaExterna} seja executado
 sobre o objeto {@link ArquivoExcel ArquivoExcel} correspondente a ARQUIVO_1.XLS, passando
 como parâmetro a localização de ARQUIVO_2.XLS (o nome completo, incluindo subdiretório)."""

    pass


  def atualizaFormulas(self) -> None:
    """Caso o arquivo tenha sido aberto para escrita (criação ou edição) ou leitura, este método
 provoca uma atualização em todas as fórmulas existentes de uma só vez.<BR>
 Isso é particularmente útil quando estiver escrevendo dados na planilha e depois
 estiver interessado em obter o resultado de algumas das fórmulas existentes (isto é, quando
 faz 'escrita' e também 'leitura')."""

    pass


  def conservaFormatacao(self, conserva) -> None:
    """Indica se deve ou não deve conservar a formatação de células que já existe na planilha
 Excel caso informações sejam inseridas em células desta planilha.<BR>
 O padrão é NÃO conservar. Isto é, a formatação de célula é escolhida pela aplicação
 conforme o tipo de informação que está sendo escrita.<BR>
 Caso seja executada esta ação com o parâmetro TRUE ("SIM"), as ações de edição posteriores a esta
 preservarão a formatação já aplicada na planilha. Note que se trata de uma situação particular
 para 'edição' de planilha (isto é, quando se parte de uma planilha já existente para alterar
 seu conteúdo)."""

    pass


  def copiaIntervalo(self, linhaInicial, colunaInicial, linhaDestino, colunaDestino, numLinhas, numColunas) -> None:
    """Caso esteja editando uma planilha existente (isto é, caso tenha aberto
 o arquivo para EDIÇÃO ou CRIAÇÃO), este método pode ser utilizado para
 copiar um intervalo de células, com múltiplas linhas e/ou múltiplas colunas,
 de uma parte da planilha para outra parte da mesma planilha."""

    pass


  def copiaIntervalo(self, linhaInicial, colunaInicial, linhaDestino, colunaDestino, numLinhas, numColunas, alteraFormulas) -> None:
    """Caso esteja editando uma planilha existente (isto é, caso tenha aberto
 o arquivo para EDIÇÃO ou CRIAÇÃO), este método pode ser utilizado para
 copiar um intervalo de células, com múltiplas linhas e/ou múltiplas colunas,
 de uma parte da planilha para outra parte da mesma planilha."""

    pass


  def criaPlanilha(self, nomePlanilha) -> None:
    """Cria uma nova planilha no arquivo, caso ele tenha sido aberto para escrita.<BR>
 A planilha recém criada é selecionada para edições posteriores."""

    pass


  def desenhaImagem(self, imagem) -> None:
    """Deseja uma imagem na planilha considerando a posição atual de linha e
 coluna. Depois desta função, a linha atual é atualizada de modo a
 alcançar a posição abaixo da imagem.<BR>
 Deste modo as funções posteriores de escrita de células na planilha, caso
 presentes, não ocupam o espaço ocupado pela imagem."""

    pass


  def desenhaImagem(self, linha, coluna, imagem) -> None:
    """Deseja uma imagem na planilha considerando a posição de linha e coluna
 indicadas como parâmetros.<BR>
 OBS: ao contrário da função de mesmo nome que recebe um único parâmetro,
 esta função não altera as indicações de linha e de coluna atuais.<BR>"""

    pass


  def deslocaColunasDireita(self, coluna, deslocamento) -> None:
    """Caso esteja editando uma planilha existente (isto é, caso tenha aberto
 o arquivo para EDIÇÃO ou CRIAÇÃO), este método provoca o deslocamento
 de colunas existentes para direita."""

    pass


  def deslocaLinhasAbaixo(self, linha, deslocamento) -> None:
    """Caso esteja editando uma planilha existente (isto é, caso tenha aberto
 o arquivo para EDIÇÃO ou CRIAÇÃO), este método provoca o deslocamento
 de linhas existentes para baixo."""

    pass


  def duplicaPlanilha(self, novo_nome) -> None:
    """Duplica a planilha atual do arquivo para uma nova planilha no mesmo
 arquivo, mas com nome diferente.<BR>
 Além disso, faz da nova planilha a planilha atual."""

    pass


  def escreveCelula(self, conteudo) -> None:
    """Escreve o conteúdo em uma célula da planilha, considerando para isso a
 linha e a coluna atuais (isto é, considerando todas as demais funções
 escreveXXX que antecederam esta, exceto aquelas funções que recebem como
 parâmetro o par de coordenadas linha/coluna).<BR>
 A indicação de "coluna atual" é incrementada após esta função.<BR>
 A indicação de "linha atual" permanece a mesma.<BR>"""

    pass


  def escreveCelula(self, linha, coluna, conteudo) -> None:
    """Escreve o conteúdo de uma célula na planilha atualmente aberta do
 arquivo.<BR>"""

    pass


  def escreveCelulaData(self, linha, coluna, data) -> None:
    """Escreve o conteúdo de uma célula do tipo DATA na planilha atualmente
 aberta do arquivo.<BR>"""

    pass


  def escreveCelulas(self, linha, coluna, criterio) -> None:
    """Adiciona os elementos que compõem o critério (que podem ser múltiplos) em
 células diferentes do Excel, começando pela célula indicada nos
 parâmetros.<BR>"""

    pass


  def escreveContagem(self, agregador) -> None:
    """Adiciona o conteúdo de um objeto "Agregador" apenas com relação ao que
 foi "contado".<BR>
 Caso o agregador tenha alguma "contagem" (seja via função "conta()", seja
 via função "contaDistintamente()"), apresenta em uma coluna própria o
 conteúdo da contagem.<BR>
 Os dados são escritos em células individuais da planilha, sendo que a
 célula superior esquerda é indicada no parâmetro desta função.<BR>
 Automaticamente avança para a próxima linha.<BR>
 Esta função é afetada por outras funções do tipo "incremental", isto é,
 onde o número de linha e o número de coluna não estão explícitos na
 chamada da função.<BR>"""

    pass


  def escreveContagem(self, linha, coluna, agregador) -> None:
    """Adiciona o conteúdo de um objeto "Agregador" apenas com relação ao que
 foi "contado".<BR>
 Caso o agregador tenha alguma "contagem" (seja via função "conta()", seja
 via função "contaDistintamente()"), apresenta em uma coluna própria o
 conteúdo da contagem.<BR>
 Os dados são escritos em células individuais da planilha, sendo que a
 célula superior esquerda é indicada no parâmetro desta função."""

    pass


  def escreveDistintos(self, agregador) -> None:
    """Adiciona o conteúdo de um objeto "Agregador" apenas com relação ao que
 foi contado de forma "distinta".<BR>
 Caso tenha sido feito um "contaDistintamente" no objeto de agregação,
 cada elemento distinto é apresentado em uma linha distinta do arquivo, e
 para cada linha repetem-se os mesmos critérios de agregação anteriores.
 Os dados são escritos em células individuais da planilha, sendo que a
 célula superior esquerda é indicada no parâmetro desta função.<BR>
 Automaticamente avança para a próxima linha.<BR>
 Esta função é afetada por outras funções do tipo "incremental", isto é,
 onde o número de linha e o número de coluna não estão explícitos na
 chamada da função.<BR>"""

    pass


  def escreveDistintos(self, linha, coluna, agregador) -> None:
    """Adiciona o conteúdo de um objeto "Agregador" apenas com relação ao que
 foi contado de forma "distinta".<BR>
 Caso tenha sido feito um "contaDistintamente" no objeto de agregação,
 cada elemento distinto é apresentado em uma linha distinta do arquivo, e
 para cada linha repetem-se os mesmos critérios de agregação anteriores.
 Os dados são escritos em células individuais da planilha, sendo que a
 célula superior esquerda é indicada no parâmetro desta função."""

    pass


  def escreveFormula(self, linha, coluna, formula) -> None:
    """Escreve uma fórmula no padrão do Excel em uma célula na planilha atualmente aberta
 do arquivo.<BR>"""

    pass


  def escreveLinha(self, criterio) -> None:
    """Adiciona os elementos que compõem o critério (que podem ser múltiplos) em
 células diferentes do Excel.<BR>
 Automaticamente avança para a próxima linha.<BR>
 Esta função é afetada por outras funções do tipo "incremental", isto é,
 onde o número de linha e o número de coluna não estão explícitos na
 chamada da função.<BR>"""

    pass


  def escreveLinha(self, conteudo) -> None:
    """Adiciona uma linha ao arquivo Excel com o conteúdo apresentado em uma
 célula.<BR>
 Automaticamente avança para a próxima linha.<BR>
 Esta função é afetada por outras funções do tipo "incremental", isto é,
 onde o número de linha e o número de coluna não estão explícitos na
 chamada da função.<BR>"""

    pass


  def escreveLinha(self, campo1, campo2, campo3, campo4) -> None:
    """Adiciona uma linha ao arquivo Excel com os conteúdos apresentado em quatro
 células.<BR>
 Automaticamente avança para a próxima linha.<BR>
 Esta função é afetada por outras funções do tipo "incremental", isto é,
 onde o número de linha e o número de coluna não estão explícitos na
 chamada da função.<BR>"""

    pass


  def escreveLinha(self) -> None:
    """Avança para a próxima linha, reiniciando pela primeira coluna da próxima
 linha.<BR>
 Esta função afeta apenas as funções que omitem a indicação de número de
 linha e número de coluna."""

    pass


  def escreveLinha(self, campo1, campo2, campo3) -> None:
    """Adiciona uma linha ao arquivo Excel com os conteúdos apresentado em três
 células.<BR>
 Automaticamente avança para a próxima linha.<BR>
 Esta função é afetada por outras funções do tipo "incremental", isto é,
 onde o número de linha e o número de coluna não estão explícitos na
 chamada da função.<BR>"""

    pass


  def escreveLinha(self, campo1, campo2) -> None:
    """Adiciona uma linha ao arquivo Excel com os conteúdos apresentado em duas
 células.<BR>
 Automaticamente avança para a próxima linha.<BR>
 Esta função é afetada por outras funções do tipo "incremental", isto é,
 onde o número de linha e o número de coluna não estão explícitos na
 chamada da função.<BR>"""

    pass


  def escreveLinha(self, campo1, campo2, campo3, campo4, campo5) -> None:
    """Adiciona uma linha ao arquivo Excel com os conteúdos apresentado em cinco
 células.<BR>
 Automaticamente avança para a próxima linha.<BR>
 Esta função é afetada por outras funções do tipo "incremental", isto é,
 onde o número de linha e o número de coluna não estão explícitos na
 chamada da função.<BR>"""

    pass


  def escreveLista(self, linha, coluna, lista) -> None:
    """Adiciona uma lista ao arquivo, sendo que cada elemento da lista é escrito
 em uma linha diferente do arquivo. Apenas uma coluna é preenchida, cujo
 conteúdo varia conforme o tipo de elemento que está na lista."""

    pass


  def escreveLista(self, lista) -> None:
    """Adiciona uma lista ao arquivo, sendo que cada elemento da lista é escrito
 em uma linha diferente do arquivo. Apenas uma coluna é preenchida, cujo
 conteúdo varia conforme o tipo de elemento que está na lista.<BR>
 Automaticamente avança para a próxima linha.<BR>
 Esta função é afetada por outras funções do tipo "incremental", isto é,
 onde o número de linha e o número de coluna não estão explícitos na
 chamada da função.<BR>"""

    pass


  def escreveTabela(self, tabela) -> None:
    """Adiciona o conteúdo integral de um objeto "Tabela". Ou seja, copia todas
 as suas linhas e suas colunas.<BR>
 Se as colunas da tabela possuírem títulos, inclui uma linha adicional com
 os títulos da coluna (isto é, uma linha de cabeçalho)."""

    pass


  def escreveTabela(self, tabela, escreveCabecalho) -> None:
    """Adiciona o conteúdo integral de um objeto "Tabela". Ou seja, copia todas
 as suas linhas e suas colunas.<BR>"""

    pass


  def escreveTabela(self, tabela, planilha, primeira_linha, primeira_coluna, escreveCabecalho) -> None:
    """Escreve uma tabela em uma posição arbitrária do arquivo Excel.<BR>
 As definições de 'planilha atual' e 'linha atual' são atualizadas
 de acordo com os parâmetros informados neste método. Ao final da execução
 do método, a 'linha atual' será a última linha após inclusão da tabela."""

    pass


  def escreveTudo(self, linha, coluna, agregador) -> None:
    """Adiciona o conteúdo integral de um objeto "Agregador". Ou seja, coloca em
 uma mesma linha todos os critérios de agregação e seus respectivos
 valores.<BR>
 Caso o agregador tenha alguma "contagem" (seja via função "conta()", seja
 via função "contaDistintamente()"), apresenta em uma coluna própria o
 conteúdo da contagem.<BR>
 Caso tenha sido feito um "contaDistintamente" no objeto de agregação,
 cada elemento distinto é apresentado em uma linha distinta do arquivo, e
 para cada linha repetem-se os mesmos critérios de agregação anteriores.<BR>
 OBS: Esta função escreve todo o conteúdo do Agregador no arquivo, o que
 inclui informações de naturezas distintas (tais como somas e contagens).
 Caso seja desejável escrever apenas as somas, ou apenas as contagens,
 utilize as funções alternativas (escreveContagem, escreveValores e
 escreveDistintos).<BR>
 Os dados são escritos em células individuais da planilha, sendo que a
 célula superior esquerda é indicada no parâmetro desta função."""

    pass


  def escreveTudo(self, agregador) -> None:
    """Adiciona o conteúdo integral de um objeto "Agregador". Ou seja, coloca em
 uma mesma linha todos os critérios de agregação e seus respectivos
 valores.<BR>
 Caso o agregador tenha alguma "contagem" (seja via função "conta()", seja
 via função "contaDistintamente()"), apresenta em uma coluna própria o
 conteúdo da contagem.<BR>
 Caso tenha sido feito um "contaDistintamente" no objeto de agregação,
 cada elemento distinto é apresentado em uma linha distinta do arquivo, e
 para cada linha repetem-se os mesmos critérios de agregação anteriores.<BR>
 OBS: Esta função escreve todo o conteúdo do Agregador no arquivo, o que
 inclui informações de naturezas distintas (tais como somas e contagens).
 Caso seja desejável escrever apenas as somas, ou apenas as contagens,
 utilize as funções alternativas (escreveContagem, escreveValores e
 escreveDistintos).<BR>
 Automaticamente avança para a próxima linha.<BR>
 Esta função é afetada por outras funções do tipo "incremental", isto é,
 onde o número de linha e o número de coluna não estão explícitos na
 chamada da função.<BR>"""

    pass


  def escreveValores(self, linha, coluna, agregador) -> None:
    """Adiciona o conteúdo de um objeto "Agregador" apenas com relação ao que
 foi "somado".<BR>
 Ou seja, coloca em uma mesma linha todos os critérios de agregação e seus
 respectivos valores.<BR>
 Os dados são escritos em células individuais da planilha, sendo que a
 célula superior esquerda é indicada no parâmetro desta função."""

    pass


  def escreveValores(self, agregador) -> None:
    """Adiciona o conteúdo de um objeto "Agregador" apenas com relação ao que
 foi "somado".<BR>
 Ou seja, coloca em uma mesma linha todos os critérios de agregação e seus
 respectivos valores.<BR>
 Os dados são escritos em células individuais da planilha, sendo que a
 célula superior esquerda é indicada no parâmetro desta função.<BR>
 Automaticamente avança para a próxima linha.<BR>
 Esta função é afetada por outras funções do tipo "incremental", isto é,
 onde o número de linha e o número de coluna não estão explícitos na
 chamada da função.<BR>"""

    pass


  def exportaTabelaUsuario(self, nome, linhaCabecalho, acrescenta) -> TabelaUsuario:
    """Exporta o conteúdo deste arquivo Excel para uma
 {@link TabelaUsuario TabelaUsuario}. Ou seja, os dados ficam armazenados
 em disco de uma forma que pode ser consultada posteriormente pelo usuário
 por um MODELO ANALÍTICO DINÂMICO ou até mesmo por script através do
 método {@link ContAgilEngine#getTabelaUsuario(String) getTabelaUsuario}.<BR>
 Se já existir uma tabela do usuário com o nome especificado, ela é
 sobrescrita com os novos dados.<BR>
 <BR>
 Se o arquivo possui mais de uma planilha, considera apenas a 'planilha atual' (definida
 por {@link ArquivoExcel#selecionaPlanilha(int) selecionaPlanilha}).<BR>
 <BR>
 Este método presume que existe uma linha de 'cabeçalho', contendo
 títulos de colunas. Esses nomes são então considerados de forma automática para
 nomear as colunas da tabela do usuário gerada.<BR>
 Presume-se que os dados se iniciam a partir desta linha de cabeçalho.<BR>
 <BR>"""

    pass


  def fechar(self) -> None:
    """Fecha o arquivo, o que significa que nenhuma operação subsequente de
 escrita ou leitura poderá ser realizada utilizando este mesmo objeto.
 Porém, o mesmo arquivo pode ser lido posteriormente se for obtido um novo
 objeto Arquivo para ele.<BR>
 A operação de "fechar" um arquivo deve SEMPRE ser realizada após todas as
 operações de escrita ou leitura sobre o mesmo objeto. Se isso não for
 feito, o arquivo permanece "aberto", o que impede outras operações do
 sistema operacional (tais como a exclusão do arquivo ou movê-lo de
 diretório).<BR>
 OBS: O ContÁgil sempre fecha todos os arquivos que foram abertos pelo
 script, seja para escrita ou para leitura, ao final da execução do
 script.<BR>"""

    pass


  def getCelula(self, linha, coluna) -> Object:
    """Retorna o conteúdo de uma célula do Excel, caso o arquivo tenha sido
 aberto para leitura (se foi aberto para escrita, gera erro).<BR>
 Caso a célula tenha uma fórmula do Excel, retorna o resultado da fórmula.<BR>
 Caso o arquivo tenha mais de uma planilha, considera a primeira planilha
 do arquivo ou considera aquela planilha que foi ajustada pela última
 chamada à função
 {@link ArquivoExcel#selecionaPlanilha(int) selecionaPlanilha}.<BR>
 ATENÇÃO: caso a célula do Excel possua 'fórmula', o ContÁgil tentará interpretar
 a fórmula e retornar o resultado correspondente. Porém, nem todas as fórmulas
 do Excel podem ser interpretadas pelo ContÁgil. Por exemplo, as fórmulas que utilizam
 PROCV não podem ser interpretadas pelo ContÁgil."""

    pass


  def getCelula(self, planilha, linha, coluna) -> Object:
    """Retorna o conteúdo de uma célula do Excel, caso o arquivo tenha sido
 aberto para leitura (se foi aberto para escrita, gera erro).<BR>
 Caso a célula tenha uma fórmula do Excel, retorna o resultado da fórmula.<BR>
 ATENÇÃO: caso a célula do Excel possua 'fórmula', o ContÁgil tentará interpretar
 a fórmula e retornar o resultado correspondente. Porém, nem todas as fórmulas
 do Excel podem ser interpretadas pelo ContÁgil. Por exemplo, as fórmulas que utilizam
 PROCV não podem ser interpretadas pelo ContÁgil."""

    pass


  def getCelulaFormatada(self, planilha, linha, coluna) -> str:
    """Retorna o conteúdo de uma célula do Excel já formatado para texto, caso o
 arquivo tenha sido aberto para leitura (se foi aberto para escrita, gera
 erro).<BR>
 Caso a célula tenha uma fórmula do Excel, retorna o resultado da fórmula."""

    pass


  def getCelulaFormatada(self, linha, coluna) -> str:
    """Retorna o conteúdo de uma célula do Excel já formatado para texto, caso o
 arquivo tenha sido aberto para leitura (se foi aberto para escrita, gera
 erro).<BR>
 Caso a célula tenha uma fórmula do Excel, retorna o resultado da fórmula.<BR>
 Caso o arquivo tenha mais de uma planilha, considera a primeira planilha
 do arquivo ou considera aquela planilha que foi ajustada pela última
 chamada à função
 {@link ArquivoExcel#selecionaPlanilha(int) selecionaPlanilha}."""

    pass


  def getColunaAtual(self) -> int:
    """Caso o arquivo tenha sido aberto para escrita, retorna a indicação de
 "coluna atual" que é considerada por algumas funções que escrevem na
 planilha (funções estas que não recebem como parâmetro o número da
 coluna, pois utiliza internamente a indicação de "coluna atual")."""

    pass


  def getLinhaAtual(self) -> int:
    """Caso o arquivo tenha sido aberto para escrita, retorna a indicação de
 "linha atual" que é considerada por algumas funções que escrevem na
 planilha (funções estas que não recebem como parâmetro o número da linha,
 pois utiliza internamente a indicação de "linha atual")."""

    pass


  def getNomePlanilha(self, indice) -> str:
    """Retorna o nome de uma determinada planilha.<BR>"""

    pass


  def getPlanilhaAtual(self) -> int:
    """Retorna o número da planilha atualmente 'selecionada', começando pelo número 1."""

    pass


  def getQtdColunas(self, planilha) -> int:
    """Retorna a quantidade de colunas existentes em uma planilha do Excel, caso
 o arquivo tenha sido aberto para leitura (se foi aberto para escrita,
 gera erro).<BR>"""

    pass


  def getQtdColunas(self) -> int:
    """Retorna a quantidade de colunas existentes em uma planilha do Excel, caso
 o arquivo tenha sido aberto para leitura (se foi aberto para escrita,
 gera erro).<BR>
 Caso o arquivo tenha mais de uma planilha, considera a primeira planilha
 do arquivo ou considera aquela planilha que foi ajustada pela última
 chamada à função
 {@link ArquivoExcel#selecionaPlanilha(int) selecionaPlanilha}."""

    pass


  def getQtdLinhas(self) -> int:
    """Retorna a quantidade de linhas existentes em uma planilha do Excel, caso
 o arquivo tenha sido aberto para leitura (se foi aberto para escrita,
 gera erro).<BR>
 Caso o arquivo tenha mais de uma planilha, considera a primeira planilha
 do arquivo ou considera aquela planilha que foi ajustada pela última
 chamada à função
 {@link ArquivoExcel#selecionaPlanilha(int) selecionaPlanilha}."""

    pass


  def getQtdLinhas(self, planilha) -> int:
    """Retorna a quantidade de linhas existentes em uma planilha do Excel, caso
 o arquivo tenha sido aberto para leitura (se foi aberto para escrita,
 gera erro).<BR>"""

    pass


  def getQtdPlanilhas(self) -> int:
    """Retorna a quantidade de planilhas existentes dentro do arquivo."""

    pass


  def getTabela(self, planilha, primeira_linha, primeira_coluna, ultima_linha, ultima_coluna) -> Tabela:
    """Converte o conteúdo de uma planilha em um objeto {@link Tabela Tabela}.
 Se o arquivo foi aberto para escrita, gera erro."""

    pass


  def getTabela(self) -> Tabela:
    """Método equivalente ao método
 {@link ArquivoExcel#getTabela(int, int, int, int, int) getTabela} onde os
 diferentes parâmetros são preenchidos conforme indicados abaixo.<BR>
 Consulte os comentários do método
 {@link ArquivoExcel#getTabela(int, int, int, int, int) getTabela} para
 mais informações.<BR>
 "planilha" igual a 1 ou ao número que foi definido com a função
 {@link ArquivoExcel#selecionaPlanilha(int) selecionaPlanilha}.<BR>
 "primeira_linha" igual a 1.<BR>
 "primeira_coluna" igual a 1.<BR>
 "ultima linha" igual ao resultado da execução do método
 {@link ArquivoExcel#getQtdLinhas() getQtdLinhas}.<BR>
 "ultima_coluna" igual ao resultado da execução do método
 {@link ArquivoExcel#getQtdColunas() getQtdColunas}.<BR>"""

    pass


  def getTabelaConvertida(self, planilha, linhaCabecalho, linhaDados, configuracaoColunas) -> TabelaConvertida:
    """Converte o conteúdo do arquivo Excel em uma tabela.<BR>
 Este método é diferente do método getTabela porque aqui existe um
 tratamento preliminar sobre os dados do arquivo. Por exemplo, a ordem das
 colunas pode variar no arquivo, mas a ordem das colunas da tabela
 retornada por este método segue rigorosamente a mesma ordem definida no
 parâmetro "configuracaoColunas" do método. Este método se encarrega de
 procurar no arquivo onde estão essas colunas.<BR>
 Além disso, outra diferença com relação ao método getTabela refere-se à
 formatação dos campos. O método getTabela retorna tudo como sendo
 "texto", ao passo que este método permite alguma conversão de formato
 (por exemplo, se uma determinada coluna for configurada como sendo
 CNPJ14, o sistema faz uma conversão de modo a tratar os números como
 sendo CNPJ de 14 dígitos, independentemente de haver caracteres de
 formatação ou não).<BR>
 Os formatos previstos são aqueles enumerados na documentação do método
 {@link Tabela#setFormato(int, String) setFormato}.<BR>
 <BR>
 Exemplo de utilização (em JavaScript):<BR>
 <CODE> arq = arquivos.abrirExcel(null,"C:\\UM_ARQUIVO.XLS"); // Abre um
 arquivo<BR>
 <BR> // Transforma o conteúdo do arquivo em uma tabela contendo 3 colunas
 (a quantidade real de colunas no<BR> // arquivo não interessa). Os nomes
 das colunas são, respectivamente, "Coluna1", "Coluna2" e "Coluna3". A<BR> //
 primeira coluna é obtida procurando na linha 1 do arquivo pelo campo que
 possui a palavra "CNPJ". Por exemplo, se<BR> // o segundo campo contém o
 texto "Cód CNPJ", considera-se que a segunda coluna do arquivo é a coluna
 que deve ser<BR> // transportada para a "Coluna1" da tabela resultante.
 Se há mais de um campo na linha 1 apresentando a palavra "CNPJ",<BR> //
 considera o primeiro deles.<BR> // Para a "Coluna2" procura pelo campo
 que contém o texto "Dia Emis". Por exemplo, se a linha 1 apresenta o
 texto "Dia Emissão"<BR> // na coluna 5, esta coluna é considerada para
 preencher a "Coluna2" da tabela resultante.<BR> // Por fim, considera
 para a "Coluna3" aquela coluna do arquivo cujo campo da linha 1 contém a
 palavra "Nome".<BR> // Depois que as colunas foram localizadas, seus
 dados são formatados da seguinte forma, respectivamente: formato CNPJ de
 14<BR> // dígitos, formato DATA e formato TEXTO.<BR>
 tab = arq.getTabelaConvertida(1,1,2,["Coluna1","CNPJ","CNPJ14",
 "Coluna2","Dia Emis","DATA", "Coluna3","Nome","TEXTO"]);<BR>
 </CODE>"""

    pass


  def getTabelas(self) -> Tabela:
    """Converte o conteúdo de todas as planilhas em objetos do tipo
 {@link Tabela Tabela}. Se o arquivo foi aberto para escrita, gera erro.<BR>
 É criada uma tabela para cada planilha existente no arquivo."""

    pass


  def hasFormulas(self) -> bool:
    pass


  def isFechado(self) -> bool:
    """Retorna a indicação de que o arquivo já foi fechado."""

    pass


  def isModoApenasLeitura(self) -> bool:
    """Retorna a indicação de que este objeto se destina a fazer apenas LEITURA do arquivo."""

    pass


  def isModoEscrita(self) -> bool:
    """Retorna a indicação de que este objeto se destina a fazer ESCRITA do arquivo."""

    pass


  def readExternal(self, in) -> None:
    """Carrega o arquivo que contém os dados."""

    pass


  def removeLinhas(self, linhaInicial, linhaFinal) -> None:
    """Remove uma ou mais linhas da planilha atual."""

    pass


  def removeLinhas(self, linhaInicial, linhaFinal, apagaFisicamente) -> None:
    """Remove uma ou mais linhas da planilha atual."""

    pass


  def removePlanilha(self, indice) -> None:
    """Remove uma determinada planilha. Apenas utilizar caso o arquivo tenha sido aberto para escrita.<BR>"""

    pass


  def removePlanilha(self, nomePlanilha) -> None:
    """Remove uma determinada planilha. Apenas utilizar caso o arquivo tenha sido aberto para escrita.<BR>"""

    pass


  def salva(self) -> None:
    """Salva as modificações feitas até agora em arquivo, mas mantém o arquivo 'aberto' para novas edições."""

    pass


  def selecionaPlanilha(self, indice) -> None:
    """Seleciona uma determinada planilha do arquivo para ser a planilha atual."""

    pass


  def selecionaPlanilha(self, nomePlanilha) -> None:
    """Seleciona uma determinada planilha do arquivo para ser a planilha atual."""

    pass


  def setColunaAtual(self, coluna) -> None:
    """Caso o arquivo tenha sido aberto para escrita, altera a indicação de
 "coluna atual" que é considerada por algumas funções que escrevem na
 planilha (funções estas que não recebem como parâmetro o número da
 coluna, pois utiliza internamente a indicação de "coluna atual")."""

    pass


  def setLinhaAtual(self, linha) -> None:
    """Caso o arquivo tenha sido aberto para escrita, altera a indicação de
 "linha atual" que é considerada por algumas funções que escrevem na
 planilha (funções estas que não recebem como parâmetro o número da linha,
 pois utiliza internamente a indicação de "linha atual")."""

    pass


  def setNomePlanilha(self, indice, nome) -> None:
    """Altera o nome de uma determinada planilha (apenas na hipótese da planilha ter sido aberta para ESCRITA).<BR>
 OBS: não podem haver duas ou mais planilhas com o mesmo nome. Caso este método seja utilizado de modo
 a violar esta restrição, gera erro.<BR>"""

    pass


  def writeExternal(self, out) -> None:
    """Persiste somente o nome do arquivo que contém os dados."""

    pass

class ArquivoJson ():

  def escreve(self, conteudo) -> None:
    """Escreve no final do arquivo um conteúdo JSON, após inserir um caractere de nova linha caso exista algum
 conteúdo anterior.<BR>
 OBS: ao utilizar este método, o conteúdo JSON é escrito diretamente no arquivo. O método {@link #getElementoRaiz() getElementoRaiz}
 continuará a exibir o conteúdo previamente existente, anterior às mudanças.<BR>
 ATENÇÃO: se você está alterando campos do objeto retornado pelo método {@link #getElementoRaiz() getElementoRaiz}, utilize o método
 {@link #salvar(String, String) salvar} para salvar as alterações em disco, a menos que se queira acrescentar dados ao final do arquivo
 sem alterar o conteúdo anterior."""

    pass


  def escreve(self, elemento) -> None:
    """Escreve no final do arquivo um conteúdo JSON, após inserir um caractere de nova linha caso exista algum
 conteúdo anterior.<BR>
 OBS: ao utilizar este método, o conteúdo JSON é escrito diretamente no arquivo. O método {@link #getElementoRaiz() getElementoRaiz}
 continuará a exibir o conteúdo previamente existente, anterior às mudanças.<BR>
 ATENÇÃO: se você está alterando campos do objeto retornado pelo método {@link #getElementoRaiz() getElementoRaiz}, utilize o método
 {@link #salvar(String, String) salvar} para salvar as alterações em disco, a menos que se queira acrescentar dados ao final do arquivo
 sem alterar o conteúdo anterior."""

    pass


  def fechar(self) -> None:
    """Fecha o arquivo, o que significa que nenhuma operação subsequente de leitura poderá ser
 realizada utilizando este mesmo objeto. Porém, o mesmo arquivo pode ser lido posteriormente se
 for obtido um novo objeto Arquivo para ele.<BR>
 A operação de "fechar" um arquivo deve SEMPRE ser realizada após todas as operações de leitura
 sobre o mesmo objeto. Se isso não for feito, o arquivo permanece "aberto", o que impede outras
 operações do sistema operacional (tais como a exclusão do arquivo ou movê-lo de
 diretório).<BR>
 OBS: O ContÁgil sempre fecha todos os arquivos que foram abertos pelo script, seja para
 escrita ou para leitura, ao final da execução do script.<BR>"""

    pass


  def getElementoRaiz(self) -> ElementoJson:
    """Retorna o elemento 'raiz' para acesso a todas as informações armazenadas no mesmo arquivo JSON"""

    pass


  def isFechado(self) -> bool:
    """Retorna a indicação de que o arquivo já foi fechado."""

    pass


  def salvar(self, diretorio, arquivo) -> None:
    """Salva em um arquivo texto o conteúdo JSON manipulado em memória.<BR>
 ATENÇÃO: este método é incompatível com o método {@link #escreve(ElementoJson) escreve}. Utilize o método {@link #salvar(String, String) salvar}
 quando quiser escrever em disco o conteúdo que foi alterado em memória sobre o objeto retornado pelo método {@link #getElementoRaiz() getElementoRaiz}. 
 Qualquer conteúdo adicional escrito através do método {@link #escreve(ElementoJson) escreve} será sobrescrito."""

    pass

class ArquivoODT ():
  """Classe que implementa diversas operações relativas a um arquivo ODT (OpenOffice).<BR>
 <BR>
 Atualmente esta implementação inclui apenas operações de LEITURA em tais tipos de arquivo.<BR>
 <BR>
 Para operações de ESCRITA envolvendo arquivos do tipo ODT, utilize o conceito de "template" (isto é,
 um arquivo ODT que é "anexado" ao script e que pode ser utilizado como "modelo" para criação de novos
 arquivos ODT).<BR>"""

  def fechar(self) -> None:
    """Fecha o arquivo, o que significa que nenhuma operação subsequente de
 escrita ou leitura poderá ser realizada utilizando este mesmo objeto.
 Porém, o mesmo arquivo pode ser lido posteriormente se for obtido um novo
 objeto Arquivo para ele.<BR>
 A operação de "fechar" um arquivo deve SEMPRE ser realizada após todas as
 operações de escrita ou leitura sobre o mesmo objeto. Se isso não for
 feito, o arquivo permanece "aberto", o que impede outras operações do
 sistema operacional (tais como a exclusão do arquivo ou movê-lo de
 diretório).<BR>
 OBS: O ContÁgil sempre fecha todos os arquivos que foram abertos pelo
 script, seja para escrita ou para leitura, ao final da execução do
 script.<BR>"""

    pass


  def getTabelas(self, consideraCabecalho) -> list:
    """Caso este documento ODT contenha uma ou mais "tabelas", retorna uma lista dessas tabelas.<BR>
 Se há apenas uma única tabela, retorna uma lista contendo um único elemento: a única tabela.<BR>
 OBS: Caso existam tabelas "aninhadas" (isto é, tabelas dentro de tabelas), essas tabelas "internas"
 são inseridas nas células das tabelas "externas". Ou seja, a quantidade de tabelas inseridas na
 lista corresponde à quantidade de tabelas de "primeiro nível" existentes no documento.<BR>
 Retorna uma lista vazia caso não exista tabela alguma dentro deste documento."""

    pass


  def getTexto(self) -> str:
    """Retorna o conteúdo completo do arquivo na forma de uma única String.<BR>
 O conteúdo da String é o próprio conteúdo original do arquivo sem tratar
 formatações.<BR>
 Se há tabelas no documento, as colunas podem perder o alinhamento neste texto.<BR>
 OBS: Se o arquivo for muito grande, pode ocorrer erro de falta de
 memória."""

    pass


  def getTextoContextoTabela(self, tab) -> str:
    """Dada uma tabela que foi obtida deste arquivo ODT com uso da função {@link ArquivoODT#getTabelas(boolean) getTabelas},
 retorna o texto compreendido no mesmo 'tópico' do arquivo onde se encontra esta tabela, incluindo o conteúdo em formato texto da própria tabela
 e também de todos os demais parágrafos inseridos no mesmo 'tópico'.<BR>
 Outros parágrafos de texto do mesmo 'tópico' onde se encontra a tabela, mas que estão fora da tabela, podem também ser retornados por este método.<BR>
 <BR>
 ATENÇÃO: para este método funcionar corretamente, espera-se que no arquivo ODT exista uma diferenciação em 'tópicos',
 onde algumas linhas do documento destinadas a indicar 'títulos' de 'tópicos' são associadas ao 'estilo' correspondente indicativo
 de 'título' (ex: estilo "Título 2" associado a um parágrafo com o texto "1.2 ALGUM REGISTRO ESPECIFICO").<BR>
 Retorna NULO ou VAZIO caso não encontre o texto procurado ou caso a tabela informada como parâmetro não tenha
 sido extraída diretamente a partir deste objeto ou caso ela não esteja localizada dentro de uma estrutura de tópicos."""

    pass


  def isFechado(self) -> bool:
    """Retorna a indicação de que o arquivo já foi fechado."""

    pass

class ArquivoPDF ():
  """Classe que disponibiliza diversas operações relativas a um arquivo PDF.<BR>
 <BR>
 Atualmente esta disponibiliza algumas operações de LEITURA e ESCRITA de campos editáveis em tais tipos de arquivo.<BR>
 <BR>
 Caso deseje abrir o arquivo somente para leitura, utilize a função {@link GerenciadorArquivos#abrirPDFSomenteLeitura(String, String) abrirPDFSomenteLeitura}<BR>
 <BR>
 Caso deseje abrir o arquivo para leitura e edição, utilize a função {@link GerenciadorArquivos#abrirPDF(String, String, String, String) abrirPDF}<BR>"""

  def extraiExpressaoRegularArquivo(self, expressaoRegular) -> str:
    """Obtém a primeira ocorrência encontrada no texto do arquivo PDF, do padrão informado na expressão regular por parâmetro. <BR>
 Caso a expressão possua grupos (parte entre parênteses), retorna apenas o primeiro grupo da expressão.<BR>"""

    pass


  def extraiExpressaoRegularComGruposArquivo(self, expressaoRegular) -> str:
    """Obtém a primeira ocorrência encontrada no texto do arquivo PDF, do padrão informado na expressão regular por parâmetro. <BR>
 Caso a expressão possua grupos (parte entre parênteses), retorna todos os grupos.<BR>"""

    pass


  def extraiExpressaoRegularComGruposPagina(self, expressaoRegular, numeroPagina) -> str:
    """Obtém a primeira ocorrência encontrada no texto da página informada, do padrão informado na expressão regular por parâmetro. <BR>
 Caso a expressão possua grupos (parte entre parênteses), retorna todos os grupos.<BR>"""

    pass


  def extraiExpressaoRegularPagina(self, expressaoRegular, numeroPagina) -> str:
    """Obtém a primeira ocorrência encontrada no texto da página informada, do padrão informado na expressão regular por parâmetro. <BR>
 Caso a expressão possua grupos (parte entre parênteses), retorna apenas o primeiro grupo da expressão.<BR>"""

    pass


  def extraiExpressoesRegularesArquivo(self, expressaoRegular) -> list:
    """Obtém todas as ocorrências encontradas no texto do arquivo PDF, do padrão informado na expressão regular por parâmetro. <BR>
 Caso a expressão possua grupos (parte entre parênteses), retorna apenas o primeiro grupo da expressão.<BR>"""

    pass


  def extraiExpressoesRegularesComGruposArquivo(self, expressaoRegular) -> list:
    """Obtém todas as ocorrências encontradas no texto do arquivo PDF, do padrão informado na expressão regular por parâmetro. <BR>
 Caso a expressão possua grupos (parte entre parênteses), retorna todos os grupos.<BR>"""

    pass


  def extraiExpressoesRegularesComGruposPagina(self, expressaoRegular, numeroPagina) -> list:
    """Obtém todas as ocorrências encontradas no texto da página informada, do padrão informado na expressão regular por parâmetro. <BR>
 Caso a expressão possua grupos (parte entre parênteses), retorna todos os grupos.<BR>"""

    pass


  def extraiExpressoesRegularesPagina(self, expressaoRegular, numeroPagina) -> list:
    """Obtém todas as ocorrências encontradas no texto da página informada, do padrão informado na expressão regular por parâmetro. <BR>
 Caso a expressão possua grupos (parte entre parênteses), retorna apenas o primeiro grupo da expressão.<BR>"""

    pass


  def fechar(self) -> None:
    """Fecha o arquivo, o que significa que nenhuma operação subsequente
 poderá ser realizada utilizando este mesmo objeto.
 Porém, o mesmo arquivo pode ser lido posteriormente se for obtido um novo
 objeto Arquivo para ele.<BR>
 A operação de "fechar" um arquivo deve SEMPRE ser realizada após todas as
 operações de escrita ou leitura sobre o mesmo objeto. Se isso não for
 feito, o arquivo permanece "aberto", o que impede outras operações do
 sistema operacional (tais como a exclusão do arquivo ou movê-lo de
 diretório).<BR>
 OBS: O ContÁgil sempre fecha todos os arquivos que foram abertos pelo
 script, seja para escrita ou para leitura, ao final da execução do
 script.<BR>"""

    pass


  def getArquivoComoTexto(self, extrator) -> str:
    """Utiliza um objeto do tipo {@link PDFExtrator PDFExtrator} criado por {@link GerenciadorArquivos#novoPDFExtrator() novoPDFExtrator} para extrair texto deste PDF. Trata-se
 de uma alternativa mais avançada do que {@link #getArquivoComoTexto() getArquivoComoTexto}. Requer configurações adicionais prévias em {@link PDFExtrator PDFExtrator}."""

    pass


  def getArquivoComoTexto(self, separadorPaginas) -> str:
    """Idem à função
 {@link ArquivoPDF#getArquivoComoTexto() getArquivoComoTexto} mas com um parâmetro que determina
 um texto para ficar entre as páginas.<BR>"""

    pass


  def getArquivoComoTexto(self) -> str:
    """Obtém o conteúdo do arquivo inteiro (todas as páginas) no formato de texto.<BR>"""

    pass


  def getNomesCampos(self) -> list:
    """Obtém os nomes de todos os campos de formulário editáveis identificados no arquivo PDF."""

    pass


  def getNumeroPaginas(self) -> int:
    """Obtém o número de páginas do documento."""

    pass


  def getOpcoesEscolhidasCampoSelecao(self, nomeCampo) -> str:
    """Obtém as opções que estão selecionadas em um campo de seleção (combobox e listas de seção).<BR>
 Por exemplo em um combobox com os valores: "São Paulo", "Paraná", "Maranhão", se opção selecionada fosse "Maranhão",
 retornaria um array o valor "Maranhão" na posição 0."""

    pass


  def getPaginaComoTexto(self, numeroPagina) -> str:
    """Obtém o conteúdo da página indicada como parâmetro no formato de texto.<BR>"""

    pass


  def getTipoCampo(self, nomeCampo) -> int:
    """Retorna o tipo do campo de formulário informado como parâmetro. Os tipos são:<BR>
 0 : NÃO IDENTIFICADO <BR>
 1 : BOTÃO <BR>
 2 : CHECKBOX <BR>
 3 : RADIOBUTTON <BR>
 4 : TEXTO <BR>
 5 : LISTA DE SELEÇÃO <BR>
 6 : COMBOBOX <BR>
 7 : ASSINATURA <BR>"""

    pass


  def getValorCampo(self, nomeCampo) -> str:
    """Obtém o valor atual de campos de formulário editáveis, tais como campos de texto, campos de escolha (combobox),<BR>
 campos de seleção, campos de marcação (checkbox e radiobutton), e outros.<BR>"""

    pass


  def getValoresExibidosCampoSelecao(self, nomeCampo) -> str:
    """Retorna os valores exibidos para um campo de seleção (combobox e listas de seção).<BR>
 Se trata dos valores exibidos para o usuário, e não dos IDs de cada possibilidade de seleção.<BR>
 Por exemplo, o usuário enxerga a opção "Paraná", enquanto o ID que representa essa opção no campo é "PR", ou ainda "05", etc.<BR>"""

    pass


  def getValoresValidosCampoMarcacao(self, nomeCampo) -> str:
    """Retorna os valores válidos para um campo de marcação (radiobutton e checkbox).<BR>
 Não se trata dos valores exibidos para o usuário, e sim os IDs de cada possibilidade de marcação.<BR>
 Por exemplo as opções de um checkbox, onde "Yes" representaria marcado e "Off" representaria desmarcado.<BR>"""

    pass


  def getValoresValidosCampoSelecao(self, nomeCampo) -> str:
    """Retorna os valores válidos para um campo de seleção (combobox e listas de seção).<BR>
 Não se trata dos valores exibidos para o usuário, e sim os IDs de cada possibilidade de seleção.<BR>
 Por exemplo, o usuário pode enxergar a opção "Paraná", mas o ID que representa essa opção no campo é "PR", ou ainda "05", etc.<BR>"""

    pass


  def isFechado(self) -> bool:
    """Retorna a indicação de que o arquivo já foi fechado."""

    pass


  def setOpcoesCampoSelecao(self, nomeCampo, valoresValidos, valoresExibidos) -> bool:
    """Define as opções possíveis para o campo de seleção (combobox e lista de seleção) informado. (função não disponível no modo SOMENTE LEITURA)<BR>
 Se trata das opções que serão disponibilizadas para seleção, e não a seleção de opções preexistentes,<BR>
 para isso deve ser usada a função {@link ArquivoPDF#setOpcoesEscolhidasCampoSelecao(String, String[]) setOpcoesEscolhidasCampoSelecao} <BR>"""

    pass


  def setOpcoesEscolhidasCampoSelecao(self, nomeCampo, opcoes) -> bool:
    """Seleciona as opções informadas, no campo de seleção informado. (função não disponível no modo SOMENTE LEITURA)<BR>"""

    pass


  def setValorCampo(self, nomeCampo, novoValor) -> bool:
    """Altera o valor de um campo de formulário editável do arquivo PDF. (função não disponível no modo SOMENTE LEITURA)<BR>"""

    pass

class ArquivoPosicoesFixas ():
  """Classe que implementa diversas operações relativas a um arquivo texto onde
 diferentes campos não são separados por um caractere especial (tal como
 vírgula ou ponto e vírgula), mas são definidos em posições e tamanhos fixos.<BR>
 
 Por exemplo, um arquivo texto onde todas as linhas possuem exatamente três
 campos, sendo o primeiro campo com tamanho 10, o segundo com tamanho 2, e o
 terceiro com tamanho 5, é um exemplo de arquivo de "posições fixas". Neste
 exemplo, uma linha contendo algo do tipo 1111111111PR00100 seria interpretada
 como sendo uma relação de três campos: 1111111111, PR e 00100 (note que a
 linha não apresenta vírgulas ou outro caractere separando os diferentes
 campos).<BR>
 
 Exemplo de utilização mais simples (quando todas as linhas do arquivo seguem
 sempre um mesmo padrão de colunas):<BR>
 <CODE> // Abre um arquivo texto cujo nome é TESTE.TXT e trata todas as suas
 linhas como sendo linhas de três campos,<BR> // sendo o primeiro campo de
 tamanho 10, o segundo de tamanho 2, o terceiro de tamanho 5.<BR>
 arquivo = arquivos.abrirArquivoTextoPosicoesFixas(null,"TESTE",[10,2,5]);<BR> //
 Lê a primeira linha do arquivo, já separando os campos entre si (neste
 exemplo, teremos sempre três campos para cada linha do arquivo)<BR>
 campos = arquivo.getCampos(1);<BR>
 arquivo.fechar(); // Fecha o arquivo<BR>
 </CODE>
 
 OBS: caso o mesmo arquivo possua diferentes "tipos" de linhas, onde podemos
 ter diferentes "campos" com diferentes "tamanhos" (este é o padrão para
 arquivos de declarações da RFB, por exemplo), antes de indicar os "tamanhos"
 com que cada linha deve ser separada é necessário primeiro descobrir qual é o
 "tipo" de linha.<BR>
 
 O componente da linha que identifica o seu "tipo" pode variar de um caso para
 outro. Geralmente isso é indicado através dos primeiros caracteres de cada
 linha. Por exemplo, em alguns padrões de arquivo são utilizados os primeiros
 dígitos de cada linha para indicar seu tipo (se começa com "00", é do tipo
 "00", se começa com "01", é do tipo "01", e assim em diante).<BR>
 
 Caso o arquivo seja de um padrão onde os diferentes "tipos" de linhas seguem
 a forma descrita acima, existem duas formas de se trabalhar com ele:<BR>
 
 <B>Forma 1</B> (quando o mesmo arquivo possui diferentes padrões de linhas e
 todos os arquivos possuem sempre os mesmos tipos de linhas nas mesmas
 posições):<BR>
 Caso se saiba de antemão quais linhas se referem a determinados tipos (por
 exemplo, um arquivo onde a primeira linha é de um tipo pre-determinado, a
 segunda linha é de outro tipo pre-determinado, e assim sucessivamente),
 pode-se executar o método
 {@link ArquivoPosicoesFixas#getCampos(int, int[]) getCampos} para cada linha,
 onde os tamanhos dos campos de cada linha é explícito em cada execução.<BR>
 Exemplo:<BR>
 <CODE> // Abre um arquivo texto cujo nome é TESTE.TXT onde os tamanhos dos
 campos em cada linha não é o mesmo para todas as linhas.<BR>
 arquivo = arquivos.abrirArquivoTextoPosicoesFixas(null,"TESTE");<BR> // Lê a
 primeira linha do arquivo, já separando os campos entre si (neste exemplo,
 teremos três campos com os tamanhos indicados neste momento)<BR>
 campos = arquivo.getCampos(1,[10,2,5]);<BR> // Lê a segunda linha do
 arquivo, já separando os campos entre si (neste exemplo, teremos dois campos
 com os tamanhos indicados neste momento)<BR>
 campos = arquivo.getCampos(2,[8,20]);<BR>
 arquivo.fechar(); // Fecha o arquivo<BR>
 </CODE>
 
 <B>Forma 2</B> (quando o mesmo arquivo possui diferentes padrões de linhas
 que podem aparecer em qualquer parte do arquivo):<BR>
 Alguns arquivos podem ter diferentes "tipos" de linhas e também indicar na
 parte inicial de cada linha qual é o seu "tipo". Nesta hipótese, antes de
 percorrer as linhas do arquivo, pode-se configurar este objeto com os "tipos
 previstos" (associando a cada um deles a relação de campos e tamanhos
 previstos).<BR>
 Depois, basta percorrer as linhas do arquivo sem se preocupar com a indicação
 dos tamanhos dos campos. O ContÁgil já se encarrega de identificar a qual
 "tipo" cada linha se refere e fazer a separação da forma apropriada.<BR>
 Exemplo:<BR>
 <CODE> // Abre um arquivo texto cujo nome é TESTE.TXT onde os tamanhos dos
 campos em cada linha não é o mesmo para todas as linhas.<BR>
 arquivo = arquivos.abrirArquivoTextoPosicoesFixas(null,"TESTE");<BR> //
 Indica que registros do tipo "00" devem possuir três campos com os tamanhos
 indicados<BR>
 arquivo.setTipoLinha("00",[10,2,5]);<BR> // Indica que registros do tipo
 "01" devem possuir dois campos com os tamanhos indicados<BR>
 arquivo.setTipoLinha("01",[8,20]);<BR> // Indica que registros do tipo "ABC"
 devem possuir três campos com os tamanhos indicados<BR>
 arquivo.setTipoLinha("ABC",[5,5,20]);<BR> // Lê a primeira linha do arquivo,
 já separando os campos entre si, mesmo sem saber a priori qual é o seu "tipo"<BR> //
 Se a linha começa com "00", obtém três campos com tamanhos 10, 2 e 5
 respectivamente.<BR> // Se a linha começa com "01", obtém dois campos com
 tamanhos 8 e 20 respectivamente.<BR> // Se a linha começa com "ABC", obtém
 três campos com tamanhos 5, 5 e 20 respectivamente.<BR> // Se a linha começa
 de outro jeito, obtém um único campo contendo o conteúdo completo da linha.<BR>
 campos = arquivo.getCampos(1);<BR> // Exibe no LOG qual é o tipo da primeira
 linha que foi lida<BR>
 println(campos.get(0));<BR>
 arquivo.fechar(); // Fecha o arquivo<BR>
 </CODE>"""

  def exportaTabelaUsuario(self, nome, acrescenta) -> TabelaUsuario:
    """Exporta o conteúdo deste arquivo texto para uma
 {@link TabelaUsuario TabelaUsuario}. Ou seja, os dados ficam armazenados
 em disco de uma forma que pode ser consultada posteriormente pelo usuário
 por um MODELO ANALÍTICO DINÂMICO ou até mesmo por script através do
 método {@link ContAgilEngine#getTabelaUsuario(String) getTabelaUsuario}.<BR>
 Se já existir uma tabela do usuário com o nome especificado, ela é
 sobrescrita com os novos dados.<BR>
 <BR>
 Tendo em vista que em geral arquivos com 'posições fixas' não possuem uma linha de 'cabeçalho'
 contendo 'nomes de colunas', este método presume que não existe tal linha de cabeçalho. Isto é,
 considera que todas as linhas do arquivo, inclusive a primeira linha, são linhas de 'dados'.<BR>
 Com isso, todos os nomes de ATRIBUTOS e MÉTRICAS serão nomes GENÉRICOS, incluindo a palavra "COLUNA-"
 acrescido de um número sequencial começando em 0. Por exemplo, "COLUNA-0" será utilizado para identificar
 a primeira coluna.<BR>
 <BR>
 OBS: todas as informações do arquivo são inseridas em uma só tabela. Mesmo que 
 este objeto tenha sido configurado de tal maneira a admitir diferentes 'tipos de registros', todos
 eles são inseridos na mesma tabela. Caso algumas linhas tenham menos campos que outras, as colunas
 remanescentes na tabela são preenchidas com campos vazios.<BR>
 Todos os campos são armazenados na tabela como campos do tipo 'TEXTO', inclusive aqueles campos
 que poderiam indicar números, datas e outras coisas."""

    pass


  def getCampo(self, linha, posicao, tamanho) -> str:
    """Obtém uma informação em uma determinada linha, indicando a posição em que
 a informação começa e o tamanho da informação.<BR>
 Note que existem outros métodos em
 {@link ArquivoPosicoesFixas ArquivoPosicoesFixas} que podem fazer a mesma
 tarefa em menos linhas de código (principalmente quando há uma grande
 quantidade de informações em cada linha). Consulte a documentação para
 mais informações sobre os outros métodos."""

    pass


  def getCampos(self, linha) -> list:
    """Retorna o conteúdo de uma linha na forma de uma lista de String, cada uma
 referente a um campo da linha.<BR>
 Atenção: a "quebra" de uma linha em "campos" através deste método apenas
 ocorre na hipótese deste objeto ter sido previamente configurado com os
 tamanhos de cada campo.<BR>
 Por exemplo, através do método
 {@link GerenciadorArquivos#abrirArquivoTextoPosicoesFixas(String, String, int[]) abrirArquivoTextoPosicoesFixas}
 pode-se configurar um padrão único de divisão de colunas para todas as
 linhas do arquivo.<BR>
 Através do método
 {@link ArquivoPosicoesFixas#setTipoLinha(String, int[]) setTipoLinha}
 pode-se configurar múltiplos padrões de divisão de colunas conforme
 diferentes "tipos" de linhas.<BR>
 OBS: Se o arquivo foi aberto para escrita, gera erro.<BR>
 OBS2: Se a linha não tiver tamanho suficiente para representar todos os
 campos, os campos faltando não são preenchidos.<BR>"""

    pass


  def getCampos(self, linha, tamanhosColunas) -> list:
    """Retorna o conteúdo de uma linha na forma de uma lista de String, cada uma
 referente a um campo da linha.<BR>
 A "quebra" de uma linha em "campos" através deste método ocorre através
 dos tamanhos especificados no segundo parâmetro.<BR>
 Note que este método alternativo de obter "campos" de uma linha prescinde
 da indicação de tamanhos no momento da abertura do arquivo.<BR>
 Trata-se de uma das formas previstas para se obter campos de um arquivo
 onde existem diferentes "tipos" de linhas, cada qual com tamanhos
 diferentes e campos diferentes.<BR>
 OBS: Se o arquivo foi aberto para escrita, gera erro."""

    pass


  def getMaiorQuantidadeCampos(self) -> int:
    """Dadas as configurações atualmente existentes, retorna a maior quantidade de campos
 considerando todos os diferentes tipos de registro configurados para leitura ou escrita deste arquivo.<BR>
 Por exemplo, se o tipo de registro "00" possui 3 campos e o tipo de registro "01" possui
 5 campos, retorna 5.<BR>
 Se não há distinção das linhas deste arquivo por tipo de registro, retorna a quantidade de campos definida de forma
 global para este arquivo."""

    pass


  def getTabela(self, tipo) -> Tabela:
    """Método alternativo a {@link ArquivoTexto#getTabela() getTabela} de dois
 parâmetros. Neste caso, ao invés de indicar a primeira e a última linha
 do intervalo de linhas do arquivo que se pretende exportar para uma
 tabela, basta indicar o "tipo" de linha dentre aquelas existentes no
 arquivo (isto é, somente as linhas começando com este "tipo" são
 consideradas para inclusão na tabela, sendo todas as demais linhas
 ignoradas).<BR>
 Converte o conteúdo do arquivo em um objeto {@link Tabela Tabela}. Se o
 arquivo foi aberto para escrita, gera erro.<BR>
 Todo o conteúdo do arquivo, compreendido nas linhas especificadas como
 parâmetro desta função, são carregados nesta estrutura
 {@link Tabela Tabela}, ou seja, ocupa a memória RAM do computador. Se
 não houver memória disponível para manter todos esses dados, haverá erro
 na execução desta função."""

    pass


  def readExternal(self, in) -> None:
    """Carrega o arquivo que contém os dados."""

    pass


  def setTipoLinha(self, tipo, tamanhosColunas) -> None:
    """Este método, quando utilizado, permite configurar a composição de colunas
 para um determinado "tipo de linha".<BR>
 Caso o arquivo contenha linhas de dois ou mais tipos diferentes, pode-se
 utilizar este método múltiplas vezes (um para cada tipo) antes de
 percorrer as linhas do arquivo. Deste modo, para cada linha que é
 "percorrida", o ContÁgil examina se o seu "tipo" corresponde a um dos
 "tipos" configurados através deste método (observando se os primeiros
 caracteres da linha correspondem ao "tipo"). Desta forma é possível
 configurar uma relação de campos (e seus tamanhos correspondentes) de
 forma independente para cada "tipo" de linha.<BR>
 Caso o arquivo contenha linhas de apenas um tipo (por exemplo, arquivos
 do padrão ADE 15), não é necessário utilizar este método, pois todas as
 linhas do arquivo são tratadas exatamente da mesma forma.<BR>
 Este método não afeta a utilização de outros métodos onde os tamanhos das
 colunas são explícitos na execução do método, mas afeta aqueles métodos
 onde os tamanhos são "implícitos" (isto é, não são indicados na execução
 do método).<BR>
 OBS: ao especificar os tamanhos das colunas, não inclua o tamanho da
 primeira coluna que corresponde à identificação do "tipo" da linha. O
 ContÁgil já entende que qualquer linha deste tipo precisa começar com os
 caracteres indicados no parâmetro "tipo".<BR>"""

    pass


  def writeExternal(self, out) -> None:
    """Persiste somente o nome do arquivo que contém os dados."""

    pass

class ArquivoTexto ():
  """Classe que implementa diversas operações relativas a um arquivo texto qualquer.<BR>
 Dependendo de como o objeto foi obtido, é possível ler ou escrever no
 arquivo.<BR>
 <BR>
 Esta é também uma classe base para outras classes que representam um arquivo do tipo "texto",
 mas de forma especial, como é o caso dos arquivos texto com separação dos campos por vírgulas (também
 chamados de CSV, do inglês "comma separated variables"), que são representados pelo objeto
 {@link ArquivoCSV ArquivoCSV}.<BR>
 <BR>
 Esta classe apresenta os métodos comuns a qualquer arquivo texto,
 independentemente do arquivo ser do tipo "campos separados por vírgulas" ou
 do tipo "campos com tamanhos e posições fixos".<BR>"""

  def escreveLinha(self, conteudo) -> None:
    """Adiciona uma linha de texto ao arquivo texto.<BR>
 Automaticamente acrescentam-se os caracteres de "nova linha" (códigos ASC
 13 e 10) ao final da linha.<BR>
 O arquivo precisa ter sido aberto para ESCRITA (isto é, uma "criação" de arquivo texto). Se foi aberto para LEITURA,
 este método irá falhar."""

    pass


  def escreveTexto(self, texto) -> None:
    """Adiciona um texto qualquer ao arquivo (o texto pode ou não conter múltiplas linhas inseridas dentro dele).<BR>
 O arquivo precisa ter sido aberto para ESCRITA (isto é, uma "criação" de arquivo texto). Se foi aberto para LEITURA,
 este método irá falhar."""

    pass


  def exportaTabelaUsuario(self, nome, acrescenta) -> TabelaUsuario:
    """Exporta o conteúdo deste arquivo texto para uma
 {@link TabelaUsuario TabelaUsuario}. Ou seja, os dados ficam armazenados
 em disco de uma forma que pode ser consultada posteriormente pelo usuário
 por um MODELO ANALÍTICO DINÂMICO ou até mesmo por script através do
 método {@link ContAgilEngine#getTabelaUsuario(String) getTabelaUsuario}.<BR>
 Se já existir uma tabela do usuário com o nome especificado, ela é
 sobrescrita com os novos dados.<BR>
 <BR>
 Este método presume que a primeira linha do arquivo é uma linha de 'cabeçalho', contendo
 títulos de colunas. Esses nomes são então considerados de forma automática para
 nomear as colunas da tabela do usuário gerada.<BR>
 Presume-se também que os dados se iniciam na segunda linha do arquivo (tendo em vista
 que a primeira linha é presumivelmente uma linha de cabeçalho).<BR>"""

    pass


  def fechar(self) -> None:
    """Fecha o arquivo, o que significa que nenhuma operação subsequente de
 escrita ou leitura poderá ser realizada utilizando este mesmo objeto.
 Porém, o mesmo arquivo pode ser lido posteriormente se for obtido um novo
 objeto Arquivo para ele.<BR>
 A operação de "fechar" um arquivo deve SEMPRE ser realizada após todas as
 operações de escrita ou leitura sobre o mesmo objeto. Se isso não for
 feito, o arquivo permanece "aberto", o que impede outras operações do
 sistema operacional (tais como a exclusão do arquivo ou movê-lo de
 diretório).<BR>
 OBS: O ContÁgil sempre fecha todos os arquivos que foram abertos pelo
 script, seja para escrita ou para leitura, ao final da execução do
 script.<BR>"""

    pass


  def flush(self) -> None:
    """Força a gravação dos dados para o disco"""

    pass


  def getCampos(self, linha) -> list:
    """Retorna o conteúdo de uma linha na forma de uma lista de String, cada uma
 referente a uma "campo" da linha. Para o propósito exclusivo deste método
 considera-se como "campo" uma palavra qualquer ou número que é separado de outras 
 palavras ou números através de "espaços em branco".<BR>
 Note que esta não é a mesma definição de "campo" para outros tipos de arquivo.
 Por exemplo, para arquivos do tipo "CSV", existe um caractere específico (como
 a vírgula, por exemplo) que separa um campo do outro. Nesses outros casos, o
 método tem o mesmo nome (também é chamado de "getCampos", ou "OBTER CAMPOS" no
 ScriptVisual), mas estão relacionados a outros tipos de objeto (no caso de
 arquivos "CSV", trata-se do objeto {@link ArquivoCSV ArquivoCSV}).<BR>
 <BR>
 OBS: Se o arquivo foi aberto para escrita, gera erro."""

    pass


  def getCodificacaoCaracteres(self) -> str:
    """Retorna o nome do padrão de codificação de caracteres utilizado por este arquivo.<BR>
 Arquivos textos podem representar os caracteres conforme diferentes padrões. As diferenças em geral estão
 na representação de caracteres acentuados, mas podem ir além disso. Por exemplo, alguns padrões definem
 caracteres com 8 bits e outros padrões podem definir caracteres com 16 bits.<BR>
 Em geral o ContÁgil irá tentar descobrir de forma automática qual é o padrão de codificação de caracteres
 utilizado pelo arquivo. Porém, em alguns casos isso talvez não seja possível determinar.<BR>
 OBS: Se o arquivo foi aberto para escrita, gera erro."""

    pass


  def getColunaComoLista(self, coluna, remove_duplicidade) -> Lista:
    """Retorna uma lista contendo todos os valores de uma única coluna do arquivo.<BR>
 Este método inclui um parâmetro adicional com o objetivo de indicar se os valores duplicados devem ser desconsiderados.<BR>
 Por "colunas" entende-se a divisão de uma linha em "campos" (ou seja, os diferentes "campos" correspondem às diferentes "colunas").<BR>
 Se o parâmetro indicar alguma coluna que não existe no arquivo, retorna uma lista vazia.<BR>
 Se alguma linha não apresentar a coluna indicada como parâmetro, ou se apresentar conteúdo vazio, ele não é incluído na lista.<BR>"""

    pass


  def getColunaComoLista(self, coluna) -> Lista:
    """Retorna uma lista contendo todos os valores de uma única coluna do arquivo.<BR>
 Por "colunas" entende-se a divisão de uma linha em "campos" (ou seja, os diferentes "campos" correspondem às diferentes "colunas").<BR>
 Se o parâmetro indicar alguma coluna que não existe no arquivo, retorna uma lista vazia.<BR>
 Se alguma linha não apresentar a coluna indicada como parâmetro, ou se apresentar conteúdo vazio, ele não é incluído na lista.<BR>"""

    pass


  def getColunas(self, colunas) -> Tabela:
    """Retorna uma ou mais colunas de um arquivo na forma de uma tabela. Os índices das colunas
 são informados no parâmetro deste método.<BR>
 Por "colunas" entende-se a divisão de uma linha em "campos" (ou seja, os diferentes "campos" correspondem às diferentes "colunas").<BR>
 Se o arquivo apresentar mais colunas do que está aqui especificado, as colunas excedentes são ignoradas (não compõem a tabela).<BR>
 A ordem das colunas na tabela segue a ordem das colunas indicadas no parâmetro. Por exemplo, se o parâmetro indicar "3" e "1", então
 a primeira coluna da tabela será a terceira coluna do arquivo (índice "3") e a segunda coluna da tabela será a primeira coluna do arquivo
 (índice "1").<BR>
 Se o parâmetro indicar alguma coluna que não existe no arquivo, a coluna correspondente na tabela é criada, mas sem conteúdo algum.<BR>
 OBS: se tiver interesse em retornar somente o conteúdo de uma única coluna, utilize o método {@link ArquivoTexto#getColunaComoLista(int) getColunaComoLista}
 no lugar deste, pois há uma economia maior no volume de dados armazenado em memória."""

    pass


  def getLinha(self) -> str:
    pass


  def getLinha(self, linha) -> str:
    """Retorna o conteúdo de uma determinada linha do arquivo (isto é, a linha
 inteira, inclusive todos os campos e seus separadores, da forma com que
 se encontra no arquivo).<BR>
 OBS: Se o arquivo foi aberto para escrita, gera erro."""

    pass


  def getLinhasComecando(self, texto, ignoraAcentosDifTamanho) -> Lista:
    """Percorre o arquivo inteiro e coleta em uma lista todas as linhas que começam com um determinado texto."""

    pass


  def getLinhasContemTexto(self, texto, ignoraAcentosDifTamanho) -> Lista:
    """Percorre o arquivo inteiro e coleta em uma lista todas as linhas que possuem um determinado
 texto."""

    pass


  def getPosicaoInicioLinha(self, linha) -> long:
    """Retorna a posição do início de uma determinada linha em relação ao início do arquivo (isto é,
 a quantidade de bytes entre o início do arquivo e o início da linha)."""

    pass


  def getQtdLinhas(self) -> int:
    """Retorna a quantidade de linhas existentes no arquivo, caso o arquivo
 tenha sido aberto para leitura (se foi aberto para escrita, gera erro).<BR>
 OBS: Se o arquivo for grande, esta operação pode demorar um tempo
 considerável até terminar, pois é necessário ler o arquivo inteiro para
 saber quantas linhas ele tem (não se pode assumir a priori que cada linha
 tem um tamanho fixo)."""

    pass


  def getTabela(self, primeira_linha, ultima_linha) -> Tabela:
    """Converte o conteúdo do arquivo em um objeto {@link Tabela Tabela}. Se o
 arquivo foi aberto para escrita, gera erro.<BR>
 Todo o conteúdo do arquivo, compreendido nas linhas especificadas como
 parâmetro desta função, são carregados nesta estrutura
 {@link Tabela Tabela}, ou seja, ocupa a memória RAM do computador. Se
 não houver memória disponível para manter todos esses dados, haverá erro
 na execução desta função."""

    pass


  def getTabela(self) -> Tabela:
    """Método equivalente ao método
 {@link ArquivoTexto#getTabela(int, int) getTabela} com o parâmetro
 "primeira_linha" igual a 1 e com o parâmetro "ultima_linha" igual ao
 resultado da função {@link ArquivoTexto#getQtdLinhas() getQtdLinhas}.<BR>
 Consulte os comentários do método
 {@link ArquivoTexto#getTabela(int, int) getTabela} para mais informações."""

    pass


  def getTabelaOtimizada(self, primeira_linha, ultima_linha) -> Tabela:
    """Método análogo a {@link ArquivoTexto#getTabela(int, int) getTabela}, mas com a diferença que a tabela
 gerada pode conter dados apresentados em outro formato diferente de "texto" (isto é, podem ser números,
 datas, valores, etc.). Isso é feito de forma automática. Isto é, se algum conteúdo se parece com um número,
 ele é tratado como sendo número.<BR>
 Este procedimento tem o objetivo de retornar uma tabela ocupando menos espaço em memória, tendo em vista
 que esses outros formatos de dados são mais compactos do que o formato "texto" convencional.<BR>
 No entanto, por ser um processo "automático", ele requer mais tempo de processamento e pode não ser capaz
 de lidar com formatações diferentes da convencional (por exemplo, para que algo seja considerado como "data"
 é necessário que se apresente no formato dd/mm/aaaa, caso contrário será tratado como simples texto).<BR>
 <BR>
 O critério automático está assim definido atualmente:<BR>
 - Conteúdos do tipo 100,0 ou 1000,0 ou 1.000,0 ou 1.000,00 são tratados como números com casas decimais.<BR>
 - Conteúdos do tipo 100 ou 1000 são tratados como números inteiros (exceto se houver zeros à esquerda).<BR>
 - Conteúdos do tipo 01/01/2010 ou 1/1/2010 ou 1-1-2010 ou 1\1\2010 são tratados como "datas".<BR>
 - Demais conteúdos são tratados como textos.<BR>"""

    pass


  def getTabelaOtimizada(self) -> Tabela:
    """Método análogo a {@link ArquivoTexto#getTabela() getTabela}, mas com a diferença que a tabela
 gerada pode conter dados apresentados em outro formato diferente de "texto" (isto é, podem ser números,
 datas, valores, etc.). Isso é feito de forma automática. Isto é, se algum conteúdo se parece com um número,
 ele é tratado como sendo número.<BR>
 Este procedimento tem o objetivo de retornar uma tabela ocupando menos espaço em memória, tendo em vista
 que esses outros formatos de dados são mais compactos do que o formato "texto" convencional.<BR>
 No entanto, por ser um processo "automático", ele requer mais tempo de processamento e pode não ser capaz
 de lidar com formatações diferentes da convencional (por exemplo, para que algo seja considerado como "data"
 é necessário que se apresente no formato dd/mm/aaaa, caso contrário será tratado como simples texto).<BR>"""

    pass


  def getTamanho(self) -> long:
    """Retorna o tamanho do arquivo em bytes.<BR>"""

    pass


  def getTamanhoCaractere(self) -> int:
    """Retorna o tamanho, em bytes, de um caractere de texto no arquivo.<BR>
 Em geral o tamanho será igual a 1, indicando que cada caractere ocupa um byte no arquivo. Porém, dependendo
 da 'codificação de caracteres' utilizada no arquivo, este tamanho pode variar (ex: 2 bytes para "UTF-16", 4 bytes para "UTF-32").<BR>
 OBS: Se o arquivo foi aberto para escrita, gera erro."""

    pass


  def getTexto(self) -> str:
    """Retorna o conteúdo completo do arquivo na forma de uma única String.<BR>
 O conteúdo da String é o próprio conteúdo original do arquivo sem tratar
 as separações de colunas.<BR>
 OBS: Se o arquivo for muito grande, pode ocorrer erro de falta de
 memória."""

    pass


  def isFechado(self) -> bool:
    """Retorna a indicação de que o arquivo já foi fechado."""

    pass


  def isModoApenasLeitura(self) -> bool:
    """Retorna a indicação de que este objeto se destina a fazer apenas LEITURA do arquivo."""

    pass


  def isModoEscrita(self) -> bool:
    """Retorna a indicação de que este objeto se destina a fazer ESCRITA do arquivo."""

    pass


  def isUseCacheEscrita(self) -> bool:
    """Indica se utiliza cache na escrita"""

    pass


  def isVazio(self) -> bool:
    """Indica se o arquivo está vazio"""

    pass


  def readExternal(self, in) -> None:
    """Carrega o arquivo que contém os dados."""

    pass


  def setCodificacaoCaracteres(self, padraoCodificacao) -> None:
    """Método utilizado na ESCRITA ou na LEITURA de arquivos. Faz com que um determinado padrão de codificação de caracteres
 seja utilizado na escrita ou leitura dos dados no arquivo.<BR>
 Arquivos textos podem representar os caracteres conforme diferentes padrões. As diferenças em geral estão
 na representação de caracteres acentuados, mas podem ir além disso. Por exemplo, alguns padrões definem
 caracteres com 8 bits e outros padrões podem definir caracteres com 16 bits.<BR>"""

    pass


  def setUseCacheEscrita(self, useCacheEscrita) -> None:
    """Define se utiliza cache na escrita, gravando no disco em blocos maiores"""

    pass


  def writeExternal(self, out) -> None:
    """Persiste somente o nome do arquivo que contém os dados."""

    pass

class ArquivoXML ():
  """Classe que implementa diversas operações relativas a um arquivo XML.<BR>
 Atualmente estão previstas apenas operações tanto de LEITURA como de ESCRITA.<BR>"""

  def fechar(self) -> None:
    """Fecha o arquivo, o que significa que nenhuma operação subsequente de leitura poderá ser
 realizada utilizando este mesmo objeto. Porém, o mesmo arquivo pode ser lido posteriormente se
 for obtido um novo objeto Arquivo para ele.<BR>
 A operação de "fechar" um arquivo deve SEMPRE ser realizada após todas as operações de leitura
 sobre o mesmo objeto. Se isso não for feito, o arquivo permanece "aberto", o que impede outras
 operações do sistema operacional (tais como a exclusão do arquivo ou movê-lo de
 diretório).<BR>
 OBS: O ContÁgil sempre fecha todos os arquivos que foram abertos pelo script, seja para
 escrita ou para leitura, ao final da execução do script.<BR>"""

    pass


  def getErros(self) -> list:
    """Caso algum erro tenha ocorrido no tratamento do conteúdo XML, retorna as mensagens de erro
 correspondentes. Se nenhum erro ocorreu, retorna uma lista vazia."""

    pass


  def getTagRaiz(self) -> XMLTag:
    """Retorna o objeto que representa a "tag raiz" (isto é, a primeira estrutura do arquivo XML que
 dá acesso a todas as demais estruturas internas).<BR>
 Se ocorrer algum erro no tratamento do conteúdo XML, ainda assim é retornado um objeto, mas
 com a indicação dos erros encontrados (mais informações em {@link XMLTag#hasErros() hasErros}
 e {@link XMLTag#getErros() getErros}).<BR>
 OBS: após obter este objeto, o arquivo pode ser fechado. O fechamento do arquivo não
 compromete o uso da informação disponibilizada por este método."""

    pass


  def hasErros(self) -> bool:
    """Retorna a indicação de que algum erro ocorreu durante o tratamento do conteúdo XML"""

    pass


  def isFechado(self) -> bool:
    """Retorna a indicação de que o arquivo já foi fechado."""

    pass


  def salvar(self, diretorio, arquivo) -> None:
    """Salva em um arquivo texto o conteúdo do XML manipulado em memória."""

    pass


  def salvar(self, idDocTypeSystem, idDocTypePublic, saida) -> None:
    """Salva em um arquivo XML o conteúdo do XML manipulado em memória."""

    pass


  def salvar(self, standalone, version, idDocTypeSystem, idDocTypePublic, saida, encoding, indent) -> None:
    """Salva em um arquivo XML o conteúdo do XML manipulado em memória."""

    pass

class ArquivoZIP ():
  """Classe que implementa diversas operações relativas a um arquivo ZIP.<BR>
 Dependendo de como o objeto foi obtido, é possível ler ou escrever no
 arquivo.<BR>
 Se o objeto foi obtido por uma função de criação (por exemplo,
 GerenciadorArquivos.criarZIP()), apenas as funções de escrita estão
 disponíveis. As demais funções geram erros na execução do script.<BR>
 Depois que um arquivo é aberto, seja para escrita, seja para leitura, após
 sua utilização ele deve ser "fechado". Caso isso não seja feito, consome-se
 memória e recursos do sistema operacional de forma indesejável e o arquivo
 fica travado para outras operações (por exemplo, um arquivo que não foi
 fechado não pode ser excluído).
 <P>
 
 OBS: Quando um arquivo ZIP é aberto para leitura, através deste objeto, esta
 leitura precisa ser feita do início ao fim (isto é, percorre-se a relação de
 todo o seu conteúdo uma única vez, sem oportunidade para se voltar ao início
 da lista). Nada impede, porém, que o mesmo arquivo ZIP seja aberto múltiplas
 vezes, e em cada vez seja percorrida a mesma lista de arquivos.<BR>
 Exemplo:<BR>
 <CODE> // Abre o arquivo ZIP para leitura (o arquivo chama-se TESTE.ZIP e
 está na pasta do projeto).<BR>
 zip = arquivos.abrirZIP(null,"TESTE");<BR> // Faz um LOOP para cada arquivo
 encontrado dentro do arquivo ZIP<BR>
 while (arq = zip.proximo())<BR> {<BR>
 &nbsp;&nbsp;&nbsp;// Apresenta informações sobre o arquivo encontrado dentro
 do ZIP<BR>
 &nbsp;&nbsp;&nbsp;println("Nome: "+arq.getNome());<BR>
 &nbsp;&nbsp;&nbsp;// Carrega o conteúdo de cada arquivo encontrado<BR>
 &nbsp;&nbsp;&nbsp;conteudo = zip.getConteudoTexto();<BR> }<BR>
 </CODE>
 
 Outra forma pouco convencional de se trabalhar com este tipo de objeto é por
 meio da função {@link WebExtrator#exportaConteudoZIP() exportaConteudoZIP},
 que trata o resultado de uma consulta a uma URL na Web como se fosse um
 arquivo ZIP, e com isso fornece acesso ao seu conteúdo. Isso apenas funciona
 caso a URL de fato exporte um arquivo ZIP como resultado de execução.<BR>"""

  def escreveArquivo(self, arquivo) -> None:
    """Caso o arquivo ZIP tenha sido aberto para escrita, insere um arquivo
 dentro dele (isto é, compacta-o).<BR>
 O arquivo a ser inserido não pode estar travado para leitura. Isto é, se
 algum outro processo, ou até mesmo o ContÁgil, estiver utilizando-o para
 escrever conteúdo dentro dele, é necessário fecha-lo por este outro
 processo ou pelo ContÁgil antes de considera-lo nesta função.<BR>"""

    pass


  def escreveArquivo(self, arquivo, novoNome) -> None:
    """Caso o arquivo ZIP tenha sido aberto para escrita, insere um arquivo
 dentro dele (isto é, compacta-o).<BR>
 O arquivo a ser inserido não pode estar travado para leitura. Isto é, se
 algum outro processo, ou até mesmo o ContÁgil, estiver utilizando-o para
 escrever conteúdo dentro dele, é necessário fecha-lo por este outro
 processo ou pelo ContÁgil antes de considera-lo nesta função.<BR>"""

    pass


  def escreveArquivoTexto(self, nome, conteudo) -> None:
    """Caso o arquivo ZIP tenha sido aberto para escrita, insere dentro dele
 (isto é, de forma compactada) o conteúdo de um arquivo texto.<BR>
 O conteúdo a ser inserido nem precisa existir em outro arquivo externo.
 Basta que esteja em uma variável de memória."""

    pass


  def extraiComExpressaoRegular(self, nomeDiretorioDestino, expressaoRegular) -> None:
    """Faz a descompactação do conteúdo deste arquivo ZIP para um diretório de destino. Todos os arquivos que apresentarem nos respectivos
 nomes a expressão regular indicada no segundo parâmetro são extraídos. Os demais não são extraídos.<BR>
 Ao contrário de {@link ArquivoZIP#extraiConteudo(String, String) extraiConteudo}, esta função não requer a execução prévia da função
 {@link ArquivoZIP#proximo() proximo}. Porém, se algum conteúdo já foi lido anteriormente a partir deste mesmo objeto {@link ArquivoZIP ArquivoZIP}, apenas
 o conteúdo restante é considerado. Para extrair o mesmo conteúdo duas ou mais vezes é necessário reabrir o objeto {@link ArquivoZIP ArquivoZIP}
 múltiplas vezes."""

    pass


  def extraiConteudo(self, diretorio, nomeArquivo) -> Arquivo:
    """Caso o arquivo ZIP tenha sido aberto para leitura, extrai o conteúdo
 do arquivo interno que foi obtido na última execução da
 função {@link ArquivoZIP#proximo() proximo}. Ou seja, para cada arquivo
 retornado naquela função, pode-se obter extrair conteúdo através desta
 função, salvando-o como um novo arquivo externo.<BR>
 Se o arquivo ZIP foi aberto para escrita, esta função gera erro.<BR>
 Se o arquivo ZIP foi aberto para leitura, mas não houve uma chamada à
 função {@link ArquivoZIP#proximo() proximo}, esta função retorna NULL.<BR>"""

    pass


  def extraiTudo(self, nomeDiretorioDestino) -> None:
    """Faz a descompactação completa do conteúdo deste arquivo ZIP para um diretório de destino.<BR>
 Ao contrário de {@link ArquivoZIP#extraiConteudo(String, String) extraiConteudo}, esta função não requer a execução prévia da função
 {@link ArquivoZIP#proximo() proximo}. Porém, se algum conteúdo já foi lido anteriormente a partir deste mesmo objeto {@link ArquivoZIP ArquivoZIP}, apenas
 o conteúdo restante é considerado. Para extrair o mesmo conteúdo duas ou mais vezes é necessário reabrir o objeto {@link ArquivoZIP ArquivoZIP}
 múltiplas vezes."""

    pass


  def fechar(self) -> None:
    pass


  def getConteudoTexto(self) -> str:
    """Caso o arquivo ZIP tenha sido aberto para leitura, retorna o conteúdo em
 formato texto do arquivo interno que foi obtido na última execução da
 função {@link ArquivoZIP#proximo() proximo}. Ou seja, para cada arquivo
 retornado naquela função, pode-se obter seu conteúdo através desta
 função.<BR>
 Se o arquivo ZIP foi aberto para escrita, esta função gera erro.<BR>
 Se o arquivo ZIP foi aberto para leitura, mas não houve uma chamada à
 função {@link ArquivoZIP#proximo() proximo}, esta função retorna NULL.<BR>"""

    pass


  def getConteudoZIP(self) -> ArquivoZIP:
    """Caso o arquivo ZIP tenha sido aberto para leitura, retorna o conteúdo ZIP
 que está dentro de outro arquivo ZIP.<BR>
 Se o arquivo ZIP foi aberto para escrita, esta função gera erro.<BR>
 Se o arquivo ZIP foi aberto para leitura, mas não houve uma chamada à
 função {@link ArquivoZIP#proximo() proximo}, esta função retorna NULL.<BR>"""

    pass


  def isFechado(self) -> bool:
    """Retorna a indicação de que o arquivo já foi fechado."""

    pass


  def proximo(self) -> Arquivo:
    """Caso o arquivo tenha sido aberto para leitura, retorna o próximo arquivo
 da lista de arquivos compactados dentro do ZIP. Se não há mais arquivos a
 serem percorridos (isto é, se a lista já acabou), retorna NULL.<BR>
 Se o arquivo ZIP foi aberto para escrita, esta função gera erro."""

    pass

class Botoes ():
  """Representa uma barra horizontal de botões."""

  def addBotao(self, botao) -> None:
    """Adiciona um novo botão a esta barra de botões. O novo botão é posicionado no final."""

    pass


  def addBotao(self, nome, subrotina, posicao) -> None:
    """Adiciona um novo botão a esta barra de botões. O novo botão é posicionado na posição indicada (0 = primeira posição)."""

    pass


  def addBotao(self, botao, posicao) -> None:
    """Adiciona um novo botão a esta barra de botões. O novo botão é posicionado na posição indicada (0 = primeira posição)."""

    pass


  def addBotao(self, nome, subrotina, imagem) -> None:
    """Adiciona um novo botão a esta barra de botões, com o nome, a subrotina e a imagem indicados. O novo botão é posicionado no final."""

    pass


  def addBotao(self, nome, subrotina, imagem, posicao) -> None:
    """Adiciona um novo botão a esta barra de botões. O novo botão é posicionado na posição indicada (0 = primeira posição)."""

    pass


  def addBotao(self, nome, subrotina) -> None:
    """Adiciona um novo botão a esta barra de botões, com o nome e a subrotina indicados. O novo botão é posicionado no final."""

    pass


  def addBotao(self, nome) -> None:
    """Adiciona um novo botão a esta barra de botões, com o nome indicado. O novo botão é posicionado no final."""

    pass


  def addBotao(self, nome, posicao) -> None:
    """Adiciona um novo botão a esta barra de botões. O novo botão é posicionado na posição indicada (0 = primeira posição)."""

    pass


  def getBotao(self, nome) -> Botao:
    """Retorna objeto com definições sobre o botão com o nome indicado, ou NULL se não encontrou botão com o nome indicado. Não diferencia
 letras maiúsculas/minúsculas ou acentuação."""

    pass


  def getBotoes(self) -> list:
    """Retorna a lista de todos os botões configurados"""

    pass


  def getImagem(self, nome) -> str:
    """Imagem que é apresentada no botão, ou NULL se não houver imagem.<BR>
 Neste método é indicado o nome da imagem que deve ser apresentada, indicando apenas o nome de ícone interno do Contágil<BR>"""

    pass


  def getImagens(self) -> list:
    """Relação de imagens exibidas em cada botão (uma imagem para cada botão, podendo repetir a mesma imagem em vários botões)<BR>
 Neste método são indicados os nomes das imagens que devem ser apresentadas, indicando apenas os nomes de ícones internos do Contágil<BR>"""

    pass


  def getNomes(self) -> list:
    """Retorna os textos (nomes dos botões) apresentados em todos os botões configurados"""

    pass


  def getSubrotina(self, nome) -> str:
    """Subrotina que deve ser executada quando o botão for pressionado.<BR>
 As subrotinas são procuradas no mesmo script atual. Caso queira utilizar subrotina definida em outro script, informe o nome do script antes do nome da subrotina, separando-os com o caractere '|'.<BR>
 <B>Parâmetros:</B> se quiser indicar parâmetros durante execução de subrotinas, informe logo após o nome da subrotina a relação
 de parâmetros entre parentesis. Ex: Subrotina(1) faz com que a subrotina de nome "Subrotina" seja executada com o valor 1
 informado no primeiro parâmetro<BR>
 Se nenhuma subrotina estiver associada ao botão, o botão é utilizado para fechar a janela exibida."""

    pass


  def getSubrotinas(self) -> list:
    """Subrotinas que devem ser executadas quando os botões correspondentes forem pressionados.<BR>
 As subrotinas são procuradas no mesmo script atual. Caso queira utilizar subrotina definida em outro script, informe o nome do script antes do nome da subrotina, separando-os com o caractere '|'.<BR>
 <B>Parâmetros:</B> se quiser indicar parâmetros durante execução de subrotinas, informe logo após o nome da subrotina a relação
 de parâmetros entre parentesis. Ex: Subrotina(1) faz com que a subrotina de nome "Subrotina" seja executada com o valor 1
 informado no primeiro parâmetro<BR>
 Se nenhuma subrotina estiver associada ao botão, o botão é utilizado para fechar a janela exibida."""

    pass


  def hasBotao(self, nome) -> bool:
    """Verifica se existe botão com o nome indicado.Não diferencia
 letras maiúsculas/minúsculas ou acentuação."""

    pass


  def removeBotao(self, nome) -> None:
    """Exclui o botão com o nome indicado. Não diferencia
 letras maiúsculas/minúsculas ou acentuação."""

    pass


  def removeBotoes(self) -> None:
    """Exclui todos os botões"""

    pass


  def setAlturaBotoes(self, altura) -> None:
    """Altera a altura de todos os botões já indicados. Se for indicado 0, deixa que a altura seja definida automaticamente."""

    pass


  def setBotoes(self, botoes) -> None:
    """Altera todos os botões desta barra de botões"""

    pass


  def setImagem(self, nome, imagem) -> None:
    """Imagem que é apresentada no botão, ou NULL se não houver imagem.<BR>
 Neste método é indicado o nome da imagem que deve ser apresentada, indicando apenas o nome de ícone interno do Contágil<BR>"""

    pass


  def setImagens(self, imagens) -> None:
    """Relação de imagens exibidas em cada botão (uma imagem para cada botão, podendo repetir a mesma imagem em vários botões)<BR>
 Neste método são indicados os nomes das imagens que devem ser apresentadas, indicando apenas os nomes de ícones internos do Contágil<BR>"""

    pass


  def setLarguraBotoes(self, largura) -> None:
    """Altera a largura de todos os botões já indicados. Se for indicado 0, deixa que a largura seja definida automaticamente."""

    pass


  def setNomes(self, nomes) -> None:
    """Altera os textos (nomes dos botões) apresentados em todos os botões"""

    pass


  def setSubrotina(self, nome, subrotina) -> None:
    """Subrotina que deve ser executada quando o botão for pressionado.<BR>
 As subrotinas são procuradas no mesmo script atual. Caso queira utilizar subrotina definida em outro script, informe o nome do script antes do nome da subrotina, separando-os com o caractere '|'.<BR>
 <B>Parâmetros:</B> se quiser indicar parâmetros durante execução de subrotinas, informe logo após o nome da subrotina a relação
 de parâmetros entre parentesis. Ex: Subrotina(1) faz com que a subrotina de nome "Subrotina" seja executada com o valor 1
 informado no primeiro parâmetro<BR>
 Se nenhuma subrotina estiver associada ao botão, o botão é utilizado para fechar a janela exibida."""

    pass


  def setSubrotinas(self, subrotinas) -> None:
    """Subrotinas que devem ser executadas quando os botões correspondentes forem pressionados.<BR>
 As subrotinas são procuradas no mesmo script atual. Caso queira utilizar subrotina definida em outro script, informe o nome do script antes do nome da subrotina, separando-os com o caractere '|'.<BR>
 <B>Parâmetros:</B> se quiser indicar parâmetros durante execução de subrotinas, informe logo após o nome da subrotina a relação
 de parâmetros entre parentesis. Ex: Subrotina(1) faz com que a subrotina de nome "Subrotina" seja executada com o valor 1
 informado no primeiro parâmetro<BR>
 Se nenhuma subrotina estiver associada ao botão, o botão é utilizado para fechar a janela exibida."""

    pass


  def setTamanhoFonte(self, tamanhoFonte) -> None:
    """Altera o tamanho da fonte de todos os botões já indicados. Se for 0, utiliza o tamanho padrão."""

    pass


  def toString(self) -> str:
    pass

class Bridge ():
  """Classe que faz a "ponte" entre alguns métodos de pacotes diferentes do módulo
 de scripting. É reservado para uso interno da implementação das interfaces.<BR>
 Esta classe não é visível pelo script."""

  def ANOVA(self, nomeFator, levels) -> ANOVA:
    """Cria um objeto que será associado a um conjunto de níveis associados a um fator."""

    pass


  def ANOVA(self) -> ANOVA:
    """Cria um objeto vazio (isto é, sem informações)<BR>
 Visibilidade restrita ao pacote para uso exclusivo de Tabela."""

    pass


  def abrirArquivo(self, diretorio, nomeArquivo, extensaoDefault) -> File:
    """Abre um arquivo a partir de uma implementação dada, e de alguns atributos
 dados.<BR>
 OBS: Na realidade este método apenas confere os parâmetros para decidir
 qual deve ser o caminho completo para o arquivo desejado. Nenhum arquivo
 é de fato aberto."""

    pass


  def addAtributo(self, leiaute, atributo) -> None:
    """Adiciona um atributo a um leiaute editável"""

    pass


  def addFiltro(self, leiaute, fap) -> None:
    """Adiciona um filtro a um leiaute editável"""

    pass


  def addWebExtratorPageChangeListener(self, web, listener) -> None:
    """Permite que código externo ao WebExtrator monitore o evento de mudança de página."""

    pass


  def aplicaDestaques(self, grafico, plot, forced) -> None:
    """Dado um objeto gráfico, aplica destaques sobre ele conforme previamente configurado."""

    pass


  def buildMatrizGraficosDispersao(self, tabela, colunaClasse, owner, modal, interrupcao) -> SimpleChartsMatrixDlg:
    """Constroi uma janela para apresentação de uma matriz de gráficos dispersão."""

    pass


  def compare(self, c1, c2) -> int:
    """Compara dois objetos Criterio entre si utilizando o "ComparadorGenerico".<BR>
 OBS: utiliza na comparação o array "Criteria" de cada "Criterio"."""

    pass


  def configuraTabela(self, tab, tabela, mview, colunasExtras) -> None:
    """Configura um componente visual "tabela" com base em um componente de
 scripting "tabela""""

    pass


  def criaArquivo(self, diretorio, nomeArquivo, extensaoDefault) -> File:
    """Cria um arquivo a partir de uma implementação dada, e de alguns atributos
 dados."""

    pass


  def criarExcel(self, diretorio, nome, tipo_interno) -> ArquivoExcel:
    """Método alternativo de criação de arquivo do Excel onde o "tipo interno" é definido
 de forma explícita."""

    pass


  def criarZIP(self, in) -> ArquivoZIP:
    """Cria um ZIP a partir do seu stream."""

    pass


  def enforceUsoSmartcard(self) -> bool:
    """Caso o ContÁgil não esteja desbloqueado com o uso de uma CHAVE com
 prerrogativa de servidor (isto é, uma prerrogativa que permite armazenar
 dados não criptografados), então pede para o usuário se autenticar com
 smart-card, se isso não foi feito ainda."""

    pass


  def equals(self, c1, c2) -> bool:
    """Compara dois objetos Criterio entre si utilizando o "ComparadorGenerico".<BR>
 OBS: utiliza na comparação o array "Criteria" de cada "Criterio"."""

    pass


  def exportaTabelaUsuario(self, tabela, nome, acrescenta, tipoArquivo, impl) -> TabelaUsuario:
    """Exporta o conteúdo de uma tabela para uma determinada "tabela do usuário"
 utilizando uma determinada implementação de "CustomWarehouse" (memória,
 serialização, banco de dados, etc.)."""

    pass


  def fechaArquivo(self, arquivo) -> None:
    """Repassa a solicitação para o GerenciadorArquivos fechar o arquivo
 pretendido"""

    pass


  def feed(self, anova, level, valor) -> None:
    """Computa um valor em adição aos demais valores computados no mesmo nível."""

    pass


  def forcaNavegacaoCompleta(self, web, forcaNavegacaoCompleta) -> None:
    """Indica que o modo de navegação completa deve ser habilitado e não pode ser
 desabilitado. Útil em alguns casos interno (não deveria ser algo atribuído
 diretamente pelo usuário)."""

    pass


  def fromMatrizToComponent(self, matriz, owner) -> CommonTableComponent:
    """Cria um CommonTableComponent a partir de um objeto Matriz"""

    pass


  def fromTabelaToComponent(self, tabela, owner, colunasExtras) -> CommonTableComponent:
    """Cria um CommonTableComponent a partir de um objeto Tabela"""

    pass


  def fromTabelaToComponent(self, tabela, owner, colunasExtras, podeFixarColunas) -> CommonTableComponent:
    """Cria um CommonTableComponent a partir de um objeto Tabela"""

    pass


  def getBase(self, leiaute) -> AnBase:
    """Dado um leiaute editável, retorna o AnBase relacionado a ele.<BR>
 Pode retornar a instância AnBase que foi informada durante a construção do MADLeiauteEditavel ou, na ausência
 desta, retorna uma instância AnBase obtida em pesquisa pelo tipo (String) consultando todos os AnBase's cadastrados
 na aplicação."""

    pass


  def getBaseFromExecutor(self, executor) -> VSEnvironmentBase:
    """Dado um objeto do tipo 'ExecutorScript', retorna um objeto do tipo 'AnBase'."""

    pass


  def getChartData(self, grafico, serie) -> Matriz:
    """Dado um gráfico com dados do tipo (X,Y) não categórico, retorna
 seus dados na forma de uma matriz."""

    pass


  def getConteudoRTF(self, conteudo) -> str:
    """Transforma o conteúdo binário de um arquivo RTF na forma de um texto"""

    pass


  def getCriteria(self, c) -> Object:
    """Dado um objeto do tipo 'Criterio', retorna o vetor interno com os componentes da tupla."""

    pass


  def getCustomChartCoordinates(self, grafico) -> CustomChartCoordinates:
    """Retorna um objeto que pode ser utilizado para customizar a apresentação de legenda (X,Y) quando
 clica sobre um ponto do gráfico.<BR>
 Esta implementação retorna sempre NULL.<BR>
 Subclasses podem sobrepor este método para retornar outra coisa."""

    pass


  def getEngine(self, executor) -> ScriptEngine:
    pass


  def getEnvironment(self, executor) -> VSEnvironment:
    pass


  def getExecutorThreadLocal(self) -> ExecutorScript:
    """Retorna a instância de 'ExecutorScript' que foi definido de forma estática na thread
 atual.<BR>
 OBS: a mesma instância definida nesta thread é também herdada pelas threads filhas.<BR>
 Caso não encontre nada na thread atual, procura pela referência 'singleton' mantida
 em 'ExecucaoEspera'<BR>
 Se não encontrar nada lá também, retorna NULL."""

    pass


  def getFieldDescriptors(self, tab) -> FieldDescriptor:
    """Dado um objeto Tabela, retorna um array de FieldDescriptor's que possibilida visualização dos dados de uma linha
 desta tabela e possibilita também sua edição na forma de um formulário."""

    pass


  def getFormatacaoCondicional(self, tabela) -> FormatacaoCondicionalConfig:
    """Retorna o objeto de formatação condicional de 'Tabela'."""

    pass


  def getFormularioAltura(self, form) -> int:
    """Retorna a altura para exibição no SPACE"""

    pass


  def getFormularioLagura(self, form) -> int:
    """Retorna a largura para exibição no SPACE"""

    pass


  def getIcon(self, imagem) -> Icon:
    """Dado um objeto Imagem, retorna um objeto Icon."""

    pass


  def getImagemBytes(self, imagem, tipo) -> byte:
    """Obtém o conteúdo binário desta imagem conforme um determinado formato
 (BMP, JPG, GIF ou PNG).<BR>"""

    pass


  def getIndTratamentoErro(self, executor) -> int:
    pass


  def getIndice(self, leiaute) -> IndiceAtributosMetricas:
    """Dado um leiaute editável, retorna o objeto do tipo IndiceAtributosMetricas definido dentro dele, o que inclui
 atributos e métricas da base utilizada no leiaute e também quaisquer atributos e métricas do tipo 'calculado'
 que foram adicionados ao leiaute."""

    pass


  def getJavaColor(self, cor) -> Color:
    """Converte um objeto de scripting "Cor" no objeto Java correspondente "Color""""

    pass


  def getLOG(self, executor) -> LOG:
    pass


  def getMADDependencias(self, mad) -> AnLeiaute:
    pass


  def getMADLeiaute(self, mad) -> AnLeiaute:
    pass


  def getMenuComponent(self, menu) -> Component:
    """Retorna o componente Swing associado a este Menu"""

    pass


  def getObjetoInterrupcao(self, executor) -> Interrupcao:
    pass


  def getOffsetLinha(self, arquivo, numero) -> long:
    """Retorna o offset de uma linha de um arquivo texto (primeira linha tem índice 0)."""

    pass


  def getParser(self, a) -> OptimizedParser:
    """Retorna o 'OptimizedParser' configurado no 'ArquivoPosicoesFixas'."""

    pass


  def getPrograma(self) -> Programa:
    """Retorna o objeto que representa o script que está sendo executado neste momento pela thread atual.<BR>
 Caso não encontre nenhum na thread atual, procura no 'singleton' mantido em 'ExecucaoEspera'.<BR>
 Caso não encontra lá também, retorna NULL."""

    pass


  def getPrograma(self, executor) -> Programa:
    pass


  def getProgramaInicial(self, chamado) -> Programa:
    """Retorna o objeto que informa o 'programa inicial', ou NULL caso este seja o programa inicial."""

    pass


  def getSPACEBinaryContents(self, space) -> byte:
    """Retorna o conteúdo da janela do SPACE de forma binária"""

    pass


  def getSourceCSV(self, arq) -> WISourceCSV:
    """Dado um objeto do tipo 'ArquivoTexto' (ou derivado), retorna um objeto do tipo 'WISourceCSV' que pode
 ser utilizado para apresentar seu conteúdo em uma janela."""

    pass


  def getSourceXLS(self, arq) -> WISourceXLS:
    """Dado um objeto do tipo 'ArquivoExcel' (ou derivado), retorna um objeto do tipo 'WISourceXLS' que pode
 ser utilizado para apresentar seu conteúdo em uma janela."""

    pass


  def getTimeElapsedChkInterrompido(self, executor) -> long:
    pass


  def getUltimoConteudoBinario(self, web) -> byte:
    """Retorna o último conteúdo binário retornado pelo servidor."""

    pass


  def getUltimoEnderecoHistorico(self, web) -> str:
    """Caso esteja utilizando o modo de navegação "completo", este método retorna o último
 endereço URL mantido no histórico de endereços e capturado pelo 'Listener' interno."""

    pass


  def getVariavelInterno(self, executor, nome) -> VSVariable:
    """Obtém o objeto que encapsula a variável e seus 'metadados'. Apenas para uso interno da aplicação."""

    pass


  def getVennElements(self, grafico, annotation) -> list:
    """Dado um diagrama de Venn, dada uma anotação sobre este diagrama, retorna a relação de elementos contabilizados
 na anotação."""

    pass


  def getWebBrowserInterface(self, web) -> WebBrowserInterface:
    """Retorna o objeto 'WebBrowserInterface' associado a um objeto 'WebExtrator'"""

    pass


  def getWebBrowserInterface(self, pagina) -> WebBrowserInterface:
    """Retorna o objeto 'WebBrowserInterface' associado a um objeto 'WebPagina'"""

    pass


  def getWebExtrator(self, pagina) -> WebExtrator:
    """Retorna o objeto 'WebExtrator' associado ao 'WebPagina'"""

    pass


  def hasModoCapturaComponentes(self) -> bool:
    """Flag que indica se quaisquer respostas geradas por aqui devem ser redirecionadas a uma instância de 'VSDesktopDlg' (editor do SPACE) que
 esteja sendo executada neste momento. Caso contrário, o método deve ter o funcionamento usual."""

    pass


  def hashCode(self, c) -> int:
    """Utiliza a implementação "HASHCODE" prevista em "ComparadorGenerico"."""

    pass


  def monitoraArquivoFechavel(self, arquivo) -> None:
    """Permite que um arquivo qualquer "fechável" possa ser fechado
 automaticamente após a conclusão do script (isto é, caso não seja fechado
 antes).<BR>
 OBS: os métodos implementados em "GerenciadorArquivos" já se encarregam
 de fazer isso. Portanto, os métodos de "GerenciadorArquivos" não precisam
 executar este método. Este método deve ser executado somente se o arquivo
 "fechável" foi criado por algum método que não seja um daqueles previstos
 em "GerenciadorArquivos"."""

    pass


  def newChaveTeste(self) -> Chave:
    """Cria uma nova chave para o propósito de TESTE (não deve ser utilizada em
 produção).<BR>
 O login é sempre TESTE e a senha é sempre TESTE."""

    pass


  def newExecutorScript(self, programa) -> ExecutorScript:
    pass


  def newHashMap(self) -> dict:
    """Retorna uma nova implementação de 'HashMap' para ser utilizado internamente por alguns objetos de scripting (por exemplo,
 para ser utilizado pelo objeto 'Agregador')."""

    pass


  def newPCA(self, num_instancias, cols_numericas, num_caracteristicas, isPop) -> PrincipalComponentAnalysisCommon:
    """Retorna uma implementação de PCA, entre algumas alternativas existentes, com base nos parâmetros."""

    pass


  def newXML(self, conteudo) -> XMLTag:
    """Cria um objeto XMLTag para processar o conteúdo XML indicado no parâmetro"""

    pass


  def newXML(self, arquivo) -> ArquivoXML:
    """Cria um objeto ArquivoXML para processar o arquivo XML indicado no parâmetro"""

    pass


  def newXML(self, conteudo) -> XMLTag:
    """Cria um objeto XMLTag para processar o conteúdo XML indicado no parâmetro"""

    pass


  def newXML(self, conteudo) -> XMLTag:
    """Cria um objeto XMLTag para processar o conteúdo XML indicado no parâmetro"""

    pass


  def novaImagem(self, image) -> Imagem:
    """Retorna um objeto de script 'Imagem' dado um objeto AWT 'BufferedImage'"""

    pass


  def novaImagem(self, image) -> Imagem:
    """Retorna um objeto de script 'Imagem' dado um objeto SWING 'ImageIcon'"""

    pass


  def novaImagem(self, image) -> Imagem:
    """Retorna um objeto de script 'Imagem' dado um objeto SWING 'Icon'"""

    pass


  def novaImagem(self, contents) -> Imagem:
    """Retorna um objeto de script 'Imagem' dado um byte array"""

    pass


  def novoArquivoCSV(self, conteudo) -> ArquivoCSV:
    pass


  def novoArquivoCSV(self, anexo) -> ArquivoCSV:
    pass


  def novoArquivoCSV(self, out, separador) -> ArquivoCSV:
    pass


  def novoArquivoCSVDeprecated(self, anexo) -> ArquivoCSV:
    """Annonymous inner class #6<BR>
 Foi mantido aqui apenas para o propósito de manter compatibilidade com
 script serializado em versão antiga do ContÁgil (anterior à versão
 1.21b43, de 28/05/2012).<BR>
 NÃO DEVE SER UTILIZADA DIRETAMENTE POR NENHUM CÒDIGO ATUALMENTE ESCRITO
 NO CONTÁGIL!"""

    pass


  def novoArquivoCSVVazio(self) -> ArquivoCSV:
    """Retorna um objeto ArquivoCSV referente a um arquivo vazio"""

    pass


  def novoArquivoExcel(self, anexo) -> ArquivoExcel:
    pass


  def novoArquivoExcel(self, in_stream, bOffice2007) -> ArquivoExcel:
    pass


  def novoArquivoExcelVazio(self) -> ArquivoExcel:
    """Retorna um objeto ArquivoExcel referente a uma planilha do Excel vazia"""

    pass


  def novoArquivoGenerico(self, anexo) -> Arquivo:
    pass


  def novoArquivoPosicoesFixas(self, conteudo, tamanhosColunas) -> ArquivoPosicoesFixas:
    pass


  def novoArquivoTexto(self, conteudo) -> ArquivoTexto:
    pass


  def novoArquivoTexto(self, conteudo) -> ArquivoTexto:
    """Retorna um objeto ArquivoTexto referente a um conteúdo texto."""

    pass


  def novoArquivoTexto(self, anexo) -> ArquivoTexto:
    pass


  def novoArquivoTextoVazio(self) -> ArquivoTexto:
    """Retorna um objeto ArquivoTexto referente a um arquivo vazio"""

    pass


  def novoGraficoPCAVars(self, pca, rotacao) -> Grafico:
    """Dado um objeto do tipo 'PCA', retorna um gráfico que exibe suas 'variáveis'."""

    pass


  def novoMADLeiaute(self, anexo) -> MADLeiaute:
    pass


  def novoMADLeiaute(self, anexo, programa) -> MADLeiaute:
    pass


  def novoMADLeiaute(self, leiaute) -> MADLeiaute:
    """Retorna um objeto MADLeiaute referente a um leiaute indicado como parâmetro"""

    pass


  def novoMADLeiauteEditavel(self, leiaute) -> MADLeiauteEditavel:
    """Cria um novo MADLeiauteEditavel utilizando um leiaute específico já existente"""

    pass


  def novoMADLeiauteEditavel(self, leiaute, base) -> MADLeiauteEditavel:
    """Cria um novo MADLeiauteEditavel utilizando um leiaute específico já existente e uma instância
 de AnBase onde a consulta será realizada"""

    pass


  def novoMADLeiauteEditavel(self, base, nomeLeiaute) -> MADLeiauteEditavel:
    """Cria um novo MADLeiauteEditavel utilizando uma implementação específica de AnBase"""

    pass


  def novoMADLeiauteVazio(self) -> MADLeiaute:
    """Retorna um objeto MADLeiaute referente a um leiaute vazio"""

    pass


  def novoModeloRelatorio(self, anexo) -> ModeloRelatorio:
    pass


  def novoModeloRelatorioVazio(self) -> ModeloRelatorio:
    """Retorna um objeto ModeloRelatorio referente a um arquivo vazio"""

    pass


  def novoSPACE(self, anexo) -> SPACE:
    pass


  def novoSPACEVazio(self) -> SPACE:
    """Retorna um objeto SPACE referente a uma área de trabalho vazia"""

    pass


  def novoWebPagina(self, anexo) -> WebPagina:
    pass


  def novoWebPaginaVazio(self) -> WebPagina:
    """Retorna um objeto WebPagina referente a um arquivo vazio"""

    pass


  def pedeOpcao(self, mensagem, opcoes, escolhida_inicialmente, permiteNovaOpcao, outros_botoes) -> str:
    """Cria combo-box com mais botões na mesma janela."""

    pass


  def prepareFormula(self, calc, overrideAtributos, overrideMetricas) -> None:
    """Compila a fórmula encapsulada no objeto de tipo calculado. Para isso, utiliza as variáveis definidas no ambiente
 de execução do script (caso a thread atual mantenha referência a ele) e utiliza também as definições de atributos
 e métricas passados nos dois parâmetros finais. Caso o ambiente possua variáveis com mesmos nomes dos atributos
 e métricas indicados no parâmetro, esses últimos têm preferência sobre o primeiro."""

    pass


  def removeListasFixedSeed(self) -> None:
    """Desfaz o que foi feito com "setListasFixedSeed"."""

    pass


  def removeWebExtratorPageChangeListener(self, web, listener) -> None:
    pass


  def removeWebExtratorPageChangeListeners(self, web) -> None:
    pass


  def render(self, grafico) -> JFreeChart:
    """Renderiza um gráfico e retorna o componente interno de visualização."""

    pass


  def salvaRTF(self, owner, conteudo) -> None:
    pass


  def salvaRTF(self, owner, conteudo) -> None:
    pass


  def setChaveInConexaoWarehouseExterno(self, chave, obj) -> None:
    """Dado um objeto Chave e um objeto ConexaoWarehouseExterno, copia as credenciais do primeiro para o segundo."""

    pass


  def setEngine(self, executor, engine) -> None:
    pass


  def setEntradaCampoResposta(self, campo, resposta) -> None:
    """Atribui uma resposta ao campo"""

    pass


  def setEntradaPeriodoFimPreenchido(self, campo, resposta) -> None:
    """Atribui uma resposta ao campo"""

    pass


  def setEntradaPeriodoInicioPreenchido(self, campo, resposta) -> None:
    """Atribui uma resposta ao campo"""

    pass


  def setEnvironment(self, executor, env) -> None:
    pass


  def setEscondeRotulosSobreValores(self, grafico, escondeRotulosSobreValores) -> None:
    """Indica se os rótulos sobre valores não devem ser apresentados mesmo que tenham sido
 armazenados em 'rotulosSobreValores'."""

    pass


  def setExecutorThreadLocal(self, executor) -> None:
    """Define na thread atual a instância de 'ExecutorScript' que deve ser acessada de forma
 estática. Apenas considerada na thread atual, não em outras threads.<BR>
 OBS: a mesma instância definida nesta thread é também herdada pelas threads filhas."""

    pass


  def setFormatacaoCondicional(self, tabela, formatacaoCondicional) -> None:
    """Altera o objeto de formatação condicional de 'Tabela'."""

    pass


  def setFormularioFieldGetter(self, form, fieldGetter) -> None:
    """Método de visibilidade restrita a este pacote.<BR>
 Parâmetro opcional. Se diferente de NULL, faz com que os objetos WebCampo retornem valores
 de acordo como é definido nesta função. Geralmente utilizado no SPACE para recuperar valores
 preenchidos em formulários."""

    pass


  def setGraficoCorBorda(self, grafico, cor) -> None:
    """Faz o mesmo que o método alternativo {@link Grafico#setCorBorda setCorBorda}, porém aceita como parâmetro um objeto no padrão Java para representação da cor."""

    pass


  def setGraficoSeriesColor(self, grafico, serie, cor) -> None:
    """Define uma cor para a série utilizando o objeto Java que representa a Cor, e não o análogo definido na linguagem de script."""

    pass


  def setHashMapImplementation(self, hashMapImplementation) -> None:
    """A aplicação pode definir uma implementação alternativa a 'HashMap' para ser utilizada pelos objetos de script (ex: para ser utilizado
 pelo objeto 'Agregador')."""

    pass


  def setIndTratamentoErro(self, executor, indTratamentoErro) -> None:
    pass


  def setInibePreenchimentoEndOfLines(self, arquivo, flag) -> None:
    """Indica se devemos ou não 'inibir' o preenchimento automático de 'eolines'"""

    pass


  def setLOG(self, executor, log) -> None:
    pass


  def setLOG(self, executor, log) -> None:
    pass


  def setListasFixedSeed(self) -> None:
    """Em caso de TESTES, informa uma mesma "semente" a ser utilizada para geração
 de números aleatórios em listas. Esta semente é sempre a mesma independentemente
 de quando esta função é chamada."""

    pass


  def setMenuImagemResposta(self, mci, resposta) -> None:
    """Atribui uma resposta ao menu com imagens"""

    pass


  def setModoCapturaComponentes(self, modoCapturaComponentes) -> None:
    """Flag que indica se quaisquer respostas geradas por aqui devem ser redirecionadas a uma instância de 'VSDesktopDlg' (editor do SPACE) que
 esteja sendo executada neste momento. Caso contrário, o método deve ter o funcionamento usual."""

    pass


  def setNumeroLinha(self, linha, numero) -> None:
    """Define o número da linha a ser retornado pelo método 'getNumeroLinha' de um objeto 'LinhaArquivo'"""

    pass


  def setObjetoInterrupcao(self, anterior, interrupcao) -> None:
    """Altera o objeto de controle de interrupção."""

    pass


  def setPrograma(self, executor, programa) -> None:
    pass


  def setProgramaInicial(self, chamado, chamador) -> None:
    """Vincula o objeto que informa o 'programa inicial'"""

    pass


  def setVennFontSizeLegend(self, grafico, fontSizeLegend) -> None:
    """Altera o tamanho da fonte para um diagrama de Venn."""

    pass


  def setVisivelPrimeiroPlano(self, web, visivelPrimeiroPlano) -> None:
    """Indica se este WebExtrator deve ser visível em primeiro plano (isto é, ele está sendo
 utilizado para apresentar em uma janela). O padrão é FALSE. Isto é, ou ele não é visível,
 ou ele não deve rodar em primeiro plano (talvez seja visível em segundo plano).!"""

    pass


  def setWebBrowserInterface(self, web, i) -> None:
    """Altera a implementação atual de 'WebBrowserInterface'"""

    pass


  def showSPACE(self, space, modoApresentacao, habilitaModoEdicao, modal, callbackOnSave) -> None:
    """Exibe a janela do SPACE - Espaço Interativo do Script Visual"""

    pass


  def showTabela(self, owner, tabela) -> SimpleTabelaView:
    """Exibe o conteúdo de uma tabela em uma janela."""

    pass


  def useChaveImportacao(self, chave, oa) -> bool:
    """Faz uso de uma chave de importação"""

    pass

class BridgeDadosRFB ():
  """Faz a ponte entre métodos relacionados a bases de dados da RFB e os objetos de script do ContÁgil.<BR>
 <BR>
 Os métodos aqui presentes não são incluídos no 'guia do programador'.<BR>"""

  def connectADA(self, chave, perfil, host) -> AdaQuery:
    pass


  def connectADA(self, chave, perfil, host, timeout_ms) -> AdaQuery:
    pass


  def connectCnisCidadao(self, chave, interrupcao) -> CnisCidadao:
    """Faz a conexão ao sistema CNIS Cidadão"""

    pass


  def connectCnisTrabalhador(self, chave, interrupcao) -> CnisTrabalhador:
    """Faz a conexão ao sistema CNIS Trabalhador"""

    pass


  def importaDACON(self, chave, cnpj, dataInicial, dataFinal, apenas_ultimas) -> str:
    """Faz a importação da DACON para uma relação de CNPJs em um dado período e com um dado objeto de autenticação."""

    pass


  def importaDARF_DW(self, contribuintes, dataInicial, dataFinal, tipo) -> list:
    """Faz a importação de DARF's pelo DW para uma relação de CNPJ em um dado período e com um dado objeto de 

autenticação."""

    pass


  def importaDCTF(self, chave, cnpjRaiz, dataInicial, dataFinal) -> str:
    """Faz a importação da DCTF para uma relação de CNPJs (raiz) em um dado período e com um dado objeto de autenticação."""

    pass


  def importaDIPJ(self, chave, cnpj, ano_inicio, ano_fim, diretorioDeclaracoes, reimportar) -> str:
    """Faz a importação da DIPJ para uma relação de CNPJs em um dado período e com um dado objeto de autenticação."""

    pass


  def importaDIRF(self, chave, nis, dataInicial, dataFinal, processo, motivo, descricao) -> str:
    """Faz a importação da DIRF para uma relação de números de inscrição (CPF ou CNPJ de 8 ou de 14 dígitos) em um dado período (ano-calendário) e com um dado objeto de autenticação."""

    pass


  def importaGFIP(self, chave, contribuinte, compInicial, compFinal, importaTrabalhadores, importaTomadores, apenasNaoImportadas, status) -> str:
    """Faz a importação da GFIP para uma relação de CNPJs (CNPJ/CEI) em um dado período e com um dado objeto de autenticação.<BR>
 Inclui mais critérios de pesquisa."""

    pass


  def importaGFIP(self, chave, contribuinte, compInicial, compFinal, importaTrabalhadores, importarStatus) -> str:
    """Faz a importação da GFIP para uma relação de CNPJs (CNPJ/CEI) em um dado período e com um dado objeto de autenticação."""

    pass


  def importaGPS_INFORMAR(self, chave, contribuinte, compInicial, compFinal, apaga_anterior, progress) -> list:
    """Faz a importação da GPS pelo INFORMAR para uma relação de CNPJs ou CEIs em um dado período e com um dado objeto de autenticação."""

    pass


  def importaGPS_PLENUS(self, chave, contribuinte, compInicial, compFinal, apaga_anterior, progress) -> list:
    """Faz a importação da GPS pelo PLENUS para uma relação de CNPJs ou CEIs em um dado período e com um dado objeto de autenticação."""

    pass


  def importaGPS_XLS(self, nomeArquivo) -> list:
    """Faz a importação da GPS a partir de um arquivo XLS"""

    pass


  def importaPERDCOMPCPERDCOMP(self, chave, nds) -> str:
    """Faz a importação de PER/DCOMP para uma relação de NDs e com um dado objeto de autenticação."""

    pass


  def importaPERDCOMPCPERDCOMP(self, chave, cnpjs, dataInicial, dataFinal) -> str:
    """Faz a importação de PER/DCOMP para uma relação de CNPJ 14, com um dado objeto de autenticação para
 um período determinado."""

    pass


  def importaPERDCOMPDW(self, chave, nis, dataInicial, dataFinal, tipoPA, tipoPesquisa) -> str:
    """Faz a importação de PEDCOMP para uma relação de CNPJs (completo) em um dado período e com um dado objeto de autenticação."""

    pass

class BridgeGrafos ():
  """Faz uma ponte entre a aplicação (código interno do aplicativo ContÁgil)
 e alguns métodos protegidos da classe "GrafoRelacionamentos".<BR>
 <BR>
 Os métodos aqui presentes não são incluídos no 'guia do programador'.<BR>"""

  def castToScripting(self, value) -> Object:
    """Converte um valor qualquer para sua representação comum em script."""

    pass


  def getGerenciadorBase(self, g, nomeBase) -> IGerenciadorBaseGrafos:
    """Adquire uma instância de 'IGerenciadorBaseGrafos'. Executa também o método 'setNomeBase' para
 definir qual base deve utilizar."""

    pass


  def getVisualizador(self, grafo) -> Visualizador:
    """Retorna o objeto de visualização associado ao objeto de script"""

    pass


  def newGrafoEntidade(self, base, entidade) -> GrafoEntidade:
    """Adquire uma instância de 'GrafoEntidade' para uma base de relacionamentos."""

    pass


  def newGrafoEntidade(self, visualizador, entidade) -> GrafoEntidade:
    """Adquire uma instância de 'GrafoEntidade' para um grafo que está sendo visualizado."""

    pass


  def newGrafoEntidade(self, grafo, entidade) -> GrafoEntidade:
    """Adquire uma instância de 'GrafoEntidade' para um grafo que não está sendo visualizado."""

    pass


  def newGrafoRelacionamento(self, grafo, relacionamento) -> GrafoRelacionamento:
    """Adquire uma instância de 'GrafoRelacionamento' para um grafo que não está sendo visualizado."""

    pass


  def newGrafoRelacionamento(self, visualizador, relacionamento) -> GrafoRelacionamento:
    """Adquire uma instância de 'GrafoRelacionamento' para um grafo que está sendo visualizado."""

    pass


  def newGrafoRelacionamento(self, base, relacionamento) -> GrafoRelacionamento:
    """Adquire uma instância de 'GrafoRelacionamento' para uma base de relacionamentos."""

    pass


  def newGrafoRelacionamentos(self, executor, grafo, persistente) -> GrafoRelacionamentos:
    """Cria um novo objeto 'GrafoRelacionamentos' dado um objeto 'grafo' que pode persistir ou não
 em disco."""

    pass


  def newGrafoRelacionamentos(self, executor, persistente) -> GrafoRelacionamentos:
    """Cria um novo objeto 'GrafoRelacionamentos' dado um flag que indica se pode persistir ou não
 em disco."""

    pass


  def newGrafoVisualizado(self, visualizador) -> GrafoVisualizado:
    """Adquire uma instância de 'GrafoVisualizado' para um grafo que está sendo visualizado."""

    pass


  def newRestauraIconesPadrao(self, nomeBase, diferenciaIdade, diferenciaSexo, interrupcao, progress) -> int:
    """Restaura, em uma base de relacionamentos, os ícones para o padrão ContÁgil,
 retirando a personalização eventualmente feita.<BR>
 
 Retorna o número de entidades que tiveram o ícone restaurado."""

    pass

class BridgeMail ():
  """Faz a ponte entre métodos relacionados a E-MAIL e os objetos de script do
 ContÁgil.<BR>
 <BR>
 Os métodos aqui presentes não são incluídos no 'guia do programador'.<BR>"""

  def autentica(self, mail, hostSMTP, login, senha, ssl) -> None:
    """Autentica-se em um servidor de e-mail indicando login e senha.<BR>
 Não recomendável para uso direto em script por expor a senha."""

    pass

class BridgeTerminal ():
  """Faz a ponte entre métodos relacionados ao terminal e os objetos de script do
 ContÁgil.<BR>
 <BR>
 Os métodos aqui presentes não são incluídos no 'guia do programador'.<BR>"""

  def getConnection(self, terminal) -> TerminalProc:
    pass


  def getWebExtrator(self, mv2) -> WebExtrator:
    pass


  def importaCNPJ(self, chave, cnpj, importarFiliais, importarSocios, importarHistorico, importarApenasEstabelecimentosInformados, progress, interrupcao) -> PessoaJuridica:
    """Faz a importação de dados cadastrais CNPJ para uma relação de CNPJs (14
 dígitos) e com um dado objeto de autenticação."""

    pass


  def importaCPF(self, chave, cpfs, progress, interrupcao) -> PessoaFisica:
    """Faz a importação de dados cadastrais CPF para uma relação de CPFs e com
 um dado objeto de autenticação."""

    pass

class Chave ():
  """Abstração de uma "chave" utilizada em criptografia de arquivos ou para
 autenticação de usuários (etapa que antecede a extração de dados de algum
 sistema).<BR>
 Uma chave utilizada em criptografia de arquivos pode ser obtida através do
 método {@link Chaves#getChaveCriptografia() getChaveCriptografia} do objeto
 {@link Chaves Chaves}, acessível a uma linguagem de scripting da seguinte
 forma:
 <P>
 <CODE> chave = chaves.getChaveCriptografia()
 <P>
 </CODE> Um mesmo objeto "Chave" pode ser utilizado em vários procedimentos de
 criptografia ou descriptografia.<BR>
 Uma chave utilizada em autenticação de usuário em sistema pode ser obtida
 através do método
 {@link Chaves#getChaveImportacao(String, String) getChaveImportacao} do
 objeto {@link Chaves Chaves}, acessível a uma linguagem de scripting da
 seguinte forma:
 <P>
 <CODE> chave = chaves.getChaveImportacao("NOME DO SISTEMA","NOME DO PERFIL")
 <P>
 </CODE> Um mesmo objeto "Chave" pode ser utilizado em vários procedimentos de
 autenticação, caso eles utilizem o mesmo login e senha. Observe que o objeto
 "Chave", apesar de encapsular o login e a senha do usuário, não disponibiliza
 essas informações de nenhuma forma. Isto é, não é possível saber qual foi o
 login ou a senha digitados pelo usuário. Essas informações ficam confinadas
 dentro do objeto "Chave", e apenas se tornam acessíveis ao próprio código do
 ContÁgil, no momento em que é necessário (por exemplo, durante a importação
 de dados de algum sistema).<BR>"""

  def isInvalida(self) -> bool:
    """Retorna a indicação de que a chave é inválida após a tentativa de
 autenticação.<BR>
 OBS: para saber se a chave é válida não basta criar a chave (isto é, não
 basta chamar o método getChaveImportacao). É preciso também que a chave
 seja utilizada em alguma rotina de autenticação (ex: na autenticação do
 sistema DW, ou na autenticação de uma rotina de importação, ou em outra
 situação qualquer envolvendo "Chave").<BR>
 Apenas depois de uma tentativa mal sucedida de autenticação é que é
 possível determinar se uma chave é inválida. Antes disso toda chave é
 considerada "válida", mesmo que ela não seja."""

    pass


  def setInvalida(self, b) -> None:
    """Após uma tentativa de autenticação, informa se a chave é considerada
 válida ou não. Esta função é utilizada internamente pelo ContÁgil e não
 precisa ser utilizada diretamente pelo script, a menos que o script tenha
 outras razões para considerar uma chave inválida."""

    pass

class Chaves ():
  """Classe utilizada por linguagem de scripting para obter chaves que podem ser
 utilizadas em outras funcionalidades.<BR>
 Por exemplo, para trabalhar com <B>criptografia</B> ou <B>descriptografia</B>
 de arquivos, existem os métodos
 {@link GerenciadorArquivos#criptografa(Chave, String, String) arquivos.criptografa()}
 e
 {@link GerenciadorArquivos#descriptografa(Chave, String, String) arquivos.descriptografa()}.
 Esses métodos, por sua vez, requerem um objeto retornado pela função
 {@link Chaves#getChaveCriptografia() chaves.getChaveCriptografia()}.<BR>
 Exemplo:<BR>
 <CODE> // Pede para o usuário escolher uma chave para criptografar o arquivo.
 chave = chaves.getChaveCriptografia();<BR>
 arquivos.criptografa(chave, "C:\\ARQUIVO.TXT", "ARQUIVO.SEC");<BR>
 </CODE> <BR>
 Este objeto está acessível para a linguagem de script através do nome
 "chaves".<BR>
 Uma mesma {@link Chave Chave} pode ser utilizada como parâmetro para mais de
 um método de importação, caso o login e a senha sejam os mesmos para os
 diferentes sistemas consultados.<BR>"""

  def getChaveCriptografia(self) -> Chave:
    """Apresenta uma janela em que o usuário deve escolher uma chave (isto é,
 ele pode escolher seu smart-card, ou um certificado digital de alguém, ou
 uma outra opção válida de criptografia).<BR>
 Caso o usuário não escolha uma opção ou não saiba o "PIN" para acessar a
 chave secreta, esta função retorna NULL.<BR>
 Esta função pode ser utilizada tanto para "criptografar" um arquivo como
 também para "descriptografar" um arquivo.
 <P>
 Caso seja desejável "descriptografar" um arquivo, o usuário não poderá
 escolher dentre as opções apresentadas aquelas que sejam apenas
 "certificados digitais" de outras pessoas, pois na "descriptografia"
 utiliza-se somente chave privada (algo que está armazenado no smart-card
 ou em algum outro dispositivo seguro).<BR>
 Por outro lado, para "criptografar" um arquivo, pode ser utilizado tanto
 um dispositivo seguro como também um simples certificado digital.
 <P>
 OBS: A "senha" não fica aparente no script e nem pode ser consultada pelo
 script. É o usuário quem deve digitar sua senha no momento da execução."""

    pass


  def getChaveImportacao(self, nomeSistema, nomeSubsistema, campoAdicional) -> Chave:
    """Método análogo a
 {@link Chaves#getChaveImportacao(String, String) getChaveImportacao},
 com a inclusão de um campo adicional para o usuário informar algo além do
 login e da senha.<BR>
 Por exemplo, no caso da GFIP, o usuário deve também informar um "código
 de acesso", portanto neste caso a função poderia ser chamada da seguinte
 forma:<BR>
 <CODE> chave = chaves.getChaveImportacao("GFIP","GFIPWeb","Código de
 Acesso"); </CODE>"""

    pass


  def getChaveImportacao(self, nomeSistema, nomeSubsistema) -> Chave:
    """Apresenta uma janela em que o usuário deve escolher uma chave que será
 utilizada posteriormente no script para consultar dados de algum sistema.<BR>
 Isto é, o usuário precisa preencher um "login" e uma "senha" para acesso
 de um determinado sistema.<BR>
 Essas informações não ficam diretamente disponíveis para o script, mas
 podem ser repassadas como parâmetro para um outro método que faz a
 autenticação do usuário com base nessas credenciais (isto é, um método
 que realiza importação de dados do referido sistema).<BR>
 Existe, portanto, a possibilidade de um problema com o login ou a senha
 apenas ser detectado apenas posteriormente no script, quando o objeto
 "Chave" é efetivamente utilizado para algum fim prático.<BR>
 OBS: A linguagem de script não pode informar diretamente o "login" ou a
 "senha" a ser utilizado neste método. É o usuário quem digita esses dados
 durante a execução do script."""

    pass


  def getChaveImportacao(self, usuario, senha) -> Chave:
    """Método para obter uma chave passando o usuário e senha como parâmetros,
 sem necessidade de apresentar janela."""

    pass


  def getChaveImportacao(self, nomeSistema, nomeSubsistema, larguraJanela) -> Chave:
    """Apresenta uma janela em que o usuário deve escolher uma chave que será
 utilizada posteriormente no script para consultar dados de algum sistema.<BR>
 Isto é, o usuário precisa preencher um "login" e uma "senha" para acesso
 de um determinado sistema.<BR>
 Essas informações não ficam diretamente disponíveis para o script, mas
 podem ser repassadas como parâmetro para um outro método que faz a
 autenticação do usuário com base nessas credenciais (isto é, um método
 que realiza importação de dados do referido sistema).<BR>
 Existe, portanto, a possibilidade de um problema com o login ou a senha
 apenas ser detectado apenas posteriormente no script, quando o objeto
 "Chave" é efetivamente utilizado para algum fim prático.<BR>
 OBS: A linguagem de script não pode informar diretamente o "login" ou a
 "senha" a ser utilizado neste método. É o usuário quem digita esses dados
 durante a execução do script."""

    pass


  def getChaveImportacao(self, nomeSistema, nomeSubsistema, larguraJanela, botaoPIN) -> Chave:
    """Apresenta uma janela em que o usuário deve escolher uma chave que será
 utilizada posteriormente no script para consultar dados de algum sistema.<BR>
 Isto é, o usuário precisa preencher um "login" e uma "senha" para acesso
 de um determinado sistema.<BR>
 Caso o <b>botão PIN</b> esteja marcado como <b>'SIM' (true)</b>, o usuário poderá acessar
 o sistema via certificado digital. Esta possibilidade está funcionando para a
 baixa de informações do <b>Portal DIRF</b>.<BR>
 Essas informações não ficam diretamente disponíveis para o script, mas
 podem ser repassadas como parâmetro para um outro método que faz a
 autenticação do usuário com base nessas credenciais (isto é, um método
 que realiza importação de dados do referido sistema).<BR>
 Existe, portanto, a possibilidade de um problema com o login ou a senha
 apenas ser detectado apenas posteriormente no script, quando o objeto
 "Chave" é efetivamente utilizado para algum fim prático.<BR>
 OBS: A linguagem de script não pode informar diretamente o "login" ou a
 "senha" a ser utilizado neste método. É o usuário quem digita esses dados
 durante a execução do script."""

    pass


  def getChaveImportacaoDominioGOV(self, nomeSistema, nomeSubsistema) -> Chave:
    """Método análogo a
 {@link Chaves#getChaveImportacao(String, String) getChaveImportacao},
 onde o LOGIN é preenchido com CPF acrescido do prefixo "GOV/".<BR>"""

    pass


  def getChaveImportacaoHod(self) -> Chave:
    """Cria uma chave que será utilizada posteriormente no script para consultar 
 dados do Grande Porte, <b>HOD</b>, utilizando o certificado digital.<BR>
 A chave criada também poderá ser usada para baixar <b>DIRF</b> do Portal via
 certificado digital<BR>
 Se o acesso ao ContÁgil foi com certificado, não será solicitada nova
 digitação do PIN.<BR>
 Caso a conexão não esteja disponível uma mensagem de erro será exibida."""

    pass


  def getChaveImportacaoSemCPF(self, nomeSistema, nomeSubsistema, campoAdicional) -> Chave:
    """Método análogo a
 {@link Chaves#getChaveImportacao(String, String) getChaveImportacao},
 com a inclusão de um campo adicional para o usuário informar algo além do
 login e da senha.<BR>
 Neste método considera-se que o campo "login" não é um campo do tipo CPF.
 Caso o campo login seja do tipo "CPF", utilize o outro método que já
 preenche o referido campo com o CPF do usuário autenticado no ContÁgil.<BR>
 Ou seja, esta função apresenta uma janela com os seguintes campos para
 preenchimento:<BR>
 LOGIN (algo que não é um CPF)<BR>
 SENHA<BR>
 CAMPO ADICIONAL (cujo rótulo é apresentado no terceiro parâmetro de
 execução deste método)<BR>"""

    pass


  def getChaveImportacaoSemCPF(self, nomeSistema, nomeSubsistema) -> Chave:
    """Método análogo a
 {@link Chaves#getChaveImportacao(String, String) getChaveImportacao}.<BR>
 Neste método considera-se que o campo "login" não é um campo do tipo CPF.
 Caso o campo login seja do tipo "CPF", utilize o outro método que já
 preenche o referido campo com o CPF do usuário autenticado no ContÁgil.<BR>
 Ou seja, esta função apresenta uma janela com os seguintes campos para
 preenchimento:<BR>
 LOGIN (algo que não é um CPF)<BR>
 SENHA<BR>"""

    pass

class Cnis ():
  """Executa consultas no sistema CNIS Trabalhadores."""

  def atualizaCadastroContAgil(self, chave, nits, apenasPessoasSemCPF) -> list:
    """Atualiza o cadastro local de pessoas físicas do ContÁgil utilizando o sistema
 CNIS Cidadão.<BR>
 A consulta é realizada sobre os códigos NIT que estão informados na lista.
 Para cada um deles é feita consulta ao sistema "CNIS Cidadão", utilizando
 esses códigos NIT como critério de pesquisa, retornando informações
 cadastrais sobre eles (ex: CPF, endereço, nome, etc.).<BR>
 Essas informações são incorporadas no cadastro de pessoas físicas local do
 ContÁgil e também são retornadas por este método."""

    pass


  def atualizaCadastroContAgil(self, chave, apenasPessoasSemCPF) -> list:
    """Atualiza o cadastro local de pessoas físicas do ContÁgil utilizando o sistema
 CNIS Cidadão.<BR>
 A consulta é realizada assim:<BR>
 Primeiro são relacionados os códigos NIT de todas as pessoas que existem no
 ContÁgil informadas em qualquer uma das seguintes bases previamente
 importadas:<BR>
 - GFIP<BR>
 - RAIS<BR>
 - Cadastro de trabalhadores (folha de pagamento, etc.)<BR>
 Depois, dados esses códigos NIT, é verificado se já existe informação de CPF
 informado no cadastro local de pessoas físicas no ContÁgil. Caso exista e
 caso o parâmetro 'apenasPessoasSemCPF' seja VERDADEIRO, exclui esses códigos
 da lista. Caso contrário, esses códigos são mantidos.<BR>
 Feito isso, para os códigos NIT que permanecem na lista, é feita consulta ao
 sistema "CNIS Cidadão", utilizando esses códigos NIT como critério de
 pesquisa, retornando informações cadastrais sobre eles (ex: CPF, endereço,
 nome, etc.).<BR>
 Essas informações são incorporadas no cadastro de pessoas físicas local do
 ContÁgil e também são retornadas por este método."""

    pass


  def atualizaCadastroContAgil(self, chave, nits) -> list:
    """Atualiza o cadastro local de pessoas físicas do ContÁgil utilizando o sistema
 CNIS Cidadão.<BR>
 A consulta é realizada sobre os códigos NIT que estão informados na lista.
 Para cada um deles é feita consulta ao sistema "CNIS Cidadão", utilizando
 esses códigos NIT como critério de pesquisa, retornando informações
 cadastrais sobre eles (ex: CPF, endereço, nome, etc.).<BR>
 Essas informações são incorporadas no cadastro de pessoas físicas local do
 ContÁgil e também são retornadas por este método. Foi adotado como padrão 
 de atualização a complementação das informações já existentes no cadastro.
 Caso seja desejada a sobreposição dos dados, usar o método
 {@link #atualizaCadastroContAgil(Chave, boolean, List)}, atribuindo 'true'
 ao parâmetro 'SOBREPOE'."""

    pass


  def atualizaCadastroContAgil(self, chave, sobrepoe, nits) -> list:
    """Atualiza o cadastro local de pessoas físicas do ContÁgil utilizando o sistema
 CNIS Cidadão.<BR>
 A consulta é realizada sobre os códigos NIT que estão informados na lista.
 Para cada um deles é feita consulta ao sistema "CNIS Cidadão", utilizando
 esses códigos NIT como critério de pesquisa, retornando informações
 cadastrais sobre eles (ex: CPF, endereço, nome, etc.).<BR>
 Essas informações são incorporadas no cadastro de pessoas físicas local do
 ContÁgil e também são retornadas por este método."""

    pass


  def consultaBeneficiosNIT(self, chave, nits) -> Tabela:
    """Consulta os benefícios de um trabalhador no sistema CNIS Trabalhadores,
 utilizando a opção "Benefícios/Consulta Benefício por Inscrição"."""

    pass


  def consultaCadastroNIT(self, chave, nits) -> Tabela:
    """Consulta o cadastro do trabalhador no sistema CNIS Trabalhadores, utilizando
 a opção "Trabalhadores/Consulta Dados Cadastrais"."""

    pass


  def consultaCadastroTrabalhador(self, chave, nits) -> Tabela:
    """Consulta o cadastro do trabalhador no sistema CNIS Cidadão, utilizando a
 opção "Trabalhadores/Consulta aos Dados Cadastrais"."""

    pass


  def consultaDadosCadastraisCPF(self, cpfs) -> Tabela:
    """Consulta os dados cadastrais do trabalhador no sistema Portal CNIS,
 utilizando a opção "Consulta/Pessoa Fisica/Dados Cadastrais"."""

    pass


  def consultaDadosCadastraisNIT(self, nits) -> Tabela:
    """Consulta os dados cadastrais do trabalhador no sistema Portal CNIS,
 utilizando a opção "Consulta/Pessoa Fisica/Dados Cadastrais"."""

    pass


  def consultaDadosCadastraisParametros(self, nome, nomeMae, tituloEleitor, cnh, dataNascimento, identidade, numeroCTPS) -> Tabela:
    """Consulta os dados cadastrais do trabalhador no sistema Portal CNIS,
 utilizando a opção "Consulta/Pessoa Fisica/Dados Cadastrais"."""

    pass


  def consultaDuplicidadesInscricao(self, chave, nits) -> Tabela:
    """Consulta as duplicidades de inscrição de um trabalhador no sistema CNIS
 Cidadão, utilizando a opção "Trabalhadores/Consulta Elos"."""

    pass


  def consultaDuplicidadesNIT(self, chave, nits) -> Tabela:
    """Consulta as duplicidades de inscrição de um trabalhador no sistema CNIS
 Trabalhadores, utilizando a opção "Trabalhadores/Consulta Duplicidade de
 inscrição"."""

    pass


  def consultaElos(self, nits) -> Tabela:
    """Consulta os Elos existentes para o trabalhador no sistema Portal CNIS,
 utilizando a opção "Consulta/Pessoa Fisica/Elos"."""

    pass


  def consultaHistoricoBeneficiosCPF(self, cpfs) -> Tabela:
    """Consulta historico de beneficios do trabalhador no sistema Portal CNIS,
 utilizando a opção "Consulta/Historico Beneficio"."""

    pass


  def consultaHistoricoBeneficiosNIT(self, nits) -> Tabela:
    """Consulta historico de beneficios do trabalhador no sistema Portal CNIS,
 utilizando a opção "Consulta/Historico Beneficio"."""

    pass


  def consultaInscricaoPorCPF(self, chave, cpfs) -> Tabela:
    """Consulta os NITs vinculados a CPFs no sistema CNIS Cidadão, utilizando a
 opção "Trabalhadores/Consulta por Nome/ Data Nascimento/CPF""""

    pass


  def consultaInscricaoPorParametros(self, chave, parametros, colunaNome, colunaDataNascimento, colunaNomeMae, colunaCTPS, colunaRG, colunaCPF, colunaTituloEleitor) -> Tabela:
    """Consulta os trabalhadores/NITs por nome, data de nascimento, nome da mãe e
 demais critérios no sistema CNIS Cidadão, utilizando a opção
 "Trabalhadores/Consulta por Nome/Data Nascimento/CPF".
 <P>
 Os parâmetros da consulta no CNIS são informados através de uma tabela, que
 pode conter todos ou apenas alguns dos parâmetros. Informe para cada
 parâmetro o título ou o índice da coluna da tabela que contém cada
 informação.<BR>
 Deixe o parâmetro em branco ou informe -1 para indicar que o parâmetro não
 será utilizado na consulta.<BR>
 
 Todos os parâmetros informados serão repassados à consulta ao CNIS.
 <p>"""

    pass


  def consultaInscricaoPorParametros(self, chave, parametros) -> Tabela:
    """Consulta os trabalhadores/NITs por nome, data de nascimento, nome da mãe e
 demais critérios no sistema CNIS Cidadão, utilizando a opção
 "Trabalhadores/Consulta por Nome/Data Nascimento/CPF".
 <P>
 Os parâmetros da consulta no CNIS são informados através de uma tabela, que
 pode conter todos ou apenas alguns dos parâmetros. A ordem das colunas na
 tabela deve ser:
 <P>
 Nome<NR> Data de Nascimento<BR>
 Nome da Mãe<BR>
 CTPS<BR>
 RG<BR>
 CPF<BR>
 Título de Eleitor
 <P>
 
 Todos os parâmetros informados serão repassados à consulta ao CNIS.
 <p>"""

    pass


  def consultaRecolhimentos(self, nits) -> Tabela:
    """Consulta os Recolhimentos existentes para o trabalhador no sistema Portal
 CNIS, utilizando a opção "Consulta/Contribuições/Recolhimentos"."""

    pass


  def consultaRecolhimentos(self, nits, competenciaInicial, competenciaFinal) -> Tabela:
    """Consulta os Recolhimentos existentes para o trabalhador em um determinado
 periido, pelo sistema Portal CNIS, utilizando a opção
 "Consulta/Contribuições/Recolhimentos"."""

    pass


  def consultaRecolhimentosCI(self, chave, nits) -> Tabela:
    """Consulta os recolhimentos de contribuinte individual (CI) para um trabalhador
 no sistema CNIS Cidadão, utilizando a opção Trabalhadores/Vínculos/Períodos
 de CI, Benefíc. e SE" e depois o botão "Valores" para vínculos de CI."""

    pass


  def consultaRecolhimentosDetalhados(self, nits) -> Tabela:
    """Consulta os Recolhimentos existentes para o trabalhador no sistema Portal
 CNIS, utilizando a opção "Consulta/Contribuições/Recolhimentos"."""

    pass


  def consultaRecolhimentosDetalhados(self, nits, competenciaInicial, competenciaFinal) -> Tabela:
    """Consulta os Recolhimentos existentes para o trabalhador em um determinado
 periido, pelo sistema Portal CNIS, utilizando a opção
 "Consulta/Contribuições/Recolhimentos"."""

    pass


  def consultaRecolhimentosGfip(self, chave, nits) -> Tabela:
    """Consulta os recolhimentos declarados em GFIP para um trabalhador no sistema
 CNIS Cidadão, utilizando a opção "Trabalhadores/Consulta Recolhimentos Gfip"."""

    pass


  def consultaRecolhimentosNIT(self, chave, nits, ano) -> Tabela:
    """Consulta os recolhimentos de um trabalhador no sistema CNIS Trabalhadores,
 utilizando a opção "Recolhimentos/Consulta Recolhimentos"."""

    pass


  def consultaRemuneracoesExtratoSIBECPF(self, cpfs) -> Tabela:
    """Consulta o historico de remunerações utilizando a opção 'Consulta -> Extrato
 para SIBE' do portal CNIS."""

    pass


  def consultaRemuneracoesExtratoSIBENIT(self, nits) -> Tabela:
    """Consulta o historico de remunerações utilizando a opção 'Consulta -> Extrato
 para SIBE' do portal CNIS."""

    pass


  def consultaTrabalhadoresPorCPF(self, chave, cpfs) -> Tabela:
    """Consulta os NITs vinculados a CPFs no sistema CNIS Trabalhadores, utilizando
 a opção "Trabalhadores/Consulta por CPF""""

    pass


  def consultaTrabalhadoresPorNome(self, chave, parametros, colunaNome, colunaDataNascimento, colunaNomeMae, colunaCTPS, colunaRG, colunaCPF, colunaTituloEleitor) -> Tabela:
    """Consulta os trabalhadores/NITs por nome, data de nascimento, nome da mãe e
 demais critérios no sistema CNIS Trabalhadores, utilizando a opção
 "Trabalhadores/Consulta por Nome ou Consulta por Nome e Data de Nascimento",
 conforme o caso.
 <P>
 Os parâmetros da consulta no CNIS são informados através de uma tabela, que
 pode conter todos ou apenas alguns dos parâmetros. Informe para cada
 parâmetro o título ou o índice da coluna da tabela que contém cada
 informação.<BR>
 Deixe o parâmetro em branco ou informe -1 para indicar que o parâmetro não
 será utilizado na consulta.<BR>
 
 Todos os parâmetros informados serão repassados à consulta ao CNIS. No
 entanto, quando o nome da mãe é informado, os parâmetros CTPS, CPF e Título
 de Eleitor são ignorados pelo CNIS.
 <p>"""

    pass


  def consultaTrabalhadoresPorNome(self, chave, parametros) -> Tabela:
    """Consulta os trabalhadores/NITs por nome, data de nascimento, nome da mãe e
 demais critérios no sistema CNIS Trabalhadores, utilizando a opção
 "Trabalhadores/Consulta por Nome ou Consulta por Nome e Data de Nascimento",
 conforme o caso.
 <P>
 Os parâmetros da consulta no CNIS são informados através de uma tabela, que
 pode conter todos ou apenas alguns dos parâmetros. A ordem das colunas na
 tabela deve ser:
 <P>
 Nome<NR> Data de Nascimento<BR>
 Nome da Mãe<BR>
 CTPS<BR>
 RG<BR>
 CPF<BR>
 Título de Eleitor
 <P>
 
 Todos os parâmetros informados serão repassados à consulta ao CNIS. No
 entanto, quando o nome da mãe é informado, os parâmetros CTPS, CPF e Título
 de Eleitor são ignorados pelo CNIS.
 <p>"""

    pass


  def consultaValoresCIGFIP(self, nits, competenciaInicial, competenciaFinal) -> Tabela:
    """Consulta os Recolhimentos existentes para o trabalhador em num determinado
 periodo, pelo sistema Portal CNIS, utilizando a opção "Consulta/Valores CI
 GFIP/INSS"."""

    pass


  def consultaValoresCIGFIP(self, nits) -> Tabela:
    """Consulta os Recolhimentos existentes para o trabalhador no sistema Portal
 CNIS, utilizando a opção "Consulta/Valores CI GFIP/INSS"."""

    pass


  def consultaVinculos(self, chave, nits) -> Tabela:
    """Consulta os vínculos empregatícios no sistema CNIS Cidadão, utilizando a
 opção "Trabalhadores/Vínculos/Períodos de CI, Benefic. e SE"."""

    pass


  def consultaVinculosNIT(self, chave, nits) -> Tabela:
    """Consulta os vínculos empregatícios no sistema CNIS Trabalhadores, utilizando
 a opção "Vínculos/Remunerações/Consulta Vínculos Empregatícios/Todos os NITs
 cadastrados"."""

    pass


  def consultaVinculosOriginaisCPF(self, cpfs) -> Tabela:
    """Consulta os Vinculos Originais existentes para o trabalhador no sistema
 Portal CNIS, utilizando a opção "Consulta/Vinculos Originais"."""

    pass


  def consultaVinculosOriginaisDetalhadoCPF(self, cpfs) -> Tabela:
    """Consulta os Vinculos Originais existentes para o trabalhador no sistema
 Portal CNIS, utilizando a opção "Consulta/Vinculos Originais". Para cada
 vinculo original consulta o detalhamento do mesmo."""

    pass


  def consultaVinculosOriginaisDetalhadoNIT(self, nits) -> Tabela:
    """Consulta os Vinculos Originais existentes para o trabalhador no sistema
 Portal CNIS, utilizando a opção "Consulta/Vinculos Originais". Para cada
 vinculo original consulta o detalhamento do mesmo."""

    pass


  def consultaVinculosOriginaisDetalhadoParametros(self, nome, nomeMae, tituloEleitor, cnh, dataNascimento, identidade, numeroCTPS) -> Tabela:
    """Consulta os Vinculos Originais existentes para o trabalhador no sistema
 Portal CNIS, utilizando a opção "Consulta/Vinculos Originais". Para cada
 vinculo original consulta o detalhamento do mesmo."""

    pass


  def consultaVinculosOriginaisNIT(self, nits) -> Tabela:
    """Consulta os Vinculos Originais existentes para o trabalhador no sistema
 Portal CNIS, utilizando a opção "Consulta/Vinculos Originais"."""

    pass


  def consultaVinculosOriginaisParametros(self, nome, nomeMae, tituloEleitor, cnh, dataNascimento, identidade, numeroCTPS) -> Tabela:
    """Consulta os Vinculos Originais existentes para o trabalhador no sistema
 Portal CNIS, utilizando a opção "Consulta/Vinculos Originais"."""

    pass


  def setProgress(self, progress) -> None:
    """Método para uso interno da aplicação. Não deve ser utilizado diretamente pelo
 script."""

    pass


  def setProgress(self, progress) -> None:
    """Método para uso interno da aplicação. Não deve ser utilizado diretamente pelo
 script."""

    pass

class CodigoUtils ():

  def getCodigoFormatado(self, objeto, cpf, cnpj8d) -> str:
    pass


  def getCodigoFormatado(self, objeto, cpf) -> str:
    pass


  def getCodigoFormatado(self, objeto, cnpj8d) -> str:
    pass


  def getCodigoFormatado(self, objeto) -> str:
    pass


  def getCodigoFormatado(self, objeto) -> str:
    pass


  def getCodigoFormatado(self, objeto) -> str:
    pass


  def getCodigoFormatado(self, objeto, cpf) -> str:
    pass


  def getCodigoFormatado(self, objeto, cpf) -> str:
    pass


  def getCodigoFormatado(self, objeto, cnpj8d) -> str:
    pass


  def getCodigoFormatado(self, objeto, cpf) -> str:
    pass


  def getCodigoFormatado(self, objeto, cpf, cnpj8d) -> str:
    pass


  def getCodigoFormatado(self, objeto, cpf, cnpj8d) -> str:
    pass


  def getCodigoFormatado(self, objeto) -> set:
    pass


  def getCodigoFormatado(self, objeto) -> str:
    pass


  def getCodigoFormatado(self, objeto) -> str:
    pass


  def getCodigoFormatado(self, objeto, cpf, cnpj8d) -> str:
    pass


  def getCodigoFromContribuintesTexto(self, contribuintes, cpf, cnpj8d) -> str:
    """Converte uma lista de objetos do tipo Number, ou Estabelecimento, ou Contabilidade, ou FolhaPagamento, ou NotasFiscais (emissores) em um array de String, cada qual referente a um CNPJ (ou CEI, dependendo do caso)."""

    pass


  def getCodigoFromContribuintesTexto(self, contribuintes) -> str:
    """Converte uma lista de objetos do tipo Number, ou Estabelecimento, ou Contabilidade, ou FolhaPagamento, ou NotasFiscais (emissores) em um array de String, cada qual referente a um CNPJ (ou CEI, dependendo do caso)."""

    pass


  def getCodigoIdentificacaoFromContribuintes(self, contribuintes) -> CodigoIdentificacao:
    """Converte uma lista de objetos do tipo Number, ou Estabelecimento, ou Contabilidade, ou FolhaPagamento, ou NotasFiscais (emissores) em um array de CodigoIdentificacao, cada qual referente a um CNPJ (ou CEI, dependendo do caso)."""

    pass

class ComparaArquivosZIPResultado ():
  """Classe que apresenta o "resultado" de uma execução da comparação de conteúdos de
 arquivos ZIP.<BR>
 
 A classe responsável por executar a comparação chama-se
 {@link Comparador Comparador}.<BR>"""

  def getNomeArquivoZIP1(self) -> str:
    """Retorna o nome do primeiro arquivo ZIP considerado na comparação."""

    pass


  def getNomeArquivoZIP2(self) -> str:
    """Retorna o nome do segundo arquivo ZIP considerado na comparação."""

    pass


  def getNomesArquivosAlterados(self) -> list:
    """Retorna os nomes de arquivos que existem em ambos arquivos ZIP e que apresentaram alguma diferença."""

    pass


  def getNomesArquivosExcluidos(self) -> list:
    """Retorna os nomes de arquivos dentro do primeiro arquivo ZIP que não foram encontrados no segundo arquivo ZIP. Note que
 diferenças em termos de 'subpastas' dentro do arquivo ZIP são também consideradas."""

    pass


  def getNomesArquivosIncluidos(self) -> list:
    """Retorna os nomes de arquivos dentro do segundo arquivo ZIP que não foram encontrados no primeiro arquivo ZIP. Note que
 diferenças em termos de 'subpastas' dentro do arquivo ZIP são também consideradas."""

    pass


  def getQuantidadeAlteracoes(self) -> int:
    """Retorna a quantidade de registros que existem em ambos arquivos ZIP, porém com modificações."""

    pass


  def getQuantidadeExclusoes(self) -> int:
    """Retorna a quantidade de registros que existem no primeiro arquivo ZIP mas não existem no segundo arquivo ZIP."""

    pass


  def getQuantidadeInclusoes(self) -> int:
    """Retorna a quantidade de registros que existem no segundo arquivo ZIP mas não existem no primeiro arquivo ZIP."""

    pass


  def getTabelaResultado(self) -> Tabela:
    """Retorna em uma tabela a relação de modificações (inclusões, exclusões e alterações) que foi observada
 nesta comparação.<BR>
 Cada linha da tabela representa um arquivo que foi incluído, excluído ou alterado.<BR>
 A tabela é apresentada com as seguintes colunas:<BR>
 1ª coluna: tipo da modificação (Inclusão, Exclusão ou Alteração)<BR>
 2ª coluna: nome do arquivo (inclui nome do subdiretório dentro do arquivo ZIP)<BR>
 3ª coluna: tamanho antes da compactação em bytes no primeiro arquivo ZIP<BR>
 4ª coluna: tamanho após compactação em bytes no primeiro arquivo ZIP<BR>
 5ª coluna: data/hora no primeiro arquivo ZIP<BR>
 6ª coluna: código CRC no primeiro arquivo ZIP<BR>
 7ª coluna: tamanho antes da compactação em bytes no segundo arquivo ZIP<BR>
 8ª coluna: tamanho após compactação em bytes no segundo arquivo ZIP<BR>
 9ª coluna: data/hora no segundo arquivo ZIP<BR>
 10ª coluna: código CRC no segundo arquivo ZIP<BR>"""

    pass


  def hasDiferencas(self) -> bool:
    """Retorna a indicação de que há diferenças entre os dois arquivos conforme os critérios
 que foram configurados durante a comparação."""

    pass

class ComparaNomesResultado ():
  """Classe que apresenta o "resultado" de uma execução da comparação de nomes de
 duas listas contendo nomes de pessoas.<BR>
 
 A classe responsável por executar a comparação chama-se
 {@link Comparador Comparador}.<BR>"""

  def getQuantidadeCorrespondencias(self, fatorProximidade) -> int:
    """Retorna a quantidade de "correspondências" (isto é, "pares" de nomes que
 foram considerados "correspondentes" pelo sistema)."""

    pass


  def getQuantidadeDivergencias(self, fatorProximidade) -> int:
    """Retorna a quantidade de "divergências" (isto é, "pares" de nomes que
 foram identificados pelo sistema com alguma divergência, não incluindo as
 "omissões")."""

    pass


  def getQuantidadeOmissoes1(self) -> int:
    """Retorna a quantidade de "omissões" da 1ª relação de nomes (isto é, nomes
 que estão presentes na primeira relação e que não foram correspondidos na
 segunda relação).<BR>
 OBS: um registro cujo "par" é localizado na outra lista, mas com alguma
 "divergência", não é considerado como "omissão", mas sim como
 "divergência"."""

    pass


  def getQuantidadeOmissoes2(self) -> int:
    """Retorna a quantidade de "omissões" da 2ª relação de nomes (isto é, nomes
 que estão presentes na segunda relação e que não foram correspondidos na
 primeira relação).<BR>
 OBS: um registro cujo "par" é localizado na outra lista, mas com alguma
 "divergência", não é considerado como "omissão", mas sim como
 "divergência"."""

    pass


  def getTabelaCorrespondencias(self, fatorProximidade) -> Tabela:
    """Retorna o resultado da comparação na forma de uma tabela, onde cada linha
 corresponde a um par de nomes que foram considerados correspondentes com
 um determinado nível de proximidade.<BR>
 A tabela é ordenada pelos fatores de proximidade (em caso de empate,
 ordena pelos nomes apresentados).<BR>
 OBS: as omissões nunca são apresentadas por este método, mesmo que o
 parâmetro fatorProximidade seja 0.<BR>"""

    pass


  def getTabelaDivergencias(self, fatorProximidade) -> Tabela:
    """Retorna o resultado da comparação na forma de uma tabela, onde cada linha
 corresponde a um par de nomes que foram considerados divergentes abaixo
 de um determinado nível de proximidade.<BR>
 A tabela é ordenada pelos fatores de proximidade (em caso de empate,
 ordena pelos nomes apresentados).<BR>
 OBS: as omissões nunca são apresentadas por este método.<BR>"""

    pass


  def getTabelaOmissoes(self) -> Tabela:
    """Retorna o resultado da comparação na forma de uma tabela, onde cada linha
 corresponde apenas aos registros que existem em uma relação mas não
 existem em outra (ex: existem na relação 1 mas não existem na relação 2).<BR>
 OBS: caso o sistema localize em ambas as relações um "par", ainda que
 bastante divergente, esses registros não são apresentados por esta
 função."""

    pass


  def getTabelaResultado(self) -> Tabela:
    """Retorna o resultado da comparação na forma de uma tabela, onde cada linha
 corresponde a um par de nomes ou a um nome que ficou sem "par".<BR>
 A tabela é ordenada pelos fatores de proximidade (em caso de empate,
 ordena pelos nomes apresentados)."""

    pass

class ComparaTextosResultado ():
  """Classe que apresenta o "resultado" de uma execução da comparação de dois textos.<BR>
 
 A classe responsável por executar a comparação chama-se
 {@link Comparador Comparador}.<BR>"""

  def getQuantidadeAlteracoes(self) -> int:
    """Retorna a quantidade de linhas que existem em ambos textos, porém com modificações."""

    pass


  def getQuantidadeExclusoes(self) -> int:
    """Retorna a quantidade de linhas que foram excluídas no segundo texto."""

    pass


  def getQuantidadeInclusoes(self) -> int:
    """Retorna a quantidade de linhas que foram adicionados no segundo texto."""

    pass


  def getTabelaResultado(self, incluiLinhasInalteradas) -> Tabela:
    """Retorna em uma tabela a relação de modificações (inclusões, exclusões e alterações) que foi observada
 nesta comparação.<BR>
 Cada linha da tabela representa uma linha de texto que foi incluída, excluída ou alterada, podendo incluir ou não as linhas 
 do texto original que não sofreram qualquer tipo de alteração.<BR>
 A tabela é apresentada com as seguintes colunas:<BR>
 1ª coluna: tipo da modificação (Inclusão, Exclusão, Alteração ou Sem Alteração).<BR>
 2ª coluna: número da linha no primeiro texto<BR>
 3ª coluna: linha conforme apresentado no primeiro texto<BR>
 4ª coluna: linha conforme apresentado no segundo texto<BR>
 5ª coluna: número da linha no segundo texto<BR>
 6ª coluna: código sequencial numérico que indica a ordem com que as linhas desta tabela devem ser lidas. Trata-se da concatenação do número
 da linha no primeiro texto com o número da linha no segundo texto."""

    pass


  def getTextoDiferencial(self, linhasRedores) -> str:
    """Retorna na forma de um texto 'diferencial' o resultado da comparação dos dois textos.<BR>
 Este é um texto especial, cuja sintaxe é comum a outros aplicativos que apuram 'diferenças'
 entre textos (são chamados de 'patch').<BR>
 Nem todas as linhas do texto original são apresentadas neste texto.<BR>
 O objetivo deste texto 'patch' é apresentar as mudanças (inclusões, exclusões e modificações),
 incluindo também algumas linhas adicionais não modificadas para 'contextualizar' os locais que
 sofreram mudanças.<BR>
 As inclusões são destacadas com o caractere '+' no início das linhas correspondentes.<BR>
 As exclusões são destacadas com o caractere '-' no início das linhas correspondentes.<BR>
 As alterações são representadas na forma de 'exclusões' seguidas de 'inclusões' (exclui a linha original
 que foi alterada e inclui a nova linha).<BR> 
 Cada 'trecho' de linhas de texto modificado é precedido por números que indicam suas posições correspondentes nos arquivos.<BR>
 Exemplo:<BR>
 <PRE>"""

    pass


  def hasDiferencas(self) -> bool:
    """Retorna a indicação de que há diferenças entre os dois textos conforme os critérios
 que foram configurados durante a comparação."""

    pass

class Comparador ():
  """Classe utilizada para realizar comparações entre duas listas ou duas tabelas
 com relação a alguma característica comum (tal como um nome ou uma
 descrição), ou dois textos entre si, ou dois arquivos entre si, etc.<BR>
 <BR>
 Atualmente esta classe disponibiliza métodos apenas os seguintes métodos:<BR>
 <BR>
 COMPARAÇÃO DE NOMES DE PESSOAS OU EMPRESAS<BR>
 ===========================================<BR>
 Um método para comparar nomes de pessoas, onde a comparação de textos é feita tanto de forma "exata" como também de forma
 "inexata". Isto é, podem ser localizadas correspondências de nomes existentes
 nas duas listas mesmo que existam diferenças na grafia.<BR>
 O método utilizado para realizar esta comparação emprega técnicas de análise
 probabilística com base na teoria bayesiana. Tendo em vista que esta técnica
 utiliza muito processamento para realizar essas análises, seu tempo de
 execução pode ser acentuado caso as listas que estão sendo comparadas sejam
 muito numerosas.<BR>
 <BR>
 COMPARAÇÃO DE OUTROS TIPOS DE NOMES OU TEXTOS<BR>
 ===========================================<BR>
 Além dos métodos implementados para comparação de nomes de pessoas ou empresas, 
 você pode também formar sua própria 'base de conhecimento' apresentando uma relação
 de nomes ou textos para um determinado contexto onde você pretende depois utilizar
 os métodos de comparação. Veja mais informações nos comentários dos métodos 
 {@link #preparaBaseNomesDeRelacoes(String, String[], String[], String[]) preparaBaseNomesDeRelacoes},
 entre outras alternativas.<BR>
 <BR>
 COMPARAÇÃO DE ARQUIVOS ZIP<BR>
 ===========================================<BR>
 Um método para comparar o conteúdo de dois arquivos ZIP entre si. Por exemplo,
 pode-se descobrir quantos arquivos foram 'incluídos', 'excluídos' ou 'modificados'
 ao comparar dois arquivos ZIP.<BR>
 <BR>
 COMPARAÇÃO DE TEXTOS<BR>
 ===========================================<BR>
 Um método para comparar dois textos entre si. Por exemplo, pode-se descobrir
 quais linhas foram incluídas, quais linhas foram excluídas e quais linhas foram
 modificadas.<BR>
 <BR>
 <BR>
 Em linguagem de script este objeto está disponível na variável de nome
 "comparar".<BR>"""

  def comparaArquivosTextos(self, nomeArquivo1, nomeArquivo2) -> ComparaTextosResultado:
    """Compara dois textos entre si, comparando seus conteúdos para avaliar se há alterações.<BR>
 Os parâmetros indicam nomes de arquivos textos.<BR>
 A comparação é feita linha a linha. Pode-se detectar se há inclusão, exclusão ou alteração de linhas existentes.<BR>
 O primeiro texto é considerado 'texto original'. O segundo texto é o que se pretende comparar com o texto original.<BR>
 Considera-se como quebra de linha o caractere convencional de quebra de linhas (código ASC 10), podendo
 estar acompanhado ou não do caractere de código ASC 13."""

    pass


  def comparaArquivosZIP(self, nomeArquivoZIP1, nomeArquivoZIP2, ignoraHoraCompactacao, ignoraCRC) -> ComparaArquivosZIPResultado:
    """Compara dois arquivos ZIP, comparando seus conteúdos para avaliar se há alterações.<BR>
 Note que não se trata de uma simples comparação binária, pois é possível que algumas informações
 que não são de interesse estejam diferentes. Por exemplo, pode haver divergência quanto à data e
 hora de criação do arquivo ZIP, porém com o mesmo conteúdo. Nesta hipótese, o método permite que tais
 divergências sejam ignoradas.<BR>
 Este método não compara conteúdos de arquivos. Se for constado que um arquivo existe em ambos arquivos ZIP
 com mesmo nome, mesmo tamanho compactado, mesmo tamanho descompactado, então são considerados iguais."""

    pass


  def comparaArquivosZIP(self, nomeArquivoZIP1, nomeArquivoZIP2, ignoraHoraCompactacao, ignoraCRC, ignoraExpressaoRegular) -> ComparaArquivosZIPResultado:
    """Compara dois arquivos ZIP, comparando seus conteúdos para avaliar se há alterações.<BR>
 Note que não se trata de uma simples comparação binária, pois é possível que algumas informações
 que não são de interesse estejam diferentes. Por exemplo, pode haver divergência quanto à data e
 hora de criação do arquivo ZIP, porém com o mesmo conteúdo. Nesta hipótese, o método permite que tais
 divergências sejam ignoradas.<BR>
 Este método não compara conteúdos de arquivos. Se for constado que um arquivo existe em ambos arquivos ZIP
 com mesmo nome, mesmo tamanho compactado, mesmo tamanho descompactado, então são considerados iguais."""

    pass


  def comparaNomes(self, lista1, lista2, baseNomesTreinada) -> ComparaNomesResultado:
    """Compara duas listas de nomes ou textos entre si, utilizando para isso uma base de
 conhecimento que pode ter sido criado por você em outra etapa (isto é, aprendendo
 com outros arquivos de nomes).<BR>
 Veja o método {@link #preparaBaseNomesDeRelacoes(String, String[], String[], String[]) preparaBaseNomesDeRelacoes}
 para mais informações sobre como criar uma base de conhecimento.<BR>"""

    pass


  def comparaNomesEmpresas(self, tabela1, colunaNome1, colunaCNPJ1, tabela2, colunaNome2, colunaCNPJ2) -> ComparaNomesResultado:
    """Compara duas tabelas contendo nomes de empresas entre si de modo a
 procurar pelas correspondências entre nomes.<BR>
 As duas tabelas não precisam ter o mesmo tamanho (isto é, admite-se que
 uma tabela contenha nomes que não estão na outra tabela, e vice-versa).<BR>
 Não é feita a correspondência de duas ou mais linhas de uma tabela para
 uma mesma linha de outra tabela (isto é, a correspondência, caso exista,
 é sempre na relação de um para um).<BR>
 Esta alternativa de método trabalha com "tabelas" no lugar de "listas", o
 que significa que é necessário também indicar os números das colunas
 correspondentes em cada tabela referente aos nomes das empresas (pois uma
 tabela pode conter outras colunas com outras informações além dos nomes).<BR>
 Além disso, é possível também indicar colunas que apresentam números CNPJ
 de 14 dígitos. Essas informações, caso presentes, são também utilizadas pelo
 algoritmo de comparação, ainda que alguns números estejam ausentes ou até
 mesmo divergentes.<BR>
 OBS: o "fator de proximidade", que indica o quão "próximo" se deseja
 encontrar os pares de nomes, é um parâmetro que é indicado apenas após a
 execução da comparação de nomes (como se fosse um "filtro" aplicado sobre
 o "resultado" da comparação).<BR>"""

    pass


  def comparaNomesEmpresas(self, lista1, lista2) -> ComparaNomesResultado:
    """Compara duas listas de nomes de empresas entre si de modo a procurar pelas
 correspondências entre nomes.<BR>
 As duas listas não precisam ter o mesmo tamanho (isto é, admite-se que
 uma lista contenha nomes que não estão na outra lista, e vice-versa).<BR>
 Não é feita a correspondência de dois ou mais elementos de uma lista para
 um mesmo elemento de outra lista (isto é, a correspondência, caso exista,
 é sempre na relação de um para um).<BR>
 OBS: o "fator de proximidade", que indica o quão "próximo" se deseja
 encontrar os pares de nomes, é um parâmetro que é indicado apenas após a
 execução da comparação de nomes (como se fosse um "filtro" aplicado sobre
 o "resultado" da comparação).<BR>"""

    pass


  def comparaNomesPessoas(self, tabela1, colunaNome1, colunaNIT1, colunaCPF1, tabela2, colunaNome2, colunaNIT2, colunaCPF2) -> ComparaNomesResultado:
    """Compara duas tabelas contendo nomes de pessoas entre si de modo a
 procurar pelas correspondências entre nomes.<BR>
 As duas tabelas não precisam ter o mesmo tamanho (isto é, admite-se que
 uma tabela contenha nomes que não estão na outra tabela, e vice-versa).<BR>
 Não é feita a correspondência de duas ou mais linhas de uma tabela para
 uma mesma linha de outra tabela (isto é, a correspondência, caso exista,
 é sempre na relação de um para um).<BR>
 Esta alternativa de método trabalha com "tabelas" no lugar de "listas", o
 que significa que é necessário também indicar os números das colunas
 correspondentes em cada tabela referente aos nomes das pessoas (pois uma
 tabela pode conter outras colunas com outras informações além dos nomes).<BR>
 Além disso, é possível também indicar colunas que apresentam números CPF
 e NIT. Essas informações, caso presentes, são também utilizadas pelo
 algoritmo de comparação, ainda que alguns números estejam ausentes ou até
 mesmo divergentes.<BR>
 OBS: o "fator de proximidade", que indica o quão "próximo" se deseja
 encontrar os pares de nomes, é um parâmetro que é indicado apenas após a
 execução da comparação de nomes (como se fosse um "filtro" aplicado sobre
 o "resultado" da comparação).<BR>"""

    pass


  def comparaNomesPessoas(self, lista1, lista2) -> ComparaNomesResultado:
    """Compara duas listas de nomes de pessoas entre si de modo a procurar pelas
 correspondências entre nomes.<BR>
 As duas listas não precisam ter o mesmo tamanho (isto é, admite-se que
 uma lista contenha nomes que não estão na outra lista, e vice-versa).<BR>
 Não é feita a correspondência de dois ou mais elementos de uma lista para
 um mesmo elemento de outra lista (isto é, a correspondência, caso exista,
 é sempre na relação de um para um).<BR>
 OBS: o "fator de proximidade", que indica o quão "próximo" se deseja
 encontrar os pares de nomes, é um parâmetro que é indicado apenas após a
 execução da comparação de nomes (como se fosse um "filtro" aplicado sobre
 o "resultado" da comparação).<BR>"""

    pass


  def comparaNomesPessoas(self, tabela1, colunaNome1, tabela2, colunaNome2) -> ComparaNomesResultado:
    """Compara duas tabelas contendo nomes de pessoas entre si de modo a
 procurar pelas correspondências entre nomes.<BR>
 As duas tabelas não precisam ter o mesmo tamanho (isto é, admite-se que
 uma tabela contenha nomes que não estão na outra tabela, e vice-versa).<BR>
 Não é feita a correspondência de duas ou mais linhas de uma tabela para
 uma mesma linha de outra tabela (isto é, a correspondência, caso exista,
 é sempre na relação de um para um).<BR>
 Esta alternativa de método trabalha com "tabelas" no lugar de "listas", o
 que significa que é necessário também indicar os números das colunas
 correspondentes em cada tabela referente aos nomes das pessoas (pois uma
 tabela pode conter outras colunas com outras informações além dos nomes).<BR>
 OBS: o "fator de proximidade", que indica o quão "próximo" se deseja
 encontrar os pares de nomes, é um parâmetro que é indicado apenas após a
 execução da comparação de nomes (como se fosse um "filtro" aplicado sobre
 o "resultado" da comparação).<BR>"""

    pass


  def comparaTextos(self, texto1, texto2) -> ComparaTextosResultado:
    """Compara dois textos entre si, comparando seus conteúdos para avaliar se há alterações.<BR>
 A comparação é feita linha a linha. Pode-se detectar se há inclusão, exclusão ou alteração de linhas existentes.<BR>
 O primeiro texto é considerado 'texto original'. O segundo texto é o que se pretende comparar com o texto original.<BR>
 Considera-se como quebra de linha o caractere convencional de quebra de linhas (código ASC 10), podendo
 estar acompanhado ou não do caractere de código ASC 13."""

    pass


  def getBasesNomes(self) -> Lista:
    """Retorna a relação de bases de conhecimento já criadas na aplicação.<BR>
 Você pode utilizar uma dessas bases ao utilizar a função {@link #comparaNomes(List, List, String) comparaNomes} para
 comparação de palavras."""

    pass


  def getDistanciaLevenshtein(self, texto1, texto2, ignoraOrdemPalavras) -> int:
    """Compara dois textos entre si retornando uma 'distância' que separa as palavras conforme o critério 'LEVENSHTEIN'. Quanto
 menor o número retornado, mas próximas entre si são consideradas as palavras. Quanto maior
 o número retornado, mas distantes entre si são consideradas as palavras.<BR>
 <BR>
 <B>LEVENSHTEIN</B><BR>
 Critério simples, muito utilizado, para fazer comparação de textos. <BR>
 Antes de aplicar o critério de '<B>LEVENSHTEIN</B>', faz um tratamento prévio nos textos de modo
 a ignorar diferenças de letras maiúsculas/minúsculas e para ignorar espaços em branco antes e depois de cada texto.<BR>
 Para mais informações, consulte http://pt.wikipedia.org/wiki/Dist%C3%A2ncia_Levenshtein.<BR>
 <BR>
 <B>LEVENSHTEIN</B> com <B>ignoraOrdemPalavras = VERDADEIRO</B><BR>
 Utiliza o critério de distância '<B>LEVENSHTEIN</B>', porém com um pequeno ajuste para que sejam ignoradas
 as posições das palavras no texto.<BR>
 Cada texto é inicialmente quebrado em palavras individuais, utilizando o espaço em branco como critério
 de separação de palavras. Depois, é feito o produto cartesiano entre palavras do primeiro
 texto com palavras do segundo texto e sobre cada 'par' deste produto cartesiano é calculada
 a distância de '<B>LEVENSHTEIN</B>' somente sobre as palavras do par. Feito isso, considera-se
 a soma das menores distâncias.<BR>
 Ex: Se o texto1 é constituído pelas palavras W1 e W2 e o texto2 é constituído pelas palavras W3 e W4,
 calcula-se as distâncias <B>LEVENSHTEIN</B> entre os pares d13 = (W1,W3), d14 = (W1,W4), d23 = (W2,W3), d24 = (W2,W4).<BR>
 Depois, toma-se o menor valor min(d13,d14) e soma com o menor valor min(d23,d24)."""

    pass


  def getSimilaridadeFuzzy(self, texto1, texto2) -> int:
    """Compara dois textos entre si retornando um grau de 'similaridade' que separa as palavras conforme o critério 'FUZZY'. Quanto
 maior o número retornado, mas próximas entre si são consideradas as palavras. Quanto menor
 o número retornado, mas distantes entre si são consideradas as palavras.<BR>"""

    pass


  def getSimilaridadeJaroWinkler(self, texto1, texto2) -> float:
    """Compara dois textos entre si retornando um grau de 'similaridade' que separa as palavras conforme o critério 'JARO-WINKLER'. Quanto
 maior o número retornado, mas próximas entre si são consideradas as palavras. Quanto menor
 o número retornado, mas distantes entre si são consideradas as palavras.<BR>"""

    pass


  def hasBaseNomes(self, nomeBase) -> bool:
    """Verifica se existe uma base de conhecimento previamente criada."""

    pass


  def preparaBaseNomesDeArquivos(self, nomeBase, nomeArquivoPalavras, nomeArquivoPalavrasAlteradas, palavrasIgnoradas) -> None:
    """Cria uma nova base utilizada para comparar nomes ou textos a partir de dois arquivos contendo nomes.<BR>
 Para formar uma nova base são necessárias duas relações de nomes. Uma delas contém nomes tipicamente
 utilizados no contexto onde você desejará fazer pesquisas. A outra contém os mesmos nomes, mas com ligeiras
 modificações, tentando simular possíveis divergências que o sistema deverá ser capaz de aprender como sendo
 comuns (por exemplo, a repetição ou a omissão de alguma letra).<BR>
 Facultativamente você pode também fornecer uma terceira relação de palavras correspondentes às 'palavras ignoradas'. Isto é,
 palavras que devem ser desconsideradas durante o uso da comparação de nomes (por exemplo, palavras como 'de', 'do', 'das').<BR>"""

    pass


  def preparaBaseNomesDeRelacoes(self, nomeBase, nomes, nomesAlterados, palavrasIgnoradas) -> None:
    """Cria uma nova base utilizada para comparar nomes ou textos a partir de duas relações de nomes.<BR>
 Para formar uma nova base são necessárias duas relações de nomes. Uma delas contém nomes tipicamente
 utilizados no contexto onde você desejará fazer pesquisas. A outra contém os mesmos nomes, mas com ligeiras
 modificações, tentando simular possíveis divergências que o sistema deverá ser capaz de aprender como sendo
 comuns (por exemplo, a repetição ou a omissão de alguma letra).<BR>
 Facultativamente você pode também fornecer uma terceira relação de palavras correspondentes às 'palavras ignoradas'. Isto é,
 palavras que devem ser desconsideradas durante o uso da comparação de nomes (por exemplo, palavras como 'de', 'do', 'das').<BR>"""

    pass


  def preparaBaseNomesDeTabela(self, nomeBase, tabelaNomes, colunaNomes, colunaNomesAlterados, palavrasIgnoradas) -> None:
    """Cria uma nova base utilizada para comparar nomes ou textos a partir de uma tabela contendo duas colunas contendo nomes.<BR>
 Para formar uma nova base são necessárias duas relações de nomes. Uma delas contém nomes tipicamente
 utilizados no contexto onde você desejará fazer pesquisas. A outra contém os mesmos nomes, mas com ligeiras
 modificações, tentando simular possíveis divergências que o sistema deverá ser capaz de aprender como sendo
 comuns (por exemplo, a repetição ou a omissão de alguma letra).<BR>
 Facultativamente você pode também fornecer uma terceira relação de palavras correspondentes às 'palavras ignoradas'. Isto é,
 palavras que devem ser desconsideradas durante o uso da comparação de nomes (por exemplo, palavras como 'de', 'do', 'das').<BR>"""

    pass


  def removeBaseNomes(self, nomeBase) -> None:
    """Remove uma base de conhecimento caso tenha sido previamente criada."""

    pass

class ConsultaSIF ():
  """Classe que permite executar relatórios nos sistemas Informar e no SIF.
 <p>
 Para utilizar essa classe, utilize a variável global "sif" disponível para os
 scripts.
 <p>
 Você deve informar os campos/variáveis que serão utilizados nas consultas,
 indicando o nome da variável exatamente como consta no Informar/SIF,
 preferencialmente indicando também o formato a ser utilizado para o dado.
 <p>
 O resultado da execução de um relatório é uma {@link Tabela}, que pode ser
 exibida, exportada ou salva como tabela de usuário utilizando-se os seus
 respectivos métodos."""

  def addCampo(self, nomeCampo) -> None:
    """Inclui um campo/variável a ser utilizado nas consultas.<br>
 Se não indicar o formato, ele será definido pelo ContÁgil.<br>
 Você pode indicar o formato colocando o seu nome entre parêntesis logo
 após o nome da variável, como em "Mas Emp DIRF 0561 (Valor)" ou utilizar
 a alternativa que permite a indicação do formato em parâmetro próprio."""

    pass


  def addCampo(self, nomeCampo, formato) -> None:
    """Inclui um campo/variável a ser utilizado nas consultas."""

    pass


  def addCampos(self, campos) -> None:
    """Inclui uma lista de campos/variávels a serem utilizados nas consultas.<br>
 Se não indicar o formato, ele será definido pelo ContÁgil.<br>
 Você pode indicar o formato colocando o seu nome entre parêntesis logo
 após o nome da variável, como em "Mas Emp DIRF 0561 (Valor)"."""

    pass


  def addFiltroCategorico(self, nomeCampo, operador, codigos) -> None:
    """Inclui um filtro do tipo categórico a ser utilizado na execução do
 relatório.<BR>
 É necessário informar uma lista de códigos e o nome da variável.<BR>
 Os códigos disponíveis para uma variável categórica podem ser obtidos
 criando um filtro equivalente utilizando a interface web do Informar/SIF,
 selecionando a opção "código e descrição". Informe aqui apenas os
 códigos.<BR>
 As variáveis que constam em "Seleções Aceleradoras" no SIF/Informar
 também são do tipo filtro categórico e devem ser informados os
 respectivos códigos, nunca as descrições."""

    pass


  def addFiltroData(self, nomeCampo, operador1, data1, operador2, data2) -> None:
    """Inclui um filtro do tipo data a ser utilizado na execução do relatório.<BR>
 Alternativa que permite definir duas comparações para a mesma variável."""

    pass


  def addFiltroData(self, nomeCampo, operador, data) -> None:
    """Inclui um filtro do tipo data a ser utilizado na execução do relatório."""

    pass


  def addFiltroData(self, nomeCampo, operador1, data1, operador2, data2) -> None:
    """Inclui um filtro do tipo data a ser utilizado na execução do relatório.<BR>
 Alternativa que permite definir duas comparações para a mesma variável."""

    pass


  def addFiltroData(self, nomeCampo, operador, data) -> None:
    """Inclui um filtro do tipo data a ser utilizado na execução do relatório."""

    pass


  def addFiltroTexto(self, nomeCampo, operador, vetorValores) -> None:
    """Inclui um filtro do tipo texto a ser utilizado na execução do relatório."""

    pass


  def addFiltroValores(self, nomeCampo, operador, valor) -> None:
    """Inclui um filtro do tipo valores a ser utilizado na execução do
 relatório."""

    pass


  def addFiltroValores(self, nomeCampo, operador1, valor1, operador2, valor2) -> None:
    """Inclui um filtro do tipo valores a ser utilizado na execução do
 relatório.<BR>
 Alternativa que permite definir duas comparações para a mesma variável."""

    pass


  def consultaArrecGpsGeral(self, ano, mes) -> Tabela:
    """Executa consulta no Informar utilizando a opção Arrecadação/GPS Geral.
 Informe os campos a serem utilizados na consulta, <b>exatamente</b> como
 constam na página de escolha das variáveis.
 <p>
 O formato pode ser informado junto com o nome da variável, entre
 parêntesis, exatamente como consta na lista de "Variáveis escolhidas" no
 SIF/Informar.
 <p>
 Se não for informado um código de formato, então será utilizado o formato
 padrão para o campo.
 <p>
 Inclua os filtros necessários antes de chamar a consulta.  Essa alternativa
 incluir filtros apenas para o ano e mês caixa.  Para incluir filtro por CNPJ, escolha a variável
 apropriada e inclua um filtro do tipo texto.
 <p>"""

    pass


  def consultaArrecGpsGeral(self, listaCnpjTexto, ano, mes) -> Tabela:
    """Executa consulta no Informar utilizando a opção Arrecadação/GPS Geral.
 Informe os campos a serem utilizados na consulta, <b>exatamente</b> como
 constam na página de escolha das variáveis.
 <p>
 O formato pode ser informado junto com o nome da variável, entre
 parêntesis, exatamente como consta na lista de "Variáveis escolhidas" no
 SIF/Informar.
 <p>
 Se não for informado um código de formato, então será utilizado o formato
 padrão para o campo.
 <p>
 Exemplo:
 <p>
 <code>
 cnpjs = new java.util.ArrayList()<BR>
 cnpjs.add("00000042")<BR>
 sif.addCampo("CNPJ/CEI (Código)");<BR>
 sif.addCampo("Cód-Pgto (Código)");<BR>
 sif.addCampo("Competência (Código)");<BR>
 sif.addCampo("Dt-Pgto (DD/MM/AAAA)");<BR>
 sif.addCampo("Vl-rubr11-Total (Valor)");<BR>
 tabela = sif.consultaArrecGpsGeral(cnpjs,2011,1)<BR>
 janelas.mostraTabela(tabela)<BR>
 </code>"""

    pass


  def consultaCadastroInformar(self, listaCnpjTexto) -> Tabela:
    """Executa consulta no Informar utilizando a opção de Cadastro/Registros.
 Informe os campos a serem utilizados na consulta, <b>exatamente</b> como
 constam na página de escolha das variáveis.
 <p>
 O formato pode ser informado junto com o nome da variável, entre
 parêntesis, exatamente como consta na lista de "Variáveis escolhidas" no
 Informar.
 <p>
 Se não for informado um código de formato, então será utilizado o formato
 padrão para o campo.
 <p>"""

    pass


  def consultaCreditosAdministrativosAtivos(self) -> Tabela:
    """Executa consulta no Informar utilizando a opção de
 Crédito/Administrativos/Créditos Ativos/Registros. Informe os campos a
 serem utilizados na consulta, <b>exatamente</b> como constam na página
 de escolha das variáveis.
 <p>
 O formato pode ser informado junto com o nome da variável, entre
 parêntesis, exatamente como consta na lista de "Variáveis escolhidas" no
 Informar.
 <p>
 Se não for informado um código de formato, então será utilizado o formato
 padrão para o campo.
 <p>
 Inclua os filtros necessários antes de chamar a consulta.  Essa alternativa
 não inclui nenhum filtro.  Para incluir filtro por CNPJ, escolha a variável
 apropriada e inclua um filtro do tipo texto.
 <p>"""

    pass


  def consultaCreditosAdministrativosAtivos(self, listaCnpjTexto) -> Tabela:
    """Executa consulta no Informar utilizando a opção de
 Crédito/Administrativos/Créditos Ativos/Registros. Informe os campos a
 serem utilizados na consulta, <b>exatamente</b> como constam na página
 de escolha das variáveis.
 <p>
 O formato pode ser informado junto com o nome da variável, entre
 parêntesis, exatamente como consta na lista de "Variáveis escolhidas" no
 Informar.
 <p>
 Se não for informado um código de formato, então será utilizado o formato
 padrão para o campo.
 <p>"""

    pass


  def consultaMonitoramentoQuedaArrec(self, ano, mes) -> Tabela:
    """Executa consulta no Informar utilizando a opção de Monitoramento de Grandes Contribuintes.
 Informe os campos a serem utilizados na consulta, <b>exatamente</b> como
 constam na página de escolha das variáveis.
 <p>
 O formato pode ser informado junto com o nome da variável, entre
 parêntesis, exatamente como consta na lista de "Variáveis escolhidas" no
 Informar.
 <p>
 Se não for informado um código de formato, então será utilizado o formato
 padrão para o campo.
 <p>
 Apenas o filtro para o Mês Caixa é definido automaticamente.  Os demais filtros devem
 ser incluídos pelo script utilizando os respectivos métodos."""

    pass


  def consultaParcelamentosAtivos(self, listaCnpjTexto) -> Tabela:
    """Executa consulta no Informar utilizando a opção de
 Crédito/Administrativos/Parcelamentos Ativos/Registros. Informe os campos a
 serem utilizados na consulta, <b>exatamente</b> como constam na página
 de escolha das variáveis.
 <p>
 O formato pode ser informado junto com o nome da variável, entre
 parêntesis, exatamente como consta na lista de "Variáveis escolhidas" no
 Informar.
 <p>
 Se não for informado um código de formato, então será utilizado o formato
 padrão para o campo.
 <p>"""

    pass


  def consultaParcelamentosAtivos(self) -> Tabela:
    """Executa consulta no Informar utilizando a opção de
 Crédito/Administrativos/Parcelamentos Ativos/Registros. Informe os campos a
 serem utilizados na consulta, <b>exatamente</b> como constam na página
 de escolha das variáveis.
 <p>
 O formato pode ser informado junto com o nome da variável, entre
 parêntesis, exatamente como consta na lista de "Variáveis escolhidas" no
 Informar.
 <p>
 Se não for informado um código de formato, então será utilizado o formato
 padrão para o campo.
 <p>
 Inclua os filtros necessários antes de chamar a consulta.  Essa alternativa
 não inclui nenhum filtro.  Para incluir filtro por CNPJ, escolha a variável
 apropriada e inclua um filtro do tipo texto.
 <p>"""

    pass


  def consultaRelatorioInformar(self, nomeUsuario, nomeRelatorio, ano) -> Tabela:
    """Executa qualquer relatório salvo no Informar, utilizando usuário e nome do relatório
 indicados nos parâmetros para encontrar o relatório.<BR>"""

    pass


  def consultaRelatorioInformar(self, nomeUsuario, nomeRelatorio) -> Tabela:
    """Executa qualquer relatório salvo no Informar, utilizando usuário e nome do relatório
 indicados nos parâmetros para encontrar o relatório.<BR>"""

    pass


  def consultaRelatorioInformar(self, nomeRelatorio) -> Tabela:
    """Executa qualquer relatório público no Informar, utilizando o nome do relatório
 indicado no parâmetro para encontrar o relatório.<BR>"""

    pass


  def consultaRelatorioInformar(self, nomeRelatorio, ano) -> Tabela:
    """Executa qualquer relatório público no Informar, utilizando o nome do relatório
 indicado no parâmetro para encontrar o relatório.<BR>"""

    pass


  def consultaRelatorioSIF(self, nomeRelatorio) -> Tabela:
    """Executa qualquer relatório público no Informar, utilizando o nome do relatório
 indicado no parâmetro para encontrar o relatório.<BR>
 Se for necessário alterar o ano ou mês do relatório via script, inclua um filtro categórico
 para a variável "Ano*" ou "Mês." e indique os valores desejados utilizando o operador "=".<BR>"""

    pass


  def consultaRelatorioSIF(self, nomeUsuario, nomeRelatorio) -> Tabela:
    """Executa qualquer relatório salvo no SIF, utilizando usuário e nome do relatório
 indicados nos parâmetros para encontrar o relatório.<BR>
 Se for necessário alterar o ano ou mês do relatório via script, inclua um filtro categórico
 para a variável "Ano*" ou "Mês." e indique os valores desejados utilizando o operador "=".<BR>"""

    pass


  def consultaSifAnual(self, ano) -> Tabela:
    """Executa consulta no SIF utilizando a opção de Registros Anual. Informe os
 campos a serem utilizados na consulta, <b>exatamente</b> como constam na
 página de escolha das variáveis.
 <p>
 O formato pode ser informado junto com o nome da variável, entre
 parêntesis, exatamente como consta na lista de "Variáveis escolhidas" no
 SIF/Informar.
 <p>
 Se não for informado um código de formato, então será utilizado o formato
 padrão para o campo.
 <p>
 Inclua os filtros necessários antes de chamar a consulta.  Essa alternativa
 somente filtra pelo ano caixa.  Para incluir filtro por CNPJ, escolha a variável
 apropriada e inclua um filtro do tipo texto.
 <p>"""

    pass


  def consultaSifAnual(self, listaCnpjTexto, ano) -> Tabela:
    """Executa consulta no SIF utilizando a opção de Registros Anual. Informe os
 campos a serem utilizados na consulta, <b>exatamente</b> como constam na
 página de escolha das variáveis.
 <p>
 O formato pode ser informado junto com o nome da variável, entre
 parêntesis, exatamente como consta na lista de "Variáveis escolhidas" no
 SIF/Informar.
 <p>
 Se não for informado um código de formato, então será utilizado o formato
 padrão para o campo.
 <p>
 Exemplo:
 <p>
 <code>
 cnpjs = new java.util.ArrayList()<BR>
 cnpjs.add("00000042")<BR>
 sif.addCampo("CNPJ/CEI (Código)";<BR>
 sif.addCampo("Ano* (Código)");<BR>
 sif.addCampo("Vl Apurado Empresa (Valor)")<BR>
 sif.addCampo("Débito (Valor)")<BR>
 tabela = sif.consultaSifAnual(cnpjs,2011)<BR>
 janelas.mostraTabela(tabela)	 <BR>
 </code>"""

    pass


  def consultaSifMensal(self, ano, mes) -> Tabela:
    """Executa consulta no SIF utilizando a opção de Registros Mensal. Informe
 os campos a serem utilizados na consulta, <b>exatamente</b> como constam
 na página de escolha das variáveis.
 <p>
 O formato pode ser informado junto com o nome da variável, entre
 parêntesis, exatamente como consta na lista de "Variáveis escolhidas" no
 SIF/Informar.
 <p>
 Se não for informado um código de formato, então será utilizado o formato
 padrão para o campo.
 <p>
 Inclua os filtros necessários antes de chamar a consulta.  Essa alternativa
 somente filtra pelo ano e mês caixa.  Para incluir filtro por CNPJ, escolha a variável
 apropriada e inclua um filtro do tipo texto.
 <p>"""

    pass


  def consultaSifMensal(self, listaCnpjTexto, ano, mes) -> Tabela:
    """Executa consulta no SIF utilizando a opção de Registros Mensal. Informe
 os campos a serem utilizados na consulta, <b>exatamente</b> como constam
 na página de escolha das variáveis.
 <p>
 O formato pode ser informado junto com o nome da variável, entre
 parêntesis, exatamente como consta na lista de "Variáveis escolhidas" no
 SIF/Informar.
 <p>
 Se não for informado um código de formato, então será utilizado o formato
 padrão para o campo.
 <p>
 Exemplo:
 <p>
 <code><BR>
 cnpjs = new java.util.ArrayList()<BR>
 cnpjs.add("00000042")<BR>
 sif.addCampo("CNPJ/CEI (Código)");<BR>
 sif.addCampo("Ano* (Código)");<BR>
 sif.addCampo("Mês.")<BR>
 sif.addCampo("Vl Apurado Empresa (Valor)")<BR>
 sif.addCampo("Débito (Valor)")<BR>
 tabela = sif.consultaSifMensal(cnpjs,2011,0)<BR>
 janelas.mostraTabela(tabela)	 <BR>
 </code>"""

    pass


  def getMensagemErro(self) -> str:
    """Retorna a mensagem de erro referente à última consulta realizada, caso tenha ocorrido
 algum erro."""

    pass


  def isRelatorioComErro(self) -> bool:
    """Indica se ocorreu erro na execução do último relatório"""

    pass


  def isRelatorioVazio(self) -> bool:
    """Indica se a consulta retornou vazia.
 Normalmente o SIF/Informar retornam a mensagem "Não há nenhum registro associado a esta consulta!"
 para essa situação."""

    pass


  def limpaCampos(self) -> None:
    """Apaga todos os campos informados anteriormente."""

    pass


  def limpaFiltros(self) -> None:
    """Apaga todos os filtros"""

    pass


  def limpaTudo(self) -> None:
    """Limpa os campos e filtros"""

    pass


  def removeFiltro(self, nomeCampo) -> None:
    """Exclui o filtro para um campo específico"""

    pass


  def setCamposOrdenacao(self, campos, consolidar) -> None:
    """Define se o resultado deve ser consolidado ou apenas ordenado e indica os 
 campos a serem utilizados como critério. <BR>
 O Informar/SIF permite no máximo 3 campos como critério de ordenação ou 
 consolidação. <BR>"""

    pass


  def setChave(self, chave) -> None:
    pass

class ConteudoAnexado ():
  """Interface de uso na linguagem de script que indica se um determinado
 objeto representa um conteúdo que foi anexado a um script.<BR>
 <BR>
 OBS: qualquer 'anexo' a um script, além de implementar alguma classe específica
 indicativa de seu conteúdo (ex: {@link ArquivoCSV ArquivoCSV}, {@link ArquivoExcel ArquivoExcel}, entre outros),
 também implementará esta interface.<BR>
 <BR>
 Esta interface em geral será desnecessária no SCRIPT VISUAL, pois em tal contexto a ação 'SALVAR ANEXO'
 já estará incorporada em cada variável representativa de anexo. Porém, no SCRIPT NÃO-VISUAL (ex: JavaScript)
 esta interface pode ser útil."""

  def salvaAnexo(self, nomeArquivo) -> None:
    """Salva o conteúdo deste anexo na forma de um arquivo externo. Se o arquivo já existe, sobrescreve-o.<BR>
 Se já existir um arquivo com este mesmo nome e ele estiver sendo utilizado por outro programa, joga erro."""

    pass

class Conversor ():
  """Classe utilizada pela linguagem de scripting para permitir a conversão de
 alguns valores em outras representações dos mesmos valores.<BR>
 Este objeto está acessível para a linguagem de script através do nome
 "conversor".<BR>
 Para converter um objeto em outro, primeiro executa-se o método "de",
 passando como parâmetro o objeto que deve ser convertido, e daí utiliza-se o
 método "paraXXX", para converter para uma outra coisa.<BR>
 Exemplo de utilização:<BR>
 <CODE> // Obtém uma lista de objetos do tipo Estabelecimento<BR>
 projeto = contagil.getProjetoAtual();<BR>
 estabelecimentos = projeto.getEstabelecimento();<BR>
 <BR> // Converte uma lista de objetos do tipo Estabelecimento em uma lista de
 números CNPJ de 8 dígitos<BR>
 numeros = conversor.de(estabelecimentos).paraListaCNPJBaseTexto();<BR>
 println("Numeros CNPJ de 8 digitos: "+ numeros);<BR>
 <BR> // Converte um número qualquer em texto (neste caso, o número "1123.1" é
 representado da forma "1.123,10").<BR>
 println("Numero: " + conversor.de(1123.1).paraTexto());<BR>
 <BR> // Converte um número formatado CNPJ em um número CNPJ sem formatação
 (de 14 dígitos).<BR>
 println("Numero: " +
 conversor.de("00.000.000/0001-91").paraListaCNPJTexto().get(0));<BR>
 </CODE>"""

  def comCasasDecimais(self, numeroCasasDecimais) -> ObjetoConverter:
    """Define o número de casas decimais para a apresentação da conversão de números.
 Por exemplo, o número em formato texto retornado pela  função {@link Conversor#paraTexto()} 
 vai exibir o número de decimais definido por esta função"""

    pass


  def de(self, lista) -> ObjetoConverter:
    """Cria um mecanismo de conversão partindo de uma lista de objetos (a lista
 será convertida)."""

    pass


  def de(self, numero) -> ObjetoConverter:
    """Cria um mecanismo de conversão partindo de um número qualquer (pode ser
 inteiro ou pode ser com casas decimais).
 Para definir o número de casas decimais a ser usado na apresentação das conversões 
 desse número, chamar a função {@link Conversor#comCasasDecimais(int)}"""

    pass


  def de(self, crit) -> ObjetoConverter:
    """Cria um mecanismo de conversão partindo de um critério qualquer de
 agregação."""

    pass


  def de(self, texto) -> ObjetoConverter:
    """Cria um mecanismo de conversão partindo de um texto qualquer."""

    pass


  def de(self, data) -> ObjetoConverter:
    """Cria um mecanismo de conversão partindo de uma data qualquer."""

    pass


  def de(self, mes) -> ObjetoConverter:
    """Cria um mecanismo de conversão partindo de um mês qualquer."""

    pass


  def paraBooleano(self) -> bool:
    """Converte o objeto original para um indicador do tipo VERDADEIRO/FALSO.<BR>
 São considerados como VERDADEIRO:<BR>
 &nbsp;&nbsp;&nbsp;qualquer valor positivo (maior que zero)<BR>
 &nbsp;&nbsp;&nbsp;qualquer texto que começa com "V" (ex: VERDADEIRO)<BR>
 &nbsp;&nbsp;&nbsp;qualquer texto que começa com "S" (ex: SIM)<BR>
 &nbsp;&nbsp;&nbsp;qualquer texto que começa com "T" (ex: TRUE)<BR>
 São considerados como FALSO:<BR>
 &nbsp;&nbsp;&nbsp;qualquer valor não positivo (menor ou igual a zero)<BR>
 &nbsp;&nbsp;&nbsp;qualquer texto que começa com "F" (ex: FALSO)<BR>
 &nbsp;&nbsp;&nbsp;qualquer texto que começa com "N" (ex: NÃO)<BR>
 &nbsp;&nbsp;&nbsp;nulo ou vazio<BR>
 &nbsp;&nbsp;&nbsp;todas as demais situações<BR>"""

    pass


  def paraCEITexto(self) -> str:
    """Converte para um texto representativo do CEI de 12 dígitos.<BR>
 Isto é, se o número original algo que se relaciona a um CEI (tal como um "{@link Estabelecimento Estabelecimento}"),
 ou um número CEI com formatação (traços e pontos), converte em um número
 CEI de 12 dígitos sem formatação alguma (isto é, apenas os dígitos).<BR>
 OBS: O ContÁgil normalmente testa o DV do número original para confirmar
 que se trata de um número CEI válido antes de fazer a conversão. Se o
 teste do DV não passar, o número não é convertido.<BR>
 OBS2: Em uma tentativa de converter uma lista de valores, retorna o
 primeiro valor da lista convertido (isto é, considerando a ordem
 numérica)."""

    pass


  def paraCNPJBaseTexto(self) -> str:
    """Converte para um texto representativo do CNPJ de 8 dígitos (CNPJ base).<BR>
 Esta função faz a mesma coisa que a função
 {@link Conversor#paraListaCNPJBaseTexto() paraListaCNPJBaseTexto}, com a
 diferença que esta retorna apenas um único valor.<BR>
 OBS: Em uma tentativa de converter uma lista de valores, retorna o
 primeiro valor da lista convertido (isto é, considerando a ordem
 numérica)."""

    pass


  def paraCNPJTexto(self) -> str:
    """Converte para um texto representativo do CNPJ de 14 dígitos.<BR>
 Esta função faz a mesma coisa que a função
 {@link Conversor#paraListaCNPJTexto() paraListaCNPJTexto}, com a
 diferença que esta retorna apenas um único valor.<BR>
 OBS: Em uma tentativa de converter uma lista de valores, retorna o
 primeiro valor da lista convertido (isto é, considerando a ordem
 numérica)."""

    pass


  def paraCPFTexto(self) -> str:
    """Converte para um texto representativo do CPF de 11 dígitos.<BR>
 Esta função faz a mesma coisa que a função
 {@link Conversor#paraListaCPFTexto() paraListaCPFTexto}, com a diferença
 que esta retorna apenas um único valor.<BR>
 OBS: Em uma tentativa de converter uma lista de valores, retorna o
 primeiro valor da lista convertido (isto é, considerando a ordem
 numérica)."""

    pass


  def paraData(self) -> Data:
    """Converte o objeto original para um objeto do tipo {@link Data Data}.
 Neste caso:<BR>
 Um número inteiro é convertido para uma data supondo que o número está no
 padrão DDMMAAAA.<BR>
 Um texto é convertido para data considerando diversos padrões distintos
 (tais como DD/MM/AAAA e DDMMAAAA).<BR>
 Uma data é mantida na forma de uma data.<BR>
 Um mês é convertido para o primeiro dia do mês.<BR>
 Uma lista não é convertida, a menos que tenha exatamente um elemento.<BR>"""

    pass


  def paraDataHora(self) -> DataHora:
    """Converte o objeto original para um objeto do tipo {@link DataHora DataHora}.
 Neste caso:<BR>
 Um número inteiro é convertido para uma data/hora supondo que o número está no
 padrão do Java (milisegundos desde 1/1/1970 00:00:00 GMT).<BR>
 Um texto é convertido para data considerando diversos o padrão DD/MM/AAAA hh:mm:ss.<BR>
 Uma data é mantida na forma de uma data (se não houver informação de hora, considera 00:00:00 daquela data).<BR>
 Um mês é convertido para o primeiro dia do mês (00:00:00 daquela data).<BR>
 Uma lista não é convertida, a menos que tenha exatamente um elemento.<BR>"""

    pass


  def paraDecimal(self) -> float:
    """Converte o objeto original para um objeto do tipo "double" (isto é, um
 número do tipo "ponto flutuante"). Neste caso:<BR>
 Um número inteiro é convertido para um valor decimal, onde há somente
 zeros após a vírgula.<BR>
 Um número decimal é mantido na mesma forma.<BR>
 Um texto é convertido, desconsiderando-se os "pontos" (considerados como
 separador de milhar) e considerando a "vírgula" como separador de casas
 decimais. A exceção é para situações onde não há vírgula, mas há somente
 um único ponto, e não há exatamente três dígitos após o ponto (isto é,
 podem haver dois, um, quatro, ou qualquer outra quantidade de dígitos
 diferente de três).<BR>
 Exemplos:<BR>
 100 vira 100,0<BR>
 100,1 vira 100,1<BR>
 100.1 vira 100,1<BR>
 1.000 vira 1000,0<BR>
 OBS: se a conversão falhar (por exemplo, tentativa de converter o texto
 "ABC" em um número decimal), a função retorna zero (0,0)."""

    pass


  def paraDia(self) -> Data:
    """Idem à função {@link Conversor#paraData() paraData}."""

    pass


  def paraDigitos(self) -> str:
    """Converte o objeto original para um texto sem formatação (isto é, preserva
 somente os dígitos).<BR>"""

    pass


  def paraInteiro(self) -> long:
    """Converte o objeto original para um objeto do tipo "long" (isto é, um
 número inteiro, sem casas decimais, de 64 bits). Neste caso:<BR>
 Um número inteiro é mantido na mesma forma.<BR>
 Um número decimal é truncado nas casas decimais, permanecendo inteiro.<BR>
 Um texto é convertido, desconsiderando-se os "pontos" (considerados como
 separador de milhar) e considerando a "vírgula" como separador de casas
 decimais (apenas para truncar o número, de modo a descartar o que vem
 depois da vírgula).<BR>
 Exemplos:<BR>
 100 vira 100<BR>
 100,1 vira 100<BR>
 100.1 vira 100<BR>
 1.000 vira 1000<BR>
 OBS: se a conversão falhar (por exemplo, tentativa de converter o texto
 "ABC" em um número inteiro), a função retorna zero (0)."""

    pass


  def paraListaCNPJBaseNumerico(self) -> list:
    """Converte para uma lista de CNPJ de 8 dígitos (CNPJ base).<BR>
 Isto é, se o número original é um número CNPJ de 14 dígitos, ou uma lista
 de números de CNPJ de 14 dígitos, ou uma lista de estabelecimentos,
 converte esses números em uma lista de CNPJ de 8 dígitos.<BR>
 OBS: Se o objeto original da conversão já corresponder a um número CNPJ
 de 8 dígitos, o resultado desta conversão pode ser um número inválido,
 pois do número original será feita a divisão por 1.000.000.<BR>
 OBS2: O ContÁgil normalmente testa o DV do número original para confirmar
 que se trata de um número CNPJ válido antes de fazer a conversão. Se o
 teste do DV não passar, o número não é convertido."""

    pass


  def paraListaCNPJBaseTexto(self) -> list:
    """Converte para uma lista de CNPJ de 8 dígitos (CNPJ base).<BR>
 Isto é, se o número original é um número CNPJ de 14 dígitos, ou uma lista
 de números de CNPJ de 14 dígitos, ou uma lista de estabelecimentos,
 converte esses números em uma lista de CNPJ de 8 dígitos.<BR>
 OBS: Se o objeto original da conversão já corresponder a um número CNPJ
 de 8 dígitos, o resultado desta conversão pode ser um número inválido,
 pois do número original será feita a divisão por 1.000.000.<BR>
 OBS2: O ContÁgil normalmente testa o DV do número original para confirmar
 que se trata de um número CNPJ válido antes de fazer a conversão. Se o
 teste do DV não passar, o número não é convertido."""

    pass


  def paraListaCNPJNumerico(self) -> list:
    """Converte para uma lista de CNPJ de 14 dígitos.<BR>
 Isto é, se o número original algo que se relaciona a um CNPJ (tal como
 uma contabilidade), ou uma lista de números de CNPJ com formatação
 (traços e pontos), ou uma lista de estabelecimentos, converte esses
 números em uma lista de CNPJ de 14 dígitos (na realidade, por serem
 números, omite-se os zeros à esquerda).<BR>
 OBS: Se o objeto original da conversão corresponder a um número CNPJ de 8
 dígitos, o resultado desta conversão pode ser um número inválido, pois
 não se pode obter um número de 14 dígitos a partir de um número de 8
 dígitos (na realidade o método presumira que o CNPJ de 8 dígitos é um
 CNPJ de 14 dígitos onde os dígitos à esquerda são zeros).<BR>
 OBS2: O ContÁgil normalmente testa o DV do número original para confirmar
 que se trata de um número CNPJ válido antes de fazer a conversão. Se o
 teste do DV não passar, o número não é convertido."""

    pass


  def paraListaCNPJTexto(self) -> list:
    """Converte para uma lista de CNPJ de 14 dígitos.<BR>
 Isto é, se o número original algo que se relaciona a um CNPJ (tal como
 uma contabilidade), ou uma lista de números de CNPJ com formatação
 (traços e pontos), ou uma lista de estabelecimentos, converte esses
 números em uma lista de CNPJ de 14 dígitos sem formatação alguma (isto é,
 apenas os dígitos).<BR>
 OBS: Se o objeto original da conversão corresponder a um número CNPJ de 8
 dígitos, o resultado desta conversão pode ser um número inválido, pois
 não se pode obter um número de 14 dígitos a partir de um número de 8
 dígitos (na realidade o método presumira que o CNPJ de 8 dígitos é um
 CNPJ de 14 dígitos onde os dígitos à esquerda são zeros).<BR>
 OBS2: O ContÁgil normalmente testa o DV do número original para confirmar
 que se trata de um número CNPJ válido antes de fazer a conversão. Se o
 teste do DV não passar, o número não é convertido."""

    pass


  def paraListaCPFLong(self) -> list:
    """Converte para uma lista de CPF de 11 dígitos.<BR>
 Isto é, se o número original algo que se relaciona a um CPF, tal como uma
 lista de números de CPF com formatação (traços e pontos), ou uma lista de
 pessoas físicas, converte esses números em uma lista de CPF de 11 dígitos
 sem formatação alguma (isto é, apenas os dígitos).<BR>
 OBS: O ContÁgil normalmente testa o DV do número original para confirmar
 que se trata de um número CPF válido antes de fazer a conversão. Se o
 teste do DV não passar, o número não é convertido."""

    pass


  def paraListaCPFTexto(self) -> list:
    """Converte para uma lista de CPF de 11 dígitos.<BR>
 Isto é, se o número original algo que se relaciona a um CPF, tal como uma
 lista de números de CPF com formatação (traços e pontos), ou uma lista de
 pessoas físicas, converte esses números em uma lista de CPF de 11 dígitos
 sem formatação alguma (isto é, apenas os dígitos).<BR>
 OBS: O ContÁgil normalmente testa o DV do número original para confirmar
 que se trata de um número CPF válido antes de fazer a conversão. Se o
 teste do DV não passar, o número não é convertido."""

    pass


  def paraListaNITTexto(self) -> list:
    """Converte para um texto representativo do NIT de 11 dígitos.<BR>"""

    pass


  def paraListaNITTextoFormatado(self) -> list:
    """Converte para um texto representativo do NIT de 11 dígitos com sinais de formatação.<BR>"""

    pass


  def paraMes(self) -> Mes:
    """Converte o objeto original para um objeto do tipo {@link Mes Mes}. Neste
 caso:<BR>
 Um número inteiro é convertido para um mês supondo que o número está no
 padrão MMAAAA caso comece com 01...13 ou no padrão AAAAMM nos demais
 casos.<BR>
 Um texto é convertido para mês considerando diversos padrões distintos
 (tais como mês por extenso, ou MM/AAAA, etc.).<BR>
 Uma data é convertida para o correspondente mês.<BR>
 Um mês é mantido na forma de mês.<BR>
 Uma lista não é convertida, a menos que tenha exatamente um elemento.<BR>"""

    pass


  def paraNITTexto(self) -> str:
    """Converte para um texto representativo do NIT de 11 dígitos.<BR>
 Esta função faz a mesma coisa que a função
 {@link Conversor#paraListaNITTexto() paraListaNITTexto}, com a diferença
 que esta retorna apenas um único valor.<BR>
 OBS: Em uma tentativa de converter uma lista de valores, retorna o
 primeiro valor da lista convertido (isto é, considerando a ordem
 numérica)."""

    pass


  def paraTexto(self) -> str:
    """Converte o objeto original para texto. Neste caso:<BR>
 Uma lista é convertida para um texto contendo tudo que tem dentro da
 lista.<BR>
 Um número inteiro é formatado com pontos separando os milhares.<BR>
 Um número com casas decimais é formatado com vírgula separando os
 decimais, e mantém-se duas casas decimais na representação.<BR>
 Um texto é representado da mesma forma original.<BR>"""

    pass


  def paraValor(self) -> float:
    """Idem à função {@link Conversor#paraDecimal() paraDecimal}"""

    pass


  def toString(self) -> str:
    pass

class CopiaBackup ():
  """Objeto que representa um arquivo de "backup" (isto é, algo que armazena dados
 do ContÁgil, tais como contabilidades, notas fiscais, tabelas do usuário,
 leiautes do MAD, dicionário de palavras, cadastro de pessoas, etc.).<BR>
 
 Pode-se dar início à criação de um backup utilizando o método
 {@link GerenciadorArquivos#criaBackup(String, String) criaBackup}.<BR>"""

  def addComponente(self, nomeComponente) -> None:
    """Caso esteja sendo criado um novo BACKUP, indica que há interesse em
 adicionar ao BACKUP todos os dados que se referem a um determinado
 componente do ContÁgil (por exemplo, se o parâmetro é igual a
 "contabilidades", inclui todas as contabilidades importadas no projeto
 atual).<BR>
 OBS: neste método apenas são obtidas as referências a esses dados. O
 backup é efetivamente criado somente no final, quando se executa o método
 "fechar"."""

    pass


  def addComponente(self, nomeComponente, cnpj, dataInicial, dataFinal) -> None:
    """Caso esteja sendo criado um novo BACKUP, indica que há interesse em
 adicionar ao BACKUP todos os dados que se referem a um determinado
 componente do ContÁgil (por exemplo, se o parâmetro é igual a
 "contabilidades", inclui todas as contabilidades importadas no projeto
 atual), sobre um determinado contribuinte em particular e sobre um determinado
 período (identificado pela data inicial e pela data final).<BR>
 Caso o tipo de componente seja desvinculado a um CNPJ específico, ele é
 inserido no BACKUP independentemente de qual CNPJ tenha sido indicado
 como parâmetro.<BR>
 O mesmo se aplica ao 'período' (se o componente independe de um 'período',
 ele é inserido independentemente do critério indicado no parâmetro).<BR>
 OBS: neste método apenas são obtidas as referências a esses dados. O
 backup é efetivamente criado somente no final, quando se executa o método
 "fechar"."""

    pass


  def addComponente(self, nomeComponente, cnpj) -> None:
    """Caso esteja sendo criado um novo BACKUP, indica que há interesse em
 adicionar ao BACKUP todos os dados que se referem a um determinado
 componente do ContÁgil (por exemplo, se o parâmetro é igual a
 "contabilidades", inclui todas as contabilidades importadas no projeto
 atual) e sobre um determinado contribuinte em particular.<BR>
 Caso o tipo de componente seja desvinculado a um CNPJ específico, ele é
 inserido no BACKUP independentemente de qual CNPJ tenha sido indicado
 como parâmetro.<BR>
 OBS: neste método apenas são obtidas as referências a esses dados. O
 backup é efetivamente criado somente no final, quando se executa o método
 "fechar"."""

    pass


  def addMadEspecifico(self, nomeMAD) -> None:
    """Adiciona um leiaute de MAD específico no backup"""

    pass


  def addScriptEspecifico(self, nomeScript) -> None:
    """Adiciona um script específico no backup"""

    pass


  def addTodosComponentes(self) -> None:
    """Caso esteja sendo criado um novo BACKUP, indica que há interesse em
 adicionar ao BACKUP todos os dados que existem sobre todos os
 componentes.<BR>
 OBS: neste método apenas são obtidas as referências a esses dados. O
 backup é efetivamente criado somente no final, quando se executa o método
 "fechar"."""

    pass


  def copiaComponente(self, nomeComponente, destino) -> None:
    """Transfere o conteúdo relacionado a um "componente" de um arquivo de BACKUP existente para outro
 arquivo de BACKUP.<BR>
 Caso o arquivo contenha outros "componentes" além daquele especificado, eles não são copiados, a menos
 que esta mesma função seja executada sucessivas vezes, uma vez para cada um dos componentes do arquivo
 de origem.<BR>
 Execute este método no objeto que representa o arquivo de BACKUP de "origem" (isto é,
 aquele que tem a informação que se deseja copiar para outro arquivo de BACKUP).<BR>"""

    pass


  def fechar(self) -> None:
    """Fecha o arquivo, o que significa que se está sendo criado um BACKUP novo,
 ele é gravado em disco.<BR>
 Por outro lado, se o objeto que está sendo fechado foi aberto para
 "restauração" (isto é, o backup já existia e foi utilizado para "abrir"),
 este método faz a restauração dos dados que foram indicados através de
 execuções anteriores de métodos de nome restauraXXX.<BR>
 Não é possível fazer mais nada depois que o arquivo já foi fechado, a
 menos que ele seja reaberto novamente."""

    pass


  def getComponentes(self) -> list:
    """Retorna a lista de todos os componentes previstos (isto é, os "tipos" de
 dados que podem ser inseridos no BACKUP sem discriminar cada dado entre
 si).<BR>
 Caso este método esteja sendo executado sobre um arquivo BACKUP já
 existente que está sendo restaurado, retorna apenas a relação de
 componentes que estão armazenados dentro do arquivo de BACKUP."""

    pass


  def getComponentesEspecificosProjeto(self) -> list:
    """Retorna a lista de todos os componentes que são específicos a 'PROJETOS' (isto é, os "tipos" de
 dados que podem ser inseridos no BACKUP sem discriminar cada dado entre si, mas que quando
 armazenados na pasta de trabalho, podem ser armazenados de forma específica a um projeto).<BR>
 Caso este método esteja sendo executado sobre um arquivo BACKUP já
 existente que está sendo restaurado, retorna apenas a relação de
 componentes que estão armazenados dentro do arquivo de BACKUP e que são específicos a 'PROJETOS'."""

    pass


  def getData(self) -> Data:
    """Caso esteja restaurando um backup existente, retorna a data em que o
 backup foi criado. Caso esteja criando um backup novo, retorna a data
 atual."""

    pass


  def getLogAlertas(self) -> list:
    """Retorna a relação de mensagens de ALERTA no LOG de criação ou de recuperação deste BACKUP.<BR>
 Este método deve ser executado "após" o "fechamento" (isto é, após executar o método "fechar")."""

    pass


  def getLogErros(self) -> list:
    """Retorna a relação de mensagens de ERRO no LOG de criação ou de recuperação deste BACKUP.<BR>
 Este método deve ser executado "após" o "fechamento" (isto é, após executar o método "fechar")."""

    pass


  def getVersao(self) -> str:
    """Caso esteja restaurando um backup existente, retorna o número da versão
 do ContÁgil que foi utilizada para gerar o arquivo de backup. Caso esteja
 criando um backup novo, retorna a versão atual do ContÁgil."""

    pass


  def hasLogAlertas(self) -> bool:
    """Retorna a indicação de que existem ALERTAS no LOG de criação ou de recuperação deste BACKUP.<BR>
 Este método deve ser executado "após" o "fechamento" (isto é, após executar o método "fechar")."""

    pass


  def hasLogErros(self) -> bool:
    """Retorna a indicação de que existem ERROS no LOG de criação ou de recuperação deste BACKUP.<BR>
 Este método deve ser executado "após" o "fechamento" (isto é, após executar o método "fechar")."""

    pass


  def isFechado(self) -> bool:
    """Retorna a indicação de que o arquivo já foi fechado."""

    pass


  def restauraComponente(self, nomeComponente) -> None:
    """Caso esteja sendo restaurado o conteúdo de um BACKUP existente, indica
 que há interesse em restaurar os dados de um determinado componente do
 ContÁgil (por exemplo, se o parâmetro é igual a "contabilidades",
 restaura no projeto atual todas as contabilidades armazenadas no BACKUP,
 sobrescrevendo tudo aquilo que já existe).<BR>
 OBS: neste método é feita apenas a indicação de quais componentes devem
 ser restaurados. Nenhuma restauração é de fato realizada por este método.
 Toda restauração é feita somente no final, quando se executa o método
 "fechar"."""

    pass


  def restauraTodosComponentes(self) -> None:
    pass

class Cor ():
  """Diferentes cores definidas para uso em alguns métodos específicos do script."""

  def getCor(self, nome) -> Cor:
    """Dado o nome da cor, que pode estar escrito de forma ligeiramente
 diferente, obtém o correspondente objeto que representa a cor.<BR>
 Por exemplo, o nome "BRANCA" ou o nome "BRANCO" retornam o mesmo objeto
 "cor" correspondente à cor branca."""

    pass


  def getNome(self) -> str:
    """Retorna o nome da cor. Exemplo: VERMELHA, VERDE."""

    pass


  def toString(self) -> str:
    pass


  def valueOf(self, name) -> Cor:
    pass


  def values(self) -> Cor:
    pass

class Criterio ():
  """Classe utilizada para representar um critério qualquer de agregação.
 <P>
 
 Pode-se passar como parâmetro um array de objetos que são utilizados como
 critério de agregação.
 <P>
 
 Esta classe implementa as funções necessárias para que este objeto possa ser
 utilizado como chave de HashMaps, HashSets, TreeMaps e TreeSets.
 <P>
 
 Consulte o comentário da classe Agregador para mais informações sobre
 utilização de critérios."""

  def clone(self, new_length) -> Criterio:
    """Obtém uma outra instância desta Tupla com uma tamanho diferente.
 Se o novo tamanho for maior que o vetor original, então os elementos
 adicionados terão valor nulo."""

    pass


  def clone(self) -> Criterio:
    """Cria uma cópia do objeto 'Criterio' atual, com o mesmo conteúdo (isto é, os mesmos 'valores').<BR>
 Após criação da 'cópia', eles se tornam independentes um do outro. Isto é, modificações posteriores
 em um não afetam o outro."""

    pass


  def compareTo(self, ref) -> int:
    pass


  def equals(self, o) -> bool:
    pass


  def getCriteria(self) -> Object:
    """Retorna a relação de todos os valores definidos neste critério"""

    pass


  def getParteFinal(self, quantidade) -> Criterio:
    """Retorna uma cópia do objeto 'Criterio' atual, porém incluindo somente os valores finais dele. A quantidade
 de valores que devem fazer parte do novo 'Criterio' é informada no parâmetro."""

    pass


  def getParteInicial(self, quantidade) -> Criterio:
    """Retorna uma cópia do objeto 'Criterio' atual, porém incluindo somente os primeiros valores dele. A quantidade
 de valores que devem fazer parte do novo 'Criterio' é informada no parâmetro."""

    pass


  def getQuantidade(self) -> int:
    """Retorna a quantidade de argumentos definidos de forma simultânea neste
 critério"""

    pass


  def getValor(self, n) -> Object:
    """Retorna o valor do n'ésimo argumento definido neste critério. O primeiro
 elemento corresponde a n = 0. O último elemento corresponde a n =
 getQuantidade()-1"""

    pass


  def getValorNoFormato(self, n, formato) -> T:
    """Faz o mesmo que {@link #getValor(int) getValor}, mas já converte o valor
 para o formato desejado. Por exemplo, se estava armazenado um 'texto' e se
 deseja no formato 'data', a conversão é feita de 'texto' para 'data'."""

    pass


  def hashCode(self) -> int:
    pass


  def setValor(self, n, valor) -> None:
    """Define o n-ésimo valor deste critério.<BR>
 OBS: Caso a posição "n" seja maior que 0 e caso este critério não tenha
 definido ainda alguns valores para as posições anteriores a "n", acarreta
 em que os valores omissos das posições anteriores são nulos."""

    pass


  def setValores(self, criteria) -> None:
    """Estabelece os valores que compõem este critério.<BR>
 OBS: Se o objeto "Criterio" foi construído a partir de um conjunto de
 valores, fica dispensado o uso deste método, pois os valores já são
 atribuídos no momento da construção."""

    pass


  def toString(self) -> str:
    pass

class DW ():
  """Classe utilizada por linguagem de scripting para utilização do sistema "DW -
 Corporativo" da RFB.
 <P>

 Através dos métodos desta classe é possível executar relatórios do DW e
 armazenar seu resultado localmente no ContÁgil, na forma de um
 {@link TabelaUsuario TabelaUsuario}.
 <P>
 Os métodos dessa classe utilizam conceitos próprios do DW, como atributo, métrica, prompt,
 histórico, carga de NIs, formulário de atributo, projeto, messageID, subscrição, qualificação
 de atributo, subscrição de relatório, etc. <BR>
 Para maiores informações sobre esses conceitos, consulte os Manuais do DW em http://dwrfb.receita.fazenda/,
 principalmente o Manual MicroStrategy para informações mais completas.
 <P>
 Este objeto está acessível para a linguagem de script através do nome "dw".<BR>"""

  def addPrompt(self, nome, valor) -> None:
    """Acrescenta um valor a ser considerado em resposta a um "prompt" de
 usuário.<BR>
 Caso este método tenha sido executado outra vez para o mesmo "prompt",
 todos os valores passados como parâmetro nas sucessivas chamadas de
 função são considerados.<BR>
 Veja mais informações na função
 {@link DW#setPrompt(String, Object) setPrompt}."""

    pass


  def addPrompt(self, nome, valores) -> None:
    """Acrescenta um valor a ser considerado em resposta a um "prompt" de
 usuário.<BR>
 Caso este método tenha sido executado outra vez para o mesmo "prompt",
 todos os valores passados como parâmetro nas sucessivas chamadas de
 função são considerados.<BR>
 Veja mais informações na função
 {@link DW#setPrompt(String, List) setPrompt}."""

    pass


  def aguardarRelatorios(self, chave, projeto, listaMessageIDs) -> list:
    """Aguarda o término da execução dos relatórios indicados através das
 respectivas chaves de execução (messageID), obtidas em chamadas a
 iniciarRelatorio."""

    pass


  def apagaCargaNI(self, tipoNI, nomeFiltro) -> bool:
    """Apaga filtro de carga de NIs"""

    pass


  def apagaPrompt(self, nome) -> None:
    """Remove o conteúdo a ser passado em um "prompt" identificado por um
 determinado nome.<BR>
 Esta função desfaz o que foi feito em chamadas anteriores a addPrompt()
 ou setPrompt().<BR>
 Observação: se o conteúdo do "prompt" não for fornecido por um método
 setPrompt() ou addPrompt() previamente à execução do relatório, o
 ContÁgil recusará o preenchimento do prompt quando for solicitado durante
 a execução do relatório do DW."""

    pass


  def apagaPrompts(self) -> None:
    """Apaga todas as respostas a prompts definidas no script antes dessa estapa.<BR>
 Esta função desfaz o que foi feito em chamadas anteriores a addPrompt()
 ou setPrompt().<BR>
 Observação: se o conteúdo do "prompt" não for fornecido por um método
 setPrompt() ou addPrompt() previamente à execução do relatório, o
 ContÁgil recusará o preenchimento do prompt quando for solicitado durante
 a execução do relatório do DW."""

    pass


  def apagarHistoricos(self, chave, projeto, messageIDs) -> bool:
    """Apaga históricos do projeto indicado através dos respectivos identificadores (message ID)."""

    pass


  def apagarSubscricoes(self, chave, projeto, expressaoRegular) -> list:
    """Apaga subscrições do projeto indicado utilizando uma expressão regular."""

    pass


  def copiaRelatorio(self, chave, projeto, relatorio, novoNome, pastaDestino) -> str:
    pass


  def duplicarHistorico(self, chave, projeto, messageID) -> str:
    """Duplica a entrada na lista de histórico a partir de uma chave de
 identificação da execução (messageID).
 {@link Chaves#getChaveImportacao(String, String) chaves.getChaveImportacao}."""

    pass


  def executaRelatorio(self, chave, projeto, relatorio, nomeSalvar, acrescenta) -> TabelaUsuario:
    """Executa um relatório do DW e armazena seu resultado na forma de um objeto
 "TabelaUsuario", que fica armazenado na pasta de trabalho do ContÁgil (se
 estiver no contexto de um "projeto", armazena dentro do projeto).<BR>
 Caso o relatório do DW apresente algum filtro do tipo "prompt do
 usuário", é necessário que sejam feitas chamadas prévias aos métodos
 addPrompt() e setPrompt() apresentando o conteúdo que deve ser repassado
 ao DW quando o relatório é executado. Isto é, não é o usuário quem
 preenche o "prompt" do relatório, mas sim o próprio script através de
 execuções a esses métodos.<BR>
 Observação: se o conteúdo do "prompt" não for fornecido por um método
 setPrompt() ou addPrompt() previamente à execução do relatório, o
 ContÁgil recusará o preenchimento do prompt quando for solicitado durante
 a execução do relatório do DW.<BR>
 Se já existir uma "tabela do usuário" com o mesmo nome que foi passado
 como parâmetro, sobrescreve o anterior com o novo resultado.<BR>
 Exemplo:<BR>
 <CODE> // Pede para o usuário escolher uma chave para importar os dados
 do DW. chave = chaves.getChaveImportacao("DW","SIGA PJ");<BR>
 dw.addPrompt("ANO", 2008);<BR>
 dw.addPrompt("CNPJ", contagil.getProjetoAtual().getEstabelecimento());<BR>
 resultado = dw.executaRelatorio(chave, "SIGA PJ", "MEU RELATORIO",
 "RESULTADO");<BR>
 println("RESULTADO = "+resultado);<BR>
 </CODE>"""

    pass


  def executaRelatorio(self, chave, projeto, relatorio) -> Tabela:
    """Executa um relatório do DW e retorna um objeto "Tabela".<BR>
 Caso o relatório do DW apresente algum filtro do tipo "prompt do
 usuário", é necessário que sejam feitas chamadas prévias aos métodos
 addPrompt() e setPrompt() apresentando o conteúdo que deve ser repassado
 ao DW quando o relatório é executado. Isto é, não é o usuário quem
 preenche o "prompt" do relatório, mas sim o próprio script através de
 execuções a esses métodos.<BR>
 Observação: se o conteúdo do "prompt" não for fornecido por um método
 setPrompt() ou addPrompt() previamente à execução do relatório, o
 ContÁgil recusará o preenchimento do prompt quando for solicitado durante
 a execução do relatório do DW.<BR>
 Exemplo:<BR>
 <CODE> // Pede para o usuário escolher uma chave para importar os dados
 do DW. chave = chaves.getChaveImportacao("DW","SIGA PJ");<BR>
 dw.addPrompt("ANO", 2008);<BR>
 dw.addPrompt("CNPJ", contagil.getProjetoAtual().getEstabelecimento());<BR>
 resultado = dw.executaRelatorio(chave, "SIGA PJ", "MEU RELATORIO");<BR>
 if(resultado)<BR>
 janelas.mostraTabela(resultado)<BR>
 </CODE>"""

    pass


  def fechaTodasSessoesDW(self) -> None:
    """Fecha todas as sessões do DW abertas durante o script até o momento"""

    pass


  def getFullVerbose(self) -> bool:
    """Retorna o nível de detalhamento das mensagens de acompanhamento da
 execução do relatório"""

    pass


  def getIncluirNoHistorico(self) -> bool:
    """Retorna o flag que indica se a execução do relatório será incluída no
 histórico"""

    pass


  def getProjetosAcessiveis(self, chave) -> str:
    """Obtém a lista de projetos que o usuário está habilitado."""

    pass


  def getPrompt(self, nome, create) -> PromptValue:
    """Retorna objeto que contém as informações necessárias para a resposta ao
 "prompt" de usuário.<BR>"""

    pass


  def getRelatorios(self, chave, projeto) -> Tabela:
    """Obtém uma tabela com as identificações dos relatórios acessíveis
 pelo usuário no sistema DW. O andamento da execução desta função
 pode ser acompanhado pressionando o botão "Visualizar Detalhes"
 da janela de execução. As colunas da tabela obtida são:<BR>
 		Coluna 1: Id do Relatório<BR>
 		Coluna 2: Nome do Relatório<BR>
 		Coluna 3: Projeto do DW em que consta o relatório<BR>
 		Coluna 4: Caminho onde se encontra o relatório no projeto."""

    pass


  def getRelatorios(self, chave) -> Tabela:
    """Obtém uma tabela com as identificações dos relatórios acessíveis
 pelo usuário no sistema DW. O andamento da execução desta função
 pode ser acompanhado pressionando o botão "Visualizar Detalhes"
 da janela de execução. As colunas da tabela obtida são:<BR>
 		Coluna 1: Id do Relatório<BR>
 		Coluna 2: Nome do Relatório<BR>
 		Coluna 3: Projeto do DW em que consta o relatório<BR>
 		Coluna 4: Caminho onde se encontra o relatório no projeto."""

    pass


  def getResposta(self, nome) -> PromptValue:
    """Retorna objeto que contém as respostas para prompts informadas pelo usuário
 nos casos em que o ContÁgil não encontra uma resposta pré-definida no script.<BR>"""

    pass


  def getRespostas(self) -> Tabela:
    """Retorna uma Tabela contendo as respostas para prompts informadas pelo usuário nos casos
 em que o ContÁgil não encontra uma resposta pré-definida no script.<BR>"""

    pass


  def getSituacaoRelatorio(self, chave, projeto, messageID) -> int:
    """Retorna a situação em que a execução do relatório identificada pelo
 messageID se encontra no DW."""

    pass


  def getSolicitarPrompts(self) -> bool:
    """Retorna flag que indica se prompts sem resposta serão solicitados ao
 usuário"""

    pass


  def iniciarRelatorio(self, chave, projeto, relatorio) -> str:
    """Executa um relatório do DW sem aguardar pelo resultado.<BR>
 Retorna a chave de execução do relatório que pode ser utilizada para se
 obter a situação do relatório através da função
 {@link DW#getSituacaoRelatorio(Chave, String, String) DW.getSituacaoRelatorio}
 e obter o resultado através da função
 {@link DW#obterHistorico(Chave, String, String, String) DW.obterHistorico}"""

    pass


  def iniciarRelatorio(self, chave, projeto, relatorio, nomeHistorico) -> str:
    """Executa um relatório do DW sem aguardar pelo resultado.<BR>
 Retorna a chave de execução do relatório que pode ser utilizada para se
 obter a situação do relatório através da função
 {@link DW#getSituacaoRelatorio(Chave, String, String) DW.getSituacaoRelatorio}
 e obter o resultado através da função
 {@link DW#obterHistorico(Chave, String, String, String) DW.obterHistorico}"""

    pass


  def isErroConexaoDW(self) -> bool:
    """Após executar método que se conecta ao DW, indica se ocorreu erro no processo de conexão.<BR>
 Pode ser causado por erro na senha, por indisponibilidade do DW ou por falta de habilitação."""

    pass


  def isErroExecucaoRelatorio(self) -> bool:
    """Após a tentativa de executar o relatório, aguardar o resultado ou obter histórico, indica se
 ocorreu erro na execução do relatório no DW ou na obtenção do resultado. <BR>"""

    pass


  def isRelatorioNaoEncontrado(self) -> bool:
    """Após a tentativa de executar um relatório, indica se o relatório não foi
 encontrado no DW.<BR>
 Note que esta indicação apenas faz algum sentido depois que o método
 {@link DW#executaRelatorio(Chave, String, String) executaRelatorio} é
 executado.<BR>
 Sem que um relatório qualquer seja executado este método sempre retorna
 FALSO."""

    pass


  def isRelatorioVazio(self) -> bool:
    """Após a tentativa de executar um relatório, indica se o relatório foi
 executado com sucesso, mas não retornou nenhum resultado (relatório
 vazio).<BR>
 Note que esta indicação apenas faz algum sentido depois que o método
 {@link DW#executaRelatorio(Chave, String, String) executaRelatorio} é
 executado.<BR>
 Sem que um relatório qualquer seja executado este método sempre retorna
 FALSO."""

    pass


  def isReterRespostas(self) -> bool:
    """Obtém a situação da configuração que define se as respostas do usuário serão
 retidas e aproveitadas em execuções de outros relatórios durante o próprio script."""

    pass


  def isUsarRespostasPadrao(self, usarRespostasPadrao) -> bool:
    """Indica se prompts sem resposta pelo script devem utilizar respostas
 padrão gravadas no relatório."""

    pass


  def liberaAcessoObjeto(self, chave, projeto, idObjeto, tipoObjeto, nomeUsuario) -> None:
    """Função genérica para alterar permissão de algum objeto do DW.<BR/>
 Utilize preferencialmente as funções específicas para alterar permissão de relatórios e pastas.<BR/>
 Códigos para os tipos de projetos:<BR/>
 3 - Relatórios
 8 - Pastas
 1 - Filtros
 10 - Prompts"""

    pass


  def liberaAcessoPasta(self, chave, projeto, pasta, nomeUsuario) -> None:
    """Altera as permissão de acesso a uma pasta do DW, concedendo
 permissão de leitura aos usuários que satisfaçam o padrão passado como
 nomeUsuario."""

    pass


  def liberaExecucaoRelatorio(self, chave, projeto, relatorio, nomeUsuario) -> None:
    """Altera as permissão de leitura e execução do relatório, concedendo
 permissão de execução aos usuários que satisfaçam o padrão passado como
 nomeUsuario."""

    pass


  def listarHistoricos(self, chave, projeto, expressaoRegular, incluirQtdLinhas) -> Tabela:
    """Lista históricos do projeto indicado utilizando uma expressão regular. Esta alternativa
 permite indicar se a tabela retornada inclui coluna com a quantidade de linhas de cada
 mensagem do histórico, o que torna a consulta muito mais lenta."""

    pass


  def listarHistoricos(self, chave, projeto, expressaoRegular) -> Tabela:
    """Lista históricos do projeto indicado utilizando uma expressão regular."""

    pass


  def listarSubscricoes(self, chave, projeto, expressaoRegular) -> list:
    """Lista subscrições do projeto indicado utilizando uma expressão regular."""

    pass


  def novaCargaNI(self, tipoNI, nomeFiltro, descricao, listaNIs, substituir) -> str:
    """Cria um novo filtro com a carga de NIs a partir de um arquivo texto."""

    pass


  def novaCargaNI(self, tipoNI, nomeFiltro, descricao, arquivoNIs, substituir) -> str:
    """Cria um novo filtro com a carga de NIs a partir de um arquivo texto."""

    pass


  def novaCargaNI(self, tipoNI, nomeFiltro, descricao, arquivoNIs) -> str:
    """Cria um novo filtro com a carga de NIs a partir de um arquivo texto."""

    pass


  def obterAtributos(self, chave, projeto, padrao) -> Tabela:
    """Retorna todos os atributos do projeto que possuem o nome no padrão indicado. O padrão utiliza o caracter * como curinga.
 Passe * para retornar tudo."""

    pass


  def obterHistorico(self, chave, projeto, relatorio, messageID) -> Tabela:
    """Obtém o resultado de um relatório já executado.<BR>
 Se a chave de execução (messageID) for informada, tentará obter o
 resultado daquela execução do relatório. <BR>
 Se não encontrar uma execução anterior com essa chave de execução,
 buscará a última execução do relatório identificado pelo parâmetro
 "relatorio"."""

    pass


  def obterMetricas(self, chave, projeto, padrao) -> Tabela:
    """Retorna todas as métricas do projeto que possuem o nome no padrão indicado. O padrão utiliza o caracter * como curinga.
 Passe * para retornar tudo."""

    pass


  def obterSQL(self, chave, projeto, listaAtributoIDs, listaMetricaIDs) -> str:
    """Retorna o SQL para um relatório novo criado com os IDs dos atributos e métricas passados como parâmetros."""

    pass


  def obterSQL(self, chave, projeto, relatorio) -> str:
    """Retorna o SQL que o DW gera para o relatório indicado. Caso o relatório possua prompts, eles devem ser definidos previamente,
 antes de executar esta função"""

    pass


  def procuraHistoricoSemErro(self, chave, projeto, relatorio, expressaoRegular) -> str:
    """Procura o último histórico que atenda os critérios de relatório e padrão de nome de histórico e
 que não tenha ocorrido erro, retornando o respectivo message_id, ou null se não encontrar."""

    pass


  def procuraUsuario(self, chave, projeto, pattern) -> list:
    """Retorna uma lista contendo o nome de usuários e grupos do DW, de acordo
 com o padrão passado como parâmetro."""

    pass


  def salvarHistorico(self, chave, projeto, relatorio, messageID, nomeSalvar, acrescenta) -> TabelaUsuario:
    """Obtém o resultado de um relatório já executado e salva em uma tabela de
 usuário.<BR>
 Se a chave de execução (messageID) for informada, tentará obter o
 resultado daquela execução do relatório. <BR>
 Se não encontrar uma execução anterior com essa chave de execução,
 buscará a última execução do relatório identificado pelo parâmetro
 "relatorio"."""

    pass


  def setFullVerbose(self, fullVerbose) -> None:
    """Configura o nível de detalhamento das mensagens de acompanhamento da
 execução do relatório. <BR>
 Utilize true para mensagens detalhadas ou false para resumidas"""

    pass


  def setIncluirNoHistorico(self, incluirNoHistorico) -> None:
    """Configura o flag que indica se a execução do relatório será incluída no
 histórico"""

    pass


  def setMaxTempoEspera(self, maxTempoEspera) -> None:
    """Define o tempo de espera máximo para execução do relatório antes de
 abortá-lo"""

    pass


  def setPrompt(self, nome, valores) -> None:
    """Durante a execução de um relatório do DW, caso o relatório que está sendo
 executado possua algum filtro do tipo "prompt de usuário", o valor deste
 filtro é preenchido com o conteúdo apresentado neste método.<BR>
 Observação: se o conteúdo do "prompt" não for fornecido por um método
 setPrompt() ou addPrompt() previamente à execução do relatório, o
 ContÁgil recusará o preenchimento do prompt quando for solicitado durante
 a execução do relatório do DW."""

    pass


  def setPrompt(self, nome, valor, nomeFormularioAtributo) -> None:
    """Durante a execução de um relatório do DW, caso o relatório que está sendo
 executado possua algum filtro do tipo "prompt de usuário", o valor deste
 filtro é preenchido com o conteúdo apresentado neste método.<BR>
 Observação: se o conteúdo do "prompt" não for fornecido por um método
 setPrompt() ou addPrompt() previamente à execução do relatório, o
 ContÁgil recusará o preenchimento do prompt quando for solicitado durante
 a execução do relatório do DW."""

    pass


  def setPrompt(self, nome, valores, nomeFormularioAtributo) -> None:
    """Durante a execução de um relatório do DW, caso o relatório que está sendo
 executado possua algum filtro do tipo "prompt de usuário", o valor deste
 filtro é preenchido com o conteúdo apresentado neste método.<BR>
 Observação: se o conteúdo do "prompt" não for fornecido por um método
 setPrompt() ou addPrompt() previamente à execução do relatório, o
 ContÁgil recusará o preenchimento do prompt quando for solicitado durante
 a execução do relatório do DW."""

    pass


  def setPrompt(self, nome, valor, nomeFormularioAtributo, operador) -> None:
    """Durante a execução de um relatório do DW, caso o relatório que está sendo
 executado possua algum filtro do tipo "prompt de usuário", o valor deste
 filtro é preenchido com o conteúdo apresentado neste método.<BR>
 Observação: se o conteúdo do "prompt" não for fornecido por um método
 setPrompt() ou addPrompt() previamente à execução do relatório, o
 ContÁgil recusará o preenchimento do prompt quando for solicitado durante
 a execução do relatório do DW. Operadores disponíveis: =,>,>=,<,<=,<>,começa
 com,não começa com,na lista,contém"""

    pass


  def setPrompt(self, nome, valores, nomeFormularioAtributo, operador) -> None:
    """Durante a execução de um relatório do DW, caso o relatório que está sendo
 executado possua algum filtro do tipo "prompt de usuário", o valor deste
 filtro é preenchido com o conteúdo apresentado neste método.<BR>
 Observação: se o conteúdo do "prompt" não for fornecido por um método
 setPrompt() ou addPrompt() previamente à execução do relatório, o
 ContÁgil recusará o preenchimento do prompt quando for solicitado durante
 a execução do relatório do DW."""

    pass


  def setPrompt(self, nome, valores, coluna) -> None:
    """Durante a execução de um relatório do DW, caso o relatório que está sendo
 executado possua algum filtro do tipo "prompt de usuário", o valor deste
 filtro é preenchido com o conteúdo apresentado neste método.<BR>
 Observação: se o conteúdo do "prompt" não for fornecido por um método
 setPrompt() ou addPrompt() previamente à execução do relatório, o
 ContÁgil recusará o preenchimento do prompt quando for solicitado durante
 a execução do relatório do DW."""

    pass


  def setPrompt(self, nome, valor) -> None:
    """Durante a execução de um relatório do DW, caso o relatório que está sendo
 executado possua algum filtro do tipo "prompt de usuário", o valor deste
 filtro é preenchido com o conteúdo apresentado neste método.<BR>
 Observação: se o conteúdo do "prompt" não for fornecido por um método
 setPrompt() ou addPrompt() previamente à execução do relatório, o
 ContÁgil recusará o preenchimento do prompt quando for solicitado durante
 a execução do relatório do DW."""

    pass


  def setReterRespostas(self, reterRespostas) -> None:
    """Define se as respostas a prompts feitas pelo usuário durante a execução do relatório,
 quando a resposta ao prompt não foi definida no script, serão utilizadas em novas execuções
 de relatórios no mesmo script. Isto é, se deve reter as respostas do usuário."""

    pass


  def setSolicitarPrompts(self, solicitarPrompts) -> None:
    """Configura flag que indica se prompts sem resposta serão solicitados ao
 usuário"""

    pass


  def setUsarRespostasPadrao(self, usarRespostasPadrao) -> None:
    """Define se prompts sem resposta pelo script devem utilizar respostas
 padrão gravadas no relatório.  O comportamento padrão é não utilizar."""

    pass


  def subscreverRelatorio(self, chave, projeto, relatorio, nomeAgenda) -> None:
    """Cria uma subscrição para o relatório identificado para ser executado
 utilizando o trigger identificado pela expressão regular passada no
 parâmetro nomeAgenda."""

    pass


  def subscreverRelatorio(self, chave, projeto, relatorio, nomeAgenda, nomeSubscricao) -> None:
    """Cria uma subscrição para o relatório identificado para ser executado
 utilizando o trigger identificado pela expressão regular passada no
 parâmetro nomeAgenda."""

    pass

class Dicionario ():
  """Dicionário de palavras do ContÁgil.<BR>
 
 Este objeto está acessível para a linguagem de script através do nome
 "dicionario".<BR>"""

  def addDocumento(self, nome, conteudo, cnpj, mes, valor) -> None:
    """Ação análoga à
 {@link Dicionario#addDocumento(String, String) addDocumento} com o
 acréscimo de três parâmetros adicionais opcionais.<BR>
 Os parâmetros adicionais permitem incrementar a quantidade de informações
 que são utilizadas durante a consulta ao dicionário de palavras.<BR>
 Se for desejável associar a um mesmo documento diferentes conjuntos de
 informação (ex: diferentes CNPJ ou diferentes valores), deve-se quebrar o
 conteúdo em partes e executar esta ação para cada parte, cada uma
 referente a um determinado conjunto de informações. Caso o mesmo conteúdo
 seja referente a diversos códigos CNPJ, ou diversos meses, ou diferentes
 valores, é preferível não diferenciar essas informações (isto é, nesta
 hipótese é melhor deixar em branco essas informações adicionais).<BR>
 Caso o mesmo documento seja incluído sucessivas vezes no dicionário, ele
 é armazenado em redundância. Isto é, as ocorrências anteriores do mesmo
 documento não são substituídas pela nova."""

    pass


  def addDocumento(self, nome, conteudo) -> None:
    """Adiciona ao dicionário de palavras o inteiro teor de um documento em
 formato texto.<BR>
 O conteúdo completo deste documento é disponibilizado nas consultas
 posteriores ao dicionário. <BR>
 O mecanismo utilizado para armazenamento desta informação é análogo
 àquele utilizado para armazenar conteúdo de tabelas do usuário no
 dicionário de palavras, com a diferença que no lugar de uma tabela temos
 um único campo do tipo texto.<BR>
 Caso o mesmo documento seja incluído sucessivas vezes no dicionário, ele
 é armazenado em redundância. Isto é, as ocorrências anteriores do mesmo
 documento não são substituídas pela nova."""

    pass


  def addTabela(self, tabela) -> None:
    """Adiciona ao dicionário de palavras o conteúdo de uma tabela.<BR>
 Cada linha da tabela é consultada de forma individual no dicionário (isto
 é, as palavras presentes em linhas diferentes não se comunicam para
 efeitos de uma mesma consulta).<BR>
 O mecanismo utilizado para armazenamento desta informação é análogo
 àquele utilizado para armazenar conteúdo de tabelas do usuário no
 dicionário de palavras.<BR>
 As colunas da tabela que estão no formato DATA ou VALOR não são
 consideradas nas pesquisas subsequentes do dicionário, mas são incluídas
 no dicionário para o propósito de DETALHAMENTO caso a informação seja
 localizada.<BR>
 Caso a mesma tabela seja incluída sucessivas vezes no dicionário, ela é
 armazenada em redundância. Isto é, as ocorrências anteriores da mesma
 tabela não são substituídas pela nova.<BR>
 O nome da tabela é considerado para efeitos de identificação deste tipo
 de informação nas consultas.<BR>
 Caso exista uma coluna com o título "CNPJ" e formato "CNPJ14", ela é
 considerada como campo especial para a finalidade de identificar o CNPJ,
 que é um critério adicional de consulta ao dicionário de palavras.<BR>
 Caso exista uma coluna com o título "MES" e formato "MES, ela é
 considerada como campo especial para a finalidade de identificar o
 período, que é um critério adicional de consulta ao dicionário de
 palavras.<BR>
 Caso exista uma coluna com o título "VALOR" e formato "DECIMAL" ou
 "MOEDA", ela é considerada como campo especial para a finalidade de
 identificar um valor."""

    pass


  def consulta(self, expressao) -> Tabela:
    """Realiza uma consulta sobre o dicionário de palavras utilizando uma
 expressão, conforme a mesma sintaxe de consulta que é utilizada no
 ContÁgil (menu Geral).<BR>
 OBS: Caso existam mais de 100 documentos que atendem o critério de
 pesquisa, limita-se a apresentar os 100 mais relevantes conforme critério
 interno de relevância. Para indicar um número diferente, utilize outro
 método alternativo."""

    pass


  def consulta(self, expressao, qtdMax) -> Tabela:
    """Realiza uma consulta sobre o dicionário de palavras utilizando uma
 expressão, conforme a mesma sintaxe de consulta que é utilizada no
 ContÁgil (menu Geral).<BR>
 O parâmetro adicional "qtdMax" é utilizado para definir uma quantidade
 máxima de resultados a retornar. Em geral é preferível manter um número
 pequeno para evitar problemas como estouro de memória em situações
 envolvendo muitos resultados."""

    pass


  def consultaComFiltros(self, expressao, qtdMax, cnpj, inicio, fim) -> Tabela:
    """Realiza uma consulta sobre o dicionário de palavras utilizando uma
 expressão, conforme a mesma sintaxe de consulta que é utilizada no
 ContÁgil (menu Geral), acrescida de outros critérios de filtragem
 opcionais.<BR>
 O parâmetro adicional "qtdMax" é utilizado para definir uma quantidade
 máxima de resultados a retornar. Em geral é preferível manter um número
 pequeno para evitar problemas como estouro de memória em situações
 envolvendo muitos resultados.<BR>
 Os parâmetros adicionais "cnpj", "inicio" e "fim" podem ser utilizados
 como critérios adicionais de pesquisa para restringir o universo de
 informações do dicionário que são pesquisadas. Tais parâmetros podem ser
 omitidos informando "null", de modo a ampliar o universo de informações
 pesquisadas."""

    pass


  def consultaComFiltros(self, expressao, qtdMax, cnpj, inicio, fim, tabela) -> Tabela:
    """Realiza uma consulta sobre o dicionário de palavras utilizando uma
 expressão, conforme a mesma sintaxe de consulta que é utilizada no
 ContÁgil (menu Geral), acrescida de outros critérios de filtragem
 opcionais.<BR>
 O parâmetro adicional "qtdMax" é utilizado para definir uma quantidade
 máxima de resultados a retornar. Em geral é preferível manter um número
 pequeno para evitar problemas como estouro de memória em situações
 envolvendo muitos resultados.<BR>
 Os parâmetros adicionais "cnpj", "inicio" e "fim" podem ser utilizados
 como critérios adicionais de pesquisa para restringir o universo de
 informações do dicionário que são pesquisadas. Tais parâmetros podem ser
 omitidos informando "null", de modo a ampliar o universo de informações
 pesquisadas.<BR>
 O parâmetro adicional "tabela" pode ser utilizado para restringir a pesquisa
 aos dados oriundos de uma determinada tabela do usuário."""

    pass


  def executaOtimizador(self) -> None:
    """Executa a rotina de "otimização" do dicionário, que consiste em
 reorganizar internamente as informações de modo a agilizar as consultas
 posteriores.<BR>
 Este método pode ser bastante demorado caso o dicionário contenha muitas
 informações.<BR>
 Este método não deve ser interrompido durante sua execução.<BR>
 Geralmente é recomendável realizar este procedimento após muitas
 exclusões de dados do dicionário de palavras."""

    pass


  def finalizar(self) -> None:
    """Caso o dicionário tenha sido alterado durante a execução do script, torna
 todas as alterações efetivas.<BR>
 Este método não precisa ser executado explicitamente. Ele é sempre
 executado no final da execução de qualquer script que altere o dicionário
 de palavras.<BR>"""

    pass


  def removeInformacoes(self, nome) -> None:
    """Remove informações previamente adicionadas ao dicionário através do
 script (isto é, não exclui outros tipos de informações existentes no
 dicionário, tais como informações oriundas da contabilidade ou notas
 fiscais).<BR>
 As informações excluídas por este método são informações previamente
 inseridas através das funções
 {@link Dicionario#addDocumento(String, String) addDocumento},
 {@link Dicionario#addTabela(Tabela) addTabela} e demais funções
 alternativas.<BR>
 OBS: as informações removidas não se tornam mais disponíveis nas
 consultas do dicionário de palavras, no entanto é possível que os nomes
 dos dados excluídos permaneçam sendo apresentados como "critérios" de
 pesquisa até que o "otimizador" seja executado através da ação
 {@link Dicionario#executaOtimizador() executaOtimizador}."""

    pass

class DistribuicaoAjustada ():
  """Resultado da aplicação de um método de inferência de distribuição a partir
 dos dados (Distribution Fitting).<BR>
 
 Este objeto é retornado em chamada à função
 {@link Tabela#getDistribuicaoAjustada(int) getDistribuicaoAjustada}<BR>
 
 Trata-se de uma técnica de inferência onde se tenta descobrir uma família de
 distribuições teóricas a partir dos dados.<BR>
 São testadas diversas hipóteses, dentre elas: Normal, LogNormal, Pareto,
 Weibull, etc.<BR>
 OBS: por se tratar de um método de aproximações, o resultado pode não
 corresponder com a realidade. Isso pode ocorrer devido a diversos fatores:<BR>
 1) Há dados insuficientes (amostra de tamanho pequeno).<BR>
 2) Há muitos "outliers" na amostra (pontos que interferem na identificação da
 distribuição correta).<BR>
 3) A distribuição correta pode não corresponder a nenhuma dentre aquelas
 conhecidas pelo sistema ou é possível que os dados tenham sido produzidos de
 relações não lineares entre diferentes tipos de distribuição.<BR>
 4) Pode haver pouca diferença entre duas ou mais distribuições com os
 parâmetros necessários para se ajustar aos dados (em outras palavras, os
 dados podem corresponder a mais de uma distribuição considerando os ajustes
 necessários nos parâmetros de cada uma delas).<BR>
 <BR>
 O método empregado (chamado de "Distribution Fitting") considera as seguintes
 etapas:<BR>
 1º) A partir dos dados são calculadas diversas estatísticas (ex: média,
 mediana, variância, etc.).<BR>
 2º) A partir dos dados são calculados diversos "quantis".<BR>
 3º) Considerando uma hipótese (ex: distribuição LogNormal), procura-se
 estimar alguns parâmetros a partir dos dados de modo a maximizar a
 verossimilhança.<BR>
 4º) Com base na distribuição e com os parâmetros estimados, são calculados os
 diversos "quantis" (em correspondência com aqueles calculados no 2º passo).<BR>
 5º) Dados os pares de "quantis" (típico de um gráfico do tipo
 "Quantil-Quantil", também chamado de "Q-Q Plot"), realiza-se uma regressão
 linear simples.<BR>
 6º) A partir da regressão linear, verifica-se o erro quadrático médio.<BR>
 7º) Dadas todas as hipóteses testadas, considera aquela que apresentou o
 menor erro quadrático médio.<BR>"""

  def getFuncaoAcumulada(self) -> str:
    """Retorna a função distribuição acumulada na forma de uma fórmula
 compreendida pelo ContÁgil (o parâmetro é "X").<BR>
 Os parâmetros da distribuição já estão ajustados de modo a melhor se
 encaixar nos dados amostrados."""

    pass


  def getFuncaoDistribuicao(self) -> str:
    """Retorna a função distribuição na forma de uma fórmula compreendida pelo
 ContÁgil (o parâmetro é "X").<BR>
 A função refere-se à função densidade de probabilidade no caso de
 variáveis contínuas ou à função massa de probabilidade no caso de
 variáveis discretas.<BR>
 Os parâmetros da distribuição já estão ajustados de modo a melhor se
 encaixar nos dados amostrados."""

    pass


  def getFuncaoQuantil(self) -> str:
    """Retorna a função quantilica (inversa da função distribuição acumulada) na
 forma de uma fórmula compreendida pelo ContÁgil (o parâmetro é "X").<BR>
 Os parâmetros da distribuição já estão ajustados de modo a melhor se
 encaixar nos dados amostrados."""

    pass


  def getGraficoDistribuicao(self, min, max, intervalo, logX) -> Grafico:
    """Retorna um gráfico que corresponde à função distribuição (pode ser
 acoplado a outros gráficos).<BR>
 Caso o parâmetro "logX" seja VERDADEIRO, a fórmula da distribuição
 retornada é alterada de modo a considerar a mudança de variáveis."""

    pass


  def getGraficoDistribuicao(self) -> Grafico:
    """Retorna um gráfico que corresponde à função distribuição (pode ser
 acoplado a outros gráficos).<BR>
 Os valores mínimo e máximo exibidos no eixo X do gráfico correspondem ao
 menor e maior valor observados nos dados.<BR>
 O intervalo entre os pontos da função é calculado de modo a dividir o
 intervalo entre o menor e o maior valor em 50 pontos equidistantes."""

    pass


  def getGraficoDistribuicao(self, min, max, intervalo) -> Grafico:
    """Retorna um gráfico que corresponde à função distribuição (pode ser
 acoplado a outros gráficos)."""

    pass


  def getModa(self) -> float:
    """Retorna a "MODA" desta distribuição (isto é, com base na curva teórica).<BR>
 Trata-se do ponto de máximo da curva da densidade de probabilidade.<BR>
 Caso a distribuição não possua uma MODA definida (pode ser que não exista
 MODA para o conjunto de parâmetros considerados), retorna NaN (Not a
 Number)."""

    pass


  def getNome(self) -> str:
    """Retorna o nome da distribuição (ex: "Normal")."""

    pass


  def hasModa(self) -> bool:
    """Retorna a indicação de que existe uma MODA para esta distribuição (isto
 é, com base na curva teórica).<BR>
 Trata-se do ponto de máximo da curva da densidade de probabilidade."""

    pass


  def toString(self) -> str:
    pass

class Dossie ():
  """Classe utilizada pela linguagem scripting para importar dados diretamente do Dossiê Integrado."""

  def agendaBasesPF(self, chave, bases, cpfs, anoInicio, anoFim) -> list:
    """Agenda as bases indicadas no Dossie Integrado para PF e grava o pedido em objetos internos do ContÁgil.<BR>
 Esses agendamentos poderão ser consultados e baixados posteriormente usando os métodos
 {@link org.guga.contagil.scripting.utils.Dossie#consultaAgendamentos() consultaAgendamentos} e
 {@link org.guga.contagil.scripting.utils.Dossie#baixaAgendamentos() baixaAgendamentos} <br>"""

    pass


  def agendaBasesPJ(self, chave, bases, cnpjs, ano_inicio, ano_fim) -> list:
    """Agenda as bases indicadas no Dossie Integrado para PJ e grava o pedido em objetos internos <BR>
 do ContÁgil.<BR>
 Para fazer agendamentos por EMPRESA utilize o menu Importar da interface do ContÁgil.<BR>
 Nesta opção são aceitos apenas CNPJ completos.<br>
 As bases marcadas com "*" serão desconsideradas, pois ainda não estão disponíveis para importação.<BR>"""

    pass


  def baixaAgendamentos(self, chave, agendamentos, excluiAgendamentos) -> ResultadoDossie:
    """Baixa os dados dos pedidos de agendamento informados no parâmetro."""

    pass


  def consultaAgendamentos(self, chave) -> list:
    """Consulta a relação de todos os agendamentos existentes. A relação traz agendamentos tanto de Pessoa Física como
 de Pessoa Jurídica. <br>
 É necessário consultar o método {@link RegistroAgendamentoDossie#isProcessado() processado} para saber se o
 agendamento está disponível para ser baixado."""

    pass


  def consultaBasesPF(self, chave, bases, cpfs, ano_inicio, ano_fim, prefixo) -> ResultadoDossie:
    """Consulta as bases indicadas no Dossie Integrado para PF e grava o resultado em tabelas de usuário.<BR>
 As bases com asterisco ainda não foram mapeadas para os campos apropriados e retornam dados sem tratamento."""

    pass


  def consultaBasesPJ(self, chave, bases, cnpjs, ano_inicio, ano_fim, prefixo) -> ResultadoDossie:
    """Consulta as bases indicadas no Dossie Integrado para PJ e grava o resultado em tabelas de usuário.<BR>
 As bases com asterisco ainda não foram mapeadas para os campos apropriados e retornam dados sem tratamento."""

    pass


  def consultaCadastroEstabelecimentos(self, chave, cnpjs) -> Tabela:
    """Consulta o cadastro dos estabelecimentos no Grande Porte a partir do CNPJ básico."""

    pass


  def consultaCadastroEstabelecimentosPorCnpjBasico(self, chave, cnpjsBasicos, apenasMatriz) -> Tabela:
    """Consulta o cadastro dos estabelecimentos no Grande Porte a partir do CNPJ básico."""

    pass


  def escolheBasesPF(self, bases_iniciais) -> str:
    """Exige janela para o usuário escolher as bases PF que deseja consultar.<BR>"""

    pass


  def escolheBasesPJ(self, bases_iniciais) -> str:
    """Exige janela para o usuário escolher as bases PJ que deseja consultar.<BR>"""

    pass


  def importaBasesPF(self, chave, bases, cpfs, anoInicio, anoFim) -> ResultadoDossie:
    """Consulta as bases indicadas no Dossie Integrado para PF e grava o resultado em objetos internos do ContÁgil.<BR>"""

    pass


  def importaBasesPFNaoImportadas(self, chave, bases, cpfs, anoInicio, anoFim, dataLimite) -> ResultadoDossie:
    """Consulta as bases indicadas no Dossie Integrado para PF e grava o resultado em objetos internos do ContÁgil.<BR>
 Esta ação não irá consultar no Dossie Integrado informações que já tenha consultado anteriormente, nem mesmo
 se houver retificação sobre as mesmas informações para um determinado contribuinte e ano.<BR>
 Você pode opcionalmente informar também uma 'data limite'. Caso seja informada e se existirem informações previamente
 importadas no ContÁgil, importadas em data anterior à data limite, elas são desprezadas (isto é, o ContÁgil poderá
 consultar novamente dados do Dossiê Integrado mesmo nesta condição)."""

    pass


  def importaBasesPJ(self, chave, bases, cnpjs, ano_inicio, ano_fim) -> ResultadoDossie:
    """Consulta as bases indicadas no Dossie Integrado para PJ e grava o resultado em objetos internos <BR>
 do ContÁgil.<BR>
 Para fazer consultas por EMPRESA utilize o menu Importar da interface do ContÁgil.<BR>
 Nesta opção são aceitos apenas CNPJ completos.<br>
 As bases marcadas com "*" serão desconsideradas, pois ainda não estão disponíveis para importação.<BR>"""

    pass


  def importaBasesPJNaoImportadas(self, chave, bases, cnpjs, ano_inicio, ano_fim, dataLimite) -> ResultadoDossie:
    """Consulta as bases indicadas no Dossie Integrado para PJ e grava o resultado em objetos internos <BR>
 do ContÁgil.<BR>
 Para fazer consultas por EMPRESA utilize o menu Importar da interface do ContÁgil.<BR>
 Nesta opção são aceitos apenas CNPJ completos.<br>
 As bases marcadas com "*" serão desconsideradas, pois ainda não estão disponíveis para importação.<BR>
 Esta ação não irá consultar no Dossie Integrado informações que já tenha consultado anteriormente, nem mesmo
 se houver retificação sobre as mesmas informações para um determinado contribuinte e ano.<BR>
 Você pode opcionalmente informar também uma 'data limite'. Caso seja informada e se existirem informações previamente
 importadas no ContÁgil, importadas em data anterior à data limite, elas são desprezadas (isto é, o ContÁgil poderá
 consultar novamente dados do Dossiê Integrado mesmo nesta condição)."""

    pass


  def importaDCTF(self, chave, cnpjs, ano_inicio, ano_fim) -> None:
    """Faz a importação da base DCTF para objetos do ContÁgil"""

    pass


  def importaDIPJ(self, chave, cnpjs, ano_inicio, ano_fim, reimportar) -> str:
    """Faz a importação da DIPJ para uma relação de CNPJs em um dado período e com um dado objeto de autenticação."""

    pass


  def importaDIPJ(self, chave, cnpjs, ano_inicio, ano_fim, pastaDeclaracoes, reimportar) -> str:
    """Faz a importação da DIPJ para uma relação de CNPJs em um dado período e com um dado objeto de autenticação."""

    pass


  def importaDacon(self, chave, cnpjs, ano_inicio, ano_fim) -> None:
    """Faz a importação da base DACON para objetos do ContÁgil"""

    pass


  def importaExtratoPF(self, chave, cpfs, anoInicio, anoFim, quebraSigiloConjuge, exibePastaPDF) -> ResultadoDossie:
    """Consulta as bases indicadas no Dossie Integrado para PF necessárias para a geração do Extrato PF e grava o resultado, <br>
 inclusive o próprio Extrato PF, em objetos internos do ContÁgil.<BR>"""

    pass


  def importaExtratoPF(self, chave, cpfs, anoInicio, anoFim) -> ResultadoDossie:
    """Consulta as bases indicadas no Dossie Integrado para PF necessárias para a geração do Extrato PF e grava o resultado, <br>
 inclusive o próprio Extrato PF, em objetos internos do ContÁgil.<BR>"""

    pass


  def importaExtratoPF(self, chave, cpfs, anoInicio, anoFim, quebraSigiloConjuge) -> ResultadoDossie:
    """Consulta as bases indicadas no Dossie Integrado para PF necessárias para a geração do Extrato PF e grava o resultado, <br>
 inclusive o próprio Extrato PF, em objetos internos do ContÁgil.<BR>"""

    pass


  def importaExtratoPJ(self, chave, cnpjs, anoInicio, anoFim) -> ResultadoDossie:
    """Consulta as bases indicadas no Dossie Integrado para PJ necessárias para gerar o Extrato PJ e grava o resultado <br>
 em objetos internos do ContÁgil, inclusive o Extrato PJ.<BR>
 Nesta opção são aceitos apenas CNPJ base.<br>"""

    pass


  def setProgress(self, progress) -> None:
    """Método para uso interno (não deve ser utilizado diretamente pelo script)."""

    pass


  def setProgress(self, progress) -> None:
    """Método para uso interno (não deve ser utilizado diretamente pelo script)."""

    pass

class ElementoJson ():
  """Um elemento JSON representa o conteúdo inteiro ou uma parte do conteúdo que é apresentado no formato JSON.<BR>
 Com esta classe, é possível consultar de forma estruturada algum conteúdo armazenado no formato JSON.<BR>
 Também é possível com esta mesma classe alterar esta estrutura em memória, para depois ser salva em arquivo ou
 convertida para um texto no formato JSON.<BR>
 <BR>
 OBS: um 'elemento JSON' pode ser qualquer uma dessas coisas:<BR>
 Algum 'tipo primitivo' (ex: um texto, um valor, um booleano).<BR>
 Algum 'objeto com campos' (ex: um objeto contendo os campos 'nome', 'idade', 'data_nascimento', etc.)<BR>
 Alguma 'lista' de tipos primitivos ou de outros objetos.<BR>
 <BR>"""

  def getConteudoJson(self) -> str:
    """Retorna o conteúdo deste objeto no formato JSON"""

    pass


  def getElementoCampo(self, nome) -> ElementoJson:
    """Caso este objeto seja do tipo que define 'campos' e 'valores', retorna o elemento associado a um dado nome de campo.<BR>
 OBS: o campo é verificado no objeto atual. Se o objeto é do tipo que contém lista de outros objetos ou do tipo que contém outros objetos,
 não é verificada a presença do campo nesses outros objetos."""

    pass


  def getElementos(self) -> list:
    """Caso este objeto seja do tipo 'lista', retorna os elementos da lista."""

    pass


  def getImagemBase64(self) -> Imagem:
    """Caso este objeto seja um tipo 'primitivo' com um texto que corresponde a uma 'imagem' que foi codificada conforme a codificação 'Base64', retorna o objeto 'Imagem'
 correspondente que resulta da transformação inversa (isto é, após converter o conteúdo do formato 'Base64' para o formato original)."""

    pass


  def getImagemCampoBase64(self, nome) -> Imagem:
    """Método equivalente a executar o método {@link #getElementoCampo(String) getElementoCampo}, seguido do método {@link #getImagemBase64() getImagemBase64}."""

    pass


  def getTabela(self) -> Tabela:
    """Converte o conteúdo JSON em uma tabela genérica, onde as colunas expõem todas as colunas, incluindo
 relações 1:1 e 1:N<BR>
 Os nomes das colunas da tabela são escolhidos de acordo com os nomes dos campos apresentados no conteúdo JSON.<BR>
 Caso existam relações hierárquicas entre os campos apresentados no conteúdo JSON, os nomes das colunas correspondentes, na tabela,
 são gerados por concatenação dos nomes desses campos, conforme a hierarquia, separando-os pelo caractere ponto.<BR>
 Conteúdo booleano é convertido para os tipos booleanos correspondentes.<BR>
 Conteúdo numérico é convertido para o formato correspondente, dependendo se é inteiro ou ponto flutuante.<BR>
 Os demais conteúdos são convertidos para texto."""

    pass


  def getValor(self) -> Object:
    """Caso este objeto seja um tipo 'primitivo', retorna seu valor (isto é, um texto ou um número)"""

    pass


  def getValorBase64(self) -> byte:
    """Caso este objeto seja um tipo 'primitivo' com um texto que corresponde a um código binário na codificação 'Base64', retorna o objeto binário
 correspondente que resulta da transformação inversa (isto é, após converter o conteúdo do formato 'Base64' para o formato original)."""

    pass


  def getValorBase64Descompactado(self) -> byte:
    """Caso este objeto seja um tipo 'primitivo' com um texto que corresponde a um código binário na codificação 'Base64' compactado, retorna o objeto binário
 correspondente que resulta da transformação inversa (isto é, após converter o conteúdo do formato 'Base64' e descompacta-lo para o formato original)."""

    pass


  def getValorCampo(self, nome) -> Object:
    """Caso este objeto seja do tipo que define 'campos' e 'valores', retorna o valor associado a um dado nome de campo.<BR>
 Se o campo não corresponder a um tipo 'primitivo' (isto é, se não for um texto ou um valor numérico), retornará NULL, mesmo
 que o campo exista. Por exemplo, se o campo se referir a uma lista ou se for um outro tipo de objeto com campos, retornará NULL.
 Neste caso, se quiser ler o conteúdo de um campo que não seja de tipo primitivo, utilize o método {@link #getElementoCampo(String) getElementoCampo}.<BR>
 Este método tem o mesmo efeito que executar o método {@link #getElementoCampo(String) getElementoCampo}, seguido do método {@link #getValor() getValor}.
 OBS: o campo é verificado no objeto atual. Se o objeto é do tipo que contém lista de outros objetos ou do tipo que contém outros objetos,
 não é verificada a presença do campo nesses outros objetos."""

    pass


  def getValorCampoBase64(self, nome) -> byte:
    """Método equivalente a executar o método {@link #getElementoCampo(String) getElementoCampo}, seguido do método {@link #getValorBase64() getValorBase64}."""

    pass


  def getValorCampoBase64Descompactado(self, nome) -> byte:
    """Método equivalente a executar o método {@link #getElementoCampo(String) getElementoCampo}, seguido do método {@link #getValorBase64Descompactado() getValorBase64Descompactado}."""

    pass


  def getValorCampoTextoBase64(self, nome) -> str:
    """Método equivalente a {@link #getValorCampoBase64() getValorCampoBase64}, mas converte o conteúdo binário em campo texto considerando a codificação UTF8."""

    pass


  def getValorCampoTextoBase64Descompactado(self, nome) -> str:
    """Método equivalente a {@link #getValorBase64Descompactado() getValorCampoBase64Descompactado}, mas converte o conteúdo binário em campo texto considerando a codificação UTF8."""

    pass


  def hasCampo(self, nome) -> bool:
    """Caso este objeto seja do tipo que define 'campos' e 'valores', retorna a indicação de que existe um campo com o nome indicado.<BR>
 OBS: o campo é verificado no objeto atual. Se o objeto é do tipo que contém lista de outros objetos ou do tipo que contém outros objetos,
 não é verificada a presença do campo nesses outros objetos."""

    pass


  def isEmpty(self) -> bool:
    """Retorna indicação de que este objeto está vazio (isto é, não possui algum valor e nem campos)"""

    pass


  def isEscreveParaApresentacao(self) -> bool:
    """Indica se na transformação deste objeto para o formato JSON deve inserir caracteres que melhoram a apresentação, tais como quebra de linha
 e tabulação."""

    pass


  def isEscreveTipos(self) -> bool:
    """Indica se na transformação deste objeto para o formato JSON deve incluir campos adicionais indicando os tipos desses campos"""

    pass


  def isTipoLista(self) -> bool:
    """Retorna a indicação de que este elemento é uma lista de outros objetos (que podem ser de tipo primitivo ou não)"""

    pass


  def isTipoObjeto(self) -> bool:
    """Retorna a indicação de que este elemento é um tipo de 'objeto' com uma estrutura interna (isto é, contém campos com nomes) e não se trata de uma lista."""

    pass


  def isTipoPrimitivo(self) -> bool:
    """Retorna a indicação de que este elemento é um tipo de campo 'primitivo' (isto é, trata-se apenas de um texto ou de um valor numérico ou booleano)"""

    pass


  def novoCampo(self, nome) -> ElementoJson:
    """Cria um novo campo neste objeto, associado ao novo campo o nome indicado, e retorna referência ao objeto 'ElementoJson' que
 pode ser utilizado para preencher o valor deste campo."""

    pass


  def novoElemento(self) -> ElementoJson:
    """Adiciona um novo elemento a este objeto. Os campos ou valor do novo elemento podem ser preenchidos diretamente na referência que é retornada
 por este método."""

    pass


  def removeCampo(self, nome) -> None:
    """Se este objeto representa um tipo de objeto com campos, remove o campo cujo nome é indicado. Se o campo não existe, nada é feito."""

    pass


  def salvar(self, arquivo) -> None:
    """Salva o conteúdo deste objeto no formato JSON em um arquivo"""

    pass


  def setConteudoJson(self, json) -> None:
    """Altera o estado interno deste objeto com base no conteúdo JSON que é informado no parâmetro."""

    pass


  def setEscreveParaApresentacao(self, escreveParaApresentacao) -> None:
    """Indica se na transformação deste objeto para o formato JSON deve inserir caracteres que melhoram a apresentação, tais como quebra de linha
 e tabulação."""

    pass


  def setEscreveTipos(self, escreveTipos) -> None:
    """Indica se na transformação deste objeto para o formato JSON deve incluir campos adicionais indicando os tipos desses campos"""

    pass


  def setImagemBase64(self, imagem, formato) -> None:
    """Armazena neste objeto o conteúdo de uma imagem. O conteúdo binário da imagem é convertido conforme o formato indicado (ex: 'PNG') e depois é codificado conforme a codificação 'Base64',
 para então ser armazenado como 'texto' no JSON."""

    pass


  def setValor(self, valor) -> None:
    """Define um valor texto para este elemento. Isto é, ele passa a ser considerado um 'tipo primitivo' com o valor texto indicado."""

    pass


  def setValor(self, valor) -> None:
    """Define um valor numérico para este elemento. Isto é, ele passa a ser considerado um 'tipo primitivo' com o valor numérico indicado."""

    pass


  def setValor(self, valor) -> None:
    """Define um valor booleano para este elemento. Isto é, ele passa a ser considerado um 'tipo primitivo' com o valor booleano indicado."""

    pass


  def setValorBase64(self, bin) -> None:
    """Armazena um conteúdo binário qualquer conforme a codificação Base64"""

    pass


  def setValorBase64Compactado(self, bin) -> None:
    """Armazena um conteúdo binário qualquer conforme a codificação Base64, mas primeiro compacta com GZIP este conteúdo"""

    pass


  def setValorCampo(self, nome, valor) -> None:
    """Define um valor booleano para um campo deste elemento. Isto é, ele passa a ser considerado um 'tipo de objeto com campos' com o valor booleano indicado associado ao campo indicado."""

    pass


  def setValorCampo(self, nome, valor) -> None:
    """Define um valor texto para um campo deste elemento. Isto é, ele passa a ser considerado um 'tipo de objeto com campos' com o valor texto indicado associado ao campo indicado."""

    pass


  def setValorCampo(self, nome, valor) -> None:
    """Define um valor texto para um campo deste elemento. Isto é, ele passa a ser considerado um 'tipo de objeto com campos' com o valor texto indicado associado ao campo indicado."""

    pass


  def setValorCampoBase64(self, nome, bin) -> None:
    """Define um valor binário qualquer conforme a codificação Base64 para um campo deste elemento. Isto é, ele passa a ser considerado um 'tipo de objeto com campos' com o valor indicado associado ao campo indicado."""

    pass


  def setValorCampoBase64Compactado(self, nome, bin) -> None:
    """Define um valor binário qualquer conforme a codificação Base64 para um campo deste elemento. Isto é, ele passa a ser considerado um 'tipo de objeto com campos' com o valor indicado associado ao campo indicado."""

    pass


  def setValorCampoTextoBase64(self, nome, texto) -> None:
    """Define um valor binário qualquer calculado a partir da codificação Base64 do conteúdo binário UTF8. Isto é, ele passa a ser considerado um 'tipo de objeto com campos' com o valor indicado associado ao campo indicado."""

    pass


  def setValorCampoTextoBase64Compactado(self, nome, texto) -> None:
    """Define um valor binário qualquer calculado a partir da codificação Base64 do conteúdo binário UTF8 compactado. Isto é, ele passa a ser considerado um 'tipo de objeto com campos' com o valor indicado associado ao campo indicado."""

    pass


  def toString(self) -> str:
    """Converte o conteúdo deste objeto para o formato JSON"""

    pass

class EntradaCampo ():
  """Interface de script que representa um campo para que o usuário possa digitar algo."""

  def getFormato(self) -> str:
    """Formato a ser utilizado na validação do conteúdo, conforme descrito no comentário do método {@link Janelas#pedeTextoNoFormato(String, String, String) pedeTextoNoFormato}"""

    pass


  def getInicial(self) -> str:
    """Conteúdo a ser apresentado inicialmente na janela."""

    pass


  def getMensagem(self) -> str:
    """Mensagem apresentada na janela que pede para o usuário digitar alguma coisa."""

    pass


  def getOpcoes(self) -> str:
    """Se diferente de NULL, indica opções para escolha em um campo do tipo 'combo-box'"""

    pass


  def getResposta(self) -> str:
    """Retorna a resposta do usuário (isto é, o campo preenchido)"""

    pass


  def getTamanhoMaximo(self) -> Integer:
    """Se diferente de NULL, indica o tamanho máximo para entrada do campo"""

    pass


  def getTamanhoMinimo(self) -> Integer:
    """Se diferente de NULL, indica o tamanho mínimo para entrada do campo"""

    pass


  def isPermiteNovaOpcao(self) -> bool:
    """Este parâmetro apenas é considerado quando há 'opções' para escolha em campo do tipo 'combo-box'.
 Se este parâmetro for VERDADEIRO, o usuário pode digitar uma nova opção não incluída na lista. Se for FALSO, o usuário apenas
 pode escolher uma opção da lista."""

    pass


  def setFormato(self, formato) -> None:
    """Formato a ser utilizado na validação do conteúdo, conforme descrito no comentário do método {@link Janelas#pedeTextoNoFormato(String, String, String) pedeTextoNoFormato}"""

    pass


  def setInicial(self, inicial) -> None:
    """Conteúdo a ser apresentado inicialmente na janela."""

    pass


  def setMensagem(self, mensagem) -> None:
    """Mensagem apresentada na janela que pede para o usuário digitar alguma coisa."""

    pass


  def setOpcoes(self, opcoes) -> None:
    """Se diferente de NULL, indica opções para escolha em um campo do tipo 'combo-box'"""

    pass


  def setPermiteNovaOpcao(self, permiteNovaOpcao) -> None:
    """Este parâmetro apenas é considerado quando há 'opções' para escolha em campo do tipo 'combo-box'.
 Se este parâmetro for VERDADEIRO, o usuário pode digitar uma nova opção não incluída na lista. Se for FALSO, o usuário apenas
 pode escolher uma opção da lista."""

    pass


  def setTamanhoMaximo(self, tamanhoMaximo) -> None:
    """Se diferente de NULL, indica o tamanho máximo para entrada do campo"""

    pass


  def setTamanhoMinimo(self, tamanhoMinimo) -> None:
    """Se diferente de NULL, indica o tamanho mínimo para entrada do campo"""

    pass

class EntradaPeriodo ():

  def getDataFim(self) -> Data:
    pass


  def getDataInicio(self) -> Data:
    pass


  def getFimPreenchido(self) -> str:
    """Resposta do usuário para ser repassada ao script para o campo representando o final do período (ex: uma data final)"""

    pass


  def getInicioPreenchido(self) -> str:
    """Resposta do usuário para ser repassada ao script para o campo representando o inicio do período (ex: uma data inicial)"""

    pass


  def getMensagem(self) -> str:
    """Mensagem apresentada na janela que pede para o usuário digitar alguma coisa."""

    pass


  def getTipoPeriodo(self) -> str:
    """Indica o tipo de período que precisa ser preenchido pelo usuário. Por exemplo, se o tipo de período é 'ano', o usuário deve preencher um 'ano inicial' e um 'ano final'."""

    pass


  def setDataFim(self, dataFim) -> None:
    pass


  def setDataInicio(self, dataInicio) -> None:
    pass


  def setMensagem(self, mensagem) -> None:
    """Mensagem apresentada na janela que pede para o usuário digitar alguma coisa."""

    pass


  def setTipoPeriodo(self, tipoPeriodo) -> None:
    """Indica o tipo de período que precisa ser preenchido pelo usuário. Por exemplo, se o tipo de período é 'ano', o usuário deve preencher um 'ano inicial' e um 'ano final'."""

    pass

class ExecutorScript ():
  """Objeto que representa a interface com o usuário de execução do script.<BR>
 
 Por exemplo, o botão "Interrompe" da janela de execução de script manifesta-se
 através de um método desta interface para avisar ao script, que está sendo executado,
 que ele deve ser interrompido.<BR>
 
 Este objeto está disponível para a linguagem de script através de uma variável de nome "executor".<BR>
 
 OBS: se o script nunca verificar se o usuário interrompeu ou não (ou seja, se o script nunca executar
 a função {@link ExecutorScript#isInterrompendo() isInterrompendo}, então o script é interrompido instantaneamente
 ao pressionar o botão "Interrompe" (qualquer informação não gravada em disco será perdida). Por outro lado,
 se o script executar de tempos em tempos a função {@link ExecutorScript#isInterrompendo() isInterrompendo}, então ao
 pressionar o botão "Interrompe" o script não é interrompido instantaneamente, mas o ContÁgil aguarda que o próprio
 script tome as providencias necessárias para se "auto-interromper" (isto é, gravar as informações que julgar necessárias, etc.)."""

  def aguardarTempo(self, milisegundos) -> None:
    """Suspende a execução do script por um pequeno período.<BR>
 Utilizado para aguardar um tempo antes de prosseguir a execução do
 script, como em loops que aguardam que uma situação ocorra, evitando de
 ficar consultando sucessivamente, pois isso sobrecarregaria o processador
 sem necessidade.<BR>"""

    pass


  def getAmbienteExecucao(self) -> str:
    """Retorna o nome do ambiente de execução deste script, caso ele seja executado remotamente
 em um servidor, ou retorna NULL caso ele seja executado localmente na estação de trabalho
 do usuário."""

    pass


  def getDependenciasMAD(self) -> list:
    """Caso tenham sido configurados 'MAD's externos' na aba 'Dependências Externas' deste script que está em execução, retorna a relação de nomes de MAD's
 que foram configurados. Caso contrário, retorna uma lista vazia."""

    pass


  def getDependenciasPlugins(self) -> list:
    """Caso tenham sido configurados 'plugins' na aba 'Dependências Externas' deste script que está em execução, retorna a relação de nomes de plugins
 que foram configurados. Caso contrário, retorna uma lista vazia."""

    pass


  def getDependenciasScripts(self) -> list:
    """Caso tenham sido configurados 'outros scripts' na aba 'Dependências Externas' deste script que está em execução, retorna a relação de nomes de scripts
 que foram configurados. Caso contrário, retorna uma lista vazia."""

    pass


  def getDependenciasTabelas(self) -> list:
    """Caso tenham sido configurados 'tabelas do usuário' na aba 'Dependências Externas' deste script que está em execução, retorna a relação de nomes de tabelas
 que foram configurados. Caso contrário, retorna uma lista vazia."""

    pass


  def getDescricaoParametro(self, nome) -> str:
    """Retorna a descrição do parâmetro."""

    pass


  def getIndicacaoAcessoOcupado(self, nomeRecurso) -> bool:
    """Retorna a indicação de que um determinado recurso está sendo utilizado por algum outro processo (talvez este mesmo). Isto é,
 algum processo executou o método {@link #setIndicacaoAcessoExclusivo(String) setIndicacaoAcessoExclusivo} ou 
 {@link #setIndicacaoAcessoCompartilhado(String) setIndicacaoAcessoCompartilhado} ou uma de suas variantes, e não fez ainda a liberação
 por meio de {@link #removeIndicacaoAcesso(String) removeIndicacaoAcesso}."""

    pass


  def getIndicacaoAcessoOcupado(self, nomeRecurso, diretorio) -> bool:
    """Retorna a indicação de que um determinado recurso está sendo utilizado por algum outro processo (talvez este mesmo). Isto é,
 algum processo executou o método {@link #setIndicacaoAcessoExclusivo(String) setIndicacaoAcessoExclusivo} ou 
 {@link #setIndicacaoAcessoCompartilhado(String) setIndicacaoAcessoCompartilhado} ou uma de suas variantes, e não fez ainda a liberação
 por meio de {@link #removeIndicacaoAcesso(String) removeIndicacaoAcesso}."""

    pass


  def getLinguagem(self) -> str:
    """Retorna o nome da linguagem que está sendo executada neste momento."""

    pass


  def getMarcadorExecucao(self, nomeArquivo) -> MarcadorExecucao:
    """Cria um objeto de marcação utilizando o nome de arquivo para armazenar ou recuperar
 os dados. Se o arquivo já existe, seus dados são recuperados para dentro deste objeto.<BR>
 O arquivo indicado como parâmetro é o lugar onde é registrado o "andamento" da execução (isto é,
 onde é indicado quais elementos da lista já foram processados).<BR>
 O conteúdo deste arquivo é específico, interno à aplicação, e apenas pode ser manipulado por ele."""

    pass


  def getMemoriaHeapDisponivel(self) -> long:
    """Retorna a quantidade de memória disponível, em bytes, para uso desta aplicação Java.<BR>
 OBS: uma aplicação Java qualquer pode utilizar, ao longo do tempo, mais memória do que é efetivamente 
 necessário em um dado momento. O Java realiza periodicamente um procedimento por meio do qual é disponibilizada 
 a parcela de memória que estava sendo ocupada por dados que não estão mais sendo utilizados. Isso é um procedimento
 automático do próprio Java (chamado de 'Garbage Collector'). Portanto, entenda como 'memória utilizada' não apenas a parcela de memória que está em uso,
 mas também aquela parcela de memória que já foi utilizada no passado e que está aguardando a realização deste procedimento
 interno do Java para ser liberada."""

    pass


  def getMemoriaHeapMaxima(self) -> long:
    """Retorna a quantidade máxima de memória, em bytes, que pode ser utilizada por esta aplicação Java."""

    pass


  def getMemoriaHeapUtilizada(self) -> long:
    """Retorna a quantidade de memória utilizada, em bytes, por esta aplicação Java.<BR>
 OBS: uma aplicação Java qualquer pode utilizar, ao longo do tempo, mais memória do que é efetivamente 
 necessário em um dado momento. O Java realiza periodicamente um procedimento por meio do qual é disponibilizada 
 a parcela de memória que estava sendo ocupada por dados que não estão mais sendo utilizados. Isso é um procedimento
 automático do próprio Java (chamado de 'Garbage Collector'). Portanto, entenda como 'memória utilizada' não apenas a parcela de memória que está em uso,
 mas também aquela parcela de memória que já foi utilizada no passado e que está aguardando a realização deste procedimento
 interno do Java para ser liberada."""

    pass


  def getMemoriaRAMDisponivel(self) -> long:
    """Retorna a quantidade de memória RAM disponíve, em bytes, para processos em execução nesta máquina.<BR>
 OBS: nem toda a memória RAM instalada na máquina pode ser utilizada por esta aplicação Java. Parte da memória é utilizada
 pelo sistema operacional e por outros processos. Para saber qual é a maior quantidade de memória que pode ser utilizada
 por esta aplicação Java, mediante configuração, utilize o método {@link #getMemoriaHeapMaxima() getMemoriaHeapMaxima}<BR>
 Para saber qual é a parcela de memória que está disponível para esta aplicação Java, utilize o método {@link #getMemoriaHeapDisponivel() getMemoriaHeapDisponivel}."""

    pass


  def getMemoriaRAMMaxima(self) -> long:
    """Retorna a quantidade de memória RAM máxima, em bytes, que está instalada nesta máquina.<BR>
 OBS: nem toda a memória RAM instalada na máquina pode ser utilizada por esta aplicação Java. Parte da memória é utilizada
 pelo sistema operacional e por outros processos. Para saber qual é a maior quantidade de memória que pode ser utilizada
 por esta aplicação Java, mediante configuração, utilize o método {@link #getMemoriaHeapMaxima() getMemoriaHeapMaxima}"""

    pass


  def getMemoriaRAMUtilizada(self) -> long:
    """Retorna a quantidade de memória RAM utilizada, em bytes, por todos os processos que são executados nesta máquina.<BR>
 OBS: nem toda a memória RAM instalada na máquina pode ser utilizada por esta aplicação Java. Parte da memória é utilizada
 pelo sistema operacional e por outros processos. Para saber qual é a maior quantidade de memória que pode ser utilizada
 por esta aplicação Java, mediante configuração, utilize o método {@link #getMemoriaHeapMaxima() getMemoriaHeapMaxima}<BR>
 Para saber qual é a parcela de memória que está em uso por esta aplicação Java, utilize o método {@link #getMemoriaHeapUtilizada() getMemoriaHeapUtilizada}."""

    pass


  def getNomePrograma(self) -> str:
    """Retorna o nome do script que está sendo executado neste momento."""

    pass


  def getNomeProgramaPrincipal(self) -> str:
    """Retorna o nome do programa principal. Isto é, o nome do próprio script que está sendo executado, ou, caso este
 script tenha sido chamado de outro script, o 'programa principal' do script que o chamou."""

    pass


  def getNomesAnexos(self) -> list:
    """Retorna os nomes dos anexos ao script que está sendo executado."""

    pass


  def getNomesAnexosProgramaPrincipal(self) -> list:
    """Retorna os nomes dos anexos ao programa principal. Isto é, referentes ao próprio script que está sendo executado, ou, caso este
 script tenha sido chamado de outro script, referentes ao 'programa principal' do script que o chamou."""

    pass


  def getObrigatorioParametro(self, nome) -> bool:
    """Retorna flag que indica se este parâmero é de preenchimento obrigatório para execução
 do SCRIPT."""

    pass


  def getRuntimeParametro(self, nome) -> bool:
    """Retorna flag que indica se deve ser solicitado ao usuário, em tempo de execução
 do SCRIPT, que seja fornecido o valor do parâmetro."""

    pass


  def getTabelaParametro(self) -> Tabela:
    """Obtém informações dos parâmetros do Script em execução. Retorna os parâmetros do Script que o chama."""

    pass


  def getTipoParametro(self, nome) -> str:
    """Retorna o tipo do parâmetro."""

    pass


  def getValorParametro(self, nome) -> str:
    """Retorna o valor do parâmetro."""

    pass


  def getVariavel(self, nome) -> Object:
    """Obtém o conteúdo de uma variável definida no ambiente de execução do script, dado o nome da variável."""

    pass


  def isExecucaoLocal(self) -> bool:
    """Retorna a indicação de que este script é executado localmente na estação de trabalho do usuário."""

    pass


  def isExecucaoSegundoPlano(self) -> bool:
    """Indica se esta execução está ocorrendo em 'segundo plano'"""

    pass


  def isInterrompendo(self) -> bool:
    """Retorna a indicação de que o usuário mandou interromper o script via
 botão "Interrompe"."""

    pass


  def isScriptVisual(self) -> bool:
    """Retorna a indicação de que está executando um 'Script Visual'."""

    pass


  def mostraErro(self, msg) -> None:
    """Exibe uma mensagem de erro na janela de LOG."""

    pass


  def mostraMensagem(self, msg) -> None:
    """Exibe uma linha de informação na janela de LOG."""

    pass


  def removeIndicacaoAcesso(self, nomeRecurso) -> None:
    """Remove o acesso que foi adquirido através de {@link #setIndicacaoAcessoExclusivo(String) setIndicacaoAcessoExclusivo} ou de 
 {@link #setIndicacaoAcessoCompartilhado(String) setIndicacaoAcessoCompartilhado} ou de uma de suas variantes.<BR>
 É importante que o script execute este método, após ter sido bem sucedido em utilizar um dos demais métodos, para
 que seja sinalizado que o recurso não está mais sendo 'ocupado'. Caso contrário, ele permanecerá com esta indicação,
 até que a aplicação ContÁgil que adquiriu o acesso seja terminada."""

    pass


  def saveParametro(self, nome, valor) -> None:
    """Altera o valor do parâmetro do script e também salva este valor em disco de modo que, na próxima execução do script,
 o mesmo valor seja recuperado."""

    pass


  def setExecucaoSegundoPlano(self) -> None:
    """Coloca esta execução em 'segundo plano'<BR>
 ATENÇÃO: é altamente NÃO RECOMENDÁVEL utilizar este método!!!!<BR>
 Existem muitas funcionalidades do ContÁgil que não toleram a concorrência de execuções em segundo plano. Isso significa que podem
 ocorrer falhas aleatórias na aplicação enquanto o script estiver executando em segundo plano.<BR>
 Apenas utilize esta opção para situações muito específicas. Por exemplo, recomenda-se NÃO utilizar em segundo plano consultas MAD, tabelas do usuário,
 base de relacionamentos, janelas em geral."""

    pass


  def setIndicacaoAcessoCompartilhado(self, nomeRecurso, diretorio) -> bool:
    """Tenta adquirir acesso de forma 'não exclusiva' a um recurso qualquer por meio de um 'artefato' que é criado em disco.<BR>
 Indique o nome de um recurso qualquer (o nome pode ser qualquer coisa combinada com outro processo que faça
 uso do mesmo procedimento).<BR>
 O ContÁgil irá criar um arquivo em disco, utilizando o nome indicado, e sinalizará que está 'em uso', mas não evitará
 que outro processo tente fazer a mesma coisa (isto é, possibilita o 'compartilhamento').<BR>
 O arquivo é criado na pasta temporária. Isso significa que tal controle se restringe a processos sendo executados
 na mesma máquina.<BR>
 O mesmo processo (a mesma aplicação ContÁgil) que adquiriu o acesso, continuará a ter acesso, mesmo que este método
 seja executado sucessivas vezes.<BR>
 Este método alternativo permite indicar um 'diretório' onde o arquivo de controle de acesso será criado.<BR>
 Isto é, quando for desejável indicar que nenhum processo está utilizando um determinado recurso.<BR>
 ATENÇÃO: lembre-se de executar no final o método {@link #removeIndicacaoAcesso(String) removeIndicacaoAcesso} para 'liberar o acesso'
 (isto é, para permitir que outros processos possam utilizar o mesmo recurso). Caso isso não seja feito, o recurso
 será mantido 'ocupado', mesmo que o script tenha sido concluído, até que a aplicação inteira seja finalizada."""

    pass


  def setIndicacaoAcessoCompartilhado(self, nomeRecurso) -> bool:
    """Tenta adquirir acesso de forma 'não exclusiva' a um recurso qualquer por meio de um 'artefato' que é criado em disco.<BR>
 Indique o nome de um recurso qualquer (o nome pode ser qualquer coisa combinada com outro processo que faça
 uso do mesmo procedimento).<BR>
 O ContÁgil irá criar um arquivo em disco, utilizando o nome indicado, e sinalizará que está 'em uso', mas não evitará
 que outro processo tente fazer a mesma coisa (isto é, possibilita o 'compartilhamento').<BR>
 O arquivo é criado na pasta temporária. Isso significa que tal controle se restringe a processos sendo executados
 na mesma máquina.<BR>
 O mesmo processo (a mesma aplicação ContÁgil) que adquiriu o acesso, continuará a ter acesso, mesmo que este método
 seja executado sucessivas vezes.<BR>
 Utilize este mecanismo para sincronizar diferentes processos que precisam fazer uso compartilhado de algum recurso.<BR>
 Isto é, quando for desejável indicar que nenhum processo está utilizando um determinado recurso.<BR>
 ATENÇÃO: lembre-se de executar no final o método {@link #removeIndicacaoAcesso(String) removeIndicacaoAcesso} para 'liberar o acesso'
 (isto é, para permitir que outros processos possam utilizar o mesmo recurso). Caso isso não seja feito, o recurso
 será mantido 'ocupado', mesmo que o script tenha sido concluído, até que a aplicação inteira seja finalizada."""

    pass


  def setIndicacaoAcessoExclusivo(self, nomeRecurso, diretorio) -> bool:
    """Tenta adquirir acesso exclusivo a um recurso qualquer por meio de um 'artefato' que é criado em disco.<BR>
 Indique o nome de um recurso qualquer (o nome pode ser qualquer coisa combinada com outro processo que faça
 uso do mesmo procedimento).<BR>
 O ContÁgil irá criar um arquivo em disco, utilizando o nome indicado, e sinalizará 'bloqueio'. Isso significa
 que se outro processo tentar fazer a mesma coisa, ele será sinalizado de que o recurso está em uso.<BR>
 Este método alternativo permite indicar um 'diretório' onde o arquivo de controle de acesso será criado.<BR>
 Utilize este mecanismo para sincronizar diferentes processos que precisam fazer uso exclusivo de algum recurso.<BR>
 O mesmo processo (a mesma aplicação ContÁgil) que adquiriu o acesso, continuará a ter acesso, mesmo que este método
 seja executado sucessivas vezes.<BR>
 ATENÇÃO: lembre-se de executar no final o método {@link #removeIndicacaoAcesso(String) removeIndicacaoAcesso} para 'liberar o acesso'
 (isto é, para permitir que outros processos possam utilizar o mesmo recurso). Caso isso não seja feito, o recurso
 será mantido 'ocupado', mesmo que o script tenha sido concluído, até que a aplicação inteira seja finalizada."""

    pass


  def setIndicacaoAcessoExclusivo(self, nomeRecurso) -> bool:
    """Tenta adquirir acesso exclusivo a um recurso qualquer por meio de um 'artefato' que é criado em disco.<BR>
 Indique o nome de um recurso qualquer (o nome pode ser qualquer coisa combinada com outro processo que faça
 uso do mesmo procedimento).<BR>
 O ContÁgil irá criar um arquivo em disco, utilizando o nome indicado, e sinalizará 'bloqueio'. Isso significa
 que se outro processo tentar fazer a mesma coisa, ele será sinalizado de que o recurso está em uso.<BR>
 O arquivo é criado na pasta temporária. Isso significa que tal controle se restringe a processos sendo executados
 na mesma máquina.<BR>
 O mesmo processo (a mesma aplicação ContÁgil) que adquiriu o acesso, continuará a ter acesso, mesmo que este método
 seja executado sucessivas vezes.<BR>
 Utilize este mecanismo para sincronizar diferentes processos que precisam fazer uso exclusivo de algum recurso.<BR>
 ATENÇÃO: lembre-se de executar no final o método {@link #removeIndicacaoAcesso(String) removeIndicacaoAcesso} para 'liberar o acesso'
 (isto é, para permitir que outros processos possam utilizar o mesmo recurso). Caso isso não seja feito, o recurso
 será mantido 'ocupado', mesmo que o script tenha sido concluído, até que a aplicação inteira seja finalizada."""

    pass


  def toString(self) -> str:
    pass

class FTP ():
  """Objeto que pode ser utilizado por uma linguagem de script para fazer
 operações de transferências de arquivos com um servidor FTP (o script
 comporta-se como cliente).<BR>
 
 Este objeto está acessível para a linguagem de script através do nome "ftp".<BR>"""

  def autentica(self, url, login, senha) -> None:
    """Faz autenticação no servidor FTP.<BR>
 Se ocorrer um erro (ex: servidor não disponível ou senha inválida), o
 método joga exceção.<BR>
 Atenção: utilize este método apenas em situações onde o login e a senha
 podem se tornar de conhecimento público, pois eles ficam expostos no
 código fonte do script. Caso seja necessário proteger esses dados,
 utilize o método alternativo de autenticação que utiliza um objeto
 {@link Chave Chave} (o qual, por sua vez, pode ser solicitado do
 usuário).<BR>"""

    pass


  def autentica(self, url, chave) -> None:
    """Faz autenticação no servidor FTP.<BR>
 Se ocorrer um erro (ex: servidor não disponível ou senha inválida), o
 método joga exceção."""

    pass


  def createListener(self, progress) -> MyCopyStreamListener:
    """Uma implementação da uma interface que acompanha o andamento do download/upload do arquivo"""

    pass


  def desconecta(self) -> None:
    """Caso esteja com uma conexão ativa no servidor FTP, desconecta. Caso
 contrário, não faz nada."""

    pass


  def download(self, arquivo, destino) -> Arquivo:
    """Faz um download de um arquivo do servidor FTP cujo nome é apontado no
 parâmetro e armazena em um arquivo local.<BR>
 Em caso de erro, joga exceção.<BR>
 O método não retorna enquanto o download não é concluído por completo.<BR>"""

    pass


  def download(self, arquivo, destino, resume, listener) -> Arquivo:
    """Faz um download de um arquivo do servidor FTP cujo nome é apontado no
 parâmetro e armazena em um arquivo local.<BR>
 Em caso de erro, joga exceção.<BR>
 O método não retorna enquanto o download não é concluído por completo.<BR>"""

    pass


  def download(self, arquivo, destino) -> Arquivo:
    """Faz um download de um arquivo do servidor FTP cujo nome é apontado no
 parâmetro e armazena em um arquivo local.<BR>
 Em caso de erro, joga exceção.<BR>
 O método não retorna enquanto o download não é concluído por completo.<BR>"""

    pass


  def download(self, arquivo, destino, resume, listener) -> Arquivo:
    """Faz um download de um arquivo do servidor FTP cujo nome é apontado no
 parâmetro e armazena em um arquivo local.<BR>
 Em caso de erro, joga exceção.<BR>
 O método não retorna enquanto o download não é concluído por completo.<BR>"""

    pass


  def getDiretorioAtual(self) -> str:
    """Retorna o nome do diretório atual no servidor FTP"""

    pass


  def getFileLastTimeStamp(self, arquivo) -> long:
    """Retorna a data e hora em que o arquivo foi modificado pela última vez."""

    pass


  def getTamanhoArquivo(self, arquivo) -> long:
    """Dado um nome de arquivo (nome completo, incluindo o dirtório), retorna o tamanho ocupado pelo arquivo
 em disco"""

    pass


  def isConectado(self) -> bool:
    """Retorna a indicação de que está conectado no servidor FTP"""

    pass


  def listaArquivos(self) -> list:
    """Lista os arquivos que existem dentro do diretório atual no servidor FTP.<BR>
 Não inclui nesta lista os nomes dos subdiretórios."""

    pass


  def listaDiretorios(self) -> list:
    """Lista os nomes dos subdiretórios encontrados no diretório atual no
 servidor FTP.<BR>
 Cada nome inclui o nome do diretório atual separado por "\" ou por "/"
 (depende de como o próprio servidor padroniza a separação de diretórios).<BR>"""

    pass


  def listaSubdiretorios(self) -> list:
    """Faz o mesmo que a função {@link FTP#listaDiretorios() listaDiretorios}"""

    pass


  def setASCIIFileType(self) -> None:
    """Configura o tipo de arquivo para a tranferência como sendo do tipo TEXTO"""

    pass


  def setBinaryFileType(self) -> None:
    """Configura o tipo de arquivo para a tranferência como sendo do tipo BINÁRIO"""

    pass


  def setDiretorioAtual(self, diretorio) -> None:
    """Altera o diretório atual no servidor FTP"""

    pass


  def toString(self) -> str:
    pass


  def upload(self, arquivo, destino) -> Arquivo:
    """Faz um upload de um arquivo local para o servidor FTP.<BR>
 Em caso de erro, joga exceção.<BR>
 O método não retorna enquanto o upload não é concluído por completo.<BR>"""

    pass


  def upload(self, arquivo, destino) -> Arquivo:
    """Faz um upload de um arquivo local para o servidor FTP.<BR>
 Em caso de erro, joga exceção.<BR>
 O método não retorna enquanto o upload não é concluído por completo.<BR>"""

    pass


  def uploadComJanela(self, arquivo, destino, mensagem, pode_interromper) -> Arquivo:
    """Método alternativo que faz o upload de um arquivo e também mostra para o
 usuário através de uma janela o progresso nesta transferência individual."""

    pass

class Formulario ():

  def criarCampoAno(self, nomeCampo, valorInicial, preenchimentoObrigatorio) -> FormularioCampoAno:
    """Cria no formulário um campo para preenchimento de um ano."""

    pass


  def criarCampoAno(self, nomeCampo, preenchimentoObrigatorio) -> FormularioCampoAno:
    """Cria no formulário um campo para preenchimento de um ano."""

    pass


  def criarCampoData(self, nomeCampo, preenchimentoObrigatorio) -> FormularioCampoData:
    """Cria no formulário um campo para preenchimento de uma data no forma
 dd/mm/aaaa."""

    pass


  def criarCampoData(self, nomeCampo, dataInicial, preenchimentoObrigatorio) -> FormularioCampoData:
    """Cria no formulário um campo para preenchimento de uma data no forma
 dd/mm/aaaa."""

    pass


  def criarCampoNumeroInteiro(self, nomeCampo, valorInicial, preenchimentoObrigatorio) -> FormularioCampoNumeroInteiro:
    """Cria no formulário um campo para preenchimento de um número inteiro."""

    pass


  def criarCampoNumeroInteiro(self, nomeCampo, preenchimentoObrigatorio) -> FormularioCampoNumeroInteiro:
    """Cria no formulário um campo para preenchimento de um número inteiro."""

    pass


  def criarCampoTexto(self, nomeCampo, textoInicial, preenchimentoObrigatorio) -> FormularioCampoTexto:
    """Cria no formulário um campo para preenchimento de um texto."""

    pass


  def criarCampoTexto(self, nomeCampo, preenchimentoObrigatorio) -> FormularioCampoTexto:
    """Cria no formulário um campo para preenchimento de um texto."""

    pass


  def criarCampoValorMonetario(self, nomeCampo, valorInicial, preenchimentoObrigatorio) -> FormularioCampoMonetario:
    """Cria no formulário um campo para preenchimento valor em moeda (R$)."""

    pass


  def criarCampoValorMonetario(self, nomeCampo, preenchimentoObrigatorio) -> FormularioCampoMonetario:
    """Cria no formulário um campo para preenchimento valor em moeda (R$)."""

    pass


  def criarCheckbox(self, nomeCampo, opcoes, preenchimentoObrigatorio) -> FormularioCheckbox:
    """Cria no formulário um campo do tipo checkbox"""

    pass


  def criarCombobox(self, nomeCampo, opcoes, preenchimentoObrigatorio) -> FormularioComboBox:
    """Cria no formulário um campo do tipo combobox"""

    pass


  def exibir(self) -> None:
    """Exibe o formulário com os campos configurados"""

    pass


  def getCampo(self, nome) -> FormularioCampo:
    """Retorna o campo que foi inserido no formulário com um determinado nome. Não faz distinção quanto a letra maiúscula/minúscula
 ou acentuação."""

    pass


  def getCampos(self) -> list:
    """Retorna a relação de todos os campos que foram inseridos no formulário"""

    pass


  def main(self, args) -> None:
    pass


  def okButtonAction(self) -> None:
    pass


  def setMensagem(self, mensagem) -> None:
    """Define a mensagem que será exibida acima do formulário"""

    pass


  def usuarioClicouOk(self) -> bool:
    """Método para verificar se o formulário foi fechado pressionando o botão "Ok",
 o que só é possível se todos os campos passarem na validação."""

    pass

class FormularioCampo ():

  def getNomeCampo(self) -> str:
    pass


  def toString(self) -> str:
    pass


  def validarObrigatoriedadeEParametro(self) -> None:
    """Verifica se o preenchimento obrigatório foi realizado, e a realiza a validação
 específica do campo"""

    pass

class FormularioCampoAno ():

  def getValor(self) -> int:
    pass


  def setValorInicial(self, valorInicial) -> None:
    pass

class FormularioCampoBaseTexto ():

  def getTexto(self) -> str:
    pass


  def toString(self) -> str:
    pass


  def validarObrigatoriedadeEParametro(self) -> None:
    """Verifica se o preenchimento obrigatório foi realizado, e a validação
 específica do campo"""

    pass

class FormularioCampoData ():

  def getAno(self) -> int:
    pass


  def getData(self) -> Data:
    pass


  def getDia(self) -> int:
    pass


  def getMes(self) -> int:
    pass


  def getTexto(self) -> str:
    """Retorna a data no formato texto dd/mm/yyyy Caso a data seja inválida, retorna
 uma string vazia"""

    pass


  def setDataInicial(self, dataInicial) -> None:
    """permite configurar uma data inicialmente preenchida no campo do formulário"""

    pass

class FormularioCampoMonetario ():

  def getValor(self) -> Double:
    pass


  def setValorInicial(self, valorInicial) -> None:
    pass

class FormularioCampoNumeroInteiro ():

  def setValorInicial(self, valorInicial) -> None:
    pass


  def setValorMaximo(self, valorMaximo) -> None:
    """Configura o valor máximo que será utilizado
 na validação do valor preenchido no campo"""

    pass


  def setValorMinimo(self, valorMinimo) -> None:
    """Configura o valor mínimo que será utilizado
 na validação do valor preenchido no campo"""

    pass


  def setValoresMinimoEMaximo(self, valorMinimo, valorMaximo) -> None:
    """Configura os valores mínimo e máximo que serão utilizados
 na validação do valor preenchido no campo"""

    pass

class FormularioCampoTexto ():

  def configurarTextoInicial(self, textoInicial) -> None:
    pass

class FormularioCheckbox ():

  def adicionarEvento(self, opcao, actionListener) -> None:
    """Este método permite a inclusão de eventos no combobox, tornando possível a
 alteração do formulário de forma dinâmica.
 

 Exemplo de utilização em Python:<BR>
 <BR>
 <pre> {@code
> form = janelas.criarFormulario("Dados Básicos")
> 
> cbxs = form.criarCheckbox("Escopo notas", ["Notas de Processo", "Notas de Equipe", "Notas de Usuário"], True)
> 
> def actionPerformed(event): 
> 
>     source = event.getSource() 
> 	itemSelecionado = source.getText()
>     opcoesSelecionadas = cbxs.getListaItensSelecionados()
> 
>     if itemSelecionado in opcoesSelecionadas:
>         for opcao in opcoesSelecionadas:
>				if opcao ==  itemSelecionado:
> 				continue
>				cbxs.desmarcarOpcao(opcao)
> 
> cbxs.adicionarEvento("Notas de Processo", actionPerformed)
> cbxs.adicionarEvento("Notas de Equipe", actionPerformed)
> cbxs.adicionarEvento("Notas de Usuário", actionPerformed)
>
> form.exibir()
>
> if form.usuarioClicouOk():
>     opcao = cbxs.getListaItensSelecionados()[0]
>     
 }</pre>
<BR>
Exemplo de utilização em JavaScript:<BR>
<BR>
 <pre> {@code
> form = janelas.criarFormulario("Dados Básicos");
> 
> cbxs = form.criarCheckbox("Escopo notas", ["Notas de Processo", "Notas de Equipe", "Notas de Usuário"], true);
> 
> checkBoxActionPerformed = function(event){
> 
>     source = event.getSource();
>     itemSelecionado = source.getText();
>		opcoesSelecionadas = cbxs.getListaItensSelecionados(); 
>		 
>     if (opcoesSelecionadas.contains(itemSelecionado)){
>         for (i = 0; i < opcoesSelecionadas.size(); i++){
> 
>             if (opcoesSelecionadas.get(i) ==  itemSelecionado){
>                 continue;
>             };
>             cbxs.desmarcarOpcao(opcoesSelecionadas.get(i));
>         };
>     };
> };
> 
> cbxs.adicionarEvento("Notas de Processo", checkBoxActionPerformed);
> cbxs.adicionarEvento("Notas de Equipe", checkBoxActionPerformed);
> cbxs.adicionarEvento("Notas de Usuário", checkBoxActionPerformed);
> 
> form.exibir();
> if (form.usuarioClicouOk()){   
>     opcao = cbxs.getListaItensSelecionados().get(0);
> };
> 
 }</pre>
 
 Nos exemplos acima, foi utilizado o método getSource() que retorna o componente que disparou o evento,
 neste caso, o evento foi disparado internamente pelo componente JCheckBox e não pelo FormularioCheckbox.
 Asim, o usuário deve consultar os métodos disponíveis na documentação do próprio JCheckBox.
 
 Observação: Como o formulário é executado em outra Thread, as funções
 print (python) e println (javascript) não funcionam, caso se deseje mostrar alguma mensagem no log
 deve-se utilizar algum método do objeto log, por exemplo: 
 {@link org.guga.contagil.scripting.impl.LOGImpl#mostraMensagem(String) mostraMensagem}."""

    pass


  def desmarcarOpcao(self, opcao) -> None:
    pass


  def getListaItensSelecionados(self) -> list:
    pass


  def isOpcaoSelecionada(self, opcao) -> bool:
    pass


  def marcarOpcao(self, opcao) -> None:
    pass


  def setNumeroMinimoSelecoes(self, numeroMinimo) -> None:
    pass


  def validarObrigatoriedadeEParametro(self) -> None:
    pass

class FormularioComboBox ():

  def adicionarEvento(self, actionListener) -> None:
    """Este método permite a inclusão de eventos no combobox, tornando possível a
 alteração do formulário de forma dinâmica
 
 Exemplo de utilização em Python:<BR>
 <BR>
 <pre> {@code
> form = janelas.criarFormulario("Unidades RFB")
> 
> combobox1 = form.criarCombobox("TipoUnidades", ["SRRF", "DRF", "ARF"], True)
> combobox2 = form.criarCombobox("Unidades", [], True)
> 
> def actionPerformed(event): 
> 
>     source = event.getSource() 
>     itemSelecionado = source.getSelectedItem()
> 
>     if itemSelecionado == "SRRF":
>         combobox2.alterarOpcoes(["SRRF01", "SRRF02"])
>			print("Tipo Unidade selecionado") # não funciona
>			log.mostraMensagem("Tipo Unidade selecionado") # funciona
> 
>     elif itemSelecionado == "DRF":
>         combobox2.alterarOpcoes(["DRF-CUIABA-MT", "DRF-JUNDIAI-SP"])
> 
>     elif itemSelecionado == "ARF":
>         combobox2.alterarOpcoes(["ARF-RONDONOPOLIS-MT", "ARF-ITU-SP"])
> 
> combobox1.adicionarEvento(actionPerformed)
> form.exibir()
>
> if form.usuarioClicouOk():
>     tipoUnidade = combobox1.getOpcaoSelecionada()
>     unidade     = combobox2.getOpcaoSelecionada()
>
 }</pre>
<BR>
<BR>
Exemplo de utilização em JavaScript:<BR>
<BR>
 <pre> {@code
> form = janelas.criarFormulario("Unidades RFB");
> 
> combobox1 = form.criarCombobox("TipoUnidades", ["SRRF", "DRF", "ARF"], true);
> combobox2 = form.criarCombobox("Unidades", [], true);
> 
> combobox1.adicionarEvento(function(event){
> 
>     source = event.getSource();
>     itemSelecionado = source.getSelectedItem();
> 
>     if (itemSelecionado == "SRRF"){
>         combobox2.alterarOpcoes(["SRRF01", "SRRF02"]);
>			println("Tipo Unidade selecionado") // não funciona
>			log.mostraMensagem("Tipo Unidade selecionado") // funciona
>     }
>     else if (itemSelecionado == "DRF"){
>         combobox2.alterarOpcoes(["DRF-CUIABA-MT", "DRF-JUNDIAI-SP"]);
> 	}
>     else if (itemSelecionado == "ARF"){
>         combobox2.alterarOpcoes(["ARF-RONDONOPOLIS-MT", "ARF-ITU-SP"]);
> 	};
> });
>
> form.exibir();
>
> if (form.usuarioClicouOk()){
>     tipoUnidade = combobox1.getOpcaoSelecionada();
>     unidade     = combobox2.getOpcaoSelecionada();
> };
 }</pre>
 
 Nos exemplos acima, foi utilizado o método getSource() que retorna o componente que disparou o evento,
 neste caso, o evento foi disparado internamente pelo componente JComboBox e não pelo FormularioComboBox.
 Asim, o usuário deve consultar os métodos disponíveis na documentação do próprio JComboBox.
 
 Observação: Como o formulário é executado em outra Thread, as funções
 print (python) e println (javascript) não funcionam, caso se deseje mostrar alguma mensagem no log
 deve-se utilizar algum método do objeto log, por exemplo: 
 {@link org.guga.contagil.scripting.impl.LOGImpl#mostraMensagem(String) mostraMensagem}."""

    pass


  def alterarOpcoes(self, novasOpcoes) -> None:
    """Este método normalmente é utilizado em conjunto com o 
 {@link FormularioComboBox#adicionarEvento(ActionListener) adicionarEvento}.
 Ele permite alterar a lista de opções de um {@link FormularioComboBox}, enquanto o 
 formulário é exibido para o usuário.
 
 
 Para um exemplo de utilização, consulte a documentação do método 
 {@link FormularioComboBox#adicionarEvento(ActionListener) adicionarEvento}"""

    pass


  def getIndiceOpcaoSelecionada(self) -> int:
    pass


  def getOpcaoSelecionada(self) -> str:
    pass


  def setOpcaoDefault(self, opcao) -> None:
    pass


  def validarObrigatoriedadeEParametro(self) -> None:
    """Verifica se o preenchimento obrigatório foi realizado, e a validação
 específica do campo"""

    pass

class GeradorCombinatorio ():
  """Gerador Combinatório para script."""

  def getNext(self) -> int:
    """Obtém a próxima combinação."""

    pass


  def getNumberOfElements(self) -> int:
    """Retorna a quantidade de elementos cujas combinações estão sendo gerados.
 Este valor diminui quando a função "remove" é executada."""

    pass


  def hasNext(self) -> bool:
    """Verifica se há mais combinações a percorrer."""

    pass


  def remove(self, index) -> None:
    """Remove o elemento de índice "index" das próximas combinações."""

    pass


  def reset(self, r) -> bool:
    """Resseta o gerador retornando para o início com alteração
 da quantidade de elementos por combinação."""

    pass


  def reset(self) -> bool:
    """Resseta o gerador retornando para o início."""

    pass

class GerenciadorArquivos ():
  """Classe utilizada por linguagem de scripting para realizar algumas operações
 com arquivos, tais como:<BR>
 &nbsp;&nbsp;&nbsp;Criar arquivo TXT com campos separados por vírgula<BR>
 &nbsp;&nbsp;&nbsp;Criar arquivo PDF<BR>
 &nbsp;&nbsp;&nbsp;Criar arquivo XLS<BR>
 &nbsp;&nbsp;&nbsp;Criptografar arquivos<BR>
 &nbsp;&nbsp;&nbsp;Descriptografar arquivos<BR>
 <BR>
 Este objeto está acessível para a linguagem de script através do nome
 "arquivos".<BR>"""

  def abrirArquivoCompactado(self, arquivo) -> ArquivoCompactado:
    """Idem à função
 {@link GerenciadorArquivos#abrirArquivoCompactado(String, String) abrirArquivoCompactado} de dois
 parâmetros, mas com apenas um parâmetro do tipo {@link Arquivo Arquivo}."""

    pass


  def abrirArquivoCompactado(self, diretorio, nomeArquivo) -> ArquivoCompactado:
    """Abre para leitura um arquivo compactado existente, utilizando bibliotecas do 7Zip, nos formatos:
 - 7-Zip, Zip, Rar, Tar, Split, Lzma, Iso, HFS, GZip, Cpio, BZip2, Arj, Chm, Lhz, Cab, Nsis, Deb, Rpm, Wim, Udf
 Se o arquivo não existe, retorna NULL.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o arquivo aberto (por exemplo, para ler
 informações no arquivo aberto).<BR>
 Por exemplo:<BR>
 <CODE> // Abre um arquivo chamado TESTE.RAR na pasta de trabalho do
 ContÁgil.<BR>
 arquivo = arquivos.abrirArquivoCompactado(null,"TESTE");<BR>
 </CODE>
 ATENÇÃO: este método apenas pode ser utilizado nas execuções locais. Não pode ser utilizado na execução em servidor (ambiente HADOOP).
 Caso queira expandir um arquivo ZIP em ambiente HADOOP, utilize o método {@link #abrirZIP(String, String) abrirZIP}."""

    pass


  def abrirArquivoTexto(self, nomeArquivo) -> ArquivoTexto:
    """Abre um arquivo texto simples (por "simples" entende-se que o arquivo não
 possui uma "estrutura" pre-definida de separação de campos).<BR>
 Se o arquivo não existe, retorna NULL.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o arquivo aberto (por exemplo, para ler
 informações no arquivo aberto).<BR>"""

    pass


  def abrirArquivoTexto(self, diretorio, nomeArquivo) -> ArquivoTexto:
    """Abre um arquivo texto simples (por "simples" entende-se que o arquivo não
 possui uma "estrutura" pre-definida de separação de campos).<BR>
 Se o arquivo não existe, retorna NULL.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o arquivo aberto (por exemplo, para ler
 informações no arquivo aberto).<BR>
 Por exemplo:<BR>
 <CODE> // Abre um arquivo chamado TESTE.TXT na pasta de trabalho do
 ContÁgil<BR>
 arquivo = arquivos.abrirArquivoTexto(null,"TESTE");<BR>
 </CODE>"""

    pass


  def abrirArquivoTexto(self, arquivo) -> ArquivoTexto:
    """Idem à função
 {@link GerenciadorArquivos#abrirArquivoTexto(String, String) abrirArquivoTexto} de dois
 parâmetros, mas com apenas um parâmetro do tipo {@link Arquivo Arquivo}."""

    pass


  def abrirArquivoTextoPosicoesFixas(self, arquivo) -> ArquivoPosicoesFixas:
    """Idem à função
 {@link GerenciadorArquivos#abrirArquivoTextoPosicoesFixas(String, String) abrirArquivoTextoPosicoesFixas}
 de dois parâmetros, mas com apenas um parâmetro do tipo
 {@link Arquivo Arquivo}."""

    pass


  def abrirArquivoTextoPosicoesFixas(self, nomeArquivo) -> ArquivoPosicoesFixas:
    """Abre um arquivo texto existente do tipo que tem campos definidos em
 posições e tamanhos fixos.<BR>
 Caso todas as linhas do arquivo sigam um mesmo padrão de separação de
 campos, ao invés de utilizar este método utilize o método alternativo
 onde se indica o parâmetro adicional "tamanhoColunas", contendo o tamanho
 de cada campo.<BR>
 Se o arquivo não existe, retorna NULL.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o arquivo aberto (por exemplo, para ler
 informações no arquivo aberto).<BR>"""

    pass


  def abrirArquivoTextoPosicoesFixas(self, diretorio, nomeArquivo, tamanhosColunas) -> ArquivoPosicoesFixas:
    """Abre um arquivo texto existente do tipo em que os campos possuem posições
 e tamanhos fixos em cada linha. Caso exista algum caractere especial
 utilizado para separação dos campos (por exemplo, vírgulas ou
 ponto-e-vírgulas), utilize o método
 {@link GerenciadorArquivos#abrirCSV(String, String, char) abrirCSV}, ou
 uma das alternativas com diferentes parâmetros.<BR>
 Se o arquivo não existe, retorna NULL.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o arquivo aberto (por exemplo, para ler
 informações no arquivo aberto).<BR>
 Para que seja possível "quebrar" as linhas do arquivo texto em segmentos
 menores, um dos parâmetros desta função requer que sejam indicados os
 "tamanhos" de cada coluna.<BR>
 Note que se o arquivo for do tipo que contém diferentes "tipos" de
 linhas, onde para cada "tipo" temos uma quantidade diferente de "campos"
 (e também de diferentes "tamanhos"), este parâmetro é ineficaz, pois
 neste caso não há como estabelecer um único "padrão" para o arquivo
 inteiro. Nesta hipótese, pode-se indicar NULL neste parâmetro e depois
 utilizar métodos específicos de
 {@link ArquivoPosicoesFixas ArquivoPosicoesFixas} onde é possível definir
 durante a consulta qual é o "padrão" a ser seguido em cada "tipo" de
 linha.<BR>
 Exemplo 1:<BR>
 <CODE> // Abre um arquivo chamado TESTE.TXT na pasta de trabalho do
 ContÁgil onde todas as linhas do arquivo<BR> // seguem um mesmo padrão
 (10 posições para o primeiro campo, 20 posições para o segundo, 5
 posições para o terceiro).<BR>
 arquivo =
 arquivos.abrirArquivoTextoPosicoesFixas(null,"TESTE",[10,20,5]);<BR>
 </CODE>"""

    pass


  def abrirArquivoTextoPosicoesFixas(self, arquivo, tamanhosColunas) -> ArquivoPosicoesFixas:
    """Idem à função
 {@link GerenciadorArquivos#abrirArquivoTextoPosicoesFixas(String, String, int[]) abrirArquivoTextoPosicoesFixas}
 de três parâmetros, mas com apenas um parâmetro do tipo
 {@link Arquivo Arquivo} e um parâmetro de indicação dos tamanhos de cada
 campo em cada linha."""

    pass


  def abrirArquivoTextoPosicoesFixas(self, diretorio, nomeArquivo) -> ArquivoPosicoesFixas:
    """Abre um arquivo texto existente do tipo que tem campos definidos em
 posições e tamanhos fixos.<BR>
 Caso todas as linhas do arquivo sigam um mesmo padrão de separação de
 campos, ao invés de utilizar este método utilize o método alternativo
 onde se indica o parâmetro adicional "tamanhoColunas", contendo o tamanho
 de cada campo.<BR>
 Se o arquivo não existe, retorna NULL.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o arquivo aberto (por exemplo, para ler
 informações no arquivo aberto).<BR>
 Por exemplo:<BR>
 <CODE> // Abre um arquivo chamado TESTE.TXT na pasta de trabalho do
 ContÁgil<BR>
 arquivo = arquivos.abrirArquivoTextoPosicoesFixas(null,"TESTE");<BR>
 </CODE>"""

    pass


  def abrirArquivoTextoPosicoesFixasSemSeparacaoLinhas(self, diretorio, nomeArquivo, tamanhosColunas) -> ArquivoPosicoesFixas:
    """Faz o mesmo que o método {@link GerenciadorArquivos#abrirArquivoTextoPosicoesFixas(String, String, int[]) abrirArquivoTextoPosicoesFixas},
 com a diferença que neste caso não se espera encontrar um caractere específico de "separação de linhas" (caractere ASC 13).<BR>
 Isto é, neste método presume-se que uma "linha" se distingue da outra apenas pela quantidade de caracteres que estão presentes em cada linha.<BR>
 Neste caso, após a ocorrência do total de "tamanhos" de todas as colunas de uma linha, considera-se que o que vem depois refere-se à "linha" seguinte, e
 assim sucessivamente."""

    pass


  def abrirBackup(self, diretorio, nomeArquivo) -> CopiaBackup:
    """Abre um arquivo de backup existente para restauração.<BR>
 Se o arquivo não existe, retorna NULL.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o arquivo aberto (por exemplo, indicar quais
 componentes existentes no BACKUP que deseja de fato restaurar).<BR>
 Note que a simples execução deste método não restaura imediatamente os
 dados. É necessário cumprir os passos intermediários de indicação do que
 deve ser restaurado. A restauração ocorre somente depois, quando o
 arquivo é "fechado".<BR>
 IMPORTANTE: não é recomendável utilizar este procedimento fora do escopo
 de um PROJETO. Algumas estruturas, tais como "tabelas do usuário", não
 possuem significado nenhum fora do escopo de um PROJETO. Portanto, a
 tentativa de restaurar dados de um arquivo de backup para a pasta de
 trabalho do ContÁgil sem a prévia abertura de um projeto existente pode
 ocasionar incosistência do ambiente.<BR>"""

    pass


  def abrirCSV(self, arquivo, separador) -> ArquivoCSV:
    """Idem à função
 {@link GerenciadorArquivos#abrirCSV(String, String, char) abrirCSV} de
 três parâmetros, mas com apenas um parâmetro do tipo
 {@link Arquivo Arquivo} e um parâmetro de indicação do caractere
 separador de campos."""

    pass


  def abrirCSV(self, arquivo) -> ArquivoCSV:
    """Idem à função
 {@link GerenciadorArquivos#abrirCSV(String, String) abrirCSV} de dois
 parâmetros, mas com apenas um parâmetro do tipo {@link Arquivo Arquivo}."""

    pass


  def abrirCSV(self, diretorio, nomeArquivo, separador) -> ArquivoCSV:
    """Abre um arquivo texto existente do tipo que tem separação por um
 caractere especial (que pode ser a vírgula ou outro caractere).<BR>
 Se o arquivo não existe, retorna NULL.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o arquivo aberto (por exemplo, para ler
 informações no arquivo aberto).<BR>
 Por exemplo:<BR>
 <CODE> // Abre um arquivo chamado TESTE.TXT na pasta de trabalho do
 ContÁgil utilizando o "ponto e vírgula"<BR> // como caractere de
 separação.<BR>
 arquivo = arquivos.abrirCSV(null,"TESTE",';');<BR>
 <BR> // Abre um arquivo chamado TESTE2.TXT na pasta de trabalho do
 ContÁgil utilizando o "tab"<BR> // como caractere de separação.<BR>
 arquivo = arquivos.abrirCSV(null,"TESTE2",'\t');<BR>
 </CODE>"""

    pass


  def abrirCSV(self, nomeArquivo) -> ArquivoCSV:
    """Abre um arquivo texto existente do tipo que tem separação por "ponto e
 vírgula".<BR>
 Se o arquivo não existe, retorna NULL.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o arquivo aberto (por exemplo, para ler
 informações no arquivo aberto).<BR>"""

    pass


  def abrirCSV(self, diretorio, nomeArquivo) -> ArquivoCSV:
    """Abre um arquivo texto existente do tipo que tem separação por "ponto e
 vírgula".<BR>
 Se o arquivo não existe, retorna NULL.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o arquivo aberto (por exemplo, para ler
 informações no arquivo aberto).<BR>
 Por exemplo:<BR>
 <CODE> // Abre um arquivo chamado TESTE.TXT na pasta de trabalho do
 ContÁgil utilizando o "ponto e vírgula"<BR> // como caractere de
 separação.<BR>
 arquivo = arquivos.abrirCSV(null,"TESTE");<BR>
 </CODE>"""

    pass


  def abrirCSVObtendoSeparador(self, arquivo) -> ArquivoCSV:
    """Abre um arquivo texto existente do tipo que tem separação por um
 caractere especial (que pode ser a vírgula ou outro caractere), obtendo 
 o separador a partir da primeira linha do arquivo.<BR>
 Os separadores aceitos são: ';', ',', '|', '\t', ':', '~' <BR>
 O caractere do conjunto acima que apresentar maior frequência na primeira
 linha é definido como separador do arquivo.<BR>
 Se o arquivo não existe, retorna NULL.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o arquivo aberto (por exemplo, para ler
 informações no arquivo aberto).<BR>
 Por exemplo:<BR>
 <CODE> // Abre um arquivo chamado TESTE.TXT <BR>
 arquivo = arquivos.abrirCSVObtendoSeparador"TESTE");
 <BR> //Obtém o separador usado no arquivo <BR>
 separador = arquivo.getSeparador();
 <BR> A variável separador vai conter o caractere de separador do arquivo CSV"""

    pass


  def abrirDOCComoTexto(self, diretorio, nomeArquivo) -> ArquivoTexto:
    """Abre um arquivo de conteúdo DOC (padrão do aplicativo Word do MS Office)
 previamente armazenado no computador local e apresenta-o na forma de um
 arquivo TEXTO (isto é, um objeto do tipo
 {@link ArquivoTexto ArquivoTexto}.<BR>
 Se o arquivo não existe, retorna NULL.<BR>
 Se o conteúdo não pode ser obtido no formato texto por algum motivo,
 retorna NULL.<BR>
 OBS: o conteúdo em formato texto pode não se apresentar visivelmente da
 mesma maneira com que é apresentado o conteúdo original.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o conteúdo aberto (por exemplo, para apresentar
 as diversas linhas, ou quebrar cada linha em "campos" em função dos
 espaços em branco que os separam).<BR>
 Por exemplo:<BR>
 <CODE> // Abre um arquivo chamado TESTE.DOC na pasta de trabalho do
 ContÁgil.<BR>
 pagina = arquivos.abrirDOCComoTexto(null,"TESTE");<BR>
 </CODE>"""

    pass


  def abrirDOCComoTexto(self, nomeArquivo) -> ArquivoTexto:
    """Idem à função
 {@link GerenciadorArquivos#abrirDOCComoTexto(String, String) abrirDOCComoTexto}
 de dois parâmetros, mas apenas com a indicação do nome do arquivo (o qual
 deve conter também o nome do diretório onde está o arquivo)."""

    pass


  def abrirDOCComoTexto(self, arquivo) -> ArquivoTexto:
    """Idem à função
 {@link GerenciadorArquivos#abrirDOCComoTexto(String, String) abrirDOCComoTexto}
 de dois parâmetros, mas com apenas um parâmetro do tipo
 {@link Arquivo Arquivo}."""

    pass


  def abrirExcel(self, arquivo) -> ArquivoExcel:
    """Idem à função
 {@link GerenciadorArquivos#abrirExcel(String, String) abrirExcel} de dois
 parâmetros, mas com apenas um parâmetro do tipo {@link Arquivo Arquivo}."""

    pass


  def abrirExcel(self, diretorio, nomeArquivo) -> ArquivoExcel:
    """Abre para leitura um arquivo existente do Excel, podendo ser o padrão
 antigo (extensão XLS) ou o padrão novo (extensão XLSX).<BR>
 Se o arquivo não existe, retorna NULL.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o arquivo aberto (por exemplo, para ler
 informações no arquivo aberto).<BR>
 Por exemplo:<BR>
 <CODE> // Abre um arquivo chamado TESTE.XLS na pasta de trabalho do
 ContÁgil.<BR>
 arquivo = arquivos.abrirExcel(null,"TESTE");<BR>
 </CODE>"""

    pass


  def abrirHTML(self, diretorio, nomeArquivo) -> WebPagina:
    """Abre um arquivo de conteúdo HTML previamente armazenado no computador
 local e apresenta-o na forma de um objeto {@link WebPagina WebPagina}.<BR>
 Se o arquivo não existe, retorna NULL.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o conteúdo aberto (por exemplo, para apresentar
 os formulários da página, ou as tabelas, ou seu conteúdo HTML).<BR>
 Por exemplo:<BR>
 <CODE> // Abre um arquivo chamado TESTE.HTML na pasta de trabalho do
 ContÁgil.<BR>
 pagina = arquivos.abrirHTML(null,"TESTE");<BR>
 </CODE>"""

    pass


  def abrirImagem(self, nomeArquivo) -> Imagem:
    """Abre um arquivo local contendo alguma imagem no formato PNG, JPG ou GIF."""

    pass


  def abrirJson(self, diretorio, nomeArquivo) -> ArquivoJson:
    """Abre um arquivo Json existente.<BR>
 Se o arquivo não existe, retorna NULL.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o arquivo aberto (por exemplo, para ler
 informações no arquivo aberto).<BR>
 Por exemplo:<BR>
 <CODE> // Abre um arquivo chamado TESTE na pasta de trabalho do
 ContÁgil<BR>
 arquivo = arquivos.abrirJson(null,"TESTE");<BR>
 </CODE>"""

    pass


  def abrirJson(self, arquivo) -> ArquivoJson:
    """Idem à função
 {@link GerenciadorArquivos#abrirJson(String, String) abrirJson} de dois
 parâmetros, mas com apenas um parâmetro do tipo {@link Arquivo Arquivo}."""

    pass


  def abrirModelo(self, diretorio, nomeArquivo) -> ModeloRelatorio:
    """Abre um arquivo do padrão ODT (OpenOffice ou BROffice) previamente
 armazenado no computador local e apresenta-o na forma de um objeto
 {@link ModeloRelatorio ModeloRelatorio}. Isto é, um objeto que pode ser
 utilizado como um "modelo de relatório".<BR>
 Se o arquivo não existe, retorna NULL.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o conteúdo aberto (por exemplo, para preencher
 o conteúdo de campos do modelo de relatório).<BR>
 Por exemplo:<BR>
 <CODE> // Abre um arquivo chamado TESTE.ODT na pasta de trabalho do
 ContÁgil.<BR>
 modelo = arquivos.abrirModelo(null,"TESTE");<BR>
 </CODE>"""

    pass


  def abrirODT(self, arquivo) -> ArquivoODT:
    """Idem à função
 {@link GerenciadorArquivos#abrirArquivoODT(String, String) abrirArquivoODT} de dois
 parâmetros, mas com apenas um parâmetro do tipo {@link Arquivo Arquivo}."""

    pass


  def abrirODT(self, nomeArquivo) -> ArquivoODT:
    """Abre um arquivo do tipo ODT (arquivo do padrão BROffice utilizado para representar documentos de texto).<BR>
 Se o arquivo não existe, retorna NULL.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o arquivo aberto (por exemplo, para ler
 informações no arquivo aberto).<BR>"""

    pass


  def abrirODT(self, diretorio, nomeArquivo) -> ArquivoODT:
    """Abre um arquivo do tipo ODT (arquivo do padrão BROffice utilizado para representar documentos de texto).<BR>
 Se o arquivo não existe, retorna NULL.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o arquivo aberto (por exemplo, para ler
 informações no arquivo aberto).<BR>
 Por exemplo:<BR>
 <CODE> // Abre um arquivo chamado TESTE.ODT na pasta de trabalho do
 ContÁgil<BR>
 arquivo = arquivos.abrirODT(null,"TESTE");<BR>
 </CODE>"""

    pass


  def abrirPDF(self, arquivo, diretorioArquivoEditado, nomeArquivoEditado) -> ArquivoPDF:
    """Idem à função
 {@link GerenciadorArquivos#abrirPDF(String, String, String, String) abrirPDF} de quatro
 parâmetros, mas com apenas um parâmetro do tipo {@link Arquivo Arquivo} e dois parâmetros do tipo texto."""

    pass


  def abrirPDF(self, nomeArquivo, nomeArquivoEditado) -> ArquivoPDF:
    """Abre um arquivo do tipo PDF (Portable Document Format).<BR>
 Se o arquivo não existe, retorna NULL.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o arquivo aberto (por exemplo, para ler
 informações no arquivo aberto e editar campos de formulário).<BR>
 Caso deseja apenas ler o arquivo PDF, utilize a função {@link GerenciadorArquivos#abrirPDFSomenteLeitura(String, String) abrirPDFSomenteLeitura}.<BR>"""

    pass


  def abrirPDF(self, diretorioArquivoOriginal, nomeArquivoOriginal, diretorioArquivoEditado, nomeArquivoEditado) -> ArquivoPDF:
    """Abre um arquivo do tipo PDF (Portable Document Format).<BR>
 Se o arquivo não existe, retorna NULL.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o arquivo aberto (por exemplo, para ler
 informações no arquivo aberto ou editar campos de formulários).<BR>
 Por exemplo:<BR>
 <CODE> // Abre um arquivo chamado TESTE.PDF na pasta de trabalho do
 ContÁgil<BR>
 arquivo = arquivos.abrirPDF(null,"TESTE");<BR>
 </CODE>"""

    pass


  def abrirPDFComoTexto(self, arquivo) -> ArquivoTexto:
    """Idem à função
 {@link GerenciadorArquivos#abrirPDFComoTexto(String, String) abrirPDFComoTexto}
 de dois parâmetros, mas com apenas um parâmetro do tipo
 {@link Arquivo Arquivo}."""

    pass


  def abrirPDFComoTexto(self, diretorio, nomeArquivo) -> ArquivoTexto:
    """Abre um arquivo de conteúdo PDF previamente armazenado no computador
 local e apresenta-o na forma de um arquivo TEXTO (isto é, um objeto do
 tipo {@link ArquivoTexto ArquivoTexto}.<BR>
 Se o arquivo não existe, retorna NULL.<BR>
 Se o conteúdo não pode ser obtido no formato texto por algum motivo,
 retorna NULL.<BR>
 OBS: alguns arquivos PDF não apresentam conteúdo do tipo "texto", mas sim
 "imagens" (ainda que elas se pareçam com texto). Esses tipos de arquivos
 não podem ser utilizados com este método.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o conteúdo aberto (por exemplo, para apresentar
 as diversas linhas, ou quebrar cada linha em "campos" em função dos
 espaços em branco que os separam).<BR>
 Por exemplo:<BR>
 <CODE> // Abre um arquivo chamado TESTE.PDF na pasta de trabalho do
 ContÁgil.<BR>
 pagina = arquivos.abrirPDFComoTexto(null,"TESTE");<BR>
 </CODE>"""

    pass


  def abrirPDFComoTexto(self, nomeArquivo) -> ArquivoTexto:
    """Idem à função
 {@link GerenciadorArquivos#abrirPDFComoTexto(String, String) abrirPDFComoTexto}
 de dois parâmetros, mas apenas com a indicação do nome do arquivo (o qual
 deve conter também o nome do diretório onde está o arquivo)."""

    pass


  def abrirPDFComoTextoComSenha(self, diretorio, nomeArquivo, senha) -> ArquivoTexto:
    """Faz o mesmo que a ação {@link #abrirPDFComoTexto(String, String) abrirPDFComoTexto}, porém permite indicar uma senha
 para abertura do PDF caso ele esteja protegido com senha."""

    pass


  def abrirPDFComoTextoSeparandoPaginas(self, diretorio, nomeArquivo, separadorPaginas) -> ArquivoTexto:
    """Faz o mesmo que o método {@link GerenciadorArquivos#abrirPDFComoTexto(String, String) abrirPDFComoTexto}, porém
 para cada 'quebra de página' que houver no PDF, insere no 'texto' resultante uma linha compreendendo
 o conteúdo que é informado no parâmetro 'separadorPaginas'."""

    pass


  def abrirPDFComoTextoSeparandoPaginas(self, nomeArquivo, separadorPaginas) -> ArquivoTexto:
    """Faz o mesmo que o método {@link GerenciadorArquivos#abrirPDFComoTexto(String) abrirPDFComoTexto}, porém
 para cada 'quebra de página' que houver no PDF, insere no 'texto' resultante uma linha compreendendo
 o conteúdo que é informado no parâmetro 'separadorPaginas'."""

    pass


  def abrirPDFComoTextoSeparandoPaginas(self, arquivo, separadorPaginas) -> ArquivoTexto:
    """Faz o mesmo que o método {@link GerenciadorArquivos#abrirPDFComoTexto(Arquivo) abrirPDFComoTexto}, porém
 para cada 'quebra de página' que houver no PDF, insere no 'texto' resultante uma linha compreendendo
 o conteúdo que é informado no parâmetro 'separadorPaginas'."""

    pass


  def abrirPDFSomenteLeitura(self, arquivo) -> ArquivoPDF:
    """Idem à função
 {@link GerenciadorArquivos#abrirPDFSomenteLeitura(String, String) abrirPDFSomenteLeitura} de dois
 parâmetros, mas com apenas um parâmetro do tipo {@link Arquivo Arquivo}."""

    pass


  def abrirPDFSomenteLeitura(self, diretorioArquivo, nomeArquivo) -> ArquivoPDF:
    """Abre um arquivo do tipo PDF (Portable Documento Format) somente para leitura.<BR>
 Caso deseja ler e editar o arquivo PDF, utilize a função {@link GerenciadorArquivos#abrirPDF(String, String, String, String) abrirPDF}.<BR>"""

    pass


  def abrirPDFSomenteLeitura(self, nomeArquivo) -> ArquivoPDF:
    """Abre um arquivo do tipo PDF (Portable Document Format) somente para leitura.<BR>
 Se o arquivo não existe, retorna NULL.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o arquivo aberto (por exemplo, para ler
 informações no arquivo aberto).<BR>
 Caso deseja ler e editar o arquivo PDF, utilize a função {@link GerenciadorArquivos#abrirPDF(String, String, String, String) abrirPDF}.<BR>"""

    pass


  def abrirRTFComoTexto(self, diretorio, nomeArquivo) -> ArquivoTexto:
    """Abre um arquivo de conteúdo RTF (padrão do aplicativo WordPad do Windows)
 previamente armazenado no computador local e apresenta-o na forma de um
 arquivo TEXTO (isto é, um objeto do tipo
 {@link ArquivoTexto ArquivoTexto}.<BR>
 Se o arquivo não existe, retorna NULL.<BR>
 Se o conteúdo não pode ser obtido no formato texto por algum motivo,
 retorna NULL.<BR>
 OBS: o conteúdo em formato texto pode não se apresentar visivelmente da
 mesma maneira com que é apresentado o conteúdo original.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o conteúdo aberto (por exemplo, para apresentar
 as diversas linhas, ou quebrar cada linha em "campos" em função dos
 espaços em branco que os separam).<BR>
 Por exemplo:<BR>
 <CODE> // Abre um arquivo chamado TESTE.RTF na pasta de trabalho do
 ContÁgil.<BR>
 pagina = arquivos.abrirRTFComoTexto(null,"TESTE");<BR>
 </CODE>"""

    pass


  def abrirRTFComoTexto(self, nomeArquivo) -> ArquivoTexto:
    """Idem à função
 {@link GerenciadorArquivos#abrirRTFComoTexto(String, String) abrirRTFComoTexto}
 de dois parâmetros, mas apenas com a indicação do nome do arquivo (o qual
 deve conter também o nome do diretório onde está o arquivo)."""

    pass


  def abrirRTFComoTexto(self, arquivo) -> ArquivoTexto:
    """Idem à função
 {@link GerenciadorArquivos#abrirRTFComoTexto(String, String) abrirRTFComoTexto}
 de dois parâmetros, mas com apenas um parâmetro do tipo
 {@link Arquivo Arquivo}."""

    pass


  def abrirXML(self, diretorio, nomeArquivo, namespace, whitespace, validacao, schemas, dtd) -> ArquivoXML:
    """Abre um arquivo XML existente.<BR>
 Se o arquivo não existe, retorna NULL.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o arquivo aberto (por exemplo, para ler
 informações no arquivo aberto).<BR>
 Por exemplo:<BR>
 <CODE> // Abre um arquivo chamado TESTE.XML na pasta de trabalho do
 ContÁgil<BR>
 arquivo = arquivos.abrirXML(null,"TESTE");<BR>
 </CODE>"""

    pass


  def abrirXML(self, diretorio, nomeArquivo) -> ArquivoXML:
    """Abre um arquivo XML existente.<BR>
 Se o arquivo não existe, retorna NULL.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o arquivo aberto (por exemplo, para ler
 informações no arquivo aberto).<BR>
 Por exemplo:<BR>
 <CODE> // Abre um arquivo chamado TESTE.XML na pasta de trabalho do
 ContÁgil<BR>
 arquivo = arquivos.abrirXML(null,"TESTE");<BR>
 </CODE>"""

    pass


  def abrirXML(self, conteudo) -> XMLTag:
    """Retorna a raiz do documento XML em função do conteúdo."""

    pass


  def abrirXML(self, arquivo) -> ArquivoXML:
    """Idem à função
 {@link GerenciadorArquivos#abrirXML(String, String) abrirXML} de dois
 parâmetros, mas com apenas um parâmetro do tipo {@link Arquivo Arquivo}."""

    pass


  def abrirZIP(self, diretorio, nomeArquivo) -> ArquivoZIP:
    """Abre para leitura um arquivo compactado existente do padrão ZIP.<BR>
 Se o arquivo não existe, retorna NULL.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o arquivo aberto (por exemplo, para ler
 informações no arquivo aberto).<BR>
 Por exemplo:<BR>
 <CODE> // Abre um arquivo chamado TESTE.ZIP na pasta de trabalho do
 ContÁgil.<BR>
 arquivo = arquivos.abrirZIP(null,"TESTE");<BR>
 </CODE>"""

    pass


  def abrirZIP(self, arquivo, verificaCRC) -> ArquivoZIP:
    """Alternativa do método onde é possível indicar se deseja ou não fazer a verificação de consistência interna do arquivo ZIP (também chamado de 'CRC').<BR>
 OBS: dependendo de como o arquivo ZIP foi criado é possível que a opção pela verificação do teste de consistência inviabilize a leitura de seu conteúdo."""

    pass


  def abrirZIP(self, arquivo) -> ArquivoZIP:
    """Idem à função
 {@link GerenciadorArquivos#abrirZIP(String, String) abrirZIP} de dois
 parâmetros, mas com apenas um parâmetro do tipo {@link Arquivo Arquivo}."""

    pass


  def abrirZIP(self, diretorio, nomeArquivo, verificaCRC) -> ArquivoZIP:
    """Alternativa do método onde é possível indicar se deseja ou não fazer a verificação de consistência interna do arquivo ZIP (também chamado de 'CRC').<BR>
 OBS: dependendo de como o arquivo ZIP foi criado é possível que a opção pela verificação do teste de consistência inviabilize a leitura de seu conteúdo."""

    pass


  def addPDFMarcaDAgua(self, nomeArquivoOriginal, nomeArquivoAlterado, marcaDAgua, tamanhoFonte, cor, espacoHorizontal, espacoVertical, anguloRadianos) -> bool:
    """Adiciona uma 'marca d'água' em todas as páginas do PDF."""

    pass


  def addPDFMarcaDAgua(self, nomeArquivoOriginal, nomeArquivoAlterado, marcaDAgua) -> bool:
    """Adiciona uma 'marca d'água' em todas as páginas do PDF.<BR>
 O texto é escrito na cor cinza, com uma inclinação de 45 graus, com espaçamentos pre-fixados.<BR>
 Caso queira definir cores, espaçamentos, inclinação ou tamanho de fonte distintos, utilize o método alternativo."""

    pass


  def apagaArquivo(self, diretorio, nomeArquivo) -> bool:
    """Exclui um arquivo existente em um diretório.<BR>
 OBS: se o arquivo foi criado ou foi aberto pelo script utilizando algum
 dos métodos listados em {@link GerenciadorArquivos GerenciadorArquivos},
 é necessário fechá-lo antes de utilizar este método. Para fechar um
 arquivo, basta executar o método "fechar" disponível no próprio objeto
 arquivo."""

    pass


  def apagaDiretorioVazio(self, diretorio) -> bool:
    """Exclui um diretório caso ele esteja vazio.<BR>
 OBS: se o diretório possuir algum arquivo ou subdiretório, ele não será excluído."""

    pass


  def assinarPDF(self, arquivoOrigem, arquivoDestino) -> ArquivoPDF:
    """Assina digitalmente um arquivo PDF."""

    pass


  def bloqueiaPDF(self, nomeArquivoOriginal, nomeArquivoBloqueado, senhaProprietario, senhaUsuario, tamanhoChaveBits) -> bool:
    """Dado um arquivo PDF, faz com que ele seja protegido com uma senha. Você pode indicar uma senha de 'proprietário' e uma senha de 'usuário' (pode indicar a mesma senha se desejar).<BR>"""

    pass


  def bloqueiaPDFComCertificadoDigital(self, nomeArquivoOriginal, nomeArquivoBloqueado, certificadoDigital, tamanhoChaveBits) -> bool:
    """Dado um arquivo PDF, faz com que ele seja protegido com um certificado digital. Apenas quem tiver a chave privada associada ao certificado digital poderá abri-lo."""

    pass


  def carregaArquivosParaTabela(self, diretorio, mascara) -> Tabela:
    """Dado um diretório, procura por todos arquivos cujo nome esteja de acordo com uma 'máscara',
 assim como ocorreria se fosse executado o comando 'DIR' do prompt do DOS.<BR>
 Os arquivos e sub-diretórios existentes em sub-diretórios internos ao diretório
 especificado são também pesquisados.<BR>
 Os arquivos ocultos são também pesquisados.<BR>
 O conteúdo de cada arquivo encontrado é lido em memória e é armazenado em uma 'tabela'.<BR><BR>
 <B>ATENÇÃO</B>: este método mantém todo o contéudo dos arquivos em memória. Tenha cuidado para não gerar
 problema de falta de memória caso existam muitos arquivos.<BR><BR>
 A tabela gerada apresenta as seguintes colunas:<BR>
 1ª coluna: NOME do arquivo, incluindo sua extensão, excluindo nome do diretório<BR>
 2ª coluna: nome do DIRETORIO<BR>
 3ª coluna: DATA do arquivo (criação ou modificação)<BR>
 4ª coluna: HORA do arquivo (criação ou modificação)<BR>
 5ª coluna: TAMANHO do arquivo<BR>
 6ª coluna: conteúdo no formato TEXTO do arquivo<BR>
 <BR>
 Conversão para TEXTO<BR>
 ==========================================<BR>
 Os arquivos encontrados, cujo nome atende ao critério definido no parâmetro 'mascara', são 'lidos'
 e transformados em 'texto' na medida do possível. Alguns, porém, não são lidos, tendo em vista a
 impossibilidade de representação no formato texto, na versão atual da aplicação (futuramente pode haver
 suporte a outros formatos).<BR>
 Os formatos atualmente suportados são:<BR>
 Arquivos texto<BR>
 Arquivos PDF<BR>
 Arquivos RTF<BR>
 Arquivos DOC<BR>
 Arquivos ODT<BR>
 Arquivos HTML<BR>"""

    pass


  def concatenarArquivoTexto(self, listaTxt, diretorio, destino) -> bool:
    """Concatena uma lista de arquivos txt ao arquivo destino."""

    pass


  def concatenarArquivoTexto(self, nomeArquivo, diretorio, destino) -> bool:
    """Concatena um arquivo txt ao arquivo destino."""

    pass


  def concatenarPDF(self, listaPDFs, diretorio, nomeArquivo) -> bool:
    """Concatena vários arquivos PDFs em um único arquivo"""

    pass


  def converterArquivoTextoParaPDF(self, nomeArquivoTexto, nomeArquivoPDF, sigiloFiscal) -> bool:
    """Converte o conteúdo de um arquivo texto qualquer para arquivo PDF.<BR>
 Este método é um recurso bastante simplificado para gerar documentos PDF com algum conteúdo qualquer.<BR>
 O arquivo PDF é gerado com cabeçalho e rodapé padronizados, conforme configurações gerais.<BR>
 O texto será inserido no relatório, podendo gerar mais páginas conforme for necessário.<BR>
 Não há formatação e nem outros recursos especiais, a não ser apenas pela quebra de parágrafos para cada
 quebra de linha presente no texto, e indentação para cada caractere de tabulação presente no início
 da linha.<BR>
 Opcionalmente pode-se incluir uma mensagem padronizada de 'sigilo fiscal' no documento gerado."""

    pass


  def converterODTparaPDF(self, nomeArquivoODT, nomeArquivoPDF) -> bool:
    """Converte um arquivo ODT em PDF.<BR>
 A conversão é realizada utilizando o Open Office instalado na máquina do usuário. <BR>
 Para a conversão de mais de um arquivo, a "Alternativa 1" é a mais eficiente.<BR>"""

    pass


  def converterODTparaPDF(self, arquivosODT) -> list:
    """Converte uma lista de arquivos ODT em PDF.<BR>
 Os arquivos convertidos em PDF possuirão o mesmo nome dos arquivos ODT de origem e serão salvos no mesmo diretorio.<BR>
 A conversão é realizada utilizando o Open Office instalado na máquina do usuário. <BR>"""

    pass


  def converterODTparaPDF(self, nomeArquivoODT, nomeArquivoPDF) -> bool:
    """Converte um arquivo ODT em PDF.<BR>
 A conversão é realizada utilizando o Open Office instalado na máquina do usuário. <BR>
 Para a conversão de mais de um arquivo, a "Alternativa 1" é a mais eficiente.<BR>"""

    pass


  def converterOpenOfficeParaPDF(self, nomeArquivoOpenOffice, nomeArquivoPDF) -> bool:
    """Converte um arquivo do Open Office em PDF.<BR>
 A conversão é realizada utilizando o Open Office instalado na máquina do usuário. <BR>
 Para a conversão de mais de um arquivo, a "Alternativa 1" é a mais eficiente.<BR>"""

    pass


  def converterTextoParaPDF(self, texto, nomeArquivoPDF, sigiloFiscal) -> bool:
    """Converte um texto qualquer para arquivo PDF.<BR>
 Este método é um recurso bastante simplificado para gerar documentos PDF com algum conteúdo qualquer.<BR>
 O arquivo PDF é gerado com cabeçalho e rodapé padronizados, conforme configurações gerais.<BR>
 O texto será inserido no relatório, podendo gerar mais páginas conforme for necessário.<BR>
 Não há formatação e nem outros recursos especiais, a não ser apenas pela quebra de parágrafos para cada
 quebra de linha presente no texto, e indentação para cada caractere de tabulação presente no início
 da linha.<BR>
 Opcionalmente pode-se incluir uma mensagem padronizada de 'sigilo fiscal' no documento gerado."""

    pass


  def copiaArquivo(self, arquivoOrigem, diretorioDestino) -> bool:
    """Copia um arquivo existente para um diretório indicado. O diretório, se não
 existir, será criado. <BR>"""

    pass


  def copiaArquivoOutroNome(self, arquivoOrigem, arquivoDestino) -> bool:
    """Copia um arquivo existente para um novo arquivo com outro nome. Se já existir o arquivo
 de destino, ele é sobrescrito.<BR>"""

    pass


  def copiaPasta(self, diretorioOrigem, diretorioDestino) -> bool:
    """Copia o conteúdo de uma pasta para outra, o que inclui todos os seus arquivos e sub-pastas.<BR>
 O diretório de destino deve incluir o nome da pasta.<BR>
 Por exemplo, digamos que existe a pasta C:\TEMP contendo vários arquivos e pastas.<BR>
 Se for executado copiaConteudoPasta com a indicação de diretório de origem "C:\TEMP" e diretório de destino
 "C:\DESTINO", então o conteúdo de "C:\TEMP" será movido para "C:\DESTINO" (o nome "TEMP" não é incluído em "DESTINO").<BR>
 Por outro lado, se o diretório de destino é "C:\DESTINO\TEMP" (isto é, se está explícito o nome "TEMP" no diretório
 de destino), então no destino será criado o diretório TEMP e dentro dele serão colocados os arquivos e subpastas de "C:\TEMP"."""

    pass


  def criaBackup(self, diretorio, nomeArquivo) -> CopiaBackup:
    """Método utilizado para gerar uma nova cópia "backup" dos dados do projeto
 atual, da mesma forma com que é feito através do menu "Geral", sub-menu
 "Migração dos Dados".<BR>
 Configurações adicionais podem ser feitas no objeto retornado por esta
 função (esta função não cria imediatamente a cópia backup, mas
 disponibiliza objeto para permitir isso).<BR>"""

    pass


  def criaDiretorio(self, diretorio) -> bool:
    """Cria um diretório a partir de um nome."""

    pass


  def criarArquivoCompactado(self, diretorio, nomeArquivo, ext) -> ArquivoCompactado:
    """Cria um arquivo compactado no formato SEVEN_ZIP, ZIP, GZIP, TAR ou BZIP2 .<BR>
 Se o arquivo já existia com o mesmo nome, ele é substituído pelo novo.<BR>
 A partir do objeto criado por esta função é possível executar outras
 funções diretamente sobre o arquivo criado (por exemplo, para inserir
 informações no arquivo criado).<BR>
 Por exemplo:<BR>
 <CODE> // Cria um arquivo chamado TESTE.7Z na pasta de trabalho do
 ContÁgil.<BR>
 arquivo = arquivos.criarCompactado(null,"TESTE.7Z","SEVEN_ZIP");<BR>
 </CODE>
 Para arquivos de extensão TAR, BZIP2 e GZIP não é possível criar arquivo compactado vazio."""

    pass


  def criarArquivoCompactado(self, diretorio, nomeArquivo, ext, arquivos) -> ArquivoCompactado:
    """Idem à função
 {@link GerenciadorArquivos#criarArquivoCompactado(String, String, String) criarArquivoCompactado} porém com uma lista
 de arquivos a serem adicionados ao arquivo compactado logo na criação. 
 Se o diretório dos arquivos estiver dentro do diretório do arquivo compactado criado, este é 
 mantido no arquivo compactado, caso contrário, é adicionado apenas o arquivo, sem diretório.
 BZIP2 e GZIP: não adiciona diretórios, apenas os arquivos."""

    pass


  def criarArquivoTexto(self, diretorio, nomeArquivo, continuacao) -> ArquivoTexto:
    """Através do parâmetro adicional 'continuacao', é possível indicar se deseja continuar a escrita
 a partir do ponto onde parou. Se o arquivo não existe, ele é criado."""

    pass


  def criarArquivoTexto(self, diretorio, nomeArquivo) -> ArquivoTexto:
    """Cria um arquivo texto simples (isto é, sem uma "estrutura" pré-definida
 de separação de campos).<BR>
 Se o arquivo já existia com o mesmo nome, ele é substituído pelo novo.<BR>
 A partir do objeto criado por esta função é possível executar outras
 funções diretamente sobre o arquivo criado (por exemplo, para inserir
 informações no arquivo criado).<BR>
 Por exemplo:<BR>
 <CODE> // Cria um arquivo chamado TESTE.TXT na pasta de trabalho do
 ContÁgil<BR>
 arquivo = arquivos.criarArquivoTexto(null,"TESTE");<BR>
 </CODE>"""

    pass


  def criarCSV(self, diretorio, nomeArquivo, separador) -> ArquivoCSV:
    """Cria um arquivo texto do tipo que tem separação por um caractere especial
 (que pode ser a vírgula ou outro caractere).<BR>
 Se o arquivo já existia com o mesmo nome, ele é substituído pelo novo.<BR>
 A partir do objeto criado por esta função é possível executar outras
 funções diretamente sobre o arquivo criado (por exemplo, para inserir
 informações no arquivo criado).<BR>
 Por exemplo:<BR>
 <CODE> // Cria um arquivo chamado TESTE.TXT na pasta de trabalho do
 ContÁgil utilizando o "ponto e vírgula"<BR> // como caractere de
 separação.<BR>
 arquivo = arquivos.criarCSV(null,"TESTE",';');<BR>
 <BR> // Cria um arquivo chamado TESTE2.TXT na pasta de trabalho do
 ContÁgil utilizando o "tab"<BR> // como caractere de separação.<BR>
 arquivo = arquivos.criarCSV(null,"TESTE2",'\t');<BR>
 </CODE>"""

    pass


  def criarCSV(self, arquivo) -> ArquivoCSV:
    """Cria um arquivo texto do tipo que tem separação por "ponto e vírgula".<BR>
 Se o arquivo já existia com o mesmo nome, ele é substituído pelo novo.<BR>
 A partir do objeto criado por esta função é possível executar outras
 funções diretamente sobre o arquivo criado (por exemplo, para inserir
 informações no arquivo criado).<BR>"""

    pass


  def criarCSV(self, diretorio, nomeArquivo, separador, continuacao) -> ArquivoCSV:
    """Através do parâmetro adicional 'continuacao', é possível indicar se deseja continuar a escrita
 a partir do ponto onde parou. Se o arquivo não existe, ele é criado."""

    pass


  def criarCSV(self, diretorio, nomeArquivo) -> ArquivoCSV:
    """Cria um arquivo texto do tipo que tem separação por "ponto e vírgula".<BR>
 Se o arquivo já existia com o mesmo nome, ele é substituído pelo novo.<BR>
 A partir do objeto criado por esta função é possível executar outras
 funções diretamente sobre o arquivo criado (por exemplo, para inserir
 informações no arquivo criado).<BR>
 Por exemplo:<BR>
 <CODE> // Cria um arquivo chamado TESTE.TXT na pasta de trabalho do
 ContÁgil utilizando o "ponto e vírgula"<BR> // como caractere de
 separação.<BR>
 arquivo = arquivos.criarCSV(null,"TESTE");<BR>
 </CODE>"""

    pass


  def criarElementoJson(self) -> ElementoJson:
    """Cria um objeto inicialmente vazio que pode ser preenchido com conteúdo JSON"""

    pass


  def criarElementoJson(self, conteudoInicial) -> ElementoJson:
    """Cria um objeto que representa o conteúdo JSON indicado no parâmetro"""

    pass


  def criarExcel(self, diretorio, nomeArquivo) -> ArquivoExcel:
    """Cria um arquivo do Excel, podendo ser o padrão antigo (extensão XLS) ou o
 padrão novo (extensão XLSX).<BR>
 Se o arquivo já existia com o mesmo nome, ele é substituído pelo novo.<BR>
 A partir do objeto criado por esta função é possível executar outras
 funções diretamente sobre o arquivo criado (por exemplo, para inserir
 informações no arquivo criado).<BR>
 Por exemplo:<BR>
 <CODE> // Cria um arquivo chamado TESTE.XLS na pasta de trabalho do
 ContÁgil.<BR>
 arquivo = arquivos.criarExcel(null,"TESTE");<BR>
 </CODE>"""

    pass


  def criarExcelGrande(self, diretorio, nomeArquivo) -> ArquivoExcel:
    """Método destinado a criar um arquivo Excel do padrão XLSX para inclusão de grande
 volume de dados.<BR>
 Este método utiliza técnicas diferentes, com menos recursos, que utilizam menos a memória,
 o que é ideal para escrever grandes volumes de dados.<BR>
 Em contrapartida, menos funções estão disponíveis para utilização pelo script.<BR>
 As seguintes funções NÃO estarão disponíveis para utilização pelo script durante criação
 do arquivo Excel por este método:<BR>
 - renomear planilha<BR>
 - copiar planilha<BR>
 - ocultar/desocultar planilha<BR>
 - alternar entre planilhas diferentes do arquivo<BR>
 - criar novas planilhas no mesmo arquivo<BR>
 - apagar planilha do arquivo<BR>
 - remover linhas<BR>
 
 Se o nome do arquivo contém ponto (.), não gera o arquivo com a extensão 
 automática (usa o que vem após o ponto).<BR>"""

    pass


  def criarJson(self, diretorio, nomeArquivo) -> ArquivoJson:
    """Cria um arquivo JSON.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o arquivo (por exemplo, para adicionar campos a ele)."""

    pass


  def criarJson(self, diretorio, nomeArquivo, conteudoJson) -> ArquivoJson:
    """Cria um arquivo JSON com o conteúdo inicialmente fornecido.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o arquivo (por exemplo, para adicionar campos a ele)."""

    pass


  def criarXML(self, diretorio, nomeArquivo, tagRaiz) -> ArquivoXML:
    """Cria um arquivo XML.<BR>
 Se o arquivo não existe, retorna NULL.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o arquivo aberto (por exemplo, para ler
 informações no arquivo aberto).<BR>
 Por exemplo:<BR>
 <CODE> // Abre um arquivo chamado TESTE.XML na pasta de trabalho do
 ContÁgil<BR>
 arquivo = arquivos.abrirXML(null,"TESTE");<BR>
 </CODE>"""

    pass


  def criarZIP(self, diretorio, nomeArquivo, arquivos) -> ArquivoZIP:
    """Cria um arquivo ZIP a partir de um conjunto de arquivos que devem ser inseridos dentro do arquivo ZIP.<BR>
 Este método é diferente do outro método homônimo de dois parâmetros ({@link GerenciadorArquivos#criarZIP(String,String) criarZIP})
 no sentido que aqui o arquivo ZIP já é criado com os arquivos indicados no terceiro parâmetro, sendo obtido como resultado um
 arquivo ZIP já aberto para 'leitura' (não para 'escrita'), ao passo que no outro método o arquivo ZIP é criado inicialmente 'vazio',
 mas para 'escrita', permitindo a inclusão dos arquivos dentro dele após a criação.<BR>
 Se já existia um arquivo ZIP com o mesmo nome no mesmo diretório, ele é sobrescrito pelo novo (isto é, este método não adiciona
 novos arquivos a um arquivo ZIP já existente)."""

    pass


  def criarZIP(self, diretorio, nomeArquivo) -> ArquivoZIP:
    """Cria um arquivo ZIP.<BR>
 Se o arquivo já existia com o mesmo nome, ele é substituído pelo novo.<BR>
 A partir do objeto criado por esta função é possível executar outras
 funções diretamente sobre o arquivo criado (por exemplo, para inserir
 informações no arquivo criado).<BR>
 Por exemplo:<BR>
 <CODE> // Cria um arquivo chamado TESTE.ZIP na pasta de trabalho do
 ContÁgil.<BR>
 arquivo = arquivos.criarZIP(null,"TESTE");<BR>
 </CODE>"""

    pass


  def criptografa(self, chave, arquivoOrigem, arquivoDestino) -> bool:
    """Realiza a operação de criptografia (converte algo que não está protegido
 para algo que está protegido).<BR>
 Utiliza nesta operação a chave retornada pela função
 {@link Chaves#getChaveCriptografia() getChaveCriptografia}, podendo ser
 o smart-card, ou o certificado digital de alguém, ou alguma chave
 protegida em arquivo.
 <P>
 Exemplo:<BR>
 <CODE> // Pede para o usuário escolher uma chave para criptografar o
 arquivo. chave = chaves.getChaveCriptografia();<BR>
 arquivos.criptografa(chave, "C:\\ARQUIVO.TXT", "ARQUIVO.SEC");<BR>
 </CODE>"""

    pass


  def desbloqueiaPDF(self, nomeArquivoOriginal, nomeArquivoDesbloqueado, senha) -> bool:
    """Dado um arquivo PDF bloqueado, tenta desbloquea-lo e salva-lo com outro nome.<BR>
 Se o arquivo PDF foi bloqueado (isto é, não se pode imprimir ou copiar ou realizar outras atividaeds) mas não foi 'criptografado', pode-se desbloquear
 o arquivo mesmo sem indicar uma senha.<BR>
 Porém, se o arquivo PDF foi criptografado, apenas será possível desbloquea-lo com a senha correta."""

    pass


  def descriptografa(self, chave, arquivoOrigem, arquivoDestino) -> bool:
    """Realiza o inverso da operação de criptografia (converte algo que está
 protegido para algo que está desprotegido).<BR>
 Utiliza nesta operação a chave retornada pela função
 {@link Chaves#getChaveCriptografia() getChaveCriptografia}, podendo ser
 o smart-card ou alguma chave protegida em arquivo.
 <P>
 Assume-se que o arquivo origem foi criptografado pelo próprio ContÁgil, e
 não por um outro aplicativo qualquer de criptografia.
 <P>
 Exemplo:<BR>
 <CODE> // Pede para o usuário escolher uma chave para descriptografar o
 arquivo. chave = chaves.getChaveCriptografia();<BR>
 arquivos.descriptografa(chave, "C:\\ARQUIVO.SEC", "ARQUIVO.TXT");<BR>
 </CODE>"""

    pass


  def editarExcel(self, diretorio, nomeArquivo) -> ArquivoExcel:
    """Edita um arquivo do Excel existente, podendo ser o padrão antigo (extensão XLS) ou o
 padrão novo (extensão XLSX).<BR>
 Se o arquivo não existe, o método gera erro.<BR>
 A partir do objeto criado por esta função é possível executar outras
 funções diretamente sobre o arquivo criado (por exemplo, para inserir
 informações no arquivo criado).<BR>
 Por exemplo:<BR>
 <CODE> // Edita um arquivo chamado TESTE.XLS na pasta de trabalho do
 ContÁgil.<BR>
 arquivo = arquivos.editarExcel(null,"TESTE");<BR>
 </CODE>"""

    pass


  def exportaXML(self, caminhoModelo, caminhoArquivo, tabelas) -> None:
    """Esta classe disponibiliza um recurso de exportação de tabelas para um arquivo XML a partir
 de um arquivo XML modelo (template) construído em uma linguagem similar à linguagem XSLT aqui denominada de
 CSL - ContÁgil Stylesheet Language.<BR><BR>
 
 Acesse o Wiki do ContÁgil para obter uma explicação mais detalhada com exemplos sobre este método. Utilize o
 menu do ContÁgil "<strong>Ajuda</strong>" -> "<strong>WIKI / Ajuda / Treinamentos</strong>". Ao abrir o navegador na página do Wiki, selecione
 em "manuais do ContÁgil" o link "<strong>Script</strong>" e, depois, o link "<strong>Exportar XML (Linguagem CSL)</strong>."""

    pass


  def exportaXML(self, caminhoModelo, caminhoArquivo) -> None:
    """Esta classe disponibiliza um recurso de exportação de tabelas para um arquivo XML a partir
 de um arquivo XML modelo (template) construído em uma linguagem similar à linguagem XSLT aqui denominada de
 CSL - ContÁgil Stylesheet Language.<BR><BR>
 
 Acesse o Wiki do ContÁgil para obter uma explicação mais detalhada com exemplos sobre este método. Utilize o
 menu do ContÁgil "<strong>Ajuda</strong>" -> "<strong>WIKI / Ajuda / Treinamentos</strong>". Ao abrir o navegador na página do Wiki, selecione
 em "manuais do ContÁgil" o link "<strong>Script</strong>" e, depois, o link "<strong>Exportar XML (Linguagem CSL)</strong>."""

    pass


  def fechaArquivos(self) -> None:
    """Fecha todos os arquivos que estiverem abertos, caso não tenham sido
 fechados ainda (isto é, considerando apenas os arquivos que foram criados
 ou foram abertos por funções desta classe).<BR>
 Esta função é chamada automaticamente pelo ContÁgil no término da
 execução de um script, mesmo que o script não chame esta função
 diretamente."""

    pass


  def getChaveCriptografia(self) -> Chave:
    pass


  def getDiretorioBase(self) -> str:
    """Caso tenha um projeto aberto, retorna o nome da pasta do projeto.<BR>
 Caso não tenha um projeto aberto, retorna o nome da pasta de trabalho."""

    pass


  def getDiretorioSuperior(self, nomeArquivo) -> str:
    """Caso seja passado o nome de um arquivo, este método retorna o nome do diretório onde este arquivo está armazenado.<BR>
 Caso seja passado o nome de um diretório, este método retorna o diretório imediatamente superior a ele.<BR>
 Caso não seja passado nenhum parâmetro, este método retorna o diretório imediatamente superior ao diretório do projeto atual. Caso
 nenhum projeto esteja aberto, retorna o diretório imediatamente superior à pasta de trabalho.<BR>
 Caso não exista um diretório superior, retorna nulo."""

    pass


  def getInformacoesArquivo(self, nomeArquivo) -> Arquivo:
    """Retorna um objeto que apresenta informações sobre um arquivo (tais como tamanho, data de criação, etc.)<BR>
 Mesmo que o arquivo não exista será retornado um objeto 'Arquivo'. Pode-se verificar posteriormente sua existência
 utilizando o método {@link Arquivo#isExistente() isExistente}. Alternativamente, utilize {@link #hasArquivo(String) hasArquivo}
 se quiser apenas saber se um determinado arquivo existe."""

    pass


  def hasArquivo(self, nomeArquivo) -> bool:
    """Verifica se existe um arquivo cujo nome é indicado no parâmetro.<BR>
 Caso exista um arquivo de tamanho "zero" (isto é, sem conteúdo algum),
 considera como "ausência de arquivo"."""

    pass


  def hasDiretorio(self, nomeDiretorio) -> bool:
    """Verifica se existe um diretório cujo nome é indicado no parâmetro."""

    pass


  def importaXML(self, diretorio) -> Tabela:
    """Importa todos os arquivos XML localizados em um diretório, inclusive arquivos XML localizados dentro
 de arquivos ZIP localizados dentro do diretório.<BR>
 Não considera subdiretórios caso estejam presentes.<BR>
 Os arquivos XML podem ter qualquer leiaute.<BR>
 Todas as tags e todas as propriedades são transformadas em 'colunas' de uma nova tabela.<BR>
 Em princípio cada arquivo XML será transformado em uma linha desta tabela, sendo todas as suas 'tags' dispostas na forma de 'colunas' da tabela.<BR>
 No entanto, caso alguma 'tag' do mesmo arquivo XML se repita mais de uma vez (algo comum quando se trata de 'coleção' de informações do mesmo tipo),
 essas diferentes ocorrências da mesma tag serão dispostas em diferentes 'linhas' da tabela. Portanto, é possível que a quantidade de linhas da
 tabela produzida seja superior à quantidade de arquivos encontrados.<BR>
 A primeira coluna da tabela identifica o nome do arquivo XML que foi tratado.<BR>
 O conteúdo é tratado como ATRIBUTO ou como MÉTRICA dependendo do tipo de informação. Os valores com casas decimais são considerados como MÉTRICAS. Os
 demais são considerados como ATRIBUTOS.<BR>
 ATENÇÃO: este recurso coloca todo o resultado em memória. Cuidado com grandes volumes de arquivos! Pode ocasionar erro de falta de memória!"""

    pass


  def importaXML(self, diretorio, mascara, recursivo) -> Tabela:
    """Importa todos os arquivos XML localizados em um diretório, inclusive arquivos XML localizados dentro
 de arquivos ZIP localizados dentro do diretório.<BR>
 Pode considerar subdiretórios caso estejam presentes caso o parâmetro 'recursivo' seja TRUE.<BR>
 Os arquivos XML podem ter qualquer leiaute.<BR>
 Todas as tags e todas as propriedades são transformadas em 'colunas' de uma nova tabela.<BR>
 Em princípio cada arquivo XML será transformado em uma linha desta tabela, sendo todas as suas 'tags' dispostas na forma de 'colunas' da tabela.<BR>
 No entanto, caso alguma 'tag' do mesmo arquivo XML se repita mais de uma vez (algo comum quando se trata de 'coleção' de informações do mesmo tipo),
 essas diferentes ocorrências da mesma tag serão dispostas em diferentes 'linhas' da tabela. Portanto, é possível que a quantidade de linhas da
 tabela produzida seja superior à quantidade de arquivos encontrados.<BR>
 A primeira coluna da tabela identifica o nome do arquivo XML que foi tratado.<BR>
 O conteúdo é tratado como ATRIBUTO ou como MÉTRICA dependendo do tipo de informação. Os valores com casas decimais são considerados como MÉTRICAS. Os
 demais são considerados como ATRIBUTOS.<BR>
 ATENÇÃO: este recurso coloca todo o resultado em memória. Cuidado com grandes volumes de arquivos! Pode ocasionar erro de falta de memória!"""

    pass


  def importaXML(self, diretorio, mascara, recursivo, tagsIgnorar, tagsConsiderar, tagsAtributos, tagsMetricas) -> Tabela:
    """Importa todos os arquivos XML localizados em um diretório, inclusive arquivos XML localizados dentro
 de arquivos ZIP localizados dentro do diretório.<BR>
 Pode considerar subdiretórios caso estejam presentes caso o parâmetro 'recursivo' seja TRUE.<BR>
 Os arquivos XML podem ter qualquer leiaute.<BR>
 Todas as tags e todas as propriedades são transformadas em 'colunas' de uma nova tabela.<BR>
 Em princípio cada arquivo XML será transformado em uma linha desta tabela, sendo todas as suas 'tags' dispostas na forma de 'colunas' da tabela.<BR>
 No entanto, caso alguma 'tag' do mesmo arquivo XML se repita mais de uma vez (algo comum quando se trata de 'coleção' de informações do mesmo tipo),
 essas diferentes ocorrências da mesma tag serão dispostas em diferentes 'linhas' da tabela. Portanto, é possível que a quantidade de linhas da
 tabela produzida seja superior à quantidade de arquivos encontrados.<BR>
 A primeira coluna da tabela identifica o nome do arquivo XML que foi tratado.<BR>
 O conteúdo é tratado como ATRIBUTO ou como MÉTRICA dependendo do tipo de informação. Os valores com casas decimais são considerados como MÉTRICAS. Os
 demais são considerados como ATRIBUTOS. Você pode, se quiser, forçar a indicação de determinadas tags como 'métricas'. Fazendo isso, mesmo que alguma
 informação não contenha casas decimais (ex: o número '0'), ela será considerada como 'métrica'. Note que as demais tags que apresentarem casas decimais
 também serão consideradas como 'métricas'.<BR>
 ATENÇÃO: este recurso coloca todo o resultado em memória. Cuidado com grandes volumes de arquivos! Pode ocasionar erro de falta de memória!"""

    pass


  def importaXML(self, diretorio, mascara) -> Tabela:
    """Importa todos os arquivos XML localizados em um diretório, inclusive arquivos XML localizados dentro
 de arquivos ZIP localizados dentro do diretório.<BR>
 Não considera subdiretórios caso estejam presentes.<BR>
 Os arquivos XML podem ter qualquer leiaute.<BR>
 Todas as tags e todas as propriedades são transformadas em 'colunas' de uma nova tabela.<BR>
 Em princípio cada arquivo XML será transformado em uma linha desta tabela, sendo todas as suas 'tags' dispostas na forma de 'colunas' da tabela.<BR>
 No entanto, caso alguma 'tag' do mesmo arquivo XML se repita mais de uma vez (algo comum quando se trata de 'coleção' de informações do mesmo tipo),
 essas diferentes ocorrências da mesma tag serão dispostas em diferentes 'linhas' da tabela. Portanto, é possível que a quantidade de linhas da
 tabela produzida seja superior à quantidade de arquivos encontrados.<BR>
 A primeira coluna da tabela identifica o nome do arquivo XML que foi tratado.<BR>
 O conteúdo é tratado como ATRIBUTO ou como MÉTRICA dependendo do tipo de informação. Os valores com casas decimais são considerados como MÉTRICAS. Os
 demais são considerados como ATRIBUTOS.<BR>
 ATENÇÃO: este recurso coloca todo o resultado em memória. Cuidado com grandes volumes de arquivos! Pode ocasionar erro de falta de memória!"""

    pass


  def listaArquivos(self, diretorio, mascara) -> list:
    """Retorna uma lista de arquivos existentes em um determinado diretório cujo nome de arquivo esteja de acordo com uma 'máscara',
 assim como ocorreria se fosse executado o comando 'DIR' do prompt do DOS.<BR>
 Os arquivos existentes em sub-diretórios internos ao diretório
 especificado não são pesquisados.<BR>
 Os nomes dos sub-diretórios internos ao diretório não são retornados (não
 são arquivos).<BR>
 Os arquivos ocultos são também pesquisados.<BR>
 Este método é análogo ao comando "DIR /A-D" do "DOS".<BR>
 OBS: a execução deste método pode demorar em decorrência dos seguintes
 fatores: se o diretório pesquisado está localizado em uma unidade de
 rede, ou se o diretório pesquisado possui muitos arquivos (isto é,
 milhares de arquivos)."""

    pass


  def listaArquivos(self, diretorio) -> list:
    """Retorna uma lista de arquivos existentes em um determinado diretório.<BR>
 Os arquivos existentes em sub-diretórios internos ao diretório
 especificado não são pesquisados.<BR>
 Os nomes dos sub-diretórios internos ao diretório não são retornados (não
 são arquivos).<BR>
 Os arquivos ocultos são também pesquisados.<BR>
 Este método é análogo ao comando "DIR /A-D" do "DOS".<BR>
 OBS: a execução deste método pode demorar em decorrência dos seguintes
 fatores: se o diretório pesquisado está localizado em uma unidade de
 rede, ou se o diretório pesquisado possui muitos arquivos (isto é,
 milhares de arquivos)."""

    pass


  def listaArquivosRecursivamente(self, diretorio, mascara, limite) -> list:
    """Alternativa que inclui a indicação de um parâmetro adicional para limitar a quantidade de arquivos desejados na listagem
 de resultado. Útil quando se quer listar apenas alguns arquivos, mas não todos eles."""

    pass


  def listaArquivosRecursivamente(self, diretorio) -> list:
    """Retorna uma lista de arquivos existentes em um determinado diretório e
 também em todos os seus subdiretórios.<BR>
 Os arquivos existentes em sub-diretórios internos ao diretório
 especificado são também pesquisados.<BR>
 Os nomes dos sub-diretórios internos ao diretório não são retornados (não
 são arquivos).<BR>
 Os arquivos ocultos são também pesquisados.<BR>
 Este método é análogo ao comando "DIR /S /A-D" do "DOS".<BR>
 OBS: a execução deste método pode demorar em decorrência dos seguintes
 fatores: se o diretório pesquisado está localizado em uma unidade de
 rede, ou se o diretório pesquisado possui muitos arquivos internamente
 (isto é, milhares de arquivos ou de sub-diretórios)."""

    pass


  def listaArquivosRecursivamente(self, diretorio, mascara) -> list:
    """Retorna uma lista de arquivos existentes em um determinado diretório cujo nome de arquivo esteja de acordo com uma 'máscara',
 assim como ocorreria se fosse executado o comando 'DIR' do prompt do DOS.<BR>
 Os arquivos existentes em sub-diretórios internos ao diretório
 especificado são também pesquisados.<BR>
 Os nomes dos sub-diretórios internos ao diretório não são retornados (não
 são arquivos).<BR>
 Os arquivos ocultos são também pesquisados.<BR>
 Este método é análogo ao comando "DIR /S /A-D" do "DOS".<BR>
 OBS: a execução deste método pode demorar em decorrência dos seguintes
 fatores: se o diretório pesquisado está localizado em uma unidade de
 rede, ou se o diretório pesquisado possui muitos arquivos internamente
 (isto é, milhares de arquivos ou de sub-diretórios)."""

    pass


  def listaDiretorioRecursivamente(self, diretorio, mascara) -> list:
    """Retorna uma lista de nomes de arquivos ou sub-diretórios existentes em um determinado diretório cujo nome de arquivo esteja de acordo com uma 'máscara',
 assim como ocorreria se fosse executado o comando 'DIR' do prompt do DOS.<BR>
 Os arquivos e sub-diretórios existentes em sub-diretórios internos ao diretório
 especificado são também pesquisados.<BR>
 Os arquivos ocultos são também pesquisados.<BR>
 Este método é análogo ao comando "DIR /S" do "DOS".<BR>
 Este método retorna apenas <B>NOMES DE ARQUIVOS</B> (o que inclui também <B>NOMES DE DIRETÓRIOS</B>)<BR>
 Existem algumas diferenças entre este método e o método alternativo {@link GerenciadorArquivos#listaArquivosRecursivamente(String, String) listaArquivosRecursivamente}:<BR>
 <TABLE BORDER="1" WIDTH="100%">
 <TR><TH>listaArquivosRecursivamente</TH><TH>listaDiretorioRecursivamente</TH></TR>
 <TR><TD>Retorna nomes (ou seja, retorna textos)</TD><TD>Retorna objetos do tipo {@link Arquivo Arquivo}</TD></TR>
 <TR><TD>Retorna não apenas nomes de arquivos, mas também nomes de subdiretórios (ou seja, o tamanho da lista é maior do que a quantidade de arquivos).</TD>
 <TD>Retorna objetos apenas para arquivos encontrados, não para subdiretórios encontrados (ou seja, o tamanho da lista é igual à quantidade de arquivos).</TD></TR>
 <TR><TD>Diretórios vazios são considerados.</TD>
 <TD>Diretórios vazios são ignorados.</TD></TR>
 </TABLE>
 OBS: a execução deste método pode demorar em decorrência dos seguintes
 fatores: se o diretório pesquisado está localizado em uma unidade de
 rede, ou se o diretório pesquisado possui muitos arquivos internamente
 (isto é, milhares de arquivos ou de sub-diretórios)."""

    pass


  def listaSubdiretorios(self, diretorio) -> list:
    """Retorna uma lista de sub-diretorios existentes em um determinado diretório.<BR>
 Os sub-diretórios existentes nos sub-diretórios internos ao diretório
 especificado não são pesquisados (ou seja, a pesquisa não é 'recursiva').<BR>"""

    pass


  def mapearArquivoTexto(self, arquivoTexto, tabelaMapa) -> Tabela:
    """Importa e mapeia um arquivo TXT da mesma forma como comandado pelo menu:<BR>
 Importação > Tabelas do Usuário > Arquivos Texto.<BR>
 No caso de se criar uma Tabela com o mapeamento desejado, é obrigatório 
 informar o nome: "nome(texto)"."""

    pass


  def mapearCSV(self, arquivoCSV, tabelaMapa) -> Tabela:
    """Importa e mapeia um arquivo CSV da mesma forma como comandado pelo menu:<BR>
 Importação > Tabelas do Usuário > Arquivos Texto.<BR>
 No caso de se criar uma Tabela com o mapeamento desejado, é obrigatório
 informar o nome: "nome(texto)".<BR>"""

    pass


  def mapearExcel(self, arquivoExcel, tabelaMapa) -> Tabela:
    """Importa e mapeia um arquivo Excel da mesma forma como comandado pelo menu:<BR>
 Importação > Tabelas do Usuário > Planilhas Excel.<BR>
 No caso de se criar uma Tabela com o mapeamento desejado, é obrigatório
 informar o nome: "nome(texto)".<BR>"""

    pass


  def moveArquivo(self, arquivoOrigem, diretorioDestino) -> bool:
    """Move um arquivo existente para um diretório indicado. O diretório, se não
 existir, será criado. <BR>"""

    pass


  def movePasta(self, diretorioOrigem, diretorioDestino) -> bool:
    """Move um diretório de um lugar para outro, o que inclui todos os seus arquivos e sub-pastas.<BR>
 O diretório de destino deve incluir o nome da pasta.<BR>
 Por exemplo, digamos que existe a pasta C:\TEMP contendo vários arquivos e pastas.<BR>
 Se for executado movePasta com a indicação de diretório de origem "C:\TEMP" e diretório de destino
 "C:\DESTINO", então o conteúdo de "C:\TEMP" será movido para "C:\DESTINO" (o nome "TEMP" não é incluído em "DESTINO").<BR>
 Por outro lado, se o diretório de destino é "C:\DESTINO\TEMP" (isto é, se está explícito o nome "TEMP" no diretório
 de destino), então no destino será criado o diretório TEMP e dentro dele serão colocados os arquivos e subpastas de "C:\TEMP"."""

    pass


  def novoPDFExtrator(self) -> PDFExtrator:
    """Cria um objeto do tipo {@link PDFExtrator PDFExtrator} destinado a extrair informações de arquivos PDF. Trata-se de um recurso
 mais avançado do que as alternativas {@link #abrirPDFComoTexto(String) abrirPDFComoTexto}, {@link #abrirPDFComoTextoComSenha(String, String, String) abrirPDFComoTextoComSenha}, etc.<BR>
 OBS: você precisará configurar o objeto antes de utiliza-lo."""

    pass


  def renomeiaPasta(self, pastaAtual, novoNome) -> bool:
    """Altera o nome de uma pasta.<BR> 
 O primeiro parâmetro deve indicar o caminho completo da pasta que deve ser renomeada.<BR>
 O segundo parâmetro deve indicar o novo nome da pasta. A pasta que será renomeada será a <BR>
 última indicada no caminho informado no primeiro parâmetro.<BR>
 Exemplo: <BR>
 Pasta a ser renomeada: D:\TEMP\CASA <BR>
 Novo nome: FAZENDA <BR>
 Resultado: D:\TEMP\FAZENDA <BR>"""

    pass


  def salvaAnexo(self, anexo, nomeArquivo) -> None:
    """Salva o conteúdo de um anexo do script na forma de um arquivo externo.<BR>
 O anexo é indicado através do primeiro parâmetro. Você deve passar o próprio
 anexo, que usualmente existe no script na forma de uma variável (cujo nome é
 definido na aba de anexos).<BR>
 Se o conteúdo passado no primeiro parâmetro não corresponder a um anexo, gera
 erro.<BR>
 Se o arquivo já existe, sobrescreve-o.<BR>
 Se já existir um arquivo com este mesmo nome e ele estiver sendo utilizado por outro programa, joga erro."""

    pass


  def salvaAnexo(self, anexo, diretorio, nomeArquivo) -> None:
    """Salva o conteúdo de um anexo do script na forma de um arquivo externo.<BR>
 O anexo é indicado através do primeiro parâmetro. Você deve passar o próprio
 anexo, que usualmente existe no script na forma de uma variável (cujo nome é
 definido na aba de anexos).<BR>
 Se o conteúdo passado no primeiro parâmetro não corresponder a um anexo, gera
 erro.<BR>
 Se o arquivo já existe, sobrescreve-o.<BR>
 Se já existir um arquivo com este mesmo nome e ele estiver sendo utilizado por outro programa, joga erro."""

    pass


  def salvaAnexo(self, anexo, arquivo) -> None:
    """Salva o conteúdo de um anexo do script na forma de um arquivo externo.<BR>
 O anexo é indicado através do primeiro parâmetro. Você deve passar o próprio
 anexo, que usualmente existe no script na forma de uma variável (cujo nome é
 definido na aba de anexos).<BR>
 Se o conteúdo passado no primeiro parâmetro não corresponder a um anexo, gera
 erro.<BR>
 Se o arquivo já existe, sobrescreve-o.<BR>
 Se já existir um arquivo com este mesmo nome e ele estiver sendo utilizado por outro programa, joga erro."""

    pass


  def separarPDF(self, arquivoOrigem, pontosCorte, diretorioDestino) -> list:
    """Idem à função {@link GerenciadorArquivos#separarPDF(String, int[], String)
 separarPDF} mas com parâmetro do tipo Arquivo."""

    pass


  def separarPDF(self, arquivoOrigem, intervalosCorte, diretorioDestino) -> list:
    """Idem à função {@link GerenciadorArquivos#separarPDF(String, String, String)
 separarPDF} mas com parâmetro do tipo Arquivo."""

    pass


  def separarPDF(self, arquivoOrigem, intervalosCorte, diretorioDestino) -> list:
    """Separa um arquivo PDF em vários arquivos utilizando os intervalos de corte
 passados como parâmetro. Pode também fornecer páginas isoladas e pode haver
 intersecção de intervalos."""

    pass


  def separarPDF(self, arquivoOrigem, pontosCorte, diretorioDestino) -> list:
    """Separa um arquivo PDF em vários arquivos utilizando os pontos de corte
 passados como parâmetro. Com n pontos de corte, são gerados n+1 arquivos como
 resultado. Sempre começando na primeira página, cada PDF gerado contém as
 páginas do número informado no vetor até a imediatamente anterior ao próximo
 número da lista, ou final do PDF."""

    pass


  def setPermissoes(self, nomeArquivo, leituraProprio, escritaProprio, execucaoProprio, leituraGrupo, escritaGrupo, execucaoGrupo, leituraOutros, escritaOutros, execucaoOutros) -> None:
    """Define as permissões de um arquivo ou diretório no padrão POSIX.<BR>
 OBS: sistemas operacionais como o LINUX permitem a definição de permissões de arquivos conforme descrito aqui. Outros
 sistemas operacionais, tais como o WINDOWS, não possuem tal definição.<BR>
 As permissões no padrão POSIX são divididas em três grupos: aquelas que se aplicam ao mesmo usuário que criou o arquivo,
 aquelas que se aplicam aos usuários que fazem parte do mesmo grupo que o usuário que criou o arquivo, e aquelas que se aplicam
 aos demais usuários (isto é, de outros grupos). As permissões definidas de forma independente em cada grupo são: leitura, escrita
 e execução. A permissão de 'execução', quando aplicada a diretório, indica que é possível listar o conteúdo daquele diretório."""

    pass

class Grafico ():
  """Objeto que representa um "gráfico". É criado por uma das funções da classe
 {@link Graficos Graficos}.<BR>
 
 Depois que um gráfico é "criado", pode-se inserir dados e preencher outros
 atributos tais como títulos e rótulos.<BR>
 
 Depois que todos os dados e atributos foram definidos para um gráfico, ele
 pode ser "salvo" na forma de um arquivo.<BR>
 
 Pode-se inserir em um mesmo gráfico mais de uma série de dados. Por exemplo,
 três séries de dados em um gráfico do tipo "linha" permite que seja gerado um
 gráfico com três linhas, cada uma com uma cor diferente.<BR>
 
 Para um exemplo na utilização deste objeto, consulte a documentação do objeto
 {@link Graficos Graficos}.<BR>
 
 OBS: Esta classe é THREAD-SAFE (isto é, o mesmo objeto pode ser compartilhado
 por execuções paralelas simultâneas)."""

  def addDestaque(self, serie, x, cor) -> None:
    """Destaca um elemento do gráfico. O efeito do destaque depende do tipo de gráfico que está sendo apresentado.<BR>
 Por exemplo, se for um gráfico de barras, o 'destaque' é feito através de uma moldura colocada ao redor da barra.<BR>
 O destaque é feito para uma determinada série (começando pelo número 1) e para um determinado valor 'x' do ponto que deseja destacar.<BR>
 Pode-se incluir quantos 'destaques' desejar.<BR>
 Note que o 'destaque' não afeta os dados. Isto é, não se trata de inserir valores no gráfico, mas sim destacar valores existentes."""

    pass


  def addMarcacaoEixoX(self, valor, cor, rotulo) -> None:
    """Cria uma "marcação" sobre o gráfico no eixo "X" (não aplicável caso o
 gráfico apresente categorias ao invés de números no eixo X).<BR>
 A "marcação" é uma linha vertical que corta o eixo "X" em um determinado
 valor."""

    pass


  def addMarcacaoEixoY(self, valor, cor, rotulo) -> None:
    """Cria uma "marcação" sobre o gráfico no eixo "Y".<BR>
 A "marcação" é uma linha horizontal que corta o eixo "Y" em um
 determinado valor."""

    pass


  def addOutroGrafico(self, grafico, mesmoEixoY) -> None:
    """Método equivalente a
 {@link Grafico#addOutroGrafico(Grafico, boolean) addOutroGrafico}, mas
 com a possibilidade de escolher se o outro gráfico que está sendo
 adicionado deve ou não deve utilizar o mesmo eixo Y que este.<BR>
 <BR>
 ATENÇÃO: as múltiplas 'séries' que porventura existam no outro gráfico
 são tratadas no outro gráfico de forma independente das séries existentes
 neste gráfico. Por exemplo, se cada um dos gráficos possui uma série de dados, NÃO
 se pode dizer que a primeira série do outro gráfico corresponde à 'segunda série'
 deste gráfico."""

    pass


  def addOutroGrafico(self, grafico) -> None:
    """Adiciona um outro gráfico a este gráfico (ou seja, os dois gráficos são
 sobrepostos um ao outro).<BR>
 OBS: nem todo tipo de gráfico pode ser adicionado a todo tipo de gráfico.<BR>
 Por exemplo, um gráfico do tipo "barras com categorias"
 {@link Graficos#novoGraficoBarraCategoria() novoGraficoBarraCategoria}
 não é compatível com gráfico do tipo "linhas" (@link
 Graficos#novoGraficoLinhaXY() novoGraficoLinhaXY}, mas um gráfico do tipo
 "barras X/Y" {@link Graficos#novoGraficoBarraXY() novoGraficoBarraXY} é
 compatível com o gráfico do tipo "linhas".<BR>
 Caso a junção pretendida não seja compatível, o gráfico incompatível não
 será exibido."""

    pass


  def addSegmentoRetaReferencia(self, x1, y1, x2, y2, cor) -> None:
    """Caso o gráfico seja de algum tipo com pares numéricos (X,Y), como no gráfico de 'linhas X,Y' ou
 no gráfico de 'barras X,Y' ou gráfico 'dispersão', este método permite apresentar um 'segmento de reta' sobre o gráfico. Este segmento de reta
 não corresponderá a uma 'série' de valores, mas pode ser útil para fazer comparações."""

    pass


  def addSubtitulo(self, subtitulo) -> None:
    """Adiciona um subtítulo ao gráfico. Um gráfico pode ter mais de um
 subtítulo. O subtítulo é apresentado abaixo do título."""

    pass


  def addValor(self, serie, x, y) -> None:
    """Faz o mesmo que a função
 {@link Grafico#addValor(Object, Object) addValor} de dois parâmetros, mas
 com a diferença que aqui pode-se especificar uma série diferente da
 primeira. Com isso torna-se possível construir um gráfico com mais de uma
 série de dados (por exemplo, se é um gráfico de linhas, apresenta mais de
 uma linha ao mesmo tempo, cada uma com uma cor diferente)."""

    pass


  def addValor(self, x, y) -> None:
    """Função que adiciona um valor para ser apresentado no gráfico.<BR>
 A forma com que o valor é apresentado no gráfico depende do tipo de
 gráfico que está sendo criado.<BR>
 Por exemplo, se este é um gráfico de série temporal, o parâmetro X indica
 o período (pode ser uma data ou um mês) e o parâmetro Y indica a posição
 vertical do ponto pelo qual deve passar a linha. Se este é um gráfico de
 barras, o parâmetro X indica a posição horizontal (um valor) e o
 parâmetro Y indica o tamanho da barra.<BR>
 Se este é um histograma, o parâmetro X indica o valor medido (posição
 horizontal do gráfico) e o parâmetro Y indica o número de ocorrências
 deste valor (este número, por sua vez, em se tratando de histograma,
 soma-se a outros números indicados para o mesmo valor X).<BR>
 Caso o gráfico possua mais de uma série de dados, esta função ajusta
 apenas os dados da primeira série."""

    pass


  def addValorComRotulo(self, serie, x, y, rotulo) -> None:
    """Função que adiciona um valor para ser apresentado no gráfico e associa ao ponto um 'rótulo'.<BR>
 IMPORTANTE: nem todos os diferentes tipos de gráficos suportam 'rótulos'. Leia a documentação
 do tipo de gráfico desejado para saber se ele suporta ou não a utilização de 'rótulos' dentro
 do gráfico. Note que não estamos falando do rótulo da 'série', o qual é setado pelo método
 {@link Grafico#setNomeSerie(String) setNomeSerie}, e nem do rótulo do 'eixo', o qual é setado
 pelo método {@link Grafico#setRotuloEixoX(String) setRotuloEixoX} ou {@link Grafico#setRotuloEixoY(String) setRotuloEixoY},
 mas sim do rótulo de uma informação individual que aparece sobre o gráfico. Por exemplo, gráficos do
 tipo 'scatter plot' podem apresentar alguns rótulos sobre os 'pontos' exibidos no gráfico (cada ponto
 pode ter um rótulo diferente).<BR>"""

    pass


  def addValorComRotulo(self, x, y, rotulo) -> None:
    """Função que adiciona um valor para ser apresentado no gráfico e associa ao ponto um 'rótulo'.<BR>
 IMPORTANTE: nem todos os diferentes tipos de gráficos suportam 'rótulos'. Leia a documentação
 do tipo de gráfico desejado para saber se ele suporta ou não a utilização de 'rótulos' dentro
 do gráfico. Note que não estamos falando do rótulo da 'série', o qual é setado pelo método
 {@link Grafico#setNomeSerie(String) setNomeSerie}, e nem do rótulo do 'eixo', o qual é setado
 pelo método {@link Grafico#setRotuloEixoX(String) setRotuloEixoX} ou {@link Grafico#setRotuloEixoY(String) setRotuloEixoY},
 mas sim do rótulo de uma informação individual que aparece sobre o gráfico. Por exemplo, gráficos do
 tipo 'scatter plot' podem apresentar alguns rótulos sobre os 'pontos' exibidos no gráfico (cada ponto
 pode ter um rótulo diferente).<BR>
 Caso o gráfico possua mais de uma série de dados, esta função ajusta
 apenas os dados da primeira série."""

    pass


  def addValores(self, x, lista) -> None:
    """Adiciona os valores de uma lista. Os valores ficam vinculados à série de número 1.<BR>
 Os valores correspondem ao componente "Y".<BR>
 O primeiro parâmetro desta função indica o componente "X", que assume ser o 
 mesmo para todos os diferentes valores da lista (isto é, como se todos os valores a
 serem incluídos no gráfico possuíssem o mesmo valor X, mas com Y variando
 conforme os valores da lista).<BR>"""

    pass


  def addValores(self, primeira_serie, matriz, colunaX, colunaY, numSeries) -> None:
    """Adiciona os valores de uma matriz.<BR>
 A coluna indicada pelo parâmetro "colunaX" é considerada para informar os
 valores do eixo X.<BR>
 A coluna indicada pelo parâmetro "colunaY" é considerada para informar os
 valores do eixo Y.<BR>
 O parâmetro "numSeries" indica quantas séries devem ser consideradas na
 leitura da tabela. O padrão é indicar "1", o que significa que apenas uma
 série de dados (colunaX + colunaY) é desenhada no gráfico. Caso seja
 indicado um número superior a "1", as colunas da matriz que se seguem à
 primeira são também consideradas para inclusão no gráfico.<BR>"""

    pass


  def addValores(self, lista, serie) -> None:
    """Adiciona os valores de uma lista, indicando o número da série à qual ficarão vinculados os dados da lista.<BR>
 Os valores correspondem aos parâmetros apresentados no eixo Y do gráfico. Admite-se que cada valor
 desta lista está relacionado a um número inteiro no eixo X que varia de 1 até o tamanho da lista.<BR>
 Por exemplo, se a lista contém os valores 10, 20, 30, 20, 10, nesta ordem, então assume-se que os valores (X,Y) são:<BR>
 (1, 10)  (2, 20)   (3, 30)   (4, 20)   (5, 10)<BR>
 <BR>
 OBS: se este é um gráfico de 'histograma', então o comportamento é diferente. Considera-se cada valor da lista de forma isolada
 e é feito o histograma computando as ocorrências desses valores na lista. Ou seja, cada elemento da lista computa uma ocorrência
 do valor correspondente, podendo haver outros valores iguais na lista computando mais ocorrências do mesmo valor."""

    pass


  def addValores(self, x, lista, serie) -> None:
    """Adiciona os valores de uma lista. Os valores ficam vinculados à série indicada no último parâmetro.<BR>
 Os valores correspondem ao componente "Y".<BR>
 O primeiro parâmetro desta função indica o componente "X", que assume ser o 
 mesmo para todos os diferentes valores da lista (isto é, como se todos os valores a
 serem incluídos no gráfico possuíssem o mesmo valor X, mas com Y variando
 conforme os valores da lista).<BR>"""

    pass


  def addValores(self, tabela) -> None:
    """Adiciona os valores de uma tabela.<BR>
 A primeira coluna da tabela é considerada para informar os valores do
 eixo X (podendo neste caso representar datas, meses, números ou textos,
 dependendo do tipo de gráfico que foi criado).<BR>
 A segunda coluna da tabela é considerada para informar os valores do eixo
 Y.<BR>
 As demais colunas da tabela (terceira em diante), caso presentes, são
 consideradas para informar os valores do eixo Y das demais séries (por
 exemplo, se é um gráfico de linhas, uma tabela com quatro colunas
 representa um gráfico de três linhas).<BR>
 Caso a tabela contenha apenas uma coluna, considera-se que a única coluna
 da tabela refere-se aos valores do eixo X e considera-se a constante "1"
 como correspondente valor "Y" (caso este gráfico seja do tipo
 "histograma", este comportamento tem o papel de computar as ocorrências
 de cada valor).<BR>
 Caso não tenham sido definidos ainda o rótulo para o eixo X ou os nomes
 das séries, esses nomes são obtidos dos nomes das colunas correspondentes
 na tabela.<BR>"""

    pass


  def addValores(self, lista) -> None:
    """Adiciona os valores de uma lista. Os dados ficam vinculados à série de número 1.<BR>
 Os valores correspondem aos parâmetros apresentados no eixo Y do gráfico. Admite-se que cada valor
 desta lista está relacionado a um número inteiro no eixo X que varia de 1 até o tamanho da lista.<BR>
 Por exemplo, se a lista contém os valores 10, 20, 30, 20, 10, nesta ordem, então assume-se que os valores (X,Y) são:<BR>
 (1, 10)  (2, 20)   (3, 30)   (4, 20)   (5, 10)<BR>
 <BR>
 OBS: se este é um gráfico de 'histograma', então o comportamento é diferente. Considera-se cada valor da lista de forma isolada
 e é feito o histograma computando as ocorrências desses valores na lista. Ou seja, cada elemento da lista computa uma ocorrência
 do valor correspondente, podendo haver outros valores iguais na lista computando mais ocorrências do mesmo valor."""

    pass


  def addValores(self, primeira_serie, tabela) -> None:
    """Adiciona os valores de uma tabela.<BR>
 A primeira coluna da tabela é considerada para informar os valores do
 eixo X (podendo neste caso representar datas, meses, números ou textos,
 dependendo do tipo de gráfico que foi criado).<BR>
 A segunda coluna da tabela é considerada para informar os valores do eixo
 Y.<BR>
 As demais colunas da tabela (terceira em diante), caso presentes, são
 consideradas para informar os valores do eixo Y das demais séries (por
 exemplo, se é um gráfico de linhas, uma tabela com quatro colunas
 representa um gráfico de três linhas).<BR>
 Caso não tenham sido definidos ainda o rótulo para o eixo X ou os nomes
 das séries, esses nomes são obtidos dos nomes das colunas correspondentes
 na tabela.<BR>"""

    pass


  def addValores(self, tabela, colunaX, colunaY, numSeries) -> None:
    """Função análoga à função
 {@link Grafico#addValores(int, Tabela, int, int, int) addValores}, com a
 particularidade que esta função omite o parâmetro "primeira_serie",
 considerando que a primeira série é a de número 1 (a primeira série do
 gráfico).<BR>
 Consulte os comentários da outra função para mais informações."""

    pass


  def addValores(self, listaX, listaY) -> None:
    """Adiciona os valores de duas listas, sendo que uma corresponde aos valores X e a outra são os correspondentes valores Y.<BR>
 Ou seja, ambas listas precisam ter a mesma quantidade de elementos. São consideradas como se fossem duas colunas de uma mesma tabela.<BR>"""

    pass


  def addValores(self, primeira_serie, tabela, colunaX, colunaY, numSeries) -> None:
    """Adiciona os valores de uma tabela.<BR>
 A coluna indicada pelo parâmetro "colunaX" é considerada para informar os
 valores do eixo X (podendo neste caso representar datas, meses, números
 ou textos, dependendo do tipo de gráfico que foi criado).<BR>
 A coluna indicada pelo parâmetro "colunaY" é considerada para informar os
 valores do eixo Y.<BR>
 O parâmetro "numSeries" indica quantas séries devem ser consideradas na
 leitura da tabela. O padrão é indicar "1", o que significa que apenas uma
 série de dados (colunaX + colunaY) é desenhada no gráfico. Caso seja
 indicado um número superior a "1", as colunas da tabela que se seguem à
 primeira são também consideradas para inclusão no gráfico.<BR>
 Caso não tenham sido definidos ainda o rótulo para o eixo X ou os nomes
 das séries, esses nomes são obtidos dos nomes das colunas correspondentes
 na tabela.<BR>"""

    pass


  def addValores(self, lista, y) -> None:
    """Adiciona os valores de uma lista.<BR>
 Os valores correspondem aos parâmetros apresentados no eixo X do gráfico
 (podendo neste caso representar datas, meses, números ou textos,
 dependendo do tipo de gráfico que foi criado).<BR>
 O segundo parâmetro desta função indica o valor a ser considerado no eixo
 Y para todos os valores da lista (isto é, como se todos os valores a
 serem incluídos no gráfico possuíssem o mesmo valor Y, mas com X variando
 conforme os valores da lista).<BR>"""

    pass


  def addValores(self, matriz) -> None:
    """Adiciona os valores de uma matriz.<BR>
 A primeira coluna da matriz é considerada para informar os valores do
 eixo X.<BR>
 A segunda coluna da matriz é considerada para informar os valores do eixo
 Y.<BR>
 As demais colunas da matriz (terceira em diante), caso presentes, são
 consideradas para informar os valores do eixo Y das demais séries (por
 exemplo, se é um gráfico de linhas, uma tabela com quatro colunas
 representa um gráfico de três linhas).<BR>
 Caso a matriz contenha apenas uma coluna, considera-se que a única coluna
 da matriz refere-se aos valores do eixo X e considera-se a constante "1"
 como correspondente valor "Y" (caso este gráfico seja do tipo
 "histograma", este comportamento tem o papel de computar as ocorrências
 de cada valor).<BR>
 O mesmo comportamento descrito no parágrafo anterior é aplicado a uma matriz
 do tipo 'linha' (isto é, contendo uma só linha e várias colunas).<BR>"""

    pass


  def addValoresComRotulos(self, primeira_serie, tabela, colunaRotulos, colunaX, colunaY, numSeries) -> None:
    """Adiciona os valores de uma tabela incluindo também um 'rótulo' para cada valor individual.<BR>
 ATENÇÃO: nem todo tipo de gráfico suporta a definição de um 'rótulo' para cada 'valor'!<BR>
 Consulte a documentação para saber quais gráficos suportam esta característica.<BR>
 Note que não estamos falando do rótulo da 'série', o qual é setado pelo método
 {@link Grafico#setNomeSerie(String) setNomeSerie}, e nem do rótulo do 'eixo', o qual é setado
 pelo método {@link Grafico#setRotuloEixoX(String) setRotuloEixoX} ou {@link Grafico#setRotuloEixoY(String) setRotuloEixoY},
 mas sim do rótulo de uma informação individual que aparece sobre o gráfico. Por exemplo, gráficos do
 tipo 'scatter plot' podem apresentar alguns rótulos sobre os 'pontos' exibidos no gráfico (cada ponto
 pode ter um rótulo diferente).<BR>	 
 A coluna indicada pelo parâmetro "colunaX" é considerada para informar os
 valores do eixo X (podendo neste caso representar datas, meses, números
 ou textos, dependendo do tipo de gráfico que foi criado).<BR>
 A coluna indicada pelo parâmetro "colunaY" é considerada para informar os
 valores do eixo Y.<BR>
 A coluna indicada pelo parâmetro "colunaRotulos" é considerada para informar
 os 'rótulos' de cada coordenada (X,Y). Rótulos nulos ou vazios são desconsiderados.<BR>
 O parâmetro "numSeries" indica quantas séries devem ser consideradas na
 leitura da tabela. O padrão é indicar "1", o que significa que apenas uma
 série de dados (colunaX + colunaY) é desenhada no gráfico. Caso seja
 indicado um número superior a "1", as colunas da tabela que se seguem à
 primeira são também consideradas para inclusão no gráfico.<BR>
 Caso não tenham sido definidos ainda o rótulo para o eixo X ou os nomes
 das séries, esses nomes são obtidos dos nomes das colunas correspondentes
 na tabela.<BR>"""

    pass


  def addValoresComRotulos(self, tabela, colunaRotulos, colunaX, colunaY, numSeries) -> None:
    """Função análoga à função
 {@link Grafico#addValoresComRotulos(int, Tabela, int, int, int, int) addValoresComRotulos}, com a
 particularidade que esta função omite o parâmetro "primeira_serie",
 considerando que a primeira série é a de número 1 (a primeira série do
 gráfico).<BR>
 Consulte os comentários da outra função para mais informações."""

    pass


  def addValoresSeriesDistintas(self, tabela, colunaSeries, colunaX, colunaY) -> None:
    """Adiciona os valores de uma tabela.<BR>
 Esta função permite indicar uma coluna para representar os valores do eixo "X", outra
 coluna para representar os valores do eixo "Y", e outra coluna para representar o nome da série (permitindo
 assim que pontos distintos estejam em séries distintas, com cores distintas)."""

    pass


  def addValoresSeriesDistintas(self, matriz, colunaSeries, renumeraSeries, colunaX, colunaY) -> None:
    """Adiciona os valores de uma matriz.<BR>
 Esta função permite indicar uma coluna para representar os valores do eixo "X", outra
 coluna para representar os valores do eixo "Y", e outra coluna para representar o número da série (permitindo
 assim que pontos distintos estejam em séries distintas, com cores distintas)."""

    pass


  def apaga(self) -> None:
    """Apaga todos os dados do gráfico."""

    pass


  def apagaSerie(self, serie) -> None:
    """Apaga os dados de uma série do gráfico."""

    pass


  def apagaSubtitulos(self) -> None:
    """Apaga todos os subtítulos que foram adicionados ao gráfico (não apaga o
 título)."""

    pass


  def apresentaPontos(self) -> None:
    """Indica que os pontos devem ser apresentados sobre o gráfico.<BR>
 Geralmente gráficos do tipo 'linha' apresentam pontos ao longo da linha.<BR>
 O comportamento pode ser diferente para outros tipos de gráficos."""

    pass


  def escondePontos(self) -> None:
    """Indica que os pontos não devem ser apresentados sobre o gráfico.<BR>
 Geralmente gráficos do tipo 'linha' apresentam pontos ao longo da linha.<BR>
 O comportamento pode ser diferente para outros tipos de gráficos."""

    pass


  def getFormatoDataEixoX(self) -> str:
    """Se o eixo X contém datas, possibilita indicar um formato para apresentação destas datas (isto é, algo diferente do convencional DD/MM/AAAA).<BR>
 Ao descrever o formato para data, utilizar a seguinte convenção: DD = dia, MM = mês, AAAA = ano. Ex: 'DD/MM' exibe algo na forma '01/12'"""

    pass


  def getImagem(self, largura, altura) -> Imagem:
    """Constrói o gráfico com os dados já preenchidos e armazena na forma de uma
 imagem em memória (isto é, ela ainda não é armazenada em disco, existe
 somente na memória).<BR>
 Isso permite, por exemplo, que a imagem seja apresentada em uma janela do
 ContÁgil através da função
 {@link Janelas#mostraImagem(Imagem) mostraImagem}.<BR>
 OBS: o melhor método para se exibir um gráfico na janela não é
 convertendo ele em imagem, mas sim utilizando-o diretamente na função
 {@link Janelas#mostraGrafico(Grafico) mostraGrafico}. Utilize
 preferencialmente a função de conversão em imagem apenas quando for
 necessário conservar o resultado em algum arquivo."""

    pass


  def getImagemFundo(self) -> Imagem:
    """Imagem de fundo que deve ser apresentada atrás do gráfico."""

    pass


  def getLinhasInvervalosPeriodicos(self) -> int:
    """Se for diferente de 0, indica que linhas verticais devem ser desenhadas
 e movimentadas conjuntamente com o movimento do cursor do mouse. Note que se
 trata de um recurso específico para apresentação do gráfico em uma janela
 do ContÁgil.<BR>
 O número se refere à quantidade de unidades utilizadas no 'espaçamento' entre
 as linhas.<BR>
 Por exemplo, se o gráfico é do tipo 'barras' onde o domínio são 'meses'
 (domínio do tipo 'categórico', não 'numérico'), se o número informado aqui for '12', isso representará
 12 meses de intervalo entre uma linha e outra. Note que neste caso se recomenda que todos os meses estejam
 devidamente representados no gráfico (isto é, se faltar algum mês no intervalo, sugere-se
 inserir no gráfico o valor 0 para aquele mês, de modo que não fiquem faltando meses no eixo X do gráfico)."""

    pass


  def getNomeSerie(self, serie) -> str:
    """Retorna o nome de uma série de dados que é apresentada no gráfico."""

    pass


  def getNomeSerie(self) -> str:
    """Retorna o nome da série de dados que é apresentada no gráfico. Caso o
 gráfico possua mais de uma série, trata-se da primeira série de dados."""

    pass


  def getOutroGrafico(self, indice) -> Grafico:
    """Retorna um outro gráfico que tenha sido adicionado a este gráfico. O parâmetro
 informa um índice que pode ser utilizado para referenciar um determinado gráfico,
 supondo haver mais de um gráfico adicionado a este gráfico."""

    pass


  def getQtdOutrosGraficos(self) -> int:
    """Retorna a quantidade de outros gráficos que foram adicionados a este gráfico."""

    pass


  def getQtdSeries(self) -> int:
    """Retorna a quantidade de séries que foram informadas no gráfico"""

    pass


  def getRotuloEixoX(self) -> str:
    """Retorna o rótulo do eixo X"""

    pass


  def getRotuloEixoY(self) -> str:
    """Retorna o rótulo do eixo Y. Se houver mais de uma série neste gráfico,
 trata-se da primeira série de dados."""

    pass


  def getTabelaDadosGraficos(self) -> Tabela:
    """Retorna em uma tabela os dados que são visualizados através do gráfico.<BR>
 Note que esses dados podem não ser exatamente os mesmos que foram adicionados ao gráfico. Por exemplo,
 em gráficos do tipo 'histograma', esta tabela apresentará os valores de cada 'barra' do histograma, onde
 cada 'barra' corresponde a um 'intervalo de valores' para o qual foi computada a frequencia, ao passo que 
 os dados que deram origem ao histograma podem ter sido mais detalhados. Neste exemplo, os dados informados
 por este método são os dados agregados, não os dados detalhados que deram origem à agregação.<BR>
 Alguns tipos de gráfico são incompatíveis com este método (isto é, a tabela retornada estará vazia).<BR>
 Em geral utilize este método com tipos de gráficos que apresentam 'linhas' ou 'barras'.<BR>
 Se o gráfico possui 'outros gráficos', os dados dos demais gráficos não são incluídos nesta tabela (ex: ao misturar
 um gráfico de barras com um gráfico de linhas, a tabela apresentará os dados inseridos diretamente nele, mas não do gráfico que foi 'adicionado'
 a ele)."""

    pass


  def getTitulo(self) -> str:
    """Retorna o título do gráfico"""

    pass


  def isTracejadoCursorVisivel(self) -> bool:
    """Indica se deve ou não exibir o tracejado do cursor de forma paralela aos eixos coordenados. Caso
 seja VERDADEIRO, é possível ver o cruzamento de uma linha horizontal e uma linha vertical passando pelo cursor,
 sendo que essas linhas se movimentam conjuntamente com o cursor."""

    pass


  def removeDestaque(self, serie, x) -> None:
    """Remove o efeito de 'destaque' que foi feito através de 'addDestaque'."""

    pass


  def removeDestaques(self) -> None:
    """Remove todos os efeitos de 'destaque' que foram feitos através de 'addDestaque'."""

    pass


  def removeLimitesVisualizacao(self) -> None:
    """Caso os limites de visualização do gráfico tenham sido previamente definidos através de {@link Grafico#setLimitesVisualizacao(double, double, double, double) setLimitesVisualizacao},
 remove esses limites."""

    pass


  def removeLinhasReferencia(self) -> None:
    """Caso tenha adicionado alguma linha referência (por exemplo, utilizando a função @{link {@link Grafico#addSegmentoRetaReferencia(double, double, double, double, String) addSegmentoRetaReferencia}),
 este método pode ser utilizado para remover todas elas do gráfico."""

    pass


  def removeMarcacoes(self) -> None:
    """Remove as marcações inseridas anteriormente no gráfico."""

    pass


  def removeOutroGrafico(self, grafico) -> None:
    """Remove deste gráfico um outro gráfico que foi adicionado anteriormente através
 do método {@link Grafico#addOutroGrafico(Grafico) addOutroGrafico}. Se o parâmetro
 informado neste método não corresponder exatamente ao mesmo objeto que foi passado
 como parâmetro no método {@link Grafico#addOutroGrafico(Grafico) addOutroGrafico},
 nada é feito."""

    pass


  def removeOutroGrafico(self, indice) -> None:
    """Remove deste gráfico um outro gráfico que foi adicionado anteriormente através
 do método {@link Grafico#addOutroGrafico(Grafico) addOutroGrafico}. O índice
 indicado como parâmetro é o índice para o outro gráfico, começando em 0, considerando
 os gráficos atualmente adicionados ao gráfico atual.<BR>
 Note que, se há mais de um gráfico adicionado ao gráfico atual, ao remover os gráficos
 localizados nas posições iniciais ou intermediárias, as demais posições são alteradas.
 Por exemplo, se há dois gráficos, sendo o primeiro referenciado pelo índice 0 e o segundo
 referenciado pelo índice 1, e se é removido o gráfico no índice 0, então o segundo gráfico
 passa a ocupar a posição correspondente ao índice 0 após a exclusão do primeiro."""

    pass


  def salvaImagem(self, nomeArquivo) -> None:
    """Constrói o gráfico com os dados já preenchidos e armazena na forma de um
 arquivo de imagem (JPG ou PNG).<BR>
 A imagem é criada com dimensões 800 pixels x 545 pixels."""

    pass


  def salvaImagem(self, nomeArquivo, largura, altura) -> None:
    """Constrói o gráfico com os dados já preenchidos e armazena na forma de um
 arquivo de imagem (JPG ou PNG)."""

    pass


  def salvaPDF(self, nomeArquivo) -> None:
    """Constrói o gráfico com os dados já preenchidos e armazena na forma de um
 arquivo PDF."""

    pass


  def setCorBorda(self, cor) -> None:
    """Define a cor de borda do gráfico (onde são exibidos rótulos dos eixos, legendas, etc.). O padrão é a cor branca."""

    pass


  def setCorFundo(self, cor) -> None:
    """Define a cor de fundo do gráfico. O padrão é a cor cinza."""

    pass


  def setCorGrade(self, cor) -> None:
    """Define a cor das linhas verticais e horizontais da "grade". O padrão é a
 cor branca."""

    pass


  def setCorSerie(self, serie, cor) -> None:
    """Define a cor de uma determinada série do gráfico."""

    pass


  def setEscalaLogaritmicaX(self, escalaLogaritmicaX) -> None:
    """Indica que o eixo X deve utilizar escala logaritmica. Esta função pode
 ser utilizada apenas em gráficos do tipo "linhas X,Y". Nos demais casos
 esta indicação é ignorada ou pode gerar gráficos de difícil visualização."""

    pass


  def setEscalaLogaritmicaY(self, escalaLogaritmicaY) -> None:
    """Indica que o eixo Y deve utilizar escala logaritmica. Esta função pode
 ser utilizada apenas em gráficos do tipo "linhas X,Y". Nos demais casos
 esta indicação é ignorada ou pode gerar gráficos de difícil visualização."""

    pass


  def setFormatoDataEixoX(self, formatoDataEixoX) -> None:
    """Se o eixo X contém datas, possibilita indicar um formato para apresentação destas datas (isto é, algo diferente do convencional DD/MM/AAAA).<BR>
 Ao descrever o formato para data, utilizar a seguinte convenção: DD = dia, MM = mês, AAAA = ano. Ex: 'DD/MM' exibe algo na forma '01/12'"""

    pass


  def setFormatoPontoSerie(self, serie, forma) -> None:
    """Define o formato dos pontos de uma determinada série no gráfico.<BR>
 Este método apenas afeta gráficos onde as informações são representadas por 'pontos' de alguma forma.<BR>
 Por exemplo, se aplica a gráficos do tipo 'linhas' e gráficos do tipo 'dispersão'. Porém, não
 se aplica a gráficos de 'barras' e outros gráficos especiais."""

    pass


  def setGraficoPizzaAgregacaoValoresBaixos(self, rotulo, porcentagemMinima, qtdMinima) -> None:
    """Se for um gráfico do tipo pizza, possibilita informar parâmetros adicionais para agregar os valores baixos, evitando sobrecarregar o gráfico com informações demais.<BR>
 Se não for um gráfico do tipo pizza, este método não tem efeito algum."""

    pass


  def setImagemFundo(self, imagemFundo) -> None:
    """Imagem de fundo que deve ser apresentada atrás do gráfico.<BR>
 Pode-se passar como parâmetro alguma imagem obtida de alguma parte do ContÁgil
 (por exemplo, através de {@link WebExtrator#downloadImagem(String) downloadImagem} de 'WebExtrator').<BR>
 A imagem é re-escalonada de modo a ocupar toda a área do gráfico, atrás
 do gráfico."""

    pass


  def setImagemFundo(self, nomeArquivo) -> None:
    """Imagem de fundo que deve ser apresentada atrás do gráfico.<BR>
 Pode-se passar como parâmetro alguma imagem armazenada em um arquivo
 que seja do formato PNG ou JPG ou GIF.<BR>
 A imagem é re-escalonada de modo a ocupar toda a área do gráfico, atrás
 do gráfico."""

    pass


  def setLimitesVisualizacao(self, xMin, xMax, yMin, yMax) -> None:
    """Define os limites de visualização do gráfico (nada impede que o usuário as altere depois através de uma janela onde ele esteja sendo exibido)"""

    pass


  def setLinhasInvervalosPeriodicos(self, linhasInvervalosPeriodicos) -> None:
    """Se for diferente de 0, indica que linhas verticais devem ser desenhadas
 e movimentadas conjuntamente com o movimento do cursor do mouse. Note que se
 trata de um recurso específico para apresentação do gráfico em uma janela
 do ContÁgil.<BR>
 O número se refere à quantidade de unidades utilizadas no 'espaçamento' entre
 as linhas.<BR>
 Por exemplo, se o gráfico é do tipo 'barras' onde o domínio são 'meses'
 (domínio do tipo 'categórico', não 'numérico'), se o número informado aqui for '12', isso representará
 12 meses de intervalo entre uma linha e outra. Note que neste caso se recomenda que todos os meses estejam
 devidamente representados no gráfico (isto é, se faltar algum mês no intervalo, sugere-se
 inserir no gráfico o valor 0 para aquele mês, de modo que não fiquem faltando meses no eixo X do gráfico)."""

    pass


  def setNomeSerie(self, serie, nome) -> None:
    """Ajusta o nome de uma série de dados que é apresentada no gráfico."""

    pass


  def setNomeSerie(self, nome) -> None:
    """Ajusta o nome da série de dados que é apresentada no gráfico. Caso o
 gráfico possua mais de uma série, trata-se da primeira série de dados."""

    pass


  def setRotuloEixoX(self, rotuloEixoX) -> None:
    """Ajusta o rótulo do eixo X"""

    pass


  def setRotuloEixoY(self, rotuloEixoY) -> None:
    """Ajusta o rótulo do eixo Y. Se houver mais de uma série neste gráfico,
 trata-se da primeira série de dados."""

    pass


  def setTitulo(self, titulo) -> None:
    """Ajusta o título do gráfico"""

    pass


  def setTracejadoCursorVisivel(self, exibir) -> None:
    """Indica se deve ou não exibir o tracejado do cursor de forma paralela aos eixos coordenados. Caso
 seja VERDADEIRO, é possível ver o cruzamento de uma linha horizontal e uma linha vertical passando pelo cursor,
 sendo que essas linhas se movimentam conjuntamente com o cursor."""

    pass

class Graficos ():
  """Objeto utilizado para criar novos "gráficos".<BR>
 
 Este objeto está acessível para a linguagem de script através da variável de
 nome "graficos".<BR>
 
 É possível criar vários tipos de gráficos (linhas, barras, etc.).<BR>
 
 Exemplo de construção de um gráfico:<BR>
 
 <CODE> // Cria um novo gráfico do tipo "série temporal"<BR>
 var graf1 = graficos.novoGraficoTemporal()<BR>
 <BR> // Adiciona um título para o gráfico<BR>
 graf1.setTitulo("Gráfico de Teste")<BR>
 <BR> // Adiciona um subtítulo para o gráfico<BR>
 graf1.addSubtitulo("Este é um gráfico de teste")<BR>
 <BR> // Define o nome para o eixo X<BR>
 graf1.setRotuloEixoX("Meses")<BR>
 <BR> // Define o nome para o eixo Y<BR>
 graf1.setRotuloEixoY("Valores")<BR>
 <BR> // Define o nome da série de dados<BR>
 graf1.setNomeSerie("Calculado")<BR>
 <BR> // Adiciona uma informação ao gráfico passando o mês como uma String<BR>
 graf1.addValor("01/2010", 100)<BR>
 <BR> // Adiciona outra informação ao gráfico passando o mês como um objeto<BR> //
 (por exemplo, pode ser o retorno de uma função de outro objeto do ContÁgil)<BR>
 var mes = contagil.getNovoMes(2, 2010) // 02/2010<BR>
 graf1.addValor(mes, 200)<BR>
 <BR> // Adiciona outros valores<BR>
 graf1.addValor("03/2010", 300)<BR>
 graf1.addValor("04/2010", 300)<BR>
 graf1.addValor("05/2010", 400)<BR>
 <BR> // Apresenta o gráfico em uma janela<BR>
 janelas.mostraGrafico(graf1)<BR>
 </CODE>
 <BR>
 Veja a seguir as características associadas a cada tipo de gráfico:<BR>
 <TABLE border="1">
 <TR><TH>Tipo</TH><TH>Valores X</TH><TH>Valores Y</TH><TH>Aceita Valores com Rótulos</TH></TR>
 <TR><TD>Linha X/Y</TD><TD>Números</TD><TD>Números</TD><TD>Sim</TD></TR>
 <TR><TD>Linha Temporal</TD><TD>Dias/Meses/Anos</TD><TD>Números</TD><TD>Sim</TD></TR>
 <TR><TD>Linha Função</TD><TD>Números</TD><TD>Números</TD><TD>Sim</TD></TR>
 <TR><TD>Linha Genérica</TD><TD>Qualquer</TD><TD>Números</TD><TD>Sim</TD></TR>
 <TR><TD>Barra X/Y</TD><TD>Números</TD><TD>Números</TD><TD>Sim</TD></TR>
 <TR><TD>Barra Categorias</TD><TD>Qualquer</TD><TD>Números</TD><TD>Sim</TD></TR>
 <TR><TD>Dispersão (Scatter Plot)</TD><TD>Números</TD><TD>Números</TD><TD>Sim</TD></TR>
 <TR><TD>Caixas (Box & Whiskers)</TD><TD>Qualquer</TD><TD>Números</TD><TD>Não</TD></TR>
 <TR><TD>Correlograma</TD><TD>Dias/Meses/Anos/Números</TD><TD>Números</TD><TD>Não</TD></TR>
 <TR><TD>Pareto</TD><TD>Textos</TD><TD>Números</TD><TD>Não</TD></TR>
 <TR><TD>Histograma</TD><TD>Números</TD><TD>Freqüências</TD><TD>Não</TD></TR>
 <TR><TD>P-P Plot/Q-Q Plot</TD><TD>Números</TD><TD>Freqüências</TD><TD>Não</TD></TR>
 <TR><TD>Diagrama de Venn</TD><TD>Qualquer</TD><TD>Qualquer</TD><TD>Não</TD></TR>
 <TR><TD>Pizza</TD><TD>Qualquer</TD><TD>Números</TD><TD>Não</TD></TR>
 </TABLE>"""

  def novoGraficoBarra(self) -> Grafico:
    """Função idêntica à função
 {@link Graficos#novoGraficoBarraXY() novoGraficoBarraXY}."""

    pass


  def novoGraficoBarraCategoria(self, seriesEmpilhadas, seriesNormalizadasY) -> Grafico:
    """Cria um novo gráfico onde são exibidas "barras" para representar valores
 em suas categorias.<BR>
 Os valores são passados na forma de pares (nome da categoria, valor Y).
 As barras são desenhadas com as alturas definidas pelo valor Y. A posição
 de cada barra é definida pela categoria (nome)."""

    pass


  def novoGraficoBarraCategoria(self) -> Grafico:
    """Cria um novo gráfico onde são exibidas "barras" para representar valores
 em suas categorias.<BR>
 Os valores são passados na forma de pares (nome da categoria, valor Y).
 As barras são desenhadas com as alturas definidas pelo valor Y. A posição
 de cada barra é definida pela categoria (nome)."""

    pass


  def novoGraficoBarraXY(self) -> Grafico:
    """Cria um novo gráfico onde são exibidas "barras" para representar valores.<BR>
 Os valores são passados na forma de pares de coordenadas (X,Y). As barras
 são desenhadas com as alturas definidas pelo valor Y. A posição de cada
 barra é definida pelo valor X."""

    pass


  def novoGraficoCaixas(self) -> Grafico:
    """Cria um novo gráfico do tipo "Diagrama de Caixas" (no inglês: "BOX PLOT", também conhecido como "BOX AND WHISKER").<BR>
 No eixo X são apresentadas as diferentes séries e "categorias".<BR>
 No eixo Y são apresentadas as "formas" que representam as seguintes estatísticas: mediana, quartis, "outliers".<BR>
 O gráfico é assim interpretado:<BR>
 Cada "forma" apresenta algumas estatísticas sobre um conjunto de valores (ou seja, uma dada série numérica é avaliada para
 apresentação de cada "caixa"). Para cada "categoria" diferente (representada por um valor diferente em "X") podemos ter uma
 série numérica diferente, portanto uma "caixa" diferente.<BR>
 A "caixa" possui sua borda inferior no 1º quartil (primeiro 1/4 dos dados quando ordenados numericamente dentro da série) e na
 sua borda superior o 3º quartil (primeiros 3/4 dos dados). Ou seja, a "altura" da caixa compreende a metade central de todos
 os números da série (também chamada de "distância interquartílica").<BR>
 A "média" e a "mediana" são indicadas dentro de cada "caixa".<BR>
 A "média" corresponde ao círculo preto pintado dentro da caixa.<BR>
 A "mediana" corresponde ao traço horizontal desenhado dentro da caixa.<BR>
 Os pontos "extremos" indicados na linha que se estende para cima e para baixo de cada caixa indicam os correspondentes valores
 "limites" para identificação de "outliers" (pontos localizados acima de (Q3 + 1,5 x (Q3-Q1)) ou abaixo de (Q1 - 1,5 x (Q3-Q1)), onde Q3 é o terceiro quartil
 e Q1 é o primeiro quartil).<BR> 
 Os "outliers" são identificados graficamente por pequenos círculos localizados nos extremos de cada caixa.<BR>
 Caso eles estejam ainda mais distantes (acima de (Q3 + 2 x (Q3-Q1)) ou abaixo de (Q1 - 2 x (Q3-Q1))), são desenhados triângulos.<BR>
 Durante o "preenchimento" dos "pontos" para este gráfico (isto é, ao utilizar os demais métodos que fornecem os valores X,Y),
 deve-se indicar em X o "nome" da "categoria" (ou outra informação que expresse uma categoria, por exemplo, um "mês") e em Y cada um dos valores que compõem
 a mesma série. Ou seja, deve-se fornecer uma série de valores Y para um mesmo X.<BR>
 Por exemplo, se existe uma série temporal de valores coletados ao longo de vários anos e pretende-se observar o efeito de
 "sazonalidade" nesses dados, uma possibilidade é construir um "Diagrama de Caixas" informando em X o "nome do mês" (sem indicar o ano)
 e em Y o valor correspondente (haverá mais de um para o mesmo mês pois neste exemplo os dados se referem a vários anos). Feito isso, o diagrama
 deixará evidente de há alguma "sazonalidade" (por exemplo, é possível que um determinado mês apresente a maioria dos dados em um "patamar inferior", ao
 passo que em outro mês ocorre o inverso).<BR>
 Caso todos os pontos sejam associados à mesma categoria (isto é, se X é o mesmo para todos os diferentes valores Y), é desenhada uma única "caixa".<BR>
 <BR>
 <B>Escala logaritmica</B><BR>
 Caso seja escolhida a "escala logaritmica" no eixo Y através do método {@link Grafico#setEscalaLogaritmicaY(boolean) setEscalaLogaritmicaY}, as
 estatísticas são calculadas sobre a escala logaritmica. Por exemplo, o ponto que representa a "média" refere-se à média na escala logaritmica (ou, em
 outras palavras, corresponde à "média geométrica").<BR>"""

    pass


  def novoGraficoCorrelograma(self, parcial, maxlag) -> Grafico:
    """Cria um novo gráfico do tipo "correlograma", onde no eixo X são apresentados
 os "lapsos temporais" (lags) e no eixo Y são apresentadas as correlações (número
 variando de -1 a +1, sendo os valores próximos de 0 indicativos de ausência de
 correlação para um determinado lapso temporal).<BR>
 Os dados de "entrada" para este tipo de gráfico (isto é, os pontos X,Y a passar
 como parâmetros ao método {@link Grafico#addValor(int, Object, Object) addValor} e
 suas variações) devem ser assim representados:<BR>
 <B>valor X</B>: qualquer tipo de informação que possa ser utilizada para "ordenar" os dados. Podem
 ser datas, podem ser meses, podem ser números, etc. Isto é, para cada valor Y que é inserido 
 no gráfico, o valor X apenas indica a sua posição relativa aos demais valores. Note que esta 
 implementação trata de forma igual todos os intervalos entre valores X consecutivos. Por exemplo, 
 se há três valores, sendo que a diferença temporal entre o primeiro e o segundo é superior ou inferior à
 diferença temporal entre o segundo e o terceiro, eles são tratados como tendo a mesma diferença temporal.<BR>
 <B>valor Y</B>: trata-se do valor efetivamente considerado para efeitos de "série temporal". Isto é, 
 os coeficientes de correlação são calculados tomando como base esses valores.<BR>
 Se houver diferentes séries temporais adicionadas ao mesmo gráfico, elas são diferenciadas entre si por cores diferentes.<BR>
 Também é plotado sobre o gráfico duas linhas horizontais indicando os limiares constantes do "nível de confiança" de 95% (útil para
 situações onde o correlograma é utilizado para o propósito de testar hipóteses de aleatoriedade).<BR>"""

    pass


  def novoGraficoDiagramaVenn(self, numeroConjuntos) -> Grafico:
    """Cria um novo gráfico do tipo "Diagrama de Venn" onde são exibidos "conjuntos" e suas interseções.<BR>
 Os valores são passados na forma de pares. A 'categoria' (geralmente um texto) é o componente 'X'
 de cada valor inserido no gráfico. O componente 'Y' é um valor qualquer que deve fazer parte da categoria
 indicada no componente 'X'.<BR>
 Dependendo se os valores indicados no componente 'Y' estiverem presentes em mais de uma categoria identificada
 no componente 'X', eles serão computados em regiões diferentes no "Diagrama de Venn".<BR>
 Por exemplo, se um mesmo valor está presente em todas as categorias, ele será considerado em uma região central
 do gráfico onde há interseção de todos os 'conjuntos' representados graficamente.<BR>
 <BR>
 ATENÇÃO: a atual implementação está limitada a um máximo de 4 conjuntos. Ou seja, ao informar valores no gráfico,
 deve-se tomar o cuidado de não informar mais do que 4 valores distintos no componente 'X' (o componente 'Y', por sua
 vez, pode conter qualquer valor)."""

    pass


  def novoGraficoDispersao(self) -> Grafico:
    """Cria um novo gráfico do tipo "dispersão", onde os pontos são inseridos na
 forma de pares de coordenadas (X,Y), mas nenhuma conexão é feita entre os
 pontos (isto é, não há "linhas" conectando os pontos entre si)."""

    pass


  def novoGraficoDispersaoElipseConfianca(self, grauConfianca) -> Grafico:
    """Cria um novo gráfico do tipo "dispersão", onde os pontos são inseridos na
 forma de pares de coordenadas (X,Y), mas nenhuma conexão é feita entre os
 pontos (isto é, não há "linhas" conectando os pontos entre si).<BR>
 O parâmetro adicional permite indicar um 'grau de confiança' para exibição
 de 'elipses'. Isto é, assumindo que os dados são gerados a partir de uma
 distribuição aleatória normal multivariada, são desenhadas elipses preenchendo
 a região onde se esperaria encontrar (grauConfianca)% das amostras.<BR>
 Se houver mais de uma série de pontos, é desenhada uma elipse para cada uma delas, com
 a cor correspondente à série."""

    pass


  def novoGraficoFuncao(self, equacao, min, max, intervalo, logX) -> Grafico:
    """Cria um novo gráfico do tipo "função". Isto é, uma linha conectando
 pontos (x,y) onde o valor de "y" é uma "função" de "x".<BR>
 Por exemplo, para construir uma parábola entre os pontos -10 e +10,
 pode-se executar:<BR>
 novoGraficoFuncao( "X^2", -10.0, 10.0, 1.0, false);<BR>"""

    pass


  def novoGraficoFuncao(self, equacao, min, max, intervalo) -> Grafico:
    """Cria um novo gráfico do tipo "função". Isto é, uma linha conectando
 pontos (x,y) onde o valor de "y" é uma "função" de "x".<BR>
 Por exemplo, para construir uma parábola entre os pontos -10 e +10,
 pode-se executar:<BR>
 novoGraficoFuncao( "X^2", -10.0, 10.0, 1.0);<BR>"""

    pass


  def novoGraficoHistograma(self, bins, min_x, max_x, acumula_extremos) -> Grafico:
    """Cria um novo gráfico do tipo "histograma" (isto é, um gráfico de "barras"
 onde a altura de cada barra reflete a freqüência de valores
 relacionados).<BR>
 Ao contrário das demais alternativas de histograma, que permitem a
 inclusão de qualquer valor, esta opção permite configurar valores
 "limites". Caso o valor inserido no histograma esteja fora de um desses
 limites (isto é, se é um valor inferior ao menor limite ou superior ao
 maior limite), o valor é tratado de uma de duas formas: ou ele é
 desprezado (caso o parâmetro "acumula_extremos" seja FALSO) ou ele é
 acumulado aos valores limites (caso o parâmetro "acumula_extremos" seja
 VERDADEIRO).<BR>
 Neste tipo de gráfico os valores são passados em pares (valor,
 freqüência). Isto é, o valor é indicado como parâmetro "X" e a freqüência
 com que o valor se repete é indicado como parâmetro "Y".<BR>
 O parâmetro "bins" indica a quantidade de "barras" (ou "bins" ou
 "classes") que devem ser apresentadas no histograma. O padrão é
 apresentar 20 "bins", o que significa que o eixo de domínio (eixo X) é
 subdividido em 20 partes iguais, sendo cada parte associada a um
 intervalo de valores, sendo as freqüências dos valores do mesmo intervalo
 (da mesma "classe") somadas entre si de modo a determinar a "altura".<BR>
 OBS: caso um mesmo valor (parâmetro "X") seja indicado múltiplas vezes,
 sua freqüência é somada à freqüência anterior. Ou seja, em um gráfico
 deste tipo, informar uma única vez o valor (100 , 10) ou indicar dez
 vezes o valor (100 , 1) produz o mesmo resultado."""

    pass


  def novoGraficoHistograma(self) -> Grafico:
    """Cria um novo gráfico do tipo "histograma" (isto é, um gráfico de "barras"
 onde a altura de cada barra reflete a freqüência de valores
 relacionados).<BR>
 Neste tipo de gráfico os valores são passados em pares (valor,
 freqüência). Isto é, o valor é indicado como parâmetro "X" e a freqüência
 com que o valor se repete é indicado como parâmetro "Y".<BR>
 OBS: caso um mesmo valor (parâmetro "X") seja indicado múltiplas vezes,
 sua freqüência é somada à freqüência anterior. Ou seja, em um gráfico
 deste tipo, informar uma única vez o valor (100 , 10) ou indicar dez
 vezes o valor (100 , 1) produz o mesmo resultado."""

    pass


  def novoGraficoHistograma(self, bins) -> Grafico:
    """Cria um novo gráfico do tipo "histograma" (isto é, um gráfico de "barras"
 onde a altura de cada barra reflete a freqüência de valores
 relacionados).<BR>
 Neste tipo de gráfico os valores são passados em pares (valor,
 freqüência). Isto é, o valor é indicado como parâmetro "X" e a freqüência
 com que o valor se repete é indicado como parâmetro "Y".<BR>
 O parâmetro "bins" indica a quantidade de "barras" (ou "bins" ou
 "classes") que devem ser apresentadas no histograma. O padrão é
 apresentar 20 "bins", o que significa que o eixo de domínio (eixo X) é
 subdividido em 20 partes iguais, sendo cada parte associada a um
 intervalo de valores, sendo as freqüências dos valores do mesmo intervalo
 (da mesma "classe") somadas entre si de modo a determinar a "altura".<BR>
 OBS: caso um mesmo valor (parâmetro "X") seja indicado múltiplas vezes,
 sua freqüência é somada à freqüência anterior. Ou seja, em um gráfico
 deste tipo, informar uma única vez o valor (100 , 10) ou indicar dez
 vezes o valor (100 , 1) produz o mesmo resultado."""

    pass


  def novoGraficoLinhaGenerica(self) -> Grafico:
    """Cria um novo gráfico onde são exibidas "linhas" para representar séries
 onde no eixo "X" podemos ter qualquer tipo de valor (ex: textos).<BR>
 OBS: o conteúdo do eixo "X" é tratado de forma genérica, como se fossem 'categorias'. Caso
 queira construir um gráfico de linhas sobre valores numéricos, utilize o método alternativo
 {@link Graficos#novoGraficoLinhaXY() novoGraficoLinhaXY}. Caso queira construir um gráfico
 de linhas sobre atributos temporais (ex: meses, datas, etc.), utilize o método alternativo
 {@link Graficos#novoGraficoLinhaTemporal() novoGraficoLinhaTemporal}.<BR>
 Os valores são passados na forma de pares (categoria,valor). As linhas são
 desenhadas ligando esses pontos."""

    pass


  def novoGraficoLinhaTemporal(self) -> Grafico:
    """Cria um novo gráfico onde são exibidas "linhas" para representar séries
 temporais de valores.<BR>
 Os valores são passados na forma de pares (tempo,valor). As linhas são
 desenhadas ligando esses pontos."""

    pass


  def novoGraficoLinhaXY(self) -> Grafico:
    """Cria um novo gráfico onde são exibidas "linhas" para representar séries
 de valores.<BR>
 Os valores são passados na forma de pares de coordenadas (X,Y). As linhas
 são desenhadas ligando esses pontos.<BR>
 <BR>
 <B>Múltiplas linhas no mesmo gráfico</B><BR>
 Caso você queira exibir múltiplas linhas no mesmo gráfico, inclusive com cores diferentes,
 você pode acrescentar os 'valores' (X,Y) informando diferentes 'números de série' (começando em 1).<BR>
 <BR>
 Exemplo:<BR>
 Digamos que você queira inserir pontos no gráfico referentes a duas diferentes 'linhas'. Uma corresponderá
 à série 1 e outra corresponderá à série 2. Você faz da seguinte forma:<BR>
 <PRE>
 // Cria o gráfico
 grafico = graficos.novoGraficoLinhaXY();
 
 // Adiciona pontos da série 1
 grafico.addValor( 1  ,  1  ,  2 );    // ponto (1,2) na série 1
 grafico.addValor( 1  ,  2  ,  4 );    // ponto (2,4) na série 1
 grafico.addValor( 1  ,  3  ,  6 );    // ponto (3,6) na série 1
 
 // Adiciona pontos da série 2
 grafico.addValor( 2  ,  1  ,  3 );    // ponto (1,3) na série 2
 grafico.addValor( 2  ,  2  ,  6 );    // ponto (2,6) na série 2
 grafico.addValor( 2  ,  3  ,  9 );    // ponto (3,9) na série 2
 </PRE>
 <BR>
 Atenção: se você executar múltiplas vezes a função 'addValor' para o mesmo X e para a mesma série, o efeito
 será o de 'somar' os valores em Y."""

    pass


  def novoGraficoPareto(self) -> Grafico:
    """Cria um novo gráfico do tipo "Pareto" onde são exibidas "barras" para
 representar valores em suas categorias.<BR>
 Os valores são passados na forma de pares (nome da categoria, valor Y).
 As barras são desenhadas com as alturas definidas pelo valor Y. A posição
 de cada barra é definida pela categoria (nome).<BR>
 Além disso, as barras (categorias) são ordenadas em ordem decrescente do
 tamanho (valor Y).<BR>
 Também é apresentada uma linha correspondente à porcentagem acumulada de
 dados em cada categoria."""

    pass


  def novoGraficoPizza(self) -> Grafico:
    """Cria um novo gráfico do tipo "PIZZA" onde as 'fatias' correspondem a diferentes 'categorias' com tamanhos variados.<BR>
 Os valores são passados na forma de pares. A 'categoria' (geralmente um texto) é o componente 'X'
 de cada valor inserido no gráfico. O componente 'Y' é um valor numérico que é somado para a mesma categoria.<BR>
 O tamanho de cada 'fatia' do gráfico 'pizza' é proporcional aos valores da categoria associada. Por exemplo, se há apenas
 duas categorias agregadas, "A" e "B", e se para a categoria "A" somamos o valor 100 e para a categoria "B" somamos o valor
 200, então 1/3 do gráfico corresponderá a "A" e 2/3 do gráfico corresponderá a "B"."""

    pass


  def novoGraficoProbabilidades(self, tipo, equacao) -> Grafico:
    """Cria um novo gráfico do tipo "plotagem de probabilidades" (Probability Plot).<BR>
 Isto é, um gráfico destinado a comparar duas distribuições de dados entre si.<BR>
 Dados que seguem uma mesma distribuição tendem a se apresentar na forma de uma linha
 reta com inclinação de 45 graus em um gráfico deste tipo.<BR>
 Existem dois 'tipos' de gráficos de 'plotagem de probabilidade' implementados aqui:<BR><BR> 
 P-P Plot: supondo que uma série de valores X segue a distribuição Fx(X) e que uma série
 de valores Y segue uma distribuição Fy(Y), este gráfico é plotado da seguinte maneira: considera-se
 um valor 'z' que é livre para variar no domínio de X (teoricamente, de menos infinito até mais infinito). Para
 cada valor, informa-se no eixo X do gráfico a probabilidade acumulada Fx(X<z) (isto é, a função distribuição
 acumulada de X, em inglês chamada de 'CDF' de X) e no eixo Y do gráfico a probabilidade acumulada Fy(Y<z) (isto é, a
 função distribuição acumulada de Y, ou 'CDF' de Y).<BR>
 Note que os valores nos eixos x e y variam no intervalo entre 0 a 1.<BR><BR>
 Q-Q Plot: supondo que uma série de valores X segue a distribuição Fx(X) e que uma série
 de valores Y segue uma distribuição Fy(Y), este gráfico é plotado da seguinte manteira: considera-se
 um valor variando de 0 até 1, encontra-se o correspondente 'quantil' conforme cada uma das distribuições (isto é, utiliza-se
 para cada uma a função inversa da função probabilidade acumulada). No eixo X do gráfico é plotado o 'quantil' calculado
 para a distribuição Fx(X) e no eixo Y do gráfico é plotado o 'quantil' correspondente na distribuição Fy(Y).<BR>
 Note que os valores nos eixos x e y podem variar conforme os domínios correspondentes das séries numéricas X e Y.<BR>
 <BR>
 <BR>
 Comparação entre valores observados e uma distribuição teórica<BR>
 ==============================================================<BR>
 Para comparar a distribuição de uma série de valores (chamados de 'observações') e uma distribuição teórica qualquer (ex:
 distribuição 'normal'), informe no parâmetro 'equacao' uma fórmula correspondente à distribuição. A função utilizada na
 fórmula depende do tipo de gráfico. Se for um gráfico do tipo 'P-P Plot', utilize uma dentre as diversas funções de 'distribuição
 acumulada' (ex: "NORMAL.ACUM" para a distribuição normal). Se for um gráfico do tipo 'Q-Q Plot', utilize uma dentre as diversas
 funções 'inversa de distribuição acumulada' (também chamada de função quantílica). Por exemplo, "NORMAL.QUANTIL" para a distribuição normal.
 O primeiro parâmetro da função deve ser uma referência a uma variável hipotética 'X'. Esta variável é internamente preenchida por
 alguns valores durante execução deste método. Se a distribuição desejada possui outros parâmetros (ex: 'média' e 'desvio padrão' no caso
 da distribuição normal), informe também esses demais parâmetros (neste caso devem ser fornecidas constantes).<BR>
 Ao comparar com a distribuição teórica, basta informar valores para uma única série (a primeira série). Caso sejam fornecidos valores
 para outras séries (segunda em diante), elas também são comparadas com a distribuição teórica.<BR>
 <BR>
 Comparação entre uma série de valores observados e outra série de valores observados<BR>
 ====================================================================================<BR>
 Para comparar a distribuição de uma série de valores com outra série de valores, sem definir uma distribuição teórica, deixe
 o parâmetro 'equacao' vazio. Fazendo desta forma, os valores da primeira série de valores serão comparados com os valores das
 demais séries. Note que este caso é necessário que existam no mínimo duas séries de valores inseridas no gráfico.<BR>
 <BR>
 Para mais informações sobre P-P Plot, consulte http://en.wikipedia.org/wiki/P%E2%80%93P_plot.<BR>
 Para mais informações sobre Q-Q Plot, consulte http://en.wikipedia.org/wiki/Q%E2%80%93Q_plot<BR>
 <BR>
 Indicação dos valores (observações)<BR>
 ===================================<BR>
 Os valores a serem comparados (chamados de 'observações') devem ser preenchidos no objeto {@link Grafico Grafico} da mesma
 forma com que são fornecidos dados para um gráfico do tipo 'HISTOGRAMA'. Isto é, indique uma série de valores. Se indicar
 valores em séries distintas (segunda série em diante), os valores de cada série são comparados de forma independente."""

    pass


  def novoGraficoProbabilidadesDistribuicaoAjustada(self, tipo) -> Grafico:
    """Faz o mesmo que a função {@link Graficos#novoGraficoProbabilidades(String, String) novoGraficoProbabilidades}, com a diferença
 que a série de valores é comparada sempre com uma distribuição teórica, sendo esta inferida a partir dos dados empregado a técnica
 de 'distribuição ajustada' do ContÁgil (algo análogo ao que é feito pela função {@link Tabela#getDistribuicaoAjustada(int) getDistribuicaoAjustada} 
 em tabela).<BR>"""

    pass


  def novoGraficoProbabilidadesDistribuicaoAjustada(self, tipo, distribuicao) -> Grafico:
    """Faz o mesmo que a função {@link Graficos#novoGraficoProbabilidades(String) novoGraficoProbabilidadesDistribuicaoAjustada}, com a diferença
 que a série de valores é comparada sempre com um mesmo tipo de distribuição teórica, onde apenas seus parâmetros são inferidos a partir dos dados empregado
 a técnica MLE (estimativa de máxima verossimilhança) e também com alguns ajustes adicionais descritos em {@link DistribuicaoAjustada DistribuicaoAjustada}."""

    pass


  def novoGraficoTemporal(self) -> Grafico:
    """Função idêntica à função
 {@link Graficos#novoGraficoLinhaTemporal() novoGraficoLinhaTemporal}."""

    pass


  def novoGraficoXY(self) -> Grafico:
    """Função idêntica à função
 {@link Graficos#novoGraficoLinhaXY() novoGraficoLinhaXY}."""

    pass

class GrafoConsulta ():
  """Representa um 'grafo-consulta', que é um tipo especial de 'grafo' definido pelo
 ContÁgil para representar uma 'consulta' por 'padrões de relacionamentos."""

  def consultaRetornaGrafo(self, nomeBase) -> None:
    """Utiliza o 'grafo-consulta' para realizar uma consulta sobre uma base de dados, retornando
 em uma janela o resultado na forma de um 'grafo de relacionamentos'.<BR>
 Este método faz o mesmo que {@link GrafoRelacionamentos#consultaRetornaGrafo(GrafoConsulta, String) consultaRetornaGrafo}."""

    pass


  def consultaRetornaGrafo(self, nomeBase, alvos) -> None:
    """Utiliza o 'grafo-consulta' para realizar uma consulta sobre uma base de dados, retornando
 em uma janela o resultado na forma de um 'grafo de relacionamentos'.<BR>
 É possível indicar uma relação de entidades que devem ser marcadas no grafo resultante como 'alvos' (isto é, recebem a 'moldura vermelha' caso estejam presentes).
 Este método faz o mesmo que {@link GrafoRelacionamentos#consultaRetornaGrafo(GrafoConsulta, String, List) consultaRetornaGrafo}"""

    pass


  def getCypher(self, nomeBase) -> str:
    """Retorna o correspondente ao grafo-consulta na linguagem 'CYPHER' do NEO4J, que é utilizado
 internamente para executar a consulta em uma base de relacionamentos"""

    pass


  def getQtdCriteriosArestas(self) -> int:
    """Retorna a quantidade total de critérios programados como arestas do grafo-consulta."""

    pass


  def getQtdCriteriosVertices(self) -> int:
    """Retorna a quantidade total de critérios programados como vértices do grafo-consulta."""

    pass

class GrafoEntidade ():
  """Objeto de script que representa uma 'entidade' de um grafo de relacionamentos ou de uma base de relacionamentos
 (isto é, um 'vértice' do grafo)."""

  def addPropriedadeNumerica(self, propriedade, somar) -> None:
    """Cria ou edita uma propriedade numérica desta entidade, fazendo com que o valor numérico anterior
 seja somado ao valor informado no parâmetro. Caso o valor anterior não tenha sido definido ou caso o valor anterior
 não seja numérico, considera que o valor anterior é 0."""

    pass


  def addRelacionamento(self, segundo, tipoRelacionamento) -> GrafoRelacionamento:
    """Adiciona à base de relacionamentos ou ao grafo de relacionamentos um novo relacionamento que relaciona esta entidade
 a uma outra entidade. O tipo do relacionamento deve ser indicado no segundo parâmetro."""

    pass


  def getGrau(self) -> int:
    """Retorna a informação indicativa do 'grau' desta entidade, que corresponde ao número de relacionamentos diretos que conectam ela a outras entidades vizinhas
 a ela. A direção do relacionamento é irrelevante nesta análise. Caso exista mais de um relacionamento entre esta entidade e alguma entidade vizinha, todos eles são computados."""

    pass


  def getGrauEntidadesDistintas(self) -> int:
    """Retorna a informação indicativa do 'grau' desta entidade, que corresponde ao número de relacionamentos diretos que conectam ela a outras entidades vizinhas
 a ela, mas sem considerar a duplicidade de entidades vizinhas. A direção do relacionamento é irrelevante nesta análise. Caso exista mais de um relacionamento entre esta entidade e alguma entidade vizinha, ela é computada uma única vez."""

    pass


  def getIdentificador(self) -> str:
    """Retorna o identificador da entidade. Se for PF, será um CPF. Se for PJ, será um CNPJ. Para outros tipos
 de entidades pode ser outro texto de identificação. Ele deve ser único no grafo ou na base de relacionamentos."""

    pass


  def getNomeGrupo(self) -> str:
    """Caso esta entidade esteja 'agrupada' com outras entidades para o propósito de exibição em um 'grafo de relacionamentos', retorna o nome do grupo onde ela se encontra.<BR>
 Caso contrário, retorna nulo.<BR>
 Esta função apenas é aplicável para informações obtidas diretamente de um 'grafo de relacionamentos' que está sendo exibido.<BR>
 Não se aplica a informações mantidas em 'base de relacionamentos' (isto é, que não estão sendo visualizadas)."""

    pass


  def getNomesPropriedades(self) -> list:
    """Retorna em uma lista os nomes das propriedades que foram previamente atribuídas a esta entidade."""

    pass


  def getPosicaoX(self) -> Double:
    """Retorna a coordenada X da posição onde esta entidade está posicionado no grafo visível.<BR>
 Se o grafo não está sendo visualizado, ou se o vértice foi 'agrupado', retorna NULL."""

    pass


  def getPosicaoY(self) -> Double:
    """Retorna a coordenada Y da posição onde esta entidade está posicionado no grafo visível.<BR>
 Se o grafo não está sendo visualizado, ou se o vértice foi 'agrupado', retorna NULL."""

    pass


  def getPropriedade(self, propriedade) -> Object:
    """Retorna o conteúdo de uma propriedade que tenha sido previamente atribuída a esta entidade, ou não retorna nada caso não tenha esta propriedade."""

    pass


  def getRelacionamentos(self) -> list:
    """Retorna uma lista com todos os relacionamentos diretos desta entidade. A direção do relacionamento
 é irrelevante nesta análise. Caso exista mais de um relacionamento entre esta entidade e alguma entidade vizinha, todos eles são informados."""

    pass


  def getTabelaPropriedades(self) -> Tabela:
    """Retorna em uma tabela todas as propriedades que foram previamente atribuídas a esta entidade.<BR>
 Cada linha da tabela corresponde a uma propriedade.<BR>
 A primeira coluna contém o nome da propriedade.<BR>
 A segunda coluna contém o valor da propriedade, já convertido para o formato texto."""

    pass


  def getTamanho(self) -> int:
    """Retorna o tamanho previamente definido com que a entidade é apresentada ao ser visualizada em grafos de relacionamentos, ou retorna
 0 caso esta informação não tenha sido explicitamente definida para a entidade (isto é, na hipótese em que ela deve ser apresentada
 com o tamanho padrão para qualquer entidade)."""

    pass


  def getTipo(self) -> str:
    """Retorna o tipo da entidade. Por exemplo, 'PF' para 'pessoa física', 'PJ' para 'pessoa jurídica', etc."""

    pass


  def getVizinhos(self) -> list:
    """Retorna uma lista com todas as entidades que são 'vizinhas' a esta. Isto é, que se relacionam diretamente com ela. A direção do relacionamento
 é irrelevante nesta análise. Caso exista mais de um relacionamento entre esta entidade e uma entidade vizinha, ela é informada uma única vez."""

    pass


  def hasPropriedade(self, propriedade) -> bool:
    """Retorna a indicação de que uma determinada propriedade com um determinado nome foi previamente atribuída a esta entidade."""

    pass


  def isAgrupado(self) -> bool:
    """Retorna a indicação de que esta entidade está 'agrupada' com outras entidades para o propósito de exibição em um 'grafo de relacionamentos'.<BR>
 Esta função apenas é aplicável para informações obtidas diretamente de um 'grafo de relacionamentos' que está sendo exibido.<BR>
 Não se aplica a informações mantidas em 'base de relacionamentos' (isto é, que não estão sendo visualizadas)."""

    pass


  def isAlvo(self) -> bool:
    """Caso o grafo esteja sendo visualizado na janela, retorna a indicação de que esta entidade é considerada como 'alvo'. Isto é,
 possui uma moldura vermelha."""

    pass


  def isOculto(self) -> bool:
    """Retorna a indicação de que esta entidade está 'escondida' para o propósito de exibição em um 'grafo de relacionamentos'.<BR>
 Esta função apenas é aplicável para informações obtidas diretamente de um 'grafo de relacionamentos' que está sendo exibido.<BR>
 Não se aplica a informações mantidas em 'base de relacionamentos' (isto é, que não estão sendo visualizadas)."""

    pass


  def isSuspeito(self) -> bool:
    """Caso o grafo esteja sendo visualizado na janela, retorna a indicação de que esta entidade é considerada como 'suspeito'. Isto é,
 possui uma moldura laranja."""

    pass


  def removeEntidade(self) -> None:
    """Remove esta entidade da base ou do grafo de relacionamentos."""

    pass


  def removePropriedade(self, propriedade) -> None:
    """Remove uma propriedade anteriormente atribuída a esta entidade."""

    pass


  def removeRelacionamento(self, segundo, tipoRelacionamento) -> None:
    """Remove da base de relacionamentos ou do grafo de relacionamentos um relacionamento entre esta entidade e uma segunda entidade,
 nesta ordem, considerando apenas relacionamentos do tipo indicado no segundo parâmetro."""

    pass


  def removeRelacionamentos(self, segundo, qualquerDirecao) -> None:
    """Remove da base de relacionamentos ou do grafo de relacionamentos todos os relacionamentos que partem desta entidade
 para a entidade informada no primeiro parâmetro. Caso o segundo parâmetro seja TRUE (VERDADEIRO), remove também todos os relacionamentos que apontam
 para esta entidade partindo da entidade informada no primeiro parâmetro."""

    pass


  def setAlvo(self, alvo) -> None:
    """Caso o grafo esteja sendo visualizado na janela, define a entidade como alvo ou não. Isto é,
 apresenta com uma moldura vermelha."""

    pass


  def setOculto(self, oculto) -> None:
    """Caso o grafo esteja sendo visualizado na janela, faz com que uma entidade não agrupada seja escondida ou seja apresentada."""

    pass


  def setPosicao(self, x, y) -> None:
    """Altera as coordenadas X, Y da posição onde esta entidade deve ser posicionada no grafo visível.<BR>
 Este método é desprezado caso o grafo não esteja visível."""

    pass


  def setPosicaoX(self, x) -> None:
    """Altera a coordenada X da posição onde esta entidade deve ser posicionada no grafo visível.<BR>
 Este método é desprezado caso o grafo não esteja visível."""

    pass


  def setPosicaoY(self, y) -> None:
    """Altera a coordenada Y da posição onde esta entidade deve ser posicionada no grafo visível.<BR>
 Este método é desprezado caso o grafo não esteja visível."""

    pass


  def setPropriedade(self, propriedade, valor) -> None:
    """Cria ou edita uma propriedade desta entidade."""

    pass


  def setSuspeito(self, suspeito) -> None:
    """Caso o grafo esteja sendo visualizado na janela, define a entidade como suspeito ou não. Isto é,
 apresenta com uma moldura laranja."""

    pass


  def setTamanho(self, tamanho) -> None:
    """Altera o tamanho com que a entidade é apresentada ao ser visualizada em grafos de relacionamentos.<BR>
 Esta função tem o mesmo efeito que definir a propriedade 'TAMANHO' da entidade."""

    pass


  def toString(self) -> str:
    pass

class GrafoRelacionamento ():
  """Objeto de script que representa um 'relacionamento' de um grafo de relacionamentos ou de uma base de relacionamentos
 (isto é, uma 'aresta' do grafo)."""

  def addPropriedadeNumerica(self, propriedade, somar) -> None:
    """Cria ou edita uma propriedade numérica deste relacionamento, fazendo com que o valor numérico anterior
 seja somado ao valor informado no parâmetro. Caso o valor anterior não tenha sido definido ou caso o valor anterior
 não seja numérico, considera que o valor anterior é 0."""

    pass


  def getNomesPropriedades(self) -> list:
    """Retorna em uma lista os nomes das propriedades que foram previamente atribuídas a este relacionamento."""

    pass


  def getPrimeiraEntidade(self) -> GrafoEntidade:
    """Retorna a primeira entidade deste relacionamento (de onde parte o relacionamento)."""

    pass


  def getPropriedade(self, propriedade) -> Object:
    """Retorna o conteúdo de uma propriedade que tenha sido previamente atribuída a este relacionamento, ou não retorna nada caso não tenha esta propriedade."""

    pass


  def getQuebrarLinhaRotuloRelacionamento(self) -> bool:
    """Retorna o valor da propriedade para quebra de linha na exibição do rótulo do
 relacionamento (aresta) quando o texto for longo. 
 Caso o relacionamento não possua a propriedade configurada, retorna o valor "falso"."""

    pass


  def getSegundaEntidade(self) -> GrafoEntidade:
    """Retorna a segunda entidade deste relacionamento (para onde aponta o relacionamento)."""

    pass


  def getTabelaPropriedades(self) -> Tabela:
    """Retorna em uma tabela todas as propriedades que foram previamente atribuídas a este relacionamento.<BR>
 Cada linha da tabela corresponde a uma propriedade.<BR>
 A primeira coluna contém o nome da propriedade.<BR>
 A segunda coluna contém o valor da propriedade, já convertido para o formato texto."""

    pass


  def getTamanhoFonteRotuloAresta(self) -> int:
    """Retorna o tamanho da fonte configurado para exibição do rótulo da aresta (relacionamento). 
 Caso não tenha sido configurado, retorna 0 (zero)."""

    pass


  def getTipo(self) -> str:
    """Retorna o tipo do relacionamento."""

    pass


  def hasPropriedade(self, propriedade) -> bool:
    """Retorna a indicação de que uma determinada propriedade com um determinado nome foi previamente atribuída a este relacionamento."""

    pass


  def isDirecional(self) -> bool:
    """Retorna a indicação de que a direção deste relacionamento é relevante para o seu significado."""

    pass


  def isOculto(self) -> bool:
    """Retorna a indicação de que este relacionamento está 'escondido' para o propósito de exibição em um 'grafo de relacionamentos'.<BR>
 Esta função apenas é aplicável para informações obtidas diretamente de um 'grafo de relacionamentos' que está sendo exibido.<BR>
 Não se aplica a informações mantidas em 'base de relacionamentos' (isto é, que não estão sendo visualizadas)."""

    pass


  def removePropriedade(self, propriedade) -> None:
    """Remove uma propriedade anteriormente atribuída a este relacionamento."""

    pass


  def removeRelacionamento(self) -> None:
    """Remove este relacionamento da base ou do grafo de relacionamentos."""

    pass


  def setOculto(self, oculto) -> None:
    """Caso o grafo esteja sendo visualizado na janela, faz com que um relacionamento seja escondido ou seja apresentado."""

    pass


  def setPropriedade(self, propriedade, valor) -> None:
    """Cria ou edita uma propriedade deste relacionamento."""

    pass


  def setQuebrarLinhaRotuloRelacionamento(self, quebrarLinha) -> None:
    """Define se haverá quebra de linha na exibição do rótulo do relacionamento
 (aresta) quando o texto for longo."""

    pass


  def setTamanhoFonteRotuloAresta(self, tamanho) -> None:
    """Define o tamanho da fonte do rótulo da aresta (relacionamento). Informar 0 (zero) para
 utilizar o tamanho de fonte padrão definido em preferências do grafo."""

    pass


  def toString(self) -> str:
    pass

class GrafoRelacionamentos ():
  """Este objeto apresenta diversos métodos para interagir com o "grafo de
 relacionamentos" do ContÁgil. Isto é, pode inserir, consultar, etc.<BR>
 <BR>
 O objeto inicial, disponibilizado na linguagem de script, persiste as
 alterações sobre o grafo em disco (ex: adição de novas entidades ou
 relacionamentos). Porém, é possível também fazer uso deste objeto para
 visualização apenas, sem persistência em disco.<BR>
 <BR>
 BASES DE GRAFOS x ARQUIVOS DE GRAFOS<BR>
 ==============================================<BR>
 Existem dois conceitos distintos que podem eventualmente causar alguma
 confusão. São eles:<BR>
 - BASE DE GRAFO DE RELACIONAMENTOS DO CONTÁGIL<BR>
 - ARQUIVO DE GRAFO DE RELACIONAMENTOS DO CONTÁGIL<BR>
 <BR>
 A 'base de grafo' é como um 'repositório de entidades e relacionamentos', a
 partir do qual podem ser realizadas diversas consultas (por exemplo, para
 obter os relacionamentos com uma determinada pessoa até um determinado
 nível). Esta base não inclui as 'posições' com as quais eles são
 apresentados. Porém, a partir de uma base de grafo, é possível construir um
 ou mais 'grafos', que seriam como 'visões distintas' da mesma base.<BR>
 O ContÁgil define como 'base inicial' a base cujo nome é 'GERAL'. O usuário é
 livre para criar outras 'bases' diferentes, atribuindo outros nomes
 diferentes para elas.<BR>
 As 'bases de grafos' são mantidas dentro da 'pasta de trabalho' do ContÁgil.
 Podem ser copiadas de um computador para outro através do recurso de 'backup'
 do ContÁgil (menu 'Geral').<BR>
 <BR>
 O 'arquivo de grafo', por sua vez, é um arquivo isolado que contém uma dada
 'apresentação' de um grafo de relacionamentos. Isto é, além de conter a
 relação de entidades e relacionamentos, este arquivo indica também as
 posições com que esses elementos devem ser apresentados na janela. Trata-se,
 portanto, de uma 'fotografia' do que é apresentado na janela do visualizador
 do grafo de relacionamentos.<BR>
 O usuário pode 'salvar' a apresentação de um grafo de relacionamentos em um
 desses arquivos, que possui extensão 'GRF', e pode compartilhar com outros
 usuários do ContÁgil. O arquivo pode residir em qualquer lugar, inclusive
 fora da pasta de trabalho do ContÁgil.<BR>"""

  def abrirGrafoConsulta(self, nomeArquivo) -> GrafoConsulta:
    """Dado o nome de um arquivo contendo um 'grafo-consulta' previamente salvo no
 projeto, disponibiliza-o para uso no script."""

    pass


  def addAlvo(self, alvo) -> None:
    """Adiciona à relação previamente configurada um 'alvo' que será apresentado com
 moldura vermelha nas próximas visualizações de grafos executadas por meio de
 funções do tipo 'vizualizarXXXXX' definidas aqui.<BR>
 Esta definição não afeta a 'base de relacionamentos'."""

    pass


  def addSuspeito(self, suspeito) -> None:
    """Adiciona à relação previamente configurada um 'suspeito' que será apresentado
 com moldura laranja nas próximas visualizações de grafos executadas por meio
 de funções do tipo 'vizualizarXXXXX' definidas aqui.<BR>
 Esta definição não afeta a 'base de relacionamentos'."""

    pass


  def apagarBase(self, nomeBase) -> None:
    """Apaga a base de grafos indicada, removendo todos os nodos e arestas"""

    pass


  def apagarBaseDefault(self) -> None:
    """Apaga a base de grafos default, removendo todos os nodos e arestas."""

    pass


  def clearAlvos(self) -> None:
    """Remove da memória a relação de 'alvos' previamente configurados com chamadas
 às funções 'addAlvo' ou 'setAlvos'.<BR>
 Esta definição não afeta a 'base de relacionamentos'."""

    pass


  def clearSuspeitos(self) -> None:
    """Remove da memória a relação de 'suspeitos' previamente configurados com
 chamadas às funções 'addSuspeito' ou 'setSuspeitos'.<BR>
 Esta definição não afeta a 'base de relacionamentos'."""

    pass


  def complementaBaseComCadastro(self, nomeBase, codigos) -> None:
    """Alternativa do método
 {@link GrafoRelacionamentos#complementaBaseComCadastro(String)
 complementaBaseComCadastro}, sendo que aqui pode ser informada uma lista
 contendo códigos CPF e/ou CNPJ (14 ou 8 dígitos) para o propósito de
 complementação da base. Nesta hipótese o ContÁgil irá considerar do cadastro
 local de pessoas as informações relacionadas a esses contribuintes, mas
 somente eles, ainda que a base que está sendo 'complementada' não contenha
 informações sobre eles."""

    pass


  def complementaBaseComCadastro(self, nomeBase) -> None:
    """Dada uma base de relacionamentos previamente construída, este método pode ser
 utilizado para complementar esta base com informações existentes no cadastro
 local de pessoas (físicas e jurídicas) do ContÁgil.<BR>
 Do cadastro de pessoas são consideradas apenas as informações referentes às
 pessoas já existentes na base, incluindo também alguns relacionamentos
 diretos a essas pessoas em decorrência do cadastro.<BR>
 <BR>
 EXEMPLO<BR>
 ======================<BR>
 Por exemplo, considere a seguinte situação hipotética realizada em etapas
 sucessivas:<BR>
 1) Uma base de relacionamentos montada inicialmente apenas sobre os dados de
 GFIP. Nesta hipótese, as pessoas físicas não estarão indicadas por CPF, mas
 sim por NIT, pois em GFIP não temos a indicação dos CPF dos empregados (a
 menos que tenha importado esses dados para o cadastro de pessoas físicas do
 ContÁgil previamente à elaboração da base de relacionamentos).<BR>
 Esta primeira etapa poderia ser realizada através da ação
 {@link GrafoRelacionamentos#importaBasesContagil(String[], String)
 importaBasesContagil} indicando "GFIP" como uma das bases.<BR>
 2) Posteriormente o cadastro de pessoas físicas do ContÁgil é atualizado com
 informações do CNIS/Cidadão, apenas sobre as pessoas para as quais se conhece
 o NIT mas não se conhece o CPF, utilizando para isso a ação
 {@link Cnis#atualizaCadastroContAgil(Chave, boolean)
 atualizaCadastroContAgil}.<BR>
 3) Depois, com o cadastro do ContÁgil já atualizado com informações
 cadastrais sobre essas pessoas, pode-se atualizar a base de relacionamentos
 montada no estágio 1 com essas novas informações, utilizando para isso esta
 ação ( {@link GrafoRelacionamentos#complementaBaseComCadastro(String)
 complementaBaseComCadastro} ).<BR>
 OBS: se antes de realizar a etapa 1 (criação da base de relacionamentos),
 conforme enunciada no exemplo hipotético acima, fosse realizada a etapa 2
 (atualização do cadastro), não seria necessário realizar a etapa 3
 (complementação da base), pois os dados do cadastro poderiam ser incorporados
 à base de relacionamentos através da mesma etapa de construção da base.<BR>
 Esta 'complementação' apenas se torna necessária caso o cadastro de pessoas
 do ContÁgil seja atualizado com novas informações depois da base de
 relacionamentos já ter sido construída.<BR>"""

    pass


  def consultaBaseComLouvainRetornaTabela(self, nomeBase) -> Tabela:
    pass


  def consultaCypherRetornaGrafo(self, consultaCypher, nomeBase, alvos) -> None:
    """Alternativa ao método
 {@link GrafoRelacionamentos#consultaCypherRetornaGrafo(String, String)
 consultaCypherRetornaGrafo} onde é possível indicar uma relação de entidades
 que devem ser marcadas no grafo resultante como 'alvos' (isto é, recebem a
 'moldura vermelha' caso estejam presentes)."""

    pass


  def consultaCypherRetornaGrafo(self, consultaCypher, nomeBase) -> None:
    """Utiliza a linguagem de consulta 'CYPHER' para realizar uma consulta sobre uma
 base de dados, retornando em uma janela o resultado na forma de um 'grafo de
 relacionamentos'.<BR>
 <BR>
 A linguagem CYPHER faz parte da especificação da tecnologia NEO4J e sua
 documentação pode ser encontrada neste endereço:<BR>
 http://docs.neo4j.org/chunked/milestone/cypher-query-lang.html<BR>
 <BR>
 Ela permite algumas consultas bem complexas que seriam difíceis de formular
 de outra forma alternativa.<BR>
 <BR>
 Há diferentes métodos para utilização desta linguagem.<BR>
 Este método deve ser utilizado somente nas consultas que retornam 'nós' e
 'relacionamentos', os quais por sua vez são apresentados em uma janela de
 visualização de grafos de relacionamentos.<BR>
 Exemplo:<BR>
 
 <PRE>
 // Apresenta em uma janela um grafo contendo sócios, suas empresas e as empresas clientes destas
 // Considera somente situações onde estão presentes as duas relações (a de sócio e a de cliente)
 // Atenção: a consulta distingue diferença de letras maiúsculas e minúsculas
 consultaCypherRetornaGrafo("MATCH (a)-[r1:Sócio]->(b)-[r2:Cliente]->(c) RETURN a,b,c,r1,r2");
 </PRE>"""

    pass


  def consultaCypherRetornaInteiro(self, consultaCypher, nomeBase) -> long:
    """Utiliza a linguagem de consulta 'CYPHER' para realizar uma consulta sobre uma
 base de dados, retornando um número inteiro qualquer (exemplo, retornar
 quantidade de elementos).<BR>
 <BR>
 A linguagem CYPHER faz parte da especificação da tecnologia NEO4J e sua
 documentação pode ser encontrada neste endereço:<BR>
 http://docs.neo4j.org/chunked/milestone/cypher-query-lang.html<BR>
 <BR>
 Ela permite algumas consultas bem complexas que seriam difíceis de formular
 de outra forma alternativa.<BR>
 <BR>
 Há diferentes métodos para utilização desta linguagem.<BR>
 Este método deve ser utilizado somente nas consultas que retornam um único
 valor do tipo inteiro.<BR>
 Exemplo:<BR>
 
 <PRE>
 // Retorna a quantidade de PJ existentes na base cuja cidade é 'Curitiba' (atenção: faz distinção de letras maiúsculas e minúsculas)
 quantidade = consultaCypherRetornaInteiro("MATCH (a:PJ) WHERE a.CIDADE='Curitiba' RETURN COUNT(DISTINCT a)");
 </PRE>"""

    pass


  def consultaCypherRetornaLista(self, consultaCypher, nomeBase) -> list:
    """Utiliza a linguagem de consulta 'CYPHER' para realizar uma consulta sobre uma
 base de dados, retornando uma lista com conteúdos quaisquer (exemplo, uma
 lista de nomes).<BR>
 <BR>
 A linguagem CYPHER faz parte da especificação da tecnologia NEO4J e sua
 documentação pode ser encontrada neste endereço:<BR>
 http://docs.neo4j.org/chunked/milestone/cypher-query-lang.html<BR>
 <BR>
 Ela permite algumas consultas bem complexas que seriam difíceis de formular
 de outra forma alternativa.<BR>
 <BR>
 Há diferentes métodos para utilização desta linguagem.<BR>
 Este método deve ser utilizado somente nas consultas que retornam uma lista
 de coisas.<BR>
 Exemplo:<BR>
 
 <PRE>
 // Retorna os nomes de pessoas físicas que são clientes de advogados<BR>
 lista = consultaCypherRetornaLista("MATCH (a)-[r:Advogado]->(b:PF) RETURN DISTINCT b.NOME");
 </PRE>"""

    pass


  def consultaCypherRetornaOutraBase(self, consultaCypher, nomeBaseOrigem, nomeBaseDestino) -> None:
    """Utiliza a linguagem de consulta 'CYPHER' para realizar uma consulta sobre uma
 base de dados, retornando em uma outra base o resultado da consulta. Isto é,
 as entidades e relacionamentos retornados na consulta são diretamente
 inseridos em outra base, podendo ser uma nova base ou uma base existente
 diferente da base que está sendo consultada.<BR>
 <BR>
 A linguagem CYPHER faz parte da especificação da tecnologia NEO4J e sua
 documentação pode ser encontrada neste endereço:<BR>
 http://docs.neo4j.org/chunked/milestone/cypher-query-lang.html<BR>
 <BR>
 Ela permite algumas consultas bem complexas que seriam difíceis de formular
 de outra forma alternativa.<BR>
 <BR>
 Há diferentes métodos para utilização desta linguagem.<BR>
 Este método deve ser utilizado somente nas consultas que retornam 'nós' e
 'relacionamentos', os quais por sua vez são inseridos diretamente em uma base
 de relacionamentos.<BR>"""

    pass


  def consultaCypherRetornaTabela(self, consultaCypher, nomeBase) -> Tabela:
    """Utiliza a linguagem de consulta 'CYPHER' para realizar uma consulta sobre uma
 base de dados, retornando o resultado na forma de uma tabela.<BR>
 <BR>
 A linguagem CYPHER faz parte da especificação da tecnologia NEO4J e sua
 documentação pode ser encontrada neste endereço:<BR>
 http://docs.neo4j.org/chunked/milestone/cypher-query-lang.html<BR>
 <BR>
 Ela permite algumas consultas bem complexas que seriam difíceis de formular
 de outra forma alternativa.<BR>
 <BR>
 Há diferentes métodos para utilização desta linguagem.<BR>
 Este método deve ser utilizado somente nas consultas que diversos dados que
 são apresentados na forma de uma 'tabela'.<BR>
 A cláusula de retorno da consulta Cypher deve conter apenas propriedades de
 nós ou relacionamentos, ou algo que possa ser interpretado como textos,
 números ou datas. Se estiver retornando referências diretas a nós ou
 relacionamentos, essas informações são ignoradas na tabela de resultado.<BR>
 <BR>
 Exemplo:<BR>
 
 <PRE>
 // Apresenta em uma janela um grafo contendo nomes de advogados, seus respectivos clientes e quanto recebeu de cada um
 // Atenção: a consulta distingue diferença de letras maiúsculas e minúsculas
 consultaCypherRetornaGrafo("MATCH (a)-[r:Advogado]->(b) RETURN a.NOME,b.NOME,SUM(r.VALOR)");
 </PRE>"""

    pass


  def consultaCypherRetornaValor(self, consultaCypher, nomeBase) -> float:
    """Utiliza a linguagem de consulta 'CYPHER' para realizar uma consulta sobre uma
 base de dados, retornando um número qualquer com casas decimais (exemplo,
 retornar uma soma sobre diversos valores).<BR>
 <BR>
 A linguagem CYPHER faz parte da especificação da tecnologia NEO4J e sua
 documentação pode ser encontrada neste endereço:<BR>
 http://docs.neo4j.org/chunked/milestone/cypher-query-lang.html<BR>
 <BR>
 Ela permite algumas consultas bem complexas que seriam difíceis de formular
 de outra forma alternativa.<BR>
 <BR>
 Há diferentes métodos para utilização desta linguagem.<BR>
 Este método deve ser utilizado somente nas consultas que retornam um único
 valor do tipo valor numérico com casas decimais.<BR>
 Exemplo:<BR>
 
 <PRE>
 // Retorna o valor total em relações do tipo 'Cliente' existentes na base (atenção: faz distinção de letras maiúsculas e minúsculas)
 total = consultaCypherRetornaValor("MATCH ()-[r:Cliente]->() RETURN SUM(r.VALOR) ");
 </PRE>"""

    pass


  def consultaRetornaGrafo(self, consulta, nomeBase, alvos) -> None:
    """Alternativa ao método {@link #consultaRetornaGrafo(GrafoConsulta, String)
 consultaRetornaGrafo} onde é possível indicar uma relação de entidades que
 devem ser marcadas no grafo resultante como 'alvos' (isto é, recebem a
 'moldura vermelha' caso estejam presentes)."""

    pass


  def consultaRetornaGrafo(self, consulta, nomeBase) -> None:
    """Utiliza um 'grafo-consulta' para realizar uma consulta sobre uma base de
 dados, retornando em uma janela o resultado na forma de um 'grafo de
 relacionamentos'.<BR>"""

    pass


  def converteEntidadesGenericas(self, nomeBase, converteNomeParaCPF, converteNomeParaCNPJ, converteNITparaCPF, pesquisaCNIS) -> None:
    """Este método tem o mesmo efeito que a funcionalidade 'Converter Entidades
 Genéricas para PF ou PJ' acessível via menu do ContÁgil.<BR>
 Esta funcionalidade se destina a alterar uma base de relacionamentos já
 existente, de modo que as 'entidades genéricas' da base sejam 'convertidas'
 para tipos mais específicos (tais como 'PF' e 'PJ'), com base em alguns
 critérios.<BR>
 <BR>
 Isso pode ser útil caso tenha montado uma base de relacionamentos a partir de
 várias fontes de dados diferentes. Dependendo de como isso foi feito, é
 possível que algumas pessoas estejam sendo apresentadas repetidas vezes na
 mesma base. Isso pode ocorrer caso a identidade da pessoa seja diferente em
 diferentes fontes (ex: uma fonte diferencia pelo NIT, outra pelo CPF, e outra
 apenas pelo nome)."""

    pass


  def desligaBase(self, nomeBase) -> None:
    """Desliga a base atualmente em uso (isto é, faz com que ela deixe de ser
 utilizada pelo ContÁgil).<BR>
 Em geral, este método não precisa ser executado, pois quaisquer base de
 grafos de relacionamentos abertas durante a utilização do ContÁgil são
 automaticamente 'desligadas' ao encerrar o ContÁgil.<BR>
 Note que não é possível ter mais de uma aplicação ContÁgil utilizando ao
 mesmo tempo a mesma base. Portanto, caso esteja interessado em disponibilizar
 o acesso à mesma base para outra aplicação sendo executada ao mesmo tempo,
 utilize este método para desligar a base na aplicação que não requer mais o
 acesso à ela.<BR>
 Este método não tem efeito caso o atual objeto 'GrafoRelacionamentos' não
 esteja sendo persistido em disco (isto é, caso ele seja meramente
 visual).<BR>
 OBS: caso algum outro método seja executado sobre este mesmo objeto
 'GrafoRelacionamentos' após o 'desligamento' da base correspondente, ela é
 automaticamente 'reaberta' (isto é, ela volta a estar 'ligada')."""

    pass


  def exibeOpcoesConsulta(self, nomeBase) -> None:
    """Exibe a janela do ContÁgil com várias opções de consulta a uma base de
 relacionamentos. A execução do script fica em espera até que essas janelas
 sejam fechadas pelo usuário."""

    pass


  def exportaBaseGrafoComoImagem(self, ni, niveis, nomeBase) -> Imagem:
    """Busca a entidade principal e relacionamentos até determinado nível. A
 consulta é feita na base de grafos indicada no parâmetro. O resultado é
 apresentado como um objeto 'Imagem' em memória. Você pode depois salvar esta
 imagem em disco (por exemplo, utilizando {@link Imagem#exportaPNG(String)
 exportaPNG}) ou adicionar a uma planilha Excel (utilizando
 {@link ArquivoExcel#desenhaImagem(Imagem) desenhaImagem}) ou alguma outra
 operação de script que possa trabalhar com imagem."""

    pass


  def exportaBaseGrafoComoPDF(self, ni, niveis, nomeBase, nomeArquivoPDF) -> Arquivo:
    """Busca a entidade principal e relacionamentos até determinado nível. A
 consulta é feita na base de grafos indicada no parâmetro. O resultado é salvo
 como arquivo PDF, onde é inserida a imagem do grafo."""

    pass


  def exportaGrafoComoImagem(self) -> Imagem:
    """Caso este objeto tenha sido originado de um outro método que resultou em um
 'grafo' em memória, exporta seu conteúdo para um objeto do tipo 'Imagem'.<BR>
 OBS: este método fica sem função nas demais hipóteses (isto é, retorna
 NULL).<BR>
 O resultado é apresentado como um objeto 'Imagem' em memória. Você pode
 depois salvar esta imagem em disco (por exemplo, utilizando
 {@link Imagem#exportaPNG(String) exportaPNG}) ou adicionar a uma planilha
 Excel (utilizando {@link ArquivoExcel#desenhaImagem(Imagem) desenhaImagem})
 ou alguma outra operação de script que possa trabalhar com imagem."""

    pass


  def exportaGrafoComoPDF(self, nomeArquivoPDF) -> Arquivo:
    """Caso este objeto tenha sido originado de um outro método que resultou em um
 'grafo' em memória, exporta seu conteúdo para um arquivo PDF, onde é inserida
 a imagem do grafo. OBS: este método fica sem função nas demais hipóteses
 (isto é, retorna NULL).<BR>"""

    pass


  def exportarArquivoCSV(self, nomeBase, arquivoEntidades, arquivoRelacionamentos) -> None:
    """Exporta o conteúdo de uma base de relacionamentos para um ou dois arquivos
 textos com campos separados por vírgulas.<BR>
 Os parâmetros do tipo {@link ArquivoCSV ArquivoCSV} devem ter sido
 previamente configurados de acordo com as opções de interesse (isto é, já
 definido previamente o caractere a ser utilizado na separação dos campos, o
 caractere a ser utilizado na separação de casas decimais, o padrão de
 codificação de caracteres, etc.)."""

    pass


  def getAlvos(self) -> Lista:
    """Retorna a relação de 'alvos' previamente configurados com chamadas às funções
 'addAlvo' ou 'setAlvos'<BR>
 Esta definição não afeta a 'base de relacionamentos'."""

    pass


  def getEntidadesBase(self, nomeBase) -> list:
    """Retorna uma lista com todas as entidades de uma determinada base. As
 entidades são informadas por meio de objetos de script do tipo @{link
 GrafoEntidade GrafoEntidade}. Você pode consultar outras informações sobre
 cada uma dessas entidades utilizando os métodos definidos nesses objetos."""

    pass


  def getGrafosConsultas(self) -> list:
    """Retorna uma relação de 'grafos-consultas' que foram salvos no projeto atual."""

    pass


  def getImagem(self, nome) -> Imagem:
    """Dado o nome de uma imagem que tenha sido previamente armazenada na pasta do
 ContÁgil dedicada ao armazenamento de imagens para bases de relacionamentos,
 ou que esteja armazenada internamente dentro da aplicação (isto é, uma das
 imagens pre-definidas), retorna o objeto {@link Imagem Imagem} que a
 representa."""

    pass


  def getNomesBases(self) -> list:
    """Retorna a relação de nomes de bases de relacionamentos criadas na pasta de
 trabalho do ContÁgil."""

    pass


  def getNomesBasesForaDoProjeto(self) -> list:
    """Retorna a relação de nomes de bases de relacionamentos criadas na pasta de
 trabalho do ContÁgil."""

    pass


  def getNomesBasesNoProjeto(self) -> list:
    """Retorna a relação de nomes de bases de relacionamentos criadas na pasta de
 trabalho do projeto."""

    pass


  def getNomesImagensExistentes(self) -> list:
    """Retorna os nomes das imagens que já existem no ContÁgil. Podem ser imagens
 armazenadas internamente no ContÁgil ou imagens que foram salvas pelo usuário
 na pasta destinada ao armazenamento de imagens."""

    pass


  def getPessoasFisicas(self, nomeBase) -> Tabela:
    """Retorna em uma tabela a relação de todas as PESSOAS FÍSICAS existentes na
 BASE DE RELACIONAMENTOS. A tabela retornada possui duas colunas: ID (com os
 códigos CPF formatados) e NOME (conforme propriedade 'NOME' informada na base
 de relacionamentos)."""

    pass


  def getPessoasFisicasRelacionadas(self, id, nomeBase) -> list:
    """Retorna a relação de pessoas físicas que estão relacionadas a alguma entidade
 existente na base de relacionamentos. Aceita qualquer tipo de relacionamento,
 contanto que seja relacionamento de primeiro nível."""

    pass


  def getPessoasFisicasRelacionadas(self, id, nomeBase, tiposRelacionamentos) -> list:
    """Retorna a relação de pessoas físicas que estão relacionadas a alguma entidade
 existente na base de relacionamentos. Aceita apenas um dos tipos de
 relacionamento informados no parâmetro do método (considera somente primeiro
 nível)."""

    pass


  def getPessoasJuridicas(self, nomeBase) -> Tabela:
    """Retorna em uma tabela a relação de todas as PESSOAS JURÍDICAS existentes na
 BASE DE RELACIONAMENTOS. A tabela retornada possui duas colunas: ID (com os
 códigos CNPJ formatados) e NOME (conforme propriedade 'NOME' informada na
 base de relacionamentos)."""

    pass


  def getPessoasJuridicasRelacionadas(self, id, nomeBase, tiposRelacionamentos) -> list:
    """Retorna a relação de pessoas jurídicas que estão relacionadas a alguma
 entidade existente na base de relacionamentos. Aceita apenas um dos tipos de
 relacionamento informados no parâmetro do método (considera somente primeiro
 nível)."""

    pass


  def getPessoasJuridicasRelacionadas(self, id, nomeBase) -> list:
    """Retorna a relação de pessoas jurídicas que estão relacionadas a alguma
 entidade existente na base de relacionamentos. Aceita qualquer tipo de
 relacionamento, contanto que seja relacionamento de primeiro nível."""

    pass


  def getQtdBases(self) -> int:
    """Retorna a quantidade de bases de relacionamentos criadas na pasta de trabalho
 do ContÁgil."""

    pass


  def getQtdEntidadesBase(self, nomeBase) -> int:
    """Retorna a quantidade total de entidades existentes na base de relacionamentos"""

    pass


  def getQtdRelacionamentosBase(self, nomeBase) -> int:
    """Retorna a quantidade total de relacionamentos existentes na base de
 relacionamentos"""

    pass


  def getQuantidadeEntidadesInseridasUltimaOperacao(self) -> int:
    """Retorna a quantidade de entidades que foram inseridas ou atualizadas na base
 de relacionamentos após a última operação realizada aqui."""

    pass


  def getQuantidadeRelacionamentosInseridosUltimaOperacao(self) -> int:
    """Retorna a quantidade de relacionamentos que foram inseridos ou atualizados na
 base de relacionamentos após a última operação realizada aqui."""

    pass


  def getRankingCentralidadeAutoVetor(self, nomeBase, pesoSobreRelevancia) -> Tabela:
    """Aplica sobre uma base de relacionamentos o cálculo do 'RANKING de ENTIDADES'
 considerando o critério 'Centralidade de Autovetor'<BR>
 Retorna uma tabela com o resultado do 'RANKING de ENTIDADES'. Cada linha da
 tabela corresponde a uma entidade. As colunas apresentam:<BR>
 TIPO: tipo da entidade<BR>
 ID: identificação da entidade<BR>
 NOME: propriedade 'NOME' da entidade<BR>
 PONTUAÇÃO: pontuação adquirida pela entidade conforme o critério de
 RANKING.<BR>"""

    pass


  def getRankingCentralidadeBaricentro(self, nomeBase, pesoSobreRelevancia) -> Tabela:
    """Aplica sobre uma base de relacionamentos o cálculo do 'RANKING de ENTIDADES'
 considerando o critério 'Centralidade de Proximidade Baricêntrica'<BR>
 Retorna uma tabela com o resultado do 'RANKING de ENTIDADES'. Cada linha da
 tabela corresponde a uma entidade. As colunas apresentam:<BR>
 TIPO: tipo da entidade<BR>
 ID: identificação da entidade<BR>
 NOME: propriedade 'NOME' da entidade<BR>
 PONTUAÇÃO: pontuação adquirida pela entidade conforme o critério de
 RANKING.<BR>"""

    pass


  def getRankingCentralidadeGrau(self, nomeBase) -> Tabela:
    """Aplica sobre uma base de relacionamentos o cálculo do 'RANKING de ENTIDADES'
 considerando o critério 'Centralidade de Grau'<BR>
 Retorna uma tabela com o resultado do 'RANKING de ENTIDADES'. Cada linha da
 tabela corresponde a uma entidade. As colunas apresentam:<BR>
 TIPO: tipo da entidade<BR>
 ID: identificação da entidade<BR>
 NOME: propriedade 'NOME' da entidade<BR>
 PONTUAÇÃO: pontuação adquirida pela entidade conforme o critério de
 RANKING.<BR>"""

    pass


  def getRankingCentralidadeIntermediacao(self, nomeBase, pesoSobreRelevancia) -> Tabela:
    """Aplica sobre uma base de relacionamentos o cálculo do 'RANKING de ENTIDADES'
 considerando o critério 'Centralidade de Intermediação'<BR>
 Retorna uma tabela com o resultado do 'RANKING de ENTIDADES'. Cada linha da
 tabela corresponde a uma entidade. As colunas apresentam:<BR>
 TIPO: tipo da entidade<BR>
 ID: identificação da entidade<BR>
 NOME: propriedade 'NOME' da entidade<BR>
 PONTUAÇÃO: pontuação adquirida pela entidade conforme o critério de
 RANKING.<BR>"""

    pass


  def getRankingCentralidadeProximidadeMedia(self, nomeBase, pesoSobreRelevancia) -> Tabela:
    """Aplica sobre uma base de relacionamentos o cálculo do 'RANKING de ENTIDADES'
 considerando o critério 'Centralidade de Proximidade pela Média'<BR>
 Retorna uma tabela com o resultado do 'RANKING de ENTIDADES'. Cada linha da
 tabela corresponde a uma entidade. As colunas apresentam:<BR>
 TIPO: tipo da entidade<BR>
 ID: identificação da entidade<BR>
 NOME: propriedade 'NOME' da entidade<BR>
 PONTUAÇÃO: pontuação adquirida pela entidade conforme o critério de
 RANKING.<BR>"""

    pass


  def getRankingHITSAutoridades(self, nomeBase, pesoSobreRelevancia) -> Tabela:
    """Aplica sobre uma base de relacionamentos o cálculo do 'RANKING de ENTIDADES'
 considerando o critério 'HITS/Autoridades'<BR>
 Retorna uma tabela com o resultado do 'RANKING de ENTIDADES'. Cada linha da
 tabela corresponde a uma entidade. As colunas apresentam:<BR>
 TIPO: tipo da entidade<BR>
 ID: identificação da entidade<BR>
 NOME: propriedade 'NOME' da entidade<BR>
 PONTUAÇÃO: pontuação adquirida pela entidade conforme o critério de
 RANKING.<BR>"""

    pass


  def getRankingHITSHub(self, nomeBase, pesoSobreRelevancia) -> Tabela:
    """Aplica sobre uma base de relacionamentos o cálculo do 'RANKING de ENTIDADES'
 considerando o critério 'HITS/Hub'<BR>
 Retorna uma tabela com o resultado do 'RANKING de ENTIDADES'. Cada linha da
 tabela corresponde a uma entidade. As colunas apresentam:<BR>
 TIPO: tipo da entidade<BR>
 ID: identificação da entidade<BR>
 NOME: propriedade 'NOME' da entidade<BR>
 PONTUAÇÃO: pontuação adquirida pela entidade conforme o critério de
 RANKING.<BR>"""

    pass


  def getRankingPageRank(self, nomeBase, pesoSobreRelevancia) -> Tabela:
    """Aplica sobre uma base de relacionamentos o cálculo do 'RANKING de ENTIDADES'
 considerando o critério 'Page Rank'<BR>
 Retorna uma tabela com o resultado do 'RANKING de ENTIDADES'. Cada linha da
 tabela corresponde a uma entidade. As colunas apresentam:<BR>
 TIPO: tipo da entidade<BR>
 ID: identificação da entidade<BR>
 NOME: propriedade 'NOME' da entidade<BR>
 PONTUAÇÃO: pontuação adquirida pela entidade conforme o critério de
 RANKING.<BR>"""

    pass


  def getRankingValor(self, nomeBase) -> Tabela:
    """Aplica sobre uma base de relacionamentos o cálculo do 'RANKING de ENTIDADES'
 considerando o critério 'Propriedade VALOR' (isto é, a propriedade VALOR de
 cada ENTIDADE é considerada para atribuir o RANKING).<BR>
 Retorna uma tabela com o resultado do 'RANKING de ENTIDADES'. Cada linha da
 tabela corresponde a uma entidade. As colunas apresentam:<BR>
 TIPO: tipo da entidade<BR>
 ID: identificação da entidade<BR>
 NOME: propriedade 'NOME' da entidade<BR>
 PONTUAÇÃO: pontuação adquirida pela entidade conforme o critério de
 RANKING.<BR>"""

    pass


  def getRelacionamentos(self, id, nomeBase) -> Tabela:
    """Retorna em uma tabela todos os relacionamentos que foram encontrados para
 alguma entidade mantida na base de relacionamentos.<BR>
 Procura-se somente relacionamentos de primeiro nível.<BR>
 A tabela retornada apresenta os diferentes relacionamentos em diferentes
 linhas e a seguinte estrutura de colunas:<BR>
 ID1 - Código que foi indicado na pesquisa (identifica a pessoa com a qual se
 relaciona)<BR>
 ID2 - Código da entidade relacionada (pode ser CPF, CNPJ, etc.)<BR>
 TIPO_ENT_2 - Tipo de pessoa identificada pelo código contido na coluna ID2
 (isto é, 'PF', 'PJ' ou outro)<BR>
 NOME - Nome da entidade relacionada<BR>
 TIPO_RELAC - Tipo de relacionamento<BR>
 DIRECAO - Direção do relacionamento<BR>
 Demais colunas da tabela indicam outras propriedades de cada
 relacionamento<BR>"""

    pass


  def getRelacionamentosBase(self, nomeBase) -> list:
    """Retorna uma lista com todos os relacionamentos de uma determinada base. Os
 relacionamentos são informados por meio de objetos de script do tipo @{link
 GrafoRelacionamento GrafoRelacionamento}. Você pode consultar outras
 informações sobre cada um desses relacionamentos utilizando os métodos
 definidos nesses objetos."""

    pass


  def getSuspeitos(self) -> Lista:
    """Retorna a relação de 'suspeitos' previamente configurados com chamadas às
 funções 'addSuspeito' ou 'setSuspeitos'<BR>
 Esta definição não afeta a 'base de relacionamentos'."""

    pass


  def hasGrafoConsulta(self, nomeArquivo) -> bool:
    """Verifica se existe um grafo-consulta previamente salvo com um determinado
 nome de arquivo."""

    pass


  def hasGrafosConsultas(self) -> bool:
    """Verifica se existe algum grafo-consulta previamente salvo no projeto atual."""

    pass


  def hasImagem(self, nome) -> bool:
    """Verifica se existe uma imagem com determinado nome na pasta do ContÁgil
 dedicada ao armazenamento de imagens para bases de relacionamentos.<BR>"""

    pass


  def importaBasesContagil(self, fontesContAgil, nomeBase) -> None:
    """Povoa uma base de relacionamentos com dados previamente importados para o
 ContÁgil. Trata-se de um recurso análogo ao item de menu "Montar Base de
 Relacionamentos com dados do ContÁgil"."""

    pass


  def importarArquivoRadarParaBaseGrafos(self, nomeArquivo, nomeBase) -> None:
    """Importa a árvore de relacionamentos de um contribuinte a partir de um arquivo
 previamente exportado pelo sistema Radar e realiza o armazenamento numa base
 de grafos local. <BR>
 Note que este método é uma alternativa ao outro método que faz a consulta
 diretamente no sistema RADAR e insere automaticamente dentro do ContÁgil.<BR>"""

    pass


  def importarArquivoRadarParaBaseGrafos(self, nomeArquivo, nomeBase, atualizaCadastroPessoas) -> None:
    """Importa a árvore de relacionamentos de um contribuinte a partir de um arquivo
 previamente exportado pelo sistema Radar e realiza o armazenamento numa base
 de grafos local. <BR>
 Note que este método é uma alternativa ao outro método que faz a consulta
 diretamente no sistema RADAR e insere automaticamente dentro do ContÁgil.<BR>"""

    pass


  def importarArquivosParaBaseGrafos(self, nomeBase, arquivoEntidades, arquivoRelacionamentos, cabecalhoEntidades, cabecalhoRelacionamentos, tipoRelacionamento, idPrimeiraEntidadeRelacionada, idSegundaEntidadeRelacionada, idEntidades, tipoEntidades, fonteInformacoes) -> None:
    """Importa um ou dois arquivos textos com campos separados por ponto e vírgula
 (ou outro caractere previamente configurado em
 {@link ArquivoCSV#setSeparador(char) setSeparador}) onde a primeira linha de
 cada arquivo apresenta os nomes dos campos e as linhas seguintes apresentam
 os dados.<BR>
 Esta rotina é otimizada para realizar carga de grandes volumes de dados. Caso
 você possua grandes volumes de dados na forma de arquivos textos e queira
 utiliza-los para formar uma 'base de relacionamentos', utilize este método no
 lugar de outras formas de importação de dados do ContÁgil (é bem mais veloz e
 ocupa bem menos memória no processo).<BR>
 O primeiro arquivo deve corresponde às entidades (isto é, identifica as
 entidades e apresenta suas propriedades). Este arquivo pode ser omitido se
 desejar importar somente um arquivo de relacionamentos.<BR>
 O segundo arquivo deve corresponder aos relacionamentos (isto é, identifica
 uma das entidades, identifica a outra entidade relacionada, indica o tipo de
 relacionamento e inclui outras propriedades do relacionamento). Este arquivo
 pode ser omitido se desejar importar somente um arquivo de entidades.<BR>
 O parâmetro 'cabecalhoEntidades' pode ser utilizado para informar uma linha
 de cabeçalho caso o arquivo de entidades não possua uma. O mesmo se aplica ao
 parâmetro 'cabecalhoRelacionamentos' com relação ao arquivo de
 relacionamentos.<BR>
 OBS: se estiver importando relacionamentos que se referem a entidades não
 informadas no arquivo de entidades, ou se o arquivo de entidades não foi
 informado, as entidades envolvidas no relacionamento são criadas de forma
 automática com as informações contidas no arquivo de relacionamentos.<BR>
 IMPORTANTE: a primeira linha do arquivo, que corresponde ao 'cabeçalho', deve
 compreender os nomes das colunas. Alguns nomes precisam estar presentes
 conforme documentado em
 {@link GrafoRelacionamentos#importarTabelaParaBaseGrafos(Tabela, Tabela)
 importarTabelaParaBaseGrafos}.<BR>
 <BR>
 Os parâmetros 'tipoRelacionamento', 'idPrimeiraEntidadeRelacionada',
 'idSegundaEntidadeRelacionada', 'idEntidades', 'tipoEntidades' e
 'fonteInformacoes' podem definir de forma específica cada uma dessas colunas,
 podendo indicar número (posição da coluna no arquivo), nome (o nome da coluna
 ou um texto qualquer a ser considerado como constante) ou deixado vazio
 (considera o nome padrão do ContÁgil para aquela coluna). <BR>
 Propriedades com nomes dinâmicos<BR>
 ================================<BR>
 Na linha de cabeçalho, no lugar de 'títulos' com conteúdo 'fixo' podemos
 também 'referências' para permitir a construção de propriedades com nomes
 dinâmicos (isto é, propriedades cujos nomes podem variar de linha para linha
 no arquivo). Para isso, utilize a sintaxe "(xx)" (um número xx entre
 parêntesis) no meio do nome da coluna, onde o número 'xx' corresponde ao
 número de posição do campo na linha, começando pelo número 1 para indicar a
 primeira coluna do arquivo.<BR>
 Por exemplo, digamos que no cabeçalho temos no primeiro campo o título "MES",
 no segundo campo o título "ANO". Poderíamos no terceiro campo definir o
 título "VALOR_(1)_(2)" para indicar que, ao longo das linhas, haverá uma
 propriedade adicional cujo nome é construído dinamicamente utilizando o
 conteúdo do primeiro campo (que é o valor na linha para a coluna 'MES') e do
 segundo campo (que é o valor na linha para a coluna 'ANO'). Assim, por
 exemplo, se em uma dada linha temos o valor 10 para o campo "MES" e o valor
 2012 para o campo "ANO", o terceiro campo (que supostamente terá um outro
 valor qualquer) será associado a uma propriedade cujo nome será
 "VALOR_10_2012". Isto é, o nome da propriedade é concatenação dos outros
 campos, e seu valor será o valor informado na linha do arquivo.<BR>
 <BR>
 Propriedades com valores agregados<BR>
 ==================================<BR>
 Caso queira informar valores monetários que devam ser 'somados' antes de
 compor o conteúdo de uma 'propriedade', utilize como nome da propriedade o
 padrão "[NOME]CRITERIO1_CRITERIO2..." (onde aspas devem ser omitidas).<BR>
 Ou seja, informe o nome da propriedade, que conterá o resultado da soma,
 entre colchetes, e informe os critérios de agregação após o colchetes,
 separados entre si pelo caractere sublinhado.<BR>
 Por exemplo, o conteúdo da propriedade de nome "[VALOR]01_2010" é
 automaticamente somado ao valor da propriedade de nome "[VALOR]02_2010" para
 compor o conteúdo de uma propriedade de nome "VALOR". Além disso, pelo
 visualizador de grafos, ainda é possível ver os valores individuais que
 compuseram o valor total (isto é, o valor de 01/2010 e o valor de
 02/2010).<BR>
 <BR>
 Colunas não desejadas<BR>
 =====================<BR>
 Por padrão todas as colunas do arquivo são importadas para a base de
 relacionamentos como propriedades das entidades e relacionamentos.<BR>
 Se não desejar importar alguma coluna, certifique-se que o nome
 correspondente da coluna indesejada está omisso (em branco) na linha de
 'cabeçalho' (isto é, que dois do caractere de separação, que pode ser ponto e
 vírgula ou outro, estão próximos um do outro sem um nome entre eles).<BR>
 Alternativamente você pode informar o caractere 'ponto de exclamação' (!)
 como primeiro caractere logo antes do nome da coluna que deseja
 'ignorar'.<BR>
 Fazendo isso, os dados da coluna correspondente, sem nome, não serão
 incorporados como valores de propriedade das entidades ou relacionamentos.
 Porém, ainda assim poderá ser utilizado para compor o 'nome' de uma
 propriedade com nome dinâmico, caso sua posição seja referenciada em outra
 coluna (vide 'Propriedades com nomes dinâmicos'), ou poderá ser importada
 caso o número de sua posição seja explicitamente informado em um dos outros
 parâmetros (ex: 'tipoRelacionamento').<BR>
 <BR>
 Propriedades calculadas<BR>
 =======================<BR>
 Caso queira em todas as linhas derivar o conteúdo de uma propriedade a partir
 de outras propriedades informadas na entidade ou relacionamento, você pode
 indicar uma 'fórmula' dentro da linha de cabeçalho, logo após o nome da
 propriedade correspondente, utilizando o sinal '=' para separar o nome da
 fórmula. Nesta hipótese, o conteúdo da propriedade é calculado com base na
 fórmula, a qual pode ser construída utilizando qualquer operador previsto no
 ContÁgil (ex: "SE", operadores matemáticos, operadores lógicos, operadores de
 textos, etc.) e referenciando qualquer outra propriedade da mesma entidade ou
 relacionamento.<BR>
 A fórmula também pode referenciar um campo qualquer da linha, mesmo que não
 tenha sido mapeado para uma propriedade, utilizando para isso a sintaxe
 'COLUNA-X' onde X é o número da coluna no arquivo, começando em 1 para
 denotar a primeira coluna no arquivo.<BR>"""

    pass


  def importarArquivosParaBaseGrafos(self, nomeBase, arquivoEntidades, arquivoRelacionamentos) -> None:
    """Importa um ou dois arquivos textos com campos separados por ponto e vírgula
 (ou outro caractere previamente configurado em
 {@link ArquivoCSV#setSeparador(char) setSeparador}) onde a primeira linha de
 cada arquivo apresenta os nomes dos campos e as linhas seguintes apresentam
 os dados.<BR>
 Esta rotina é otimizada para realizar carga de grandes volumes de dados. Caso
 você possua grandes volumes de dados na forma de arquivos textos e queira
 utiliza-los para formar uma 'base de relacionamentos', utilize este método no
 lugar de outras formas de importação de dados do ContÁgil (é bem mais veloz e
 ocupa bem menos memória no processo).<BR>
 O primeiro arquivo deve corresponde às entidades (isto é, identifica as
 entidades e apresenta suas propriedades). Este arquivo pode ser omitido se
 desejar importar somente um arquivo de relacionamentos.<BR>
 O segundo arquivo deve corresponder aos relacionamentos (isto é, identifica
 uma das entidades, identifica a outra entidade relacionada, indica o tipo de
 relacionamento e inclui outras propriedades do relacionamento). Este arquivo
 pode ser omitido se desejar importar somente um arquivo de entidades.<BR>
 O parâmetro 'cabecalhoEntidades' pode ser utilizado para informar uma linha
 de cabeçalho caso o arquivo de entidades não possua uma. O mesmo se aplica ao
 parâmetro 'cabecalhoRelacionamentos' com relação ao arquivo de
 relacionamentos.<BR>
 OBS: se estiver importando relacionamentos que se referem a entidades não
 informadas no arquivo de entidades, ou se o arquivo de entidades não foi
 informado, as entidades envolvidas no relacionamento são criadas de forma
 automática com as informações contidas no arquivo de relacionamentos.<BR>
 <BR>
 IMPORTANTE: a primeira linha do arquivo, que corresponde ao 'cabeçalho', deve
 compreender os nomes das colunas. Alguns nomes precisam estar presentes
 conforme documentado em
 {@link GrafoRelacionamentos#importarTabelaParaBaseGrafos(Tabela, Tabela)
 importarTabelaParaBaseGrafos}. <BR>
 Propriedades com nomes dinâmicos<BR>
 ================================<BR>
 Na linha de cabeçalho, no lugar de 'títulos' com conteúdo 'fixo' podemos
 também 'referências' para permitir a construção de propriedades com nomes
 dinâmicos (isto é, propriedades cujos nomes podem variar de linha para linha
 no arquivo). Para isso, utilize a sintaxe "(xx)" (um número xx entre
 parêntesis) no meio do nome da coluna, onde o número 'xx' corresponde ao
 número de posição do campo na linha, começando pelo número 1 para indicar a
 primeira coluna do arquivo.<BR>
 Por exemplo, digamos que no cabeçalho temos no primeiro campo o título "MES",
 no segundo campo o título "ANO". Poderíamos no terceiro campo definir o
 título "VALOR_(1)_(2)" para indicar que, ao longo das linhas, haverá uma
 propriedade adicional cujo nome é construído dinamicamente utilizando o
 conteúdo do primeiro campo (que é o valor na linha para a coluna 'MES') e do
 segundo campo (que é o valor na linha para a coluna 'ANO'). Assim, por
 exemplo, se em uma dada linha temos o valor 10 para o campo "MES" e o valor
 2012 para o campo "ANO", o terceiro campo (que supostamente terá um outro
 valor qualquer) será associado a uma propriedade cujo nome será
 "VALOR_10_2012". Isto é, o nome da propriedade é concatenação dos outros
 campos, e seu valor será o valor informado na linha do arquivo.<BR>
 <BR>
 Propriedades com valores agregados<BR>
 ==================================<BR>
 Caso queira informar valores monetários que devam ser 'somados' antes de
 compor o conteúdo de uma 'propriedade', utilize como nome da propriedade o
 padrão "[NOME]CRITERIO1_CRITERIO2..." (onde aspas devem ser omitidas).<BR>
 Ou seja, informe o nome da propriedade, que conterá o resultado da soma,
 entre colchetes, e informe os critérios de agregação após o colchetes,
 separados entre si pelo caractere sublinhado.<BR>
 Por exemplo, o conteúdo da propriedade de nome "[VALOR]01_2010" é
 automaticamente somado ao valor da propriedade de nome "[VALOR]02_2010" para
 compor o conteúdo de uma propriedade de nome "VALOR". Além disso, pelo
 visualizador de grafos, ainda é possível ver os valores individuais que
 compuseram o valor total (isto é, o valor de 01/2010 e o valor de 02/2010).
 <BR>
 Colunas não desejadas<BR>
 =====================<BR>
 Por padrão todas as colunas do arquivo são importadas para a base de
 relacionamentos como propriedades das entidades e relacionamentos.<BR>
 Se não desejar importar alguma coluna, certifique-se que o nome
 correspondente da coluna indesejada está omisso (em branco) na linha de
 'cabeçalho' (isto é, que dois do caractere de separação, que pode ser ponto e
 vírgula ou outro, estão próximos um do outro sem um nome entre eles).<BR>
 Alternativamente você pode informar o caractere 'ponto de exclamação' (!)
 como primeiro caractere logo antes do nome da coluna que deseja
 'ignorar'.<BR>
 Fazendo isso, os dados da coluna correspondente, sem nome, não serão
 incorporados como valores de propriedade das entidades ou relacionamentos.
 Porém, ainda assim poderá ser utilizado para compor o 'nome' de uma
 propriedade com nome dinâmico, caso sua posição seja referenciada em outra
 coluna (vide 'Propriedades com nomes dinâmicos').<BR>
 <BR>
 Propriedades calculadas<BR>
 =======================<BR>
 Caso queira em todas as linhas derivar o conteúdo de uma propriedade a partir
 de outras propriedades informadas na entidade ou relacionamento, você pode
 indicar uma 'fórmula' dentro da linha de cabeçalho, logo após o nome da
 propriedade correspondente, utilizando o sinal '=' para separar o nome da
 fórmula. Nesta hipótese, o conteúdo da propriedade é calculado com base na
 fórmula, a qual pode ser construída utilizando qualquer operador previsto no
 ContÁgil (ex: "SE", operadores matemáticos, operadores lógicos, operadores de
 textos, etc.) e referenciando qualquer outra propriedade da mesma entidade ou
 relacionamento.<BR>
 A fórmula também pode referenciar um campo qualquer da linha, mesmo que não
 tenha sido mapeado para uma propriedade, utilizando para isso a sintaxe
 'COLUNA-X' onde X é o número da coluna no arquivo, começando em 1 para
 denotar a primeira coluna no arquivo.<BR>"""

    pass


  def importarArquivosParaBaseGrafos(self, nomeBase, arquivoEntidades, arquivoRelacionamentos, tipoRelacionamento) -> None:
    """Importa um ou dois arquivos textos com campos separados por ponto e vírgula
 (ou outro caractere previamente configurado em
 {@link ArquivoCSV#setSeparador(char) setSeparador}) onde a primeira linha de
 cada arquivo apresenta os nomes dos campos e as linhas seguintes apresentam
 os dados.<BR>
 Esta rotina é otimizada para realizar carga de grandes volumes de dados. Caso
 você possua grandes volumes de dados na forma de arquivos textos e queira
 utiliza-los para formar uma 'base de relacionamentos', utilize este método no
 lugar de outras formas de importação de dados do ContÁgil (é bem mais veloz e
 ocupa bem menos memória no processo).<BR>
 O primeiro arquivo deve corresponde às entidades (isto é, identifica as
 entidades e apresenta suas propriedades). Este arquivo pode ser omitido se
 desejar importar somente um arquivo de relacionamentos.<BR>
 O segundo arquivo deve corresponder aos relacionamentos (isto é, identifica
 uma das entidades, identifica a outra entidade relacionada, indica o tipo de
 relacionamento e inclui outras propriedades do relacionamento). Este arquivo
 pode ser omitido se desejar importar somente um arquivo de entidades.<BR>
 O parâmetro 'cabecalhoEntidades' pode ser utilizado para informar uma linha
 de cabeçalho caso o arquivo de entidades não possua uma. O mesmo se aplica ao
 parâmetro 'cabecalhoRelacionamentos' com relação ao arquivo de
 relacionamentos.<BR>
 OBS: se estiver importando relacionamentos que se referem a entidades não
 informadas no arquivo de entidades, ou se o arquivo de entidades não foi
 informado, as entidades envolvidas no relacionamento são criadas de forma
 automática com as informações contidas no arquivo de relacionamentos.<BR>
 IMPORTANTE: a primeira linha do arquivo, que corresponde ao 'cabeçalho', deve
 compreender os nomes das colunas. Alguns nomes precisam estar presentes
 conforme documentado em
 {@link GrafoRelacionamentos#importarTabelaParaBaseGrafos(Tabela, Tabela)
 importarTabelaParaBaseGrafos}. <BR>
 Propriedades com nomes dinâmicos<BR>
 ================================<BR>
 Na linha de cabeçalho, no lugar de 'títulos' com conteúdo 'fixo' podemos
 também 'referências' para permitir a construção de propriedades com nomes
 dinâmicos (isto é, propriedades cujos nomes podem variar de linha para linha
 no arquivo). Para isso, utilize a sintaxe "(xx)" (um número xx entre
 parêntesis) no meio do nome da coluna, onde o número 'xx' corresponde ao
 número de posição do campo na linha, começando pelo número 1 para indicar a
 primeira coluna do arquivo.<BR>
 Por exemplo, digamos que no cabeçalho temos no primeiro campo o título "MES",
 no segundo campo o título "ANO". Poderíamos no terceiro campo definir o
 título "VALOR_(1)_(2)" para indicar que, ao longo das linhas, haverá uma
 propriedade adicional cujo nome é construído dinamicamente utilizando o
 conteúdo do primeiro campo (que é o valor na linha para a coluna 'MES') e do
 segundo campo (que é o valor na linha para a coluna 'ANO'). Assim, por
 exemplo, se em uma dada linha temos o valor 10 para o campo "MES" e o valor
 2012 para o campo "ANO", o terceiro campo (que supostamente terá um outro
 valor qualquer) será associado a uma propriedade cujo nome será
 "VALOR_10_2012". Isto é, o nome da propriedade é concatenação dos outros
 campos, e seu valor será o valor informado na linha do arquivo.<BR>
 <BR>
 Propriedades com valores agregados<BR>
 ==================================<BR>
 Caso queira informar valores monetários que devam ser 'somados' antes de
 compor o conteúdo de uma 'propriedade', utilize como nome da propriedade o
 padrão "[NOME]CRITERIO1_CRITERIO2..." (onde aspas devem ser omitidas).<BR>
 Ou seja, informe o nome da propriedade, que conterá o resultado da soma,
 entre colchetes, e informe os critérios de agregação após o colchetes,
 separados entre si pelo caractere sublinhado.<BR>
 Por exemplo, o conteúdo da propriedade de nome "[VALOR]01_2010" é
 automaticamente somado ao valor da propriedade de nome "[VALOR]02_2010" para
 compor o conteúdo de uma propriedade de nome "VALOR". Além disso, pelo
 visualizador de grafos, ainda é possível ver os valores individuais que
 compuseram o valor total (isto é, o valor de 01/2010 e o valor de 02/2010).
 <BR>
 Colunas não desejadas<BR>
 =====================<BR>
 Por padrão todas as colunas do arquivo são importadas para a base de
 relacionamentos como propriedades das entidades e relacionamentos.<BR>
 Se não desejar importar alguma coluna, certifique-se que o nome
 correspondente da coluna indesejada está omisso (em branco) na linha de
 'cabeçalho' (isto é, que dois do caractere de separação, que pode ser ponto e
 vírgula ou outro, estão próximos um do outro sem um nome entre eles).<BR>
 Alternativamente você pode informar o caractere 'ponto de exclamação' (!)
 como primeiro caractere logo antes do nome da coluna que deseja
 'ignorar'.<BR>
 Fazendo isso, os dados da coluna correspondente, sem nome, não serão
 incorporados como valores de propriedade das entidades ou relacionamentos.
 Porém, ainda assim poderá ser utilizado para compor o 'nome' de uma
 propriedade com nome dinâmico, caso sua posição seja referenciada em outra
 coluna (vide 'Propriedades com nomes dinâmicos').<BR>
 <BR>
 Propriedades calculadas<BR>
 =======================<BR>
 Caso queira em todas as linhas derivar o conteúdo de uma propriedade a partir
 de outras propriedades informadas na entidade ou relacionamento, você pode
 indicar uma 'fórmula' dentro da linha de cabeçalho, logo após o nome da
 propriedade correspondente, utilizando o sinal '=' para separar o nome da
 fórmula. Nesta hipótese, o conteúdo da propriedade é calculado com base na
 fórmula, a qual pode ser construída utilizando qualquer operador previsto no
 ContÁgil (ex: "SE", operadores matemáticos, operadores lógicos, operadores de
 textos, etc.) e referenciando qualquer outra propriedade da mesma entidade ou
 relacionamento.<BR>
 A fórmula também pode referenciar um campo qualquer da linha, mesmo que não
 tenha sido mapeado para uma propriedade, utilizando para isso a sintaxe
 'COLUNA-X' onde X é o número da coluna no arquivo, começando em 1 para
 denotar a primeira coluna no arquivo.<BR>"""

    pass


  def importarMultiplosArquivosParaBaseGrafos(self, nomeBase, nomesArquivosEntidades, nomesArquivosRelacionamentos, codificacaoCaracteresArquivos, formatoNumericoArquivos, separadorCampos, desconsideraAspas, cabecalhoEntidades, cabecalhoRelacionamentos, tipoRelacionamento, idPrimeiraEntidadeRelacionada, idSegundaEntidadeRelacionada, idEntidades, tipoEntidades, fonteInformacoes) -> None:
    """Faz o mesmo que a função 'importarArquivosParaBaseGrafos', mas permite
 indicar mais de um arquivo de entidades ou mais de um arquivo de
 relacionamentos ou mais de um de ambos.<BR>
 Note que este método apenas poderá ser utilizado se os 'múltiplos arquivos'
 apresentarem exatamente a mesma estrutura de colunas sobre cada tipo. Isto é,
 os arquivos de entidades precisam ter o mesmo número de colunas, nas mesmas
 posições. Assim também devem ser os arquivos de relacionamentos.<BR>
 Não precisa haver o mesmo número de arquivos de entidades quando comparados
 com os de relacionamentos.<BR>
 Outra diferença deste método em relação a 'importarArquivosParaBaseGrafos' é
 que aqui você não indica diretamente os objetos do tipo {@link ArquivoCSV
 ArquivoCSV}, mas indica seus nomes e vários parâmetros adicionais utilizados
 na leitura (ex: 'desconsideraAspas', 'separadorCampos',
 'codificacaoCaracteresArquivos' e 'formatoNumericoArquivos'). Isso é feito
 desta forma para permitir que um arquivo seja aberto depois que o arquivo
 anterior foi 'fechado', evitando assim que vários arquivos sejam abertos ao
 mesmo tempo, o que oneraria o uso de memória."""

    pass


  def importarRadarParaBaseGrafos(self, chave, contribuinte, quadroResumo, limite, nomeBase) -> None:
    """Importa a árvore de relacionamentos de um contribuinte a partir do sistema
 Radar, utilizando a opção "Consulta árvore em arquivo", e realiza o
 armazenamento numa base de grafos local. <BR>
 Necessita habilitação no sistema Radar.<BR>"""

    pass


  def importarRadarParaBaseGrafos(self, chave, contribuintes, quadroResumo, limite, nomeBase) -> None:
    """Importa a árvore de relacionamentos de um contribuinte a partir do sistema
 Radar, utilizando a opção "Consulta árvore em arquivo", e realiza o
 armazenamento numa base de grafos local. <BR>
 Necessita habilitação no sistema Radar.<BR>
 Este método alternativo permite indicar uma relação de contribuintes, onde
 cada um servirá como critério de pesquisa (isto é, realiza múltiplas
 pesquisas no RADAR, cada pesquisa com um contribuinte diferente como critério
 inicial)."""

    pass


  def importarRadarParaBaseGrafos(self, chave, contribuinte, quadroResumo, limite) -> None:
    """Importa a árvore de relacionamentos de um contribuinte a partir do sistema
 Radar, utilizando a opção "Consulta árvore em arquivo", e realiza o
 armazenamento numa base de grafos local (base default - pasta GERAL no
 ContAgil). <BR>
 Necessita habilitação no sistema Radar.<BR>"""

    pass


  def importarRadarParaVisualizacao(self, chave, contribuinte, quadroResumo, limite) -> None:
    """Importa a árvore de relacionamentos de um contribuinte a partir do sistema
 Radar, utilizando a opção "Consulta árvore em arquivo", e realiza o
 armazenamento numa base de grafos local (base default - pasta GERAL no
 ContAgil). <BR>
 Necessita habilitação no sistema Radar.<BR>"""

    pass


  def importarTabelaParaBaseGrafos(self, tabelaEntidades, tabelaRelacionamentos) -> None:
    """Importacao para persistencia em banco de grafos a partir de duas tabelas
 genericas: uma com as entidades e outra com os relacionamentos.<BR>
 <BR>
 A tabela de entidades deve possuir obrigatoriamente as colunas de
 identificacao (chave natural da entidade. Ex: CPF, CNPJ) e o tipo de entidade
 (Ex: PF, PJ, Conta telefonica). Os nomes das duas colunas obrigatórias da
 tabela de entidade precisam ser exatamente estes:<BR>
 <BR>
 ID - Coluna que identifica o CPF ou CNPJ ou outra chave natural para o tipo
 de entidade (OBS: se for CPF ou CNPJ, o ContÁgil irá formatar o número no
 formato 000.000.000-00 ou 00.000.000/0000-00, conforme o caso)<BR>
 TIPO - Coluna que identifica o tipo de entidade, podendo ser: PF (pessoa
 física), PJ (pessoa jurídica), CONTA (conta bancária), TELEFONE (número de
 telefone), ESTRANGEIRO (interveniente estrangeiro) ou GENERICA (outra
 entidade qualquer).<BR>
 <BR>
 Caso a tabela de entidades inclua a coluna opcional 'NOME', ela indicará o
 nome da entidade e será automaticamente formatada de modo a transformar
 letras minúsculas em letras maiúsculas e retirar caracteres acentuados.<BR>
 <BR>
 As demais colunas da tabela de entidades podem ter quaisquer nomes e serão
 consideradas como 'propriedades' adicionais de cada entidade.<BR>
 <BR>
 A tabela de relacionamentos deve possuir obrigatoriamente as colunas de
 identificação das entidades relacionadas (chave natural de cada uma. Ex: CPF
 ou CNPJ) e o tipo de relacionamento que há entre elas. Opcionalmente, pode-se
 informar também os tipos de cada entidade relacionada. Se não forem
 informados os tipos das entidades relacionadas, infere-se o tipo a partir do
 próprio código (ex: um código de 11 dígitos será considerado como um tipo de
 entidade 'PF').<BR>
 Os nomes das três colunas obrigatórias da tabela de relacionamentos precisam
 ser exatamente estes:<BR>
 <BR>
 ID1 - Coluna que identifica o CPF ou CNPJ ou outra chave natural para a
 primeira entidade do relacionamento<BR>
 ID2 - Coluna que identifica o CPF ou CNPJ ou outra chave natural para a
 segunda entidade do relacionamento<BR>
 TIPO_RELAC - Coluna que identifica o tipo de relacionamento que há entre as
 entidades. Pode ser um dos tipos previstos no ContÁgil (ex: CONJUGE,
 CONTADOR, SOCIO, FILHO, etc.) ou pode ser um novo tipo.<BR>
 <BR>
 As demais colunas da tabela de relacionamentos podem ter quaisquer nomes e
 serão consideradas como 'propriedades' adicionais de cada relacionamento.<BR>
 As entidades informadas na tabela de relacionamentos devem estar presentes na
 tabela de entidades ou presentes no banco de grafos para o funcionamento
 correto.<BR>"""

    pass


  def importarTabelaParaBaseGrafos(self, tabelaEntidades, tabelaRelacionamentos, nomeBase) -> None:
    """Idem à outra alternativa do mesmo método, porém inclui a indicação da base de
 relacionamentos onde deseja inserir os novos dados."""

    pass


  def importarTabelaParaVisualizacaoGrafos(self, tabelaEntidades, tabelaRelacionamentos) -> None:
    """Importacao para visualizacao em grafos a partir de duas tabelas genericas:
 uma com as entidades e outra com os relacionamentos.<BR>
 <BR>
 A tabela de entidades deve possuir obrigatoriamente as colunas de
 identificacao (chave natural da entidade. Ex: CPF, CNPJ) e o tipo de entidade
 (Ex: PF, PJ, Conta telefonica). Os nomes das duas colunas obrigatórias da
 tabela de entidade precisam ser exatamente estes:<BR>
 <BR>
 ID - Coluna que identifica o CPF ou CNPJ ou outra chave natural para o tipo
 de entidade (OBS: se for CPF ou CNPJ, o ContÁgil irá formatar o número no
 formato 000.000.000-00 ou 00.000.000/0000-00, conforme o caso)<BR>
 TIPO - Coluna que identifica o tipo de entidade, podendo ser: PF (pessoa
 física), PJ (pessoa jurídica), CONTA (conta bancária), TELEFONE (número de
 telefone), ESTRANGEIRO (interveniente estrangeiro) ou GENERICA (outra
 entidade qualquer).<BR>
 <BR>
 Caso a tabela de entidades inclua a coluna opcional 'NOME', ela indicará o
 nome da entidade e será automaticamente formatada de modo a transformar
 letras minúsculas em letras maiúsculas e retirar caracteres acentuados.<BR>
 <BR>
 As demais colunas da tabela de entidades podem ter quaisquer nomes e serão
 consideradas como 'propriedades' adicionais de cada entidade.<BR>
 <BR>
 A tabela de relacionamentos deve possuir obrigatoriamente as colunas de
 identificação das entidades relacionadas (chave natural de cada uma. Ex: CPF
 ou CNPJ) e o tipo de relacionamento que há entre elas. Opcionalmente, pode-se
 informar também os tipos de cada entidade relacionada. Se não forem
 informados os tipos das entidades relacionadas, infere-se o tipo a partir do
 próprio código (ex: um código de 11 dígitos será considerado como um tipo de
 entidade 'PF').<BR>
 Os nomes das três colunas obrigatórias da tabela de relacionamentos precisam
 ser exatamente estes:<BR>
 <BR>
 ID1 - Coluna que identifica o CPF ou CNPJ ou outra chave natural para a
 primeira entidade do relacionamento<BR>
 ID2 - Coluna que identifica o CPF ou CNPJ ou outra chave natural para a
 segunda entidade do relacionamento<BR>
 TIPO_RELAC - Coluna que identifica o tipo de relacionamento que há entre as
 entidades. Pode ser um dos tipos previstos no ContÁgil (ex: CONJUGE,
 CONTADOR, SOCIO, FILHO, etc.) ou pode ser um novo tipo.<BR>
 <BR>
 Opcionalmente, pode-se incluir também nesta tabela de relacionamentos colunas
 que indicam o tipo de cada uma das pessoas, com exatamente esses nomes:<BR>
 TIPO_ENT_1 - Indica o tipo de entidade a que se refere ID1 ("PF", "PJ",
 etc.)<BR>
 TIPO_ENT_2 - Indica o tipo de entidade a que se refere ID2 ("PF", "PJ",
 etc.)<BR>
 <BR>
 As demais colunas da tabela de relacionamentos podem ter quaisquer nomes e
 serão consideradas como 'propriedades' adicionais de cada relacionamento.<BR>
 As entidades informadas na tabela de relacionamentos devem estar presentes na
 tabela de entidades ou presentes no banco de grafos para o funcionamento
 correto.<BR>"""

    pass


  def inserirEntidade(self, tipo, id, nomeBase, propriedadesAdicionais) -> None:
    """Insere uma entidade na base do grafo de relacionamentos. A entidade pode ser
 de qualquer tipo (PF, PJ ou algum outro tipo).<BR>
 Trata-se de um método simplificado para inserir uma só entidade, indicando
 para esta entidade o seu código ('id') e uma relação de propriedades
 adicionais.<BR>
 O parâmetro 'propriedadesAdicionais' é opcional. Pode ser deixado vazio. Se
 for informado, deve indicar as propriedades da entidade aos 'pares'.<BR>
 Por exemplo, se quiser indicar a propriedade "NOME" com o valor "Gustavo" e a
 propriedade "ANO" com o valor "2015", indicar em
 'propriedadesAdicionais':<BR>
 
 <PRE>
 NOME
 Gustavo
 ANO
 2015
 </PRE>
 
 OBS: se a base já possui uma entidade com o tipo e o 'id' informado, ela é
 atualizada com as informações inseridas por este método. Se a entidade
 existente na base possui algumas propriedades não informadas aqui, elas são
 preservadas. As demais propriedades são substituídas com novos conteúdos."""

    pass


  def inserirPessoaFisica(self, cpf, nome) -> None:
    """Insere uma pessoa física na base do grafo de relacionamentos. Trata-se de um
 método simplificado para inserir uma só pessoa, indicando para esta pessoa
 apenas o CPF e o NOME. Note que um grafo de relacionamentos pode conter
 diversas outras propriedades sobre uma pessoa. Utilize outros métodos para
 informar mais dados ou para inserir outros tipos de objetos no grafo de
 relacionamentos.<BR>
 Os dados são inseridos na base default (GERAL)."""

    pass


  def inserirPessoaFisica(self, cpf, nome, nomeBase) -> None:
    """Insere uma pessoa física na base do grafo de relacionamentos. Trata-se de um
 método simplificado para inserir uma só pessoa, indicando para esta pessoa
 apenas o CPF e o NOME. Note que um grafo de relacionamentos pode conter
 diversas outras propriedades sobre uma pessoa. Utilize outros métodos para
 informar mais dados ou para inserir outros tipos de objetos no grafo de
 relacionamentos."""

    pass


  def inserirPessoaJuridica(self, cnpj, nome) -> None:
    """Insere uma pessoa jurídica na base do grafo de relacionamentos. Trata-se de
 um método simplificado para inserir uma só pessoa, indicando para esta pessoa
 apenas o CNPJ e o NOME. Note que um grafo de relacionamentos pode conter
 diversas outras propriedades sobre uma pessoa. Utilize outros métodos para
 informar mais dados ou para inserir outros tipos de objetos no grafo de
 relacionamentos.<BR>
 Os dados são inseridos na base default (GERAL)."""

    pass


  def inserirPessoaJuridica(self, cnpj, nome, nomeBase) -> None:
    """Insere uma pessoa jurídica na base do grafo de relacionamentos. Trata-se de
 um método simplificado para inserir uma só pessoa, indicando para esta pessoa
 apenas o CNPJ e o NOME. Note que um grafo de relacionamentos pode conter
 diversas outras propriedades sobre uma pessoa. Utilize outros métodos para
 informar mais dados ou para inserir outros tipos de objetos no grafo de
 relacionamentos."""

    pass


  def inserirRelacionamento(self, codigo1, tipoCodigo1, codigo2, tipoCodigo2, tipoRelacionamento, direcao, nomeBase, propriedadesAdicionais) -> None:
    """Alternativa mais genérica do método 'inserirRelacionamento', onde é possível
 incluir um relacionamento sobre qualquer tipo de entidade, mesmo que o código
 de identificação da entidade não se refira a CPF e nem CNPJ (ex: pode ser um
 telefone, um CEP, etc.).<BR>
 Para mais informações sobre os demais parâmetros, consulte a documentação do
 método alternativo."""

    pass


  def inserirRelacionamento(self, codigo1, codigo2, tipoRelacionamento, direcao) -> None:
    """Insere um relacionamento de um determinado tipo entre uma pessoa e outra
 pessoa existentes no grafo de relacionamentos.<BR>
 As pessoas já devem ter sido previamente inseridas na base do grafo de
 relacionamentos.<BR>
 Os códigos utilizados para identificar essas pessoas precisam corresponder a
 um CNPJ ou a um CPF válidos (com ou sem sinal de formatação).<BR>
 O tipo de relacionamento é indicado no terceiro parâmetro (ex: "SÓCIO").<BR>
 Pode-se definir um ou mais relacionamentos distintos entre duas pessoas
 quaisquer.<BR>
 Os dados são inseridos na base default (GERAL)."""

    pass


  def inserirRelacionamento(self, codigo1, codigo2, tipoRelacionamento, direcao, nomeBase) -> None:
    """Insere um relacionamento de um determinado tipo entre uma pessoa e outra
 pessoa existentes no grafo de relacionamentos.<BR>
 As pessoas já devem ter sido previamente inseridas na base do grafo de
 relacionamentos.<BR>
 Os códigos utilizados para identificar essas pessoas precisam corresponder a
 um CNPJ ou a um CPF válidos (com ou sem sinal de formatação).<BR>
 O tipo de relacionamento é indicado no terceiro parâmetro (ex: "SÓCIO").<BR>
 Pode-se definir um ou mais relacionamentos distintos entre duas pessoas
 quaisquer.<BR>"""

    pass


  def inserirRelacionamento(self, codigo1, codigo2, tipoRelacionamento, direcao, nomeBase, propriedadesAdicionais) -> None:
    """Alternativa ao método 'inserirRelacionamento' onde é possível indicar uma
 relação de propriedades adicionais que são armazenadas no relacionamento.<BR>
 O parâmetro 'propriedadesAdicionais' é opcional. Pode ser deixado vazio. Se
 for informado, deve indicar as propriedades do relacionamento aos
 'pares'.<BR>
 Por exemplo, se quiser indicar a propriedade "VALOR" com o valor "100,00" e a
 propriedade "DATA_INICIAL" com o valor "01/01/2015", indicar em
 'propriedadesAdicionais':<BR>
 
 <PRE>
 VALOR
 100,00
 DATA_INICIAL
 01/01/2015
 </PRE>
 
 Para mais informações sobre os demais parâmetros, consulte a documentação do
 método alternativo."""

    pass


  def isBaseNoProjeto(self, nomeBase) -> bool:
    """Retorna a indicação se abase indicada no parâmetro existe na pasta de
 trabalho do projeto."""

    pass


  def isOpcaoVisualizacaoConverteTiposNaoPadroes(self) -> bool:
    """Indica se na apresentação de grafos por este objeto, via script, se deve ou
 não converter tipos de relacionamentos não padrões para tipos padrões,
 geralmente com nome mais reduzido do que o nome original. O padrão é não
 converter (isto é, reproduz como está na base).<BR>
 OBS: esta configuração afeta somente o grafo que é exibido em janela, não
 afeta a base de relacionamentos armazenada em disco."""

    pass


  def isOpcaoVisualizacaoDerivaTiposSimilares(self) -> bool:
    """Indica se na apresentação de grafos por este objeto, via script, se deve ou
 não derivar outros tipos de relacionamentos padrões similares a tipos de
 relacionamentos padrões encontrados. O padrão é não gerar esses outros
 relacionamentos (isto é, reproduz o que está na base).<BR>
 OBS: esta configuração afeta somente o grafo que é exibido em janela, não
 afeta a base de relacionamentos armazenada em disco."""

    pass


  def isOpcaoVisualizacaoExcluiRedundancias(self) -> bool:
    """Indica se na apresentação de grafos por este objeto, via script, se deve ou
 não remover os tipos de relacionamentos redundantes a outros relacionamentos
 existentes. O padrão é não remover (isto é, reproduz o que está na base).<BR>
 OBS: esta configuração afeta somente o grafo que é exibido em janela, não
 afeta a base de relacionamentos armazenada em disco."""

    pass


  def juntaBases(self, baseOrigem, baseDestino) -> None:
    """Junta duas bases de relacionamentos em uma só base. O conteúdo da primeira
 base é copiado para a segunda base. A primeira base é mantida intacta. A
 segunda base, que recebe o conteúdo da primeira, tem seu conteúdo alterado.
 As entidades que existem em ambas bases são atualizadas na segunda base com
 as propriedades da primeira, mantendo as propriedades que já existirem na
 segunda e inexistirem na primeira. As entidades que não existem na segunda
 base são criadas com as informações da primeira.<BR>
 Além das entidades, os relacionamentos entre as entidades também são
 atualizados de acordo."""

    pass


  def moverBase(self, base) -> None:
    """Move uma base de relacionamentos da pasta de trabalho do projeto para a pasta
 de trabalho do ContÁgil ou vice-versa."""

    pass


  def ofuscaBase(self, baseOrigem, baseDestino) -> None:
    """Ofusca o conteúdo de uma base de relacionamentos, criando com isso uma nova
 base ou povoando uma base existente que seja diferente da original.<BR>
 O 'ofuscamento' consiste em alterar os códigos CPF,CNPJ e nomes das entidades
 de modo a descaracterizar de onde vieram os dados. Geralmente é utilizado
 para elaborar material de treinamento."""

    pass


  def padronizaTiposRelacionamentos(self, nomeBase, removeRedundancias) -> None:
    """Dado um conjunto de tipos padronizados de relacionamentos e de associações
 entre diferentes tipos de relacionamentos, este método permite 'padronizar'
 uma base de relacionamentos."""

    pass


  def pedeNomeBase(self, mensagem, opcaoPadrao) -> str:
    """Apresenta ao usuário uma janela com nomes de bases de relacionamentos
 previamente criadas e aguarda que ele escolha uma base da relação.<BR>
 Retorna o nome da base escolhida.<BR>
 Se não escolher nenhuma base, retorna NULL.<BR>
 Se não existem bases de relacionamentos previamente criadas, exibe mensagem
 de alerta e retorna NULL."""

    pass


  def pedeNomeBase(self, mensagem, opcaoPadrao, permiteNovaBase) -> str:
    """Apresenta ao usuário uma janela com nomes de bases de relacionamentos
 previamente criadas e aguarda que ele escolha uma base da relação.<BR>
 Retorna o nome da base escolhida.<BR>
 Se não escolher nenhuma base, retorna NULL.<BR>
 Se não existem bases de relacionamentos previamente criadas, exibe mensagem
 de alerta e retorna NULL."""

    pass


  def removeImagem(self, nome) -> bool:
    """Dado o nome de uma imagem existente, armazenada na pasta do ContÁgil dedicada
 ao armazenamento de imagens para bases de relacionamentos, remove-a (isto é,
 a imagem não poderá mais ser utilizada por nenhuma base de relacionamentos
 nesta estação de trabalho).<BR>
 Esta função não afeta imagens internas do ContÁgil."""

    pass


  def renomearBase(self, base, novoNome) -> None:
    """Altera o nome de uma base de relacionamentos."""

    pass


  def restauraIconesPadrao(self, nomeBase, diferenciaIdade, diferenciaSexo) -> int:
    """Restaura, em uma base de relacionamentos, os ícones para o padrão ContÁgil,
 retirando a personalização eventualmente feita. <BR>
 Adicionalmente, atribui ícones padrão diferenciados por sexo e/ou idade, se
 os parâmetros assim determinarem.<BR>"""

    pass


  def restauraIconesPadrao(self, nomeBase) -> int:
    """Restaura, em uma base de relacionamentos, os ícones para o padrão ContÁgil,
 retirando a personalização eventualmente feita.<BR>"""

    pass


  def salvaImagem(self, imagem, nome) -> Arquivo:
    """Dada uma imagem qualquer, que pode ter sido obtida de várias formas (veja
 anotações em {@link Imagem Imagem}), grava esta imagem no local da pasta de
 trabalho destinado a manter as 'imagens' utilizadas em 'grafo de
 relacionamentos'.<BR>
 Trata-se de um local específico com escopo global ao ContÁgil (isto é,
 acessível de qualquer projeto e de qualquer base de relacionamentos).<BR>
 OBS: se já existia uma imagem com o mesmo nome no diretório de imagens, a
 imagem anterior é sobrescrita pela nova."""

    pass


  def salvaImagemAnexada(self, anexo, nome) -> Arquivo:
    """Dada uma imagem qualquer que reside como 'anexo' a este script, grava esta
 imagem no local da pasta de trabalho destinado a manter as 'imagens'
 utilizadas em 'grafo de relacionamentos'.<BR>
 Trata-se de um local específico com escopo global ao ContÁgil (isto é,
 acessível de qualquer projeto e de qualquer base de relacionamentos).<BR>
 OBS: se já existia uma imagem com o mesmo nome no diretório de imagens, a
 imagem anterior é sobrescrita pela nova."""

    pass


  def salvaImagemArquivo(self, nomeArquivo) -> Arquivo:
    """Dada uma imagem qualquer que reside em algum arquivo no formato JPG, BMP, GIF
 ou PNG, grava esta imagem no local da pasta de trabalho destinado a manter as
 'imagens' utilizadas em 'grafo de relacionamentos'.<BR>
 Trata-se de um local específico com escopo global ao ContÁgil (isto é,
 acessível de qualquer projeto e de qualquer base de relacionamentos).<BR>
 A imagem é copiada com o mesmo nome do arquivo original.<BR>
 OBS: se já existia uma imagem com o mesmo nome no diretório de imagens, a
 imagem anterior é sobrescrita pela nova."""

    pass


  def salvaImagemArquivo(self, nomeArquivo, novoNome) -> Arquivo:
    """Alternativa que pode ser utilizada caso queira armazenar a imagem com nome
 diferente do nome original."""

    pass


  def setAlvos(self, alvos) -> None:
    """Define uma relação de 'alvos' que serão apresentados com moldura vermelha nas
 próximas visualizações de grafos executadas por meio de funções do tipo
 'vizualizarXXXXX' definidas aqui.<BR>
 Esta definição não afeta a 'base de relacionamentos'."""

    pass


  def setGravaBasesForaDoProjeto(self) -> None:
    """Informa ao ContÁgil que as bases de dados devem ser gravadas na pasta de
 trabalho do ContAgil."""

    pass


  def setGravaBasesNoProjeto(self) -> None:
    """Informa ao ContÁgil que as bases de dados devem ser gravadas na pasta de
 trabalho do projeto."""

    pass


  def setOpcaoVisualizacaoConverteTiposNaoPadroes(self, converteTiposNaoPadroes) -> None:
    """Indica se na apresentação de grafos por este objeto, via script, se deve ou
 não converter tipos de relacionamentos não padrões para tipos padrões,
 geralmente com nome mais reduzido do que o nome original. O padrão é não
 converter (isto é, reproduz como está na base).<BR>
 OBS: esta configuração afeta somente o grafo que é exibido em janela, não
 afeta a base de relacionamentos armazenada em disco."""

    pass


  def setOpcaoVisualizacaoDerivaTiposSimilares(self, derivaTiposSimilares) -> None:
    """Indica se na apresentação de grafos por este objeto, via script, se deve ou
 não derivar outros tipos de relacionamentos padrões similares a tipos de
 relacionamentos padrões encontrados. O padrão é não gerar esses outros
 relacionamentos (isto é, reproduz o que está na base).<BR>
 OBS: esta configuração afeta somente o grafo que é exibido em janela, não
 afeta a base de relacionamentos armazenada em disco."""

    pass


  def setOpcaoVisualizacaoExcluiRedundancias(self, excluiRedundancias) -> None:
    """Indica se na apresentação de grafos por este objeto, via script, se deve ou
 não remover os tipos de relacionamentos redundantes a outros relacionamentos
 existentes. O padrão é não remover (isto é, reproduz o que está na base).<BR>
 OBS: esta configuração afeta somente o grafo que é exibido em janela, não
 afeta a base de relacionamentos armazenada em disco."""

    pass


  def setProgress(self, progress) -> None:
    """Método para uso interno (não deve ser utilizado diretamente pelo script)."""

    pass


  def setProgress(self, progress) -> None:
    """Método para uso interno (não deve ser utilizado diretamente pelo script)."""

    pass


  def setSuspeitos(self, suspeitos) -> None:
    """Define uma relação de 'suspeitos' que serão apresentados com moldura laranja
 nas próximas visualizações de grafos executadas por meio de funções do tipo
 'vizualizarXXXXX' definidas aqui.<BR>
 Esta definição não afeta a 'base de relacionamentos'."""

    pass


  def visualizarArquivoGrafos(self, arquivo) -> None:
    """Abre um arquivo de grafo de relacionamentos do ContÁgil (GRF) e apresenta-o
 em uma janela.<BR>
 OBS: não confunda 'arquivo de grafo' com 'base de grafo'. Este método
 destina-se a abrir 'arquivo de grafo', que é um arquivo criado pelo usuário,
 contendo não apenas a relação de nós e relacionamentos, mas também as
 posições desses elementos no grafo.<BR>
 A 'base de grafo' é mantida internamente no ContÁgil para permitir diversos
 tipos de consultas (como se fosse um repositório de 'nós' e 'relacionamentos'
 que podem ser utilizados para construção de diferentes 'grafos')."""

    pass


  def visualizarBaseGrafos(self, ni, niveis) -> None:
    """Busca a entidade principal e relacionamentos até determinado nível. A
 consulta é feita na base de grafos padrão (GERAL)."""

    pass


  def visualizarBaseGrafos(self, ni, niveis, nomeBase) -> None:
    """Busca a entidade principal e relacionamentos até determinado nível. A
 consulta é feita na base de grafos indicada no parâmetro."""

    pass


  def visualizarBaseGrafos(self) -> None:
    """Busca todos as entidades e relacionamentos na base de grafos padrão (GERAL)
 para visualizacao em forma de grafos."""

    pass


  def visualizarBaseGrafos(self, codigos, niveis, nomeBase) -> None:
    """Dada uma relação de códigos (podem ser CPF ou CNPJ ou outro identificador
 único) busca para cada um deles a entidade correspondente e os
 relacionamentos até determinado nível. A consulta é feita na base de grafos
 indicada no parâmetro."""

    pass


  def visualizarBaseGrafos(self, nomeBase) -> None:
    """Busca todos as entidades e relacionamentos na base de grafos indicada para
 visualizacao em forma de grafos."""

    pass


  def visualizarDiagramaVenn(self, agrupadores, nomeBase) -> None:
    """Constrói um 'Diagrama de Venn' sobre as informações da base de
 relacionamentos.<BR>
 Cada 'conjunto' do 'Diagrama de Venn' é representado por uma 'entidade
 agregadora' (pessoa física, pessoa jurídica, etc.) que se relaciona a outras
 entidades.<BR>
 Dentro de cada conjunto são computadas as demais entidades que se conectam
 diretamente a elas.<BR>
 Caso uma mesma entidade seja relacionada diretamente a duas ou mais
 'entidades agregadoras', ela é computada em regiões diferentes do Diagrama de
 Venn.<BR>
 Com este tipo de gráfico é possível visualizar facilmente situações onde duas
 ou mais entidades compartilham os mesmos relacionamentos diretos."""

    pass


  def visualizarGrafo(self) -> None:
    """Caso este objeto tenha sido originado de um outro método que resultou em um
 'grafo' em memória, apresenta este grafo em uma janela.<BR>
 OBS: este método fica sem função nas demais hipóteses.<BR>"""

    pass


  def visualizarMenoresCaminhos(self, nomeBase, codigosIdentificacao, maxNosIntermediarios) -> None:
    """Dadas duas ou mais entidades existentes na base de relacionamentos, procura
 pelos 'menores caminhos' que conectam essas entidades entre si."""

    pass


  def visualizarTodosCaminhos(self, nomeBase, codigosIdentificacao, maxNosIntermediarios) -> None:
    """Dadas duas ou mais entidades existentes na base de relacionamentos, procura
 por todos os 'caminhos' que conectam essas entidades entre si."""

    pass

class GrafoVisualizado ():
  """Objeto de script que representa um 'grafo de relacionamentos' que está sendo 'visualizado' no ContÁgil."""

  def addEntidade(self, id, tipo, nome) -> GrafoEntidade:
    """Insere no grafo uma nova entidade."""

    pass


  def atualizaExibicao(self) -> None:
    """Atualiza a exibição do grafo de relacionamentos na janela. Útil quando o script deseja manter o usuário ciente do que está ocorrendo sobre
 o grafo enquanto o script é executado.<BR>
 OBS: este método pode demorar um tempo para concluir. Portanto, o script deve evitar chamar este método muitas vezes."""

    pass


  def exportaBaseGrafoComoImagem(self) -> Imagem:
    """Apresenta o grafo como um objeto 'Imagem' em memória.
 Você pode depois salvar esta imagem em disco (por exemplo, utilizando {@link Imagem#exportaPNG(String) exportaPNG})
 ou adicionar a uma planilha Excel (utilizando {@link ArquivoExcel#desenhaImagem(Imagem) desenhaImagem}) ou alguma
 outra operação de script que possa trabalhar com imagem."""

    pass


  def exportaBaseGrafoComoPDF(self, nomeArquivoPDF) -> Arquivo:
    """Salva o grafo como arquivo PDF, onde é inserida a imagem do grafo."""

    pass


  def getAlturaGrafo(self) -> float:
    """Retorna a altura do grafo tomando como base as dimensões dos vértices existentes e suas posições."""

    pass


  def getAlvos(self) -> list:
    """Caso existam entidades no grafo consideradas como 'alvos' (isto é, com moldura vermelha), retorna-as."""

    pass


  def getEntidade(self, id) -> GrafoEntidade:
    """Procura no grafo por alguma entidade cujo identificador é passado como parâmetro. A entidade é procurada em todo o grafo,
 mesmo que esteja oculta ou agrupada."""

    pass


  def getEntidadesAgrupadas(self, nomeGrupo) -> list:
    """Dado o nome de um grupo de entidades, retorna as entidades que estão agrupadas neste grupo, inclusive aquelas que estão 'ocultas'."""

    pass


  def getEntidadesVisiveis(self) -> list:
    """Retorna todas as entidades do grafo, exceto aquelas que estão 'ocultas'."""

    pass


  def getLarguraGrafo(self) -> float:
    """Retorna a largura do grafo tomando como base as dimensões dos vértices existentes e suas posições."""

    pass


  def getNomesGruposEntidades(self) -> list:
    """Retorna os nomes dos grupos de entidades que estão presentes no grafo, inclusive aqueles que estão 'ocultos'."""

    pass


  def getQtdEntidades(self) -> int:
    """Retorna a quantidade de entidades existentes no grafo, inclusive aquelas que estão 'ocultas' ou 'agrupadas'."""

    pass


  def getQtdGrupos(self) -> int:
    """Retorna a quantidade de grupos de entidades existentes no grafo, inclusive aqueles que estão 'ocultos'."""

    pass


  def getQtdRelacionamentos(self) -> int:
    """Retorna a quantidade de relacionamentos existentes no grafo, inclusive aqueles que estão 'ocultos'."""

    pass


  def getRankingCentralidadeAutoVetor(self, pesoSobreRelevancia) -> Tabela:
    """Aplica sobre o grafo visível na janela o cálculo do 'RANKING de ENTIDADES' considerando o critério 'Centralidade de Autovetor'<BR>
 Retorna uma tabela com o resultado do 'RANKING de ENTIDADES'. Cada linha da tabela corresponde a uma entidade. As colunas apresentam:<BR>
 TIPO: tipo da entidade<BR>
 ID: identificação da entidade<BR>
 NOME: propriedade 'NOME' da entidade<BR>
 PONTUAÇÃO: pontuação adquirida pela entidade conforme o critério de RANKING.<BR>"""

    pass


  def getRankingCentralidadeBaricentro(self, pesoSobreRelevancia) -> Tabela:
    """Aplica sobre o grafo visível na janela o cálculo do 'RANKING de ENTIDADES' considerando o critério 'Centralidade de Proximidade Baricêntrica'<BR>
 Retorna uma tabela com o resultado do 'RANKING de ENTIDADES'. Cada linha da tabela corresponde a uma entidade. As colunas apresentam:<BR>
 TIPO: tipo da entidade<BR>
 ID: identificação da entidade<BR>
 NOME: propriedade 'NOME' da entidade<BR>
 PONTUAÇÃO: pontuação adquirida pela entidade conforme o critério de RANKING.<BR>"""

    pass


  def getRankingCentralidadeGrau(self) -> Tabela:
    """Aplica sobre o grafo visível na janela o cálculo do 'RANKING de ENTIDADES' considerando o critério 'Centralidade de Grau'<BR>
 Retorna uma tabela com o resultado do 'RANKING de ENTIDADES'. Cada linha da tabela corresponde a uma entidade. As colunas apresentam:<BR>
 TIPO: tipo da entidade<BR>
 ID: identificação da entidade<BR>
 NOME: propriedade 'NOME' da entidade<BR>
 PONTUAÇÃO: pontuação adquirida pela entidade conforme o critério de RANKING.<BR>"""

    pass


  def getRankingCentralidadeIntermediacao(self, pesoSobreRelevancia) -> Tabela:
    """Aplica sobre o grafo visível na janela o cálculo do 'RANKING de ENTIDADES' considerando o critério 'Centralidade de Intermediação'<BR>
 Retorna uma tabela com o resultado do 'RANKING de ENTIDADES'. Cada linha da tabela corresponde a uma entidade. As colunas apresentam:<BR>
 TIPO: tipo da entidade<BR>
 ID: identificação da entidade<BR>
 NOME: propriedade 'NOME' da entidade<BR>
 PONTUAÇÃO: pontuação adquirida pela entidade conforme o critério de RANKING.<BR>"""

    pass


  def getRankingCentralidadeProximidadeMedia(self, pesoSobreRelevancia) -> Tabela:
    """Aplica sobre o grafo visível na janela o cálculo do 'RANKING de ENTIDADES' considerando o critério 'Centralidade de Proximidade pela Média'<BR>
 Retorna uma tabela com o resultado do 'RANKING de ENTIDADES'. Cada linha da tabela corresponde a uma entidade. As colunas apresentam:<BR>
 TIPO: tipo da entidade<BR>
 ID: identificação da entidade<BR>
 NOME: propriedade 'NOME' da entidade<BR>
 PONTUAÇÃO: pontuação adquirida pela entidade conforme o critério de RANKING.<BR>"""

    pass


  def getRankingHITSAutoridades(self, pesoSobreRelevancia) -> Tabela:
    """Aplica sobre o grafo visível na janela o cálculo do 'RANKING de ENTIDADES' considerando o critério 'HITS/Autoridades'<BR>
 Retorna uma tabela com o resultado do 'RANKING de ENTIDADES'. Cada linha da tabela corresponde a uma entidade. As colunas apresentam:<BR>
 TIPO: tipo da entidade<BR>
 ID: identificação da entidade<BR>
 NOME: propriedade 'NOME' da entidade<BR>
 PONTUAÇÃO: pontuação adquirida pela entidade conforme o critério de RANKING.<BR>"""

    pass


  def getRankingHITSHub(self, pesoSobreRelevancia) -> Tabela:
    """Aplica sobre o grafo visível na janela o cálculo do 'RANKING de ENTIDADES' considerando o critério 'HITS/Hub'<BR>
 Retorna uma tabela com o resultado do 'RANKING de ENTIDADES'. Cada linha da tabela corresponde a uma entidade. As colunas apresentam:<BR>
 TIPO: tipo da entidade<BR>
 ID: identificação da entidade<BR>
 NOME: propriedade 'NOME' da entidade<BR>
 PONTUAÇÃO: pontuação adquirida pela entidade conforme o critério de RANKING.<BR>"""

    pass


  def getRankingPageRank(self, pesoSobreRelevancia) -> Tabela:
    """Aplica sobre o grafo visível na janela o cálculo do 'RANKING de ENTIDADES' considerando o critério 'Page Rank'<BR>
 Retorna uma tabela com o resultado do 'RANKING de ENTIDADES'. Cada linha da tabela corresponde a uma entidade. As colunas apresentam:<BR>
 TIPO: tipo da entidade<BR>
 ID: identificação da entidade<BR>
 NOME: propriedade 'NOME' da entidade<BR>
 PONTUAÇÃO: pontuação adquirida pela entidade conforme o critério de RANKING.<BR>"""

    pass


  def getRankingValor(self) -> Tabela:
    """Aplica sobre o grafo visível na janela o cálculo do 'RANKING de ENTIDADES' considerando o critério 'Propriedade VALOR' (isto é, a propriedade VALOR de cada ENTIDADE é considerada
 para atribuir o RANKING).<BR>
 Retorna uma tabela com o resultado do 'RANKING de ENTIDADES'. Cada linha da tabela corresponde a uma entidade. As colunas apresentam:<BR>
 TIPO: tipo da entidade<BR>
 ID: identificação da entidade<BR>
 NOME: propriedade 'NOME' da entidade<BR>
 PONTUAÇÃO: pontuação adquirida pela entidade conforme o critério de RANKING.<BR>"""

    pass


  def getRelacionamentosVisiveis(self) -> list:
    """Retorna todos os relacionamentos do grafo, exceto aqueles que estão 'ocultos'."""

    pass


  def getSuspeitos(self) -> list:
    """Caso existam entidades no grafo consideradas como 'suspeitos' (isto é, com moldura laranja), retorna-as."""

    pass


  def getTodasEntidades(self) -> list:
    """Retorna todas as entidades do grafo, inclusive aquelas que estão 'ocultas'."""

    pass


  def getTodosRelacionamentos(self) -> list:
    """Retorna todos os relacionamentos do grafo, inclusive aqueles que estão 'ocultos'."""

    pass


  def hasAlvos(self) -> bool:
    """Retorna a indicação de que há alguma entidade no grafo que é considerada como 'alvo'. Isto é,
 possui uma moldura vermelha."""

    pass


  def hasSuspeitos(self) -> bool:
    """Retorna a indicação de que há alguma entidade no grafo que é considerada como 'suspeito'. Isto é,
 possui uma moldura laranja."""

    pass


  def isMostraIcones(self) -> bool:
    """Indica se deve ou não mostrar ícones nos vértices do grafo. Por padrão, mostra ícones. Caso indique que não deve mostrar ícones, os vértices
 são desenhados na forma de pequenas bolas coloridas."""

    pass


  def readExternal(self, in) -> None:
    pass


  def removeIndicacoesAlvos(self) -> None:
    """Caso existam entidades no grafo consideradas como 'alvos' (isto é, com moldura vermelha), remove esta indicação.<BR>
 OBS: as entidades não são removidas do grafo. Apenas elas deixam de ser consideradas como alvos."""

    pass


  def removeIndicacoesSuspeitos(self) -> None:
    """Caso existam entidades no grafo consideradas como 'suspeitos' (isto é, com moldura laranja), remove esta indicação.<BR>
 OBS: as entidades não são removidas do grafo. Apenas elas deixam de ser consideradas como suspeitos."""

    pass


  def setMostraIcones(self, mostraIcones) -> None:
    """Indica se deve ou não mostrar ícones nos vértices do grafo. Por padrão, mostra ícones. Caso indique que não deve mostrar ícones, os vértices
 são desenhados na forma de pequenas bolas coloridas."""

    pass


  def setProgress(self, progress) -> None:
    """Método para uso interno (não deve ser utilizado diretamente pelo script)."""

    pass


  def setProgress(self, progress) -> None:
    """Método para uso interno (não deve ser utilizado diretamente pelo script)."""

    pass


  def setTelaCheia(self, telaCheia) -> None:
    """Indica se deve ou não exibir o grafo no modo de 'tela cheia' (isto é, sem barra de botões, etc.)"""

    pass


  def setTodaAreaVisivel(self) -> None:
    """Através do recurso de 'zoom', faz com que toda a área do grafo ocupada por vértices seja visível."""

    pass


  def writeExternal(self, out) -> None:
    pass

class Imagem ():
  """Representa uma imagem qualquer (tal como um GIF, PNG, JPG, etc.).
 <P>
 
 Uma imagem pode ser obtida diretamente da Internet (ou da Intranet) através
 do método {@link WebExtrator#downloadImagem(String) downloadImagem}.
 <P>
 
 Uma imagem também pode ser utilizada em um "teste de CAPTCHA" (uma imagem
 contendo letras e números que o usuário deve preencher para ter acesso a
 algum serviço na Web). Para isso, utilize o método
 {@link Janelas#pedeCAPTCHA(Imagem) pedeCAPTCHA}.
 <P>
 
 Uma imagem também pode ser obtida a partir de um "gráfico" plotado sobre uma
 série de dados (ex: gráfico de "linhas", gráfico de "barras", etc.). Para
 mais informações sobre gráficos, consulte a documentação do objeto
 {@link Graficos Graficos}.
 <P>
 
 Para exibir uma imagem em uma janela, existem vários métodos em
 {@link Janelas Janelas}. Por exemplo, o método:
 {@link Janelas#mostraImagem(Imagem) mostraImagem}.<BR>
 
 Para armazenar uma imagem em um arquivo em disco, pode-se escolher uma das
 várias funçõs "exporta" existentes nesta classe. Por exemplo, o método:
 {@link Imagem#exportaPNG(String) exportaPNG}.<BR>
 
 Para armazenar uma imagem em uma planilha do formato Excel, pode-se utilizar
 o método {@link ArquivoExcel#desenhaImagem(Imagem) desenhaImagem}.<BR>"""

  def exportaBMP(self, nomeArquivo) -> None:
    """Exporta o conteúdo desta imagem para um novo arquivo do tipo BMP,
 sobrescrevendo o arquivo que porventura já exista.<BR>
 O tipo "BMP" refere-se a um formato padronizado suportado em diversos
 aplicativos. <BR>"""

    pass


  def exportaGIF(self, nomeArquivo) -> None:
    """Exporta o conteúdo desta imagem para um novo arquivo do tipo GIF,
 sobrescrevendo o arquivo que porventura já exista.<BR>
 O tipo "GIF" refere-se ao formato "Graphics Interchange Format", cuja
 documentação pode ser encontrada no seguinte link:<BR>
 {@link http://www.w3.org/Graphics/GIF/spec-gif89a.txt}"""

    pass


  def exportaJPG(self, nomeArquivo) -> None:
    """Exporta o conteúdo desta imagem para um novo arquivo do tipo JPG,
 sobrescrevendo o arquivo que porventura já exista.<BR>
 O tipo "JPG" refere-se ao formato "JPEG", cuja documentação pode ser
 encontrada no seguinte link:<BR>
 {@link http://www.jpeg.org/}<BR>"""

    pass


  def exportaPNG(self, nomeArquivo) -> None:
    """Exporta o conteúdo desta imagem para um novo arquivo do tipo PNG,
 sobrescrevendo o arquivo que porventura já exista.<BR>
 O tipo "PNG" refere-se ao formato "Portable Network Graphics", cuja
 documentação pode ser encontrada no seguinte link:<BR>
 {@link http://www.libpng.org/pub/png/spec/}<BR>"""

    pass


  def getAltura(self) -> int:
    """Obtém a altura da imagem"""

    pass


  def getLargura(self) -> int:
    """Obtém a largura da imagem"""

    pass


  def toString(self) -> str:
    pass

class Janelas ():
  """Classe utilizada pela linguagem de scripting para permitir a exibição de
 algumas janelas comuns durante a execução do script.<BR>
 Este objeto está acessível para a linguagem de script através do nome
 "janelas".<BR>"""

  def abreItemMenuAplicacao(self, caminho_menu) -> None:
    """Abre (isto é, executa) um determinado item de menu da aplicação.<BR>
 Deve ser indicado o caminho completo para o item de menu, incluindo o nome do menu e todos os demais submenus que houver
 até chegar no item desejado. Os nomes dos menus e submenus devem ser separados pelo caractere '|'"""

    pass


  def criarFormulario(self, titulo, mensagem) -> Formulario:
    """Cria um novo formulário, a partir do qual podem ser configurados os campo que serão exibidos ao usuário."""

    pass


  def criarFormulario(self, titulo) -> Formulario:
    """Cria um novo formulário, a partir do qual podem ser configurados os campo que serão exibidos ao usuário."""

    pass


  def fechaJanela(self, titulo) -> bool:
    """Fecha uma janela que possui um determinado título (o qual não pode ser vazio ou NULO).<BR>
 A janela a ser fechada pode ser uma janela do próprio ContÁgil ou pode ser uma outra janela
 qualquer aberta por outro aplicativo diferente do ContÁgil."""

    pass


  def getIconeInterno(self, nome) -> Imagem:
    """Dado o nome de um dos ícones internos definidos no ContÁgil, retorna o objeto {@link Imagem Imagem} correspondente.<BR>
 Este método se destina a retornar apenas ícones internos definidos pela aplicação. Caso queira carregar arquivos de imagem externos,
 utilize {@link GerenciadorArquivos#abrirImagem(String) abrirImagem} ou {@link WebExtrator#downloadImagem(String) downloadImagem} ou
 algum outro método.<BR>
 As dimensões das imagens podem variar de uma para outra. Algumas são grandes, outras são pequenas. Para escalonar imagens de modo
 a apresentar um mesmo tamanho, utilize {@link #getIconeInterno(String, int, int) getIconeInterno}."""

    pass


  def getIconeInterno(self, nome, largura, altura) -> Imagem:
    """Dado o nome de um dos ícones internos definidos no ContÁgil, retorna o objeto {@link Imagem Imagem} correspondente.<BR>
 Este método se destina a retornar apenas ícones internos definidos pela aplicação. Caso queira carregar arquivos de imagem externos,
 utilize {@link GerenciadorArquivos#abrirImagem(String) abrirImagem} ou {@link WebExtrator#downloadImagem(String) downloadImagem} ou
 algum outro método.<BR>
 Este método possibilita alterar o tamanho da imagem (isto é, sua largura e sua altura), de modo a manter fixa a sua dimensão."""

    pass


  def getMonitorAltura(self, monitor) -> int:
    """Retorna a altura em pixels da resolução atual do monitor indicado. Retorna 0 se não existe o monitor indicado."""

    pass


  def getMonitorLargura(self, monitor) -> int:
    """Retorna a largura em pixels da resolução atual do monitor indicado. Retorna 0 se não existe o monitor indicado."""

    pass


  def getMonitorPadrao(self) -> int:
    """Retorna o índice do monitor a ser utilizado como padrão para exibição das próximas janelas, caso existam
 múltiplos monitores.<BR>
 O número -1 indica que esta escolha é realizada pelo ContÁgil com base nas demais configurações. <BR> 
 Este método não afeta janelas de simples mensagem (avisos ou erros).<BR>"""

    pass


  def getProgresso(self) -> int:
    """Retorna o nível de progresso atual, conforme atualizado de forma direta pelo script em chamadas ao método {@link #setProgresso(int) setProgresso}"""

    pass


  def getQtdMonitores(self) -> int:
    """Retorna a quantidade de monitores que existem na estação de trabalho do usuário"""

    pass


  def getTabelaIconesInternos(self, largura, altura) -> Tabela:
    """Retorna uma tabela contendo todos os ícones definidos internamente no ContÁgil.<BR>
 A primeira coluna apresenta o nome com que estes ícones podem ser identificados. Pode-se utilizar este nome
 para fazer referência a estas mesmas imagens a partir de outros métodos.<BR>
 A segunda coluna da tabela apresenta a imagem (isto é, um objeto do tipo {@link Imagem Imagem}).<BR>
 Este método possibilita alterar o tamanho de todas as imagens (isto é, a largura e altura de cada uma), de modo a manter a mesma dimensão em todas elas."""

    pass


  def getTabelaIconesInternos(self) -> Tabela:
    """Retorna uma tabela contendo todos os ícones definidos internamente no ContÁgil.<BR>
 A primeira coluna apresenta o nome com que estes ícones podem ser identificados. Pode-se utilizar este nome
 para fazer referência a estas mesmas imagens a partir de outros métodos.<BR>
 A segunda coluna da tabela apresenta a imagem (isto é, um objeto do tipo {@link Imagem Imagem}).<BR>
 As dimensões das imagens podem variar de uma para outra. Algumas são grandes, outras são pequenas. Para escalonar imagens de modo
 a apresentar um mesmo tamanho, utilize {@link #getTabelaIconesInternos(int, int) getTabelaIconesInternos}."""

    pass


  def getTabelaUsuarioPerguntaUsuario(self) -> TabelaUsuario:
    """Exibe uma janela contendo a relação de todas as tabelas do usuário já
 criadas no projeto atualmente aberto. O usuário pode então escolher uma
 das tabelas do usuário listadas. Ao fazer isso, a tabela escolhida pelo
 usuário na janela é retornada por este método (a tabela não chega a ser
 "aberta" na janela principal do ContÁgil, ela é simplesmente retornada
 por este método, mas é possível utilizar qualquer outro método sobre esta
 tabela).<BR>
 Caso o usuário não escolha nenhuma tabela, ou caso não exista nenhuma
 tabela para escolher, este método retorna NULL.<BR>"""

    pass


  def getTabelasUsuarioPerguntaUsuario(self) -> list:
    """Exibe uma janela contendo a relação de todas as tabelas do usuário já
 criadas no projeto atualmente aberto. O usuário pode então escolher uma
 ou mais de uma das tabelas do usuário listadas. Ao fazer isso, as tabelas escolhidas pelo
 usuário na janela são retornada por este método (as tabelas não chegam a ser
 "abertas" na janela principal do ContÁgil, elas são simplesmente retornadas
 por este método, mas é possível utilizar qualquer outro método sobre esta lista de
 tabelas).<BR>
 Caso o usuário não escolha nenhuma tabela, ou caso não exista nenhuma
 tabela para escolher, este método retorna uma lista vazia.<BR>
 OBS: este método sempre retorna uma 'lista'. Mesmo que o usuário selecione uma única
 tabela, o resultado deste método será uma lista contendo um elemento."""

    pass


  def hasBarraProgresso(self) -> bool:
    """Indica se alguma barra de progresso foi criada diretamente pelo script em uma chamada ao método {@link #mostraBarraProgresso() mostraBarraProgresso}"""

    pass


  def isAlternaMonitores(self) -> bool:
    """Indica que deve haver alternância automática de qual monitor será utilizado para exibir uma janela,
 caso existam múltiplos monitores."""

    pass


  def mostraArquivoGenerico(self, nomeArquivo) -> None:
    """Solicita que o sistema operacional abra um arquivo qualquer através do aplicativo que
 estiver instalado e associado à extensão do arquivo.<BR>
 Por exemplo, se o aplicativo "Microsoft Excel" estiver instalado e associado à extensão
 de arquivo "XLS", abre-se este aplicativo caso o arquivo passado como parâmetro apresentar
 esta extensão. Porém, caso o aplicativo seja outro (ex: "BR-Office CALC"), abre-se este
 outro aplicativo.<BR>
 Ou seja, o efeito é o mesmo de se abrir este arquivo através do "Windows Explorer".<BR>
 Se nenhum aplicativo estiver associado à extensão do arquivo indicado no parâmetro, nada
 é feito.<BR>
 Se o arquivo não existe, nada é feito.<BR>"""

    pass


  def mostraBarraProgresso(self, titulo, largura, altura) -> None:
    """Método que pode ser utilizado por um script comum para exibição de uma 'barra de progresso' na frente do script, o qual
 pode ser atualizado diretamente por um script (isto é, quando o script deseja ter o controle sobre o nível de progresso
 exibido).<BR>
 Atenção: a janela de progresso é exibida sobre outras janelas exibidas no ContAgil, e permanecerá sendo exibida
 até que o método {@link #removeBarraProgresso() removeBarraProgresso} seja executado ou que o script conclua.<BR>
 Scripts visuais não precisam utilizar este método, pois o próprio ContÁgil exibe e atualiza barras de progresso de forma
 automática. Porém, nada impede que um script visual utilize este método para sobrepor a janela de progresso padrão com
 uma nova janela que possa ser atualizada diretamente por ele.<BR>
 Esta alternativa possibilita indicar parâmetros adicionais para customizar a apresentação da janela de progresso.<BR>"""

    pass


  def mostraBarraProgresso(self) -> None:
    """Método que pode ser utilizado por um script comum para exibição de uma 'barra de progresso' na frente do script, o qual
 pode ser atualizado diretamente por um script (isto é, quando o script deseja ter o controle sobre o nível de progresso
 exibido).<BR>
 Atenção: a janela de progresso é exibida sobre outras janelas exibidas no ContAgil, e permanecerá sendo exibida
 até que o método {@link #removeBarraProgresso() removeBarraProgresso} seja executado ou que o script conclua.<BR>
 Scripts visuais não precisam utilizar este método, pois o próprio ContÁgil exibe e atualiza barras de progresso de forma
 automática. Porém, nada impede que um script visual utilize este método para sobrepor a janela de progresso padrão com
 uma nova janela que possa ser atualizada diretamente por ele."""

    pass


  def mostraBotoes(self, nomes_e_subrotinas) -> None:
    """Exibe uma janela com um ou mais botões.<BR>
 Cada botão deve possuir um nome e uma subrotina.<BR>
 Ao pressionar o botão, a subrotina correspondente é executada.<BR>
 As subrotinas são procuradas no mesmo script atual. Caso queira utilizar subrotina definida em outro script, informe o nome do script antes do nome da subrotina, separando-os com o caractere '|'.<BR>
 Se nenhuma subrotina for informada para um determinado botão, assume que o botão deve fechar a janela de botões.<BR>
 <B>Parâmetros:</B> se quiser indicar parâmetros durante execução de subrotinas, informe logo após o nome da subrotina a relação
 de parâmetros entre parentesis. Ex: Subrotina(1) faz com que a subrotina de nome "Subrotina" seja executada com o valor 1
 informado no primeiro parâmetro."""

    pass


  def mostraChecklist(self, tabela, selecionados) -> Tabela:
    """Exibe uma janela contendo um "checklist" (uma relação de itens que podem
 ser marcados ou desmarcados pelo usuário).<BR>
 As informações apresentadas no "checklist" são obtidas a partir de uma
 {@link Tabela Tabela} (isto é, possui linhas e colunas).<BR>
 O resultado corresponde à escolha do usuário. Ele é apresentado na forma
 de uma nova tabela, cujo conteúdo são apenas as linhas marcadas.<BR>"""

    pass


  def mostraChecklist(self, tabela, selecionados, mensagem, admiteVazio) -> Tabela:
    """Idem ao método {@link Janelas#mostraChecklist(Tabela, int[], String) mostraChecklist}, mas inclui um parâmetro
 adicional para indicar se admite ou não o retorno com uma tabela vazia (isto é, para a hipótese em que o usuário
 fecha a janela sem escolher nenhuma das opções)."""

    pass


  def mostraChecklist(self, lista, selecionados, mensagem) -> Lista:
    """Idem ao método {@link Janelas#mostraChecklist(List, int[]) mostraChecklist}, mas inclui um parâmetro
 adicional para exibir uma mensagem em acréscimo ao checklist."""

    pass


  def mostraChecklist(self, lista, selecionados) -> Lista:
    """Exibe uma janela contendo um "checklist" (uma relação de itens que podem
 ser marcados ou desmarcados pelo usuário).<BR>
 As informações apresentadas no "checklist" são obtidas a partir de uma
 {@link Lista Lista} (isto é, possui linhas, mas uma única coluna).<BR>
 O resultado corresponde à escolha do usuário. Ele é apresentado na forma
 de uma nova lista, cujo conteúdo são apenas os elementos marcados.<BR>"""

    pass


  def mostraChecklist(self, tabela, selecionados, mensagem) -> Tabela:
    """Idem ao método {@link Janelas#mostraChecklist(Tabela, int[]) mostraChecklist}, mas inclui um parâmetro
 adicional para exibir uma mensagem em acréscimo ao checklist."""

    pass


  def mostraChecklist(self, lista, selecionados, mensagem, admiteVazio) -> Lista:
    """Idem ao método {@link Janelas#mostraChecklist(List, int[], String) mostraChecklist}, mas inclui um parâmetro
 adicional para indicar se admite ou não o retorno com uma lista vazia (isto é, para a hipótese em que o usuário
 fecha a janela sem escolher nenhuma das opções)."""

    pass


  def mostraChecklistValoresSelecionados(self, lista, selecionados, mensagem) -> Lista:
    """Idem ao método {@link Janelas#mostraChecklist(List, int[],String) mostraChecklist}, mas no lugar de indicar 'posições', indicamos
 os valores que queremos que estejam selecionados."""

    pass


  def mostraConfigurarProjeto(self) -> None:
    """Exibe a janela de configuração do projeto (onde o usuário indica, por
 exemplo, contribuintes e período de interesse).<BR>
 Esta função não faz nada caso não esteja atualmente no escopo de um
 projeto.<BR>
 Caso seja exibida a janela de configuração do projeto, esta função
 retorna apenas depois que a janela é fechada pelo usuário.<BR>
 A função não indica se algo foi alterado nesta janela (o usuário pode
 simplesmente ter consultado as informações e fechado a janela sem editar
 nada)."""

    pass


  def mostraErro(self, mensagem, titulo) -> None:
    """Apresenta uma mensagem de erro para o usuário.<BR>
 A execução do script fica temporariamente paralizada até que o usuário
 feche a janela exibida."""

    pass


  def mostraErro(self, mensagem) -> None:
    """Apresenta uma mensagem de erro para o usuário.<BR>
 A janela não tem título, apenas mensagem.<BR>
 A execução do script fica temporariamente paralizada até que o usuário
 feche a janela exibida."""

    pass


  def mostraErro(self, mensagem, titulo, tempoEspera) -> None:
    """Apresenta uma mensagem de erro para o usuário e com temporizador
 regressivo.<BR>
 A execução do script fica temporariamente paralizada até que o usuário
 feche a janela exibida ou até que o tempo de espera seja esgotado (neste
 caso, a janela fecha-se sozinha)."""

    pass


  def mostraFormularioHTML(self, html) -> WebFormulario:
    """Dado um conteúdo HTML que contém um formulário, exibe este conteúdo em uma janela e retorna o objeto 'WebFormulario' com
 os campos preenchidos.<BR>
 O conteúdo HTML deve incluir um formulário com algum campo.<BR>
 É recomendável que o conteúdo HTML não inclua botões que façam redirecionamento de página ou submissão de formulário, pois
 isso prejudicará o funcionamento deste método.<BR>
 Ao fechar a janela confirmando, os campos preenchidos são retornados na forma de um objeto do tipo {@link WebFormulario WebFormulario}. Você
 pode recuperar os valores desses campos utilizando métodos como {@link WebCampo#getValor() getValor} sobre os campos retornados
 com {@link WebFormulario#getCampos() getCampos}.<BR>
 Se o usuário pressionar o botão Cancelar, retorna NULL."""

    pass


  def mostraFormularioHTML(self, html, largura, altura) -> WebFormulario:
    """Alternativa ao método {@link #mostraFormularioWeb(String) mostraFormularioWeb}, podendo indicar largura e altura (em pixels)
 para exibição da janela."""

    pass


  def mostraGrafico(self, grafico) -> None:
    """Exibe um gráfico em uma janela do ContÁgil. Esta função retorna apenas
 depois que o usuário pressiona o botão OK.<BR>
 OBS: Esta função difere da função
 {@link Janelas#mostraImagem(Imagem) mostraImagem} pelo fato de
 disponibilizar não apenas uma figura (o gráfico), mas também todas as
 possibilidades de manipulação do gráfico, tais como: ZOOM, salvar como
 imagem, alterar título, etc. Ou seja, ficam disponíveis as ações de
 clicar com o botão direito do mouse e arrastar o botão esquerdo do mouse."""

    pass


  def mostraGrafico(self, grafico, titulo) -> None:
    """Exibe um gráfico em uma janela do ContÁgil. Esta função retorna apenas
 depois que o usuário pressiona o botão OK.<BR>
 OBS: Esta função difere da função
 {@link Janelas#mostraImagem(Imagem) mostraImagem} pelo fato de
 disponibilizar não apenas uma figura (o gráfico), mas também todas as
 possibilidades de manipulação do gráfico, tais como: ZOOM, salvar como
 imagem, alterar título, etc. Ou seja, ficam disponíveis as ações de
 clicar com o botão direito do mouse e arrastar o botão esquerdo do mouse."""

    pass


  def mostraGraficos(self, graficos, titulo) -> None:
    """Exibe em uma janela diversos gráficos de uma só vez. Os diversos gráficos
 são dispostos em linhas e colunas, como se fosse uma 'matriz de gráficos'.<BR>
 Os gráficos informados como parâmetro são os gráficos exibidos em cada
 parte desta 'matriz de gráficos'.<BR>
 Se a quantidade de gráficos informados no parâmetro é um número 'quadrado perfeito'
 (ex: 1, 4, 9, 16, etc.), os gráficos são arranjados dentro de uma 'matriz quadrada'.
 Caso contrário, procura-se arranjar os gráficos de tal modo a caber em uma matriz quadrada
 arbitrária, podendo restar algumas 'células vazias' (isto é, sem gráficos).<BR>
 Os gráficos podem ser de qualquer tipo, inclusive de tipos diferentes."""

    pass


  def mostraImagem(self, img, titulo) -> None:
    """Exibe uma imagem no ContÁgil. Esta função retorna apenas depois que o
 usuário pressiona o botão OK."""

    pass


  def mostraImagem(self, img) -> None:
    """Exibe uma imagem no ContÁgil. Esta função retorna apenas depois que o
 usuário pressiona o botão OK."""

    pass


  def mostraLista(self, lista, formato) -> None:
    """Exibe o conteúdo de uma lista em uma janela, como se fosse uma tabela
 contendo uma única coluna."""

    pass


  def mostraLista(self, lista, formato, mensagemAdicional, tituloColuna, larguraColuna) -> None:
    """Exibe o conteúdo de uma lista em uma janela, como se fosse uma tabela
 contendo uma única coluna."""

    pass


  def mostraLista(self, lista, formato, mensagemAdicional) -> None:
    """Exibe o conteúdo de uma lista em uma janela, como se fosse uma tabela
 contendo uma única coluna."""

    pass


  def mostraMatriz(self, matriz, espera, confirmarFechar, mensagemAdicional) -> None:
    """Exibe o conteúdo de uma matriz em uma janela. A janela exibe os dados da
 matriz no padrão do ContÁgil (isto é, com filtros de colunas, sumários,
 entre outras coisas).<BR>
 Os nomes das colunas são índices de colunas na matriz, começando em 0.<BR>"""

    pass


  def mostraMatriz(self, matriz) -> None:
    """Método equivalente ao método
 {@link Janelas#mostraMatriz(Matriz, boolean) mostraMatriz} com o
 parâmetro "espera" igual a TRUE (ou seja, a função não retorna enquanto a
 janela que foi apresentada não for fechada pelo usuário).<BR>
 Consulte os comentários do método
 {@link Janelas#mostraMatriz(Matriz, boolean) mostraMatriz} para mais
 informações."""

    pass


  def mostraMatriz(self, matriz, espera, confirmarFechar) -> None:
    """Exibe o conteúdo de uma matriz em uma janela. A janela exibe os dados da
 matriz no padrão do ContÁgil (isto é, com filtros de colunas, sumários,
 entre outras coisas).<BR>
 Os nomes das colunas são índices de colunas na matriz, começando em 0.<BR>"""

    pass


  def mostraMatriz(self, matriz, esperar) -> None:
    """Método equivalente ao método
 {@link Janelas#mostraMatriz(Matriz, boolean, boolean) mostraMatriz} com o
 parâmetro "confirmarFechar" igual a FALSE (ou seja, a função não alerta o
 usuário quando a janela é fechada sem salvar os dados).<BR>
 Consulte os comentários do método
 {@link Janelas#mostraMatriz(Matriz, boolean, boolean) mostraMatriz} para
 mais informações."""

    pass


  def mostraMatrizEditavel(self, matriz) -> None:
    """Exibe o conteúdo de uma matriz em uma janela e também permite sua 'edição' pelo usuário (isto é,
 ele pode 'editar' o conteúdo das células)."""

    pass


  def mostraMatrizEditavel(self, matriz, mensagemAdicional) -> None:
    """Exibe o conteúdo de uma matriz em uma janela e também permite sua 'edição' pelo usuário (isto é,
 ele pode 'editar' o conteúdo das células)."""

    pass


  def mostraMatrizGraficosDispersao(self, tabela, colunaClasse) -> None:
    """Exibe em uma janela uma visualização conhecida como 'matriz de gráficos dispersão'.<BR>
 Trata-se de uma janela com diversos gráficos, onde cada gráfico é construído conforme
 a seguinte regra:<BR>
 Linha 'i' e coluna 'j', onde 'i' é diferente de 'j' (ex: '1,2'): apresenta o gráfico
 do tipo 'dispersão' onde no eixo X temos os valores da i-ésima coluna da tabela e no
 eixo Y temos os valores da j-ésima coluna da tabela. O título exibido nesta parte do gráfico corresponde
 ao coeficiente de correlação de Pearson entre as duas variáveis envolvidas.<BR>
 Além disso, pinta-se o fundo dessas 'células' com tons escuros para altos coeficientes de correlação (próximo de +1 ou -1)
 e com tons claros para baixos coeficientes de correlação (próximos de 0).<BR>
 Linha 'i' e coluna 'i' (isto é, os gráficos compreendidos na 'diagonal' da janela):
 apresenta o gráfico do tipo 'histograma' da i-ésima coluna da tabela.<BR>
 O parâmetro adicional 'colunaClasse', se for maior ou igual a 0, indica uma coluna da tabela que deve ser considerada
 de forma especial, como sendo uma coluna dependente das demais colunas, cujo conteúdo será tratado
 para o propósito de definição de 'classes' (ou 'categorias') para cada observação. Por exemplo, se fazemos
 100 observações sobre 3 variáveis independentes e se para cada uma delas temos também atribuições nas classes '0' e '1' (que podem
 significar alguma coisa, como 'fraude' ou 'não fraude', entre outras coisas), então a tabela informada pode
 conter 100 linhas e 4 colunas, sendo 3 colunas para indicação das 3 variáveis independentes e a quarta coluna
 destinada à indicação das 'classes' (isto é, os valores 0 e 1). Neste exemplo hipotético, o parâmetro 'colunaClasse'
 deve indicar o número 3 para informar que a quarta coluna da tabela contém as indicações das classes.<BR>
 Com isso, os diferentes pontos são pintados com diferentes cores para diferenciar as diferentes classes. Assim, por exemplo,
 os pontos associados ao valor '0' poderiam ser pintados de VERMELHO e os pontos associados ao valor '1' poderiam ser pintados
 de AZUL.<BR>
 Se a tabela não apresenta uma coluna assim, com indicação de 'classes', deve ser passado neste parâmetro um número negativo qualquer.
 Com isso, todas as colunas da tabela são consideradas como sendo variáveis independentes e todos os pontos no gráfico são pintados
 na mesma cor."""

    pass


  def mostraMatrizGraficosDispersao(self, tabela) -> None:
    """Exibe em uma janela uma visualização conhecida como 'matriz de gráficos dispersão'.<BR>
 Trata-se de uma janela com diversos gráficos, onde cada gráfico é construído conforme
 a seguinte regra:<BR>
 Linha 'i' e coluna 'j', onde 'i' é diferente de 'j' (ex: '1,2'): apresenta o gráfico
 do tipo 'dispersão' onde no eixo X temos os valores da i-ésima coluna da tabela e no
 eixo Y temos os valores da j-ésima coluna da tabela. O título exibido nesta parte do gráfico corresponde
 ao coeficiente de correlação de Pearson entre as duas variáveis envolvidas.<BR>
 Além disso, pinta-se o fundo dessas 'células' com tons escuros para altos coeficientes de correlação (próximo de +1 ou -1)
 e com tons claros para baixos coeficientes de correlação (próximos de 0).<BR>
 Linha 'i' e coluna 'i' (isto é, os gráficos compreendidos na 'diagonal' da janela):
 apresenta o gráfico do tipo 'histograma' da i-ésima coluna da tabela.<BR>
 Todas as colunas da tabela são consideradas como sendo variáveis independentes e todos os pontos no gráfico são pintados
 na mesma cor. Se quiser associar cada ponto da tabela a uma 'classe' distinta (com coloração distinta), utilize
 o método alternativo que recebe um parâmetro adicional para identificação da coluna contendo as 'classes'."""

    pass


  def mostraMatrizGraficosDispersao(self, matriz, colunaClasse) -> None:
    """Exibe em uma janela uma visualização conhecida como 'matriz de gráficos dispersão'.<BR>
 Trata-se de uma janela com diversos gráficos, onde cada gráfico é construído conforme
 a seguinte regra:<BR>
 Linha 'i' e coluna 'j', onde 'i' é diferente de 'j' (ex: '1,2'): apresenta o gráfico
 do tipo 'dispersão' onde no eixo X temos os valores da i-ésima coluna da matriz e no
 eixo Y temos os valores da j-ésima coluna da matriz. O título exibido nesta parte do gráfico corresponde
 ao coeficiente de correlação de Pearson entre as duas variáveis envolvidas.<BR>
 Além disso, pinta-se o fundo dessas 'células' com tons escuros para altos coeficientes de correlação (próximo de +1 ou -1)
 e com tons claros para baixos coeficientes de correlação (próximos de 0).<BR>
 Linha 'i' e coluna 'i' (isto é, os gráficos compreendidos na 'diagonal' da janela):
 apresenta o gráfico do tipo 'histograma' da i-ésima coluna da matriz.<BR>
 O parâmetro adicional 'colunaClasse', se for maior ou igual a 0, indica uma coluna da matriz que deve ser considerada
 de forma especial, como sendo uma coluna dependente das demais colunas, cujo conteúdo será tratado
 para o propósito de definição de 'classes' (ou 'categorias') para cada observação. Por exemplo, se fazemos
 100 observações sobre 3 variáveis independentes e se para cada uma delas temos também atribuições nas classes '0' e '1' (que podem
 significar alguma coisa, como 'fraude' ou 'não fraude', entre outras coisas), então a matriz informada pode
 conter 100 linhas e 4 colunas, sendo 3 colunas para indicação das 3 variáveis independentes e a quarta coluna
 destinada à indicação das 'classes' (isto é, os valores 0 e 1). Neste exemplo hipotético, o parâmetro 'colunaClasse'
 deve indicar o número 3 para informar que a quarta coluna da matriz contém as indicações das classes.<BR>
 Com isso, os diferentes pontos são pintados com diferentes cores para diferenciar as diferentes classes. Assim, por exemplo,
 os pontos associados ao valor '0' poderiam ser pintados de VERMELHO e os pontos associados ao valor '1' poderiam ser pintados
 de AZUL.<BR>
 Se a matriz não apresenta uma coluna assim, com indicação de 'classes', deve ser passado neste parâmetro um número negativo qualquer.
 Com isso, todas as colunas da matriz são consideradas como sendo variáveis independentes e todos os pontos no gráfico são pintados
 na mesma cor."""

    pass


  def mostraMatrizGraficosDispersao(self, matriz) -> None:
    """Exibe em uma janela uma visualização conhecida como 'matriz de gráficos dispersão'.<BR>
 Trata-se de uma janela com diversos gráficos, onde cada gráfico é construído conforme
 a seguinte regra:<BR>
 Linha 'i' e coluna 'j', onde 'i' é diferente de 'j' (ex: '1,2'): apresenta o gráfico
 do tipo 'dispersão' onde no eixo X temos os valores da i-ésima coluna da matriz e no
 eixo Y temos os valores da j-ésima coluna da matriz. O título exibido nesta parte do gráfico corresponde
 ao coeficiente de correlação de Pearson entre as duas variáveis envolvidas.<BR>
 Além disso, pinta-se o fundo dessas 'células' com tons escuros para altos coeficientes de correlação (próximo de +1 ou -1)
 e com tons claros para baixos coeficientes de correlação (próximos de 0).<BR>
 Linha 'i' e coluna 'i' (isto é, os gráficos compreendidos na 'diagonal' da janela):
 apresenta o gráfico do tipo 'histograma' da i-ésima coluna da matriz.<BR>
 Todas as colunas da matriz são consideradas como sendo variáveis independentes e todos os pontos no gráfico são pintados
 na mesma cor. Se quiser associar cada ponto da matriz a uma 'classe' distinta (com coloração distinta), utilize
 o método alternativo que recebe um parâmetro adicional para identificação da coluna contendo as 'classes'."""

    pass


  def mostraMensagem(self, mensagem) -> None:
    """Exibe uma mensagem para o usuário.<BR>
 A janela não tem título, apenas mensagem.<BR>
 OBS: Se for desejável apresentar uma mensagem de erro, deve-se
 preferencialmente utilizar um dos métodos "mostraErro" disponíveis."""

    pass


  def mostraMensagem(self, mensagem, titulo) -> None:
    """Exibe uma mensagem para o usuário.<BR>
 OBS: Se for desejável apresentar uma mensagem de erro, deve-se
 preferencialmente utilizar um dos métodos "mostraErro" disponíveis."""

    pass


  def mostraMenu(self, itens, titulo) -> str:
    """Apresenta um menu com as opções indicadas no parâmetro desta função.<BR>
 As primeiras doze opções do menu podem ser acessadas com teclas de atalho
 F1, F2, ... F12.<BR>
 A tecla ESC tem o mesmo efeito de fechar a janela sem escolher opção
 alguma.<BR>
 Exemplo:<BR>
 <CODE> var itens = new Array()<BR>
 itens[0] = "Opção 1"<BR>
 itens[1] = "Opção 2"<BR>
 itens[2] = "Opção 3"<BR>
 var resposta = janelas.mostraMenu(itens,"Escolha uma opção")<BR>
 println("Opção escolhida: "+resposta)<BR>
 </CODE>"""

    pass


  def mostraMenu(self, itens, titulo, teclasAtalho) -> str:
    """Apresenta um menu com as opções indicadas no parâmetro desta função.<BR>
 O terceiro parâmetro indica se deve ou não associar teclas de atalho para
 cada opção do menu.<BR>
 A tecla ESC tem o mesmo efeito de fechar a janela sem escolher opção
 alguma.<BR>
 Exemplo:<BR>
 <CODE> var itens = new Array()<BR>
 itens[0] = "Opção 1"<BR>
 itens[1] = "Opção 2"<BR>
 itens[2] = "Opção 3"<BR>
 var resposta = janelas.mostraMenu(itens,"Escolha uma opção")<BR>
 println("Opção escolhida: "+resposta)<BR>
 </CODE>"""

    pass


  def mostraMenu(self, itens) -> str:
    """Método equivalente ao método
 {@link Janelas#mostraMenu(String[], String) mostraMenu} onde não há
 indicação de título na janela que apresenta o menu."""

    pass


  def mostraMenu(self, itens, titulo, teclasAtalho, mensagem) -> str:
    """Apresenta um menu com as opções indicadas no parâmetro desta função.<BR>
 O terceiro parâmetro indica se deve ou não associar teclas de atalho para
 cada opção do menu.<BR>
 A tecla ESC tem o mesmo efeito de fechar a janela sem escolher opção
 alguma.<BR>
 Exemplo:<BR>
 <CODE> var itens = new Array()<BR>
 itens[0] = "Opção 1"<BR>
 itens[1] = "Opção 2"<BR>
 itens[2] = "Opção 3"<BR>
 var resposta = janelas.mostraMenu(itens,"Escolha uma opção")<BR>
 println("Opção escolhida: "+resposta)<BR>
 </CODE>"""

    pass


  def mostraMenuComImagens(self, imagens, textos, titulo, ajuda) -> str:
    """Apresenta uma janela com várias opções para escolha, exibindo também uma imagem ao lado (à esquerda) de cada opção.<BR>
 O primeiro parâmetro contém imagens (objetos do tipo {@link Imagem Imagem}). Essas imagens podem tanto ser ícones internos definidos no ContÁgil (isto é,
 algum ícone da relação obtida em {@link #getTabelaIconesInternos() getTabelaIconesInternos}) como também imagens externas obtidas de arquivos externos (isto é,
 algo obtido através de {@link GerenciadorArquivos#abrirImagem(String) abrirImagem}, ou de {@link WebExtrator#downloadImagem(String) downloadImagem}, ou por outro
 método qualquer que retorne objeto do tipo {@link Imagem Imagem}).<BR>
 Caso queira, pode repetir o mesmo objeto {@link Imagem Imagem} para apresentar a mesma imagem mais de uma vez. Caso queira, pode deixar posições vazias, para indicar que não deve
 ser exibida imagem no item correspondente.<BR>
 O segundo parâmetro contém os textos que devem ser exibidos na janela, ao lado de cada imagem. Quando o usuário escolher uma oção da janela, o método retorna
 o texto indicado neste parâmetro, na opção escolhida. Este parâmetro não pode ser omitido e não deve conter textos em branco. A quantidade de itens exibidos
 na janela é determinado em função da quantidade de textos indicados neste parâmetro. Cada elemento desta relação de textos se associa com a imagem correspondente
 indicada no primeiro parâmetro.<BR>
 As imagens podem ter tamanhos diferentes. Porém, para melhor apresentação, recomenda-se que tenham dimensões parecidas.<BR>"""

    pass


  def mostraMenuComImagensInternas(self, nomesIconesInternos, textos, titulo, ajuda, larguraImagens, alturaImagens) -> str:
    """Apresenta uma janela com várias opções para escolha, exibindo também uma imagem ao lado (à esquerda) de cada opção.<BR>
 O primeiro parâmetro contém os nomes dos ícones internos existentes no ContÁgil. Indique apenas nomes conforme a relação de ícones obtida na primeira coluna
 do retorno do método {@link #getTabelaIconesInternos() getTabelaIconesInternos}. Você deve indicar um nome para cada item que deve ser exibido na janela. Caso
 queira, pode repetir o mesmo nome para apresentar a mesma imagem mais de uma vez. Caso queira, pode deixar alguns nomes em branco, para indicar que não deve
 ser exibida imagem no item correspondente.<BR>
 O segundo parâmetro contém os textos que devem ser exibidos na janela, ao lado de cada imagem. Quando o usuário escolher uma oção da janela, o método retorna
 o texto indicado neste parâmetro, na opção escolhida. Este parâmetro não pode ser omitido e não deve conter textos em branco. A quantidade de itens exibidos
 na janela é determinado em função da quantidade de textos indicados neste parâmetro. Cada elemento desta relação de textos se associa com a imagem correspondente
 indicada no primeiro parâmetro.<BR>
 Todas as imagens serão apresentadas com o mesmo tamanho (mesma largura e mesma altura)."""

    pass


  def mostraMenuComSubrotinas(self, itens_e_subrotinas, titulo, teclasAtalho, mensagem, reapresenta) -> str:
    """Apresenta um menu com as opções indicadas no parâmetro desta função e com as subrotinas correspondentes a cada item de menu.<BR>
 As subrotinas são procuradas no mesmo script atual. Caso queira utilizar subrotina definida em outro script, informe o nome do script antes do nome da subrotina, separando-os com o caractere '|'.<BR>
 Ao escolher um item de menu, o menu é fechado e a subrotina correspondente é executada logo na sequência.<BR>
 O terceiro parâmetro indica se deve ou não associar teclas de atalho para
 cada opção do menu.<BR>
 A tecla ESC tem o mesmo efeito de fechar a janela sem escolher opção
 alguma.<BR>
 Exemplo:<BR>
 <CODE> var itens_subrotinas = new Array()<BR>
 itens_subrotinas[0] = "Opção 1"<BR>
 itens_subrotinas[1] = "Subrotina1"<BR>
 itens_subrotinas[2] = "Opção 2"<BR>
 itens_subrotinas[3] = "Subrotina2"<BR>
 itens_subrotinas[4] = "Opção 3"<BR>
 itens_subrotinas[5] = "Subrotina3"<BR>
 var resposta = janelas.mostraMenuComSubrotinas(itens_subrotinas,"Escolha uma opção")<BR>
 </CODE>
 <B>Parâmetros:</B> se quiser indicar parâmetros durante execução de subrotinas, informe logo após o nome da subrotina a relação
 de parâmetros entre parentesis. Ex: Subrotina(1) faz com que a subrotina de nome "Subrotina" seja executada com o valor 1
 informado no primeiro parâmetro."""

    pass


  def mostraMenuComSubrotinas(self, itens_e_subrotinas) -> str:
    """Apresenta um menu com as opções indicadas no parâmetro desta função e com as subrotinas correspondentes a cada item de menu.<BR>
 As subrotinas são procuradas no mesmo script atual. Caso queira utilizar subrotina definida em outro script, informe o nome do script antes do nome da subrotina, separando-os com o caractere '|'.<BR>
 Ao escolher um item de menu, o menu é fechado e a subrotina correspondente é executada logo na sequência.<BR>
 A tecla ESC tem o mesmo efeito de fechar a janela sem escolher opção
 alguma.<BR>
 Exemplo:<BR>
 <CODE> var itens_subrotinas = new Array()<BR>
 itens_subrotinas[0] = "Opção 1"<BR>
 itens_subrotinas[1] = "Subrotina1"<BR>
 itens_subrotinas[2] = "Opção 2"<BR>
 itens_subrotinas[3] = "Subrotina2"<BR>
 itens_subrotinas[4] = "Opção 3"<BR>
 itens_subrotinas[5] = "Subrotina3"<BR>
 var resposta = janelas.mostraMenuComSubrotinas(itens_subrotinas)<BR>
 </CODE>
 <B>Parâmetros:</B> se quiser indicar parâmetros durante execução de subrotinas, informe logo após o nome da subrotina a relação
 de parâmetros entre parentesis. Ex: Subrotina(1) faz com que a subrotina de nome "Subrotina" seja executada com o valor 1
 informado no primeiro parâmetro."""

    pass


  def mostraMenuComSubrotinas(self, itens_e_subrotinas, titulo) -> str:
    """Apresenta um menu com as opções indicadas no parâmetro desta função e com as subrotinas correspondentes a cada item de menu.<BR>
 As subrotinas são procuradas no mesmo script atual. Caso queira utilizar subrotina definida em outro script, informe o nome do script antes do nome da subrotina, separando-os com o caractere '|'.<BR>
 Ao escolher um item de menu, o menu é fechado e a subrotina correspondente é executada logo na sequência.<BR>
 A tecla ESC tem o mesmo efeito de fechar a janela sem escolher opção
 alguma.<BR>
 Exemplo:<BR>
 <CODE> var itens_subrotinas = new Array()<BR>
 itens_subrotinas[0] = "Opção 1"<BR>
 itens_subrotinas[1] = "Subrotina1"<BR>
 itens_subrotinas[2] = "Opção 2"<BR>
 itens_subrotinas[3] = "Subrotina2"<BR>
 itens_subrotinas[4] = "Opção 3"<BR>
 itens_subrotinas[5] = "Subrotina3"<BR>
 var resposta = janelas.mostraMenuComSubrotinas(itens_subrotinas,"Escolha uma opção")<BR>
 </CODE>
 <B>Parâmetros:</B> se quiser indicar parâmetros durante execução de subrotinas, informe logo após o nome da subrotina a relação
 de parâmetros entre parentesis. Ex: Subrotina(1) faz com que a subrotina de nome "Subrotina" seja executada com o valor 1
 informado no primeiro parâmetro."""

    pass


  def mostraMenuComSubrotinas(self, itens_e_subrotinas, titulo, teclasAtalho) -> str:
    """Apresenta um menu com as opções indicadas no parâmetro desta função e com as subrotinas correspondentes a cada item de menu.<BR>
 As subrotinas são procuradas no mesmo script atual. Caso queira utilizar subrotina definida em outro script, informe o nome do script antes do nome da subrotina, separando-os com o caractere '|'.<BR>
 Ao escolher um item de menu, o menu é fechado e a subrotina correspondente é executada logo na sequência.<BR>
 O terceiro parâmetro indica se deve ou não associar teclas de atalho para
 cada opção do menu.<BR>
 A tecla ESC tem o mesmo efeito de fechar a janela sem escolher opção
 alguma.<BR>
 Exemplo:<BR>
 <CODE> var itens_subrotinas = new Array()<BR>
 itens_subrotinas[0] = "Opção 1"<BR>
 itens_subrotinas[1] = "Subrotina1"<BR>
 itens_subrotinas[2] = "Opção 2"<BR>
 itens_subrotinas[3] = "Subrotina2"<BR>
 itens_subrotinas[4] = "Opção 3"<BR>
 itens_subrotinas[5] = "Subrotina3"<BR>
 var resposta = janelas.mostraMenuComSubrotinas(itens_subrotinas,"Escolha uma opção")<BR>
 </CODE>
 <B>Parâmetros:</B> se quiser indicar parâmetros durante execução de subrotinas, informe logo após o nome da subrotina a relação
 de parâmetros entre parentesis. Ex: Subrotina(1) faz com que a subrotina de nome "Subrotina" seja executada com o valor 1
 informado no primeiro parâmetro."""

    pass


  def mostraObjeto(self, objeto) -> None:
    """Apresenta em uma janela o objeto indicado no parâmetro.<BR>
 O objeto pode ser de qualquer tipo (texto, data, lista, tabela, página da
 web, arquivo, etc.)<BR>
 A janela apresenta informações sobre o objeto e também uma lista de
 "ações", de forma análoga ao que é apresentado no editor de Script Visual
 (catálogo de ações). A diferença é que aqui as ações são executadas
 diretamente sobre o objeto indicado no parâmetro, produzindo seus efeitos
 imediatos sobre ele.<BR>
 Note que este método é diferente dos demais. Por exemplo, o método
 {@link Janelas#mostraTabela(Tabela) mostraTabela} é utilizado para
 apresentar uma tabela em uma janela, mas sem incluir esta lista de
 "ações" que é aqui apresentada.<BR>"""

    pass


  def mostraPagina(self, pagina) -> None:
    """Exibe o conteúdo de uma página em uma janela.<BR>
 Enquanto o usuário não fechar a janela, o método não termina.<BR>
 OBS: Caso o "modo de navegação completa" não tenha sido previamente
 habilitado, este método implementa de forma bem precária o suporte para a
 apresentação de página com conteúdo HTML. Muitas características que são
 comuns a páginas na Web não são apresentadas corretamente (por exemplo,
 comandos em javascript que estão presentes no código HTML da página, que
 são responsáveis por deixa-las mais "dinâmicas", são ignorados aqui).<BR>
 Por outro lado, caso o "modo de navegação completa" tenha sido previamente
 habilitado através de {@link WebExtrator#habilitaNavegacaoCompleta() habilitaNavegacaoCompleta},
 retorna o conteúdo de forma bem parecida com o que seria apresentado em
 um navegador comum (isto é, com molduras, divisórias, imagens e qualquer outro conteúdo "ativo" na
 máquina do usuário)."""

    pass


  def mostraSPACE(self, space, modoApresentacao, habilitaModoEdicao) -> None:
    """Dado um objeto que representa uma área de trabalho do SPACE (Espaço Interativo do Script Visual), exibe a janela
 correspondente.<BR>
 O método retorna apenas depois que a janela for fechada."""

    pass


  def mostraSPACE(self, space) -> None:
    """Dado um objeto que representa uma área de trabalho do SPACE (Espaço Interativo do Script Visual), exibe a janela
 correspondente.<BR>
 O método retorna apenas depois que a janela for fechada.<BR>
 OBS: este método faz com que seja exibido o 'MODO DE APRESENTAÇÃO'. Isto é, o usuário não poderá editar os componentes da janela exibida e não poderá alternar para o 'MODO DE EDIÇÃO'. Caso queria
 possibilitar o 'MODO DE EDIÇÃO' durante exibição da janela, utilize o método alternativo."""

    pass


  def mostraTabela(self, tabela) -> None:
    """Método equivalente ao método
 {@link Janelas#mostraTabela(Tabela, boolean) mostraTabela} com o
 parâmetro "espera" igual a TRUE (ou seja, a função não retorna enquanto a
 janela que foi apresentada não for fechada pelo usuário).<BR>
 Consulte os comentários do método
 {@link Janelas#mostraTabela(Tabela, boolean) mostraTabela} para mais
 informações."""

    pass


  def mostraTabela(self, tabela, esperar) -> None:
    """Método equivalente ao método
 {@link Janelas#mostraTabela(Tabela, boolean, boolean) mostraTabela} com o
 parâmetro "confirmarFechar" igual a FALSE (ou seja, a função não alerta o
 usuário quando a janela é fechada sem salvar os dados).<BR>
 Consulte os comentários do método
 {@link Janelas#mostraTabela(Tabela, boolean, boolean) mostraTabela} para
 mais informações."""

    pass


  def mostraTabela(self, tabela, espera, confirmarFechar) -> None:
    """Exibe o conteúdo de uma tabela em uma janela. A janela exibe os dados da
 tabela no padrão do ContÁgil (isto é, com filtros de colunas, sumários,
 entre outras coisas).<BR>
 Os nomes das colunas são aqueles definidos pelas funções
 {@link Tabela#setTitulo(int, String) setTitulo}. Na falta desses nomes,
 arbitra-se um nome interno para cada coluna.<BR>
 O ContÁgil descobre automaticamente que tipo de informação está contido
 em cada coluna da tabela (isto é, se são "datas" ou se são "valores" ou
 se são "textos") para que quando o usuário resolver inserir "filtro"
 sobre uma dessas colunas, sejam apresentados os critérios de filtragem
 apropriados para o tipo de informação (por exemplo, em se tratando de
 "datas", os critérios de filtragem incluem "menor data", "maior data",
 entre outras opções que se referem a datas).<BR>
 OBS: Esta função pode demorar para ser executada na hipótese da tabela
 ser muito grande, pois neste caso há mais dados que precisam ser
 analisados de modo a construir a janela de exibição da tabela."""

    pass


  def mostraTabela(self, tabela, espera, confirmarFechar, mensagemAdicional) -> None:
    """Método alternativo que inclui o parâmetro adicional opcional 'mensagemAdicional'. Veja mais comentários no método
 alternativo com mesmo nome e menos parâmetros."""

    pass


  def mostraTabelaEditavel(self, tabela, opcoesEdicao, mensagemAdicional, colunasIndividualmenteBloqueadas) -> None:
    """Exibe o conteúdo de uma tabela em uma janela e também permite sua 'edição' pelo usuário (isto é,
 ele pode 'editar' o conteúdo das células). Além disso, é possível indicar quais operações de 'edição'
 estão permitidas (por exemplo, se é possível incluir uma nova linha, se é possível excluir, etc.)."""

    pass


  def mostraTabelaEditavel(self, tabela, opcoesEdicao, colunasBloqueadas, mensagemAdicional) -> None:
    """Exibe o conteúdo de uma tabela em uma janela e também permite sua 'edição' pelo usuário (isto é,
 ele pode 'editar' o conteúdo das células). Além disso, é possível indicar quais operações de 'edição'
 estão permitidas (por exemplo, se é possível incluir uma nova linha, se é possível excluir, etc.)."""

    pass


  def mostraTabelaEditavel(self, tabela, opcoesEdicao, colunasBloqueadas) -> None:
    """Exibe o conteúdo de uma tabela em uma janela e também permite sua 'edição' pelo usuário (isto é,
 ele pode 'editar' o conteúdo das células). Além disso, é possível indicar quais operações de 'edição'
 estão permitidas (por exemplo, se é possível incluir uma nova linha, se é possível excluir, etc.)."""

    pass


  def mostraTabelaEditavelPedeConfirmacao(self, tabela, opcoesEdicao, colunasBloqueadas, mensagemAdicional) -> bool:
    """Exibe o conteúdo de uma tabela em uma janela e também permite sua 'edição' pelo usuário (isto é,
 ele pode 'editar' o conteúdo das células). Além disso, é possível indicar quais operações de 'edição'
 estão permitidas (por exemplo, se é possível incluir uma nova linha, se é possível excluir, etc.).<BR>
 Além disso, exibe também os botões 'Ok' e 'Cancelar'. Este método retornará 'TRUE' se o usuário pressionar
 'Ok' e retornará 'FALSE' se o usuário pressionar 'Cancelar'.<BR>
 Em qualquer uma dessas hipóteses, as modificações que o usuário fizer na janela têm efeitos sobre a tabela
 que está em memória."""

    pass


  def mostraTabelaEditavelPedeConfirmacao(self, tabela, opcoesEdicao, mensagemAdicional, colunasIndividualmenteBloqueadas) -> bool:
    """Exibe o conteúdo de uma tabela em uma janela e também permite sua 'edição' pelo usuário (isto é,
 ele pode 'editar' o conteúdo das células). Além disso, é possível indicar quais operações de 'edição'
 estão permitidas (por exemplo, se é possível incluir uma nova linha, se é possível excluir, etc.).<BR>
 Além disso, exibe também os botões 'Ok' e 'Cancelar'. Este método retornará 'TRUE' se o usuário pressionar
 'Ok' e retornará 'FALSE' se o usuário pressionar 'Cancelar'.<BR>
 Em qualquer uma dessas hipóteses, as modificações que o usuário fizer na janela têm efeitos sobre a tabela
 que está em memória."""

    pass


  def mostraTabelaUsuario(self, tabela, espera) -> None:
    """Exibe o conteúdo de uma tabela do usuário em uma janela. A janela exibe
 os dados da tabela no padrão do ContÁgil (isto é, com filtros de colunas,
 sumários, entre outras coisas).<BR>
 Este método não deve ser confundido com o método
 {@link Janelas#mostraTabela(Tabela, boolean) mostraTabela}, que é
 utilizado para exibir objetos do tipo {@link Tabela Tabela}.<BR>"""

    pass


  def mostraTabelaUsuario(self, tabela) -> None:
    """Exibe o conteúdo de uma tabela do usuário em uma janela. A janela exibe
 os dados da tabela no padrão do ContÁgil (isto é, com filtros de colunas,
 sumários, entre outras coisas).<BR>
 Este método não deve ser confundido com o método
 {@link Janelas#mostraTabela(Tabela, boolean) mostraTabela}, que é
 utilizado para exibir objetos do tipo {@link Tabela Tabela}.<BR>
 OBS: esta função apenas retorna depois que o usuário fechar a janela que
 é apresentada. Para permitir a exibição da janela e ao mesmo tempo
 permitir que o código que chamou esta função continue executando em
 paralelo, deve-se utilizar a função
 {@link Janelas#mostraTabelaUsuario(TabelaUsuario, boolean) mostraTabelaUsuario}
 com o parâmetro "espera" igual a FALSE."""

    pass


  def mostraTabelas(self, tabela1, tabela2, tabela3) -> None:
    """Método equivalente ao método
 {@link Janelas#mostraTabela(Tabela) mostraTabela} que apresenta três
 tabelas. A janela apresenta em "abas" diferentes as diferentes tabelas. O
 nome de cada aba é o nome de cada tabela (isto é, o nome setado pela
 função {@link Tabela#setNome(String) setNome}).<BR>
 OBS: Se desejar apresentar mais de três tabelas, utilize outra função
 variante desta."""

    pass


  def mostraTabelas(self, tabelas) -> None:
    """Método equivalente ao método
 {@link Janelas#mostraTabela(Tabela) mostraTabela} que apresenta mais de
 uma tabela. A janela apresenta em "abas" diferentes as diferentes
 tabelas. O nome de cada aba é o nome de cada tabela (isto é, o nome
 setado pela função {@link Tabela#setNome(String) setNome})."""

    pass


  def mostraTabelas(self, tabelas, titulo, isFrame) -> None:
    """Este método faz o mesmo que o método {@link #mostraTabelas(Tabela[], String, boolean) mostraTabelas}, mas
 foi mantido aqui apenas para manter compatibilidade com scripts criados em JavaScript (por alguma razão, o
 código em JavaScript contendo um parâmetro do tipo 'Array' não consegue localizar o método indicado)."""

    pass


  def mostraTabelas(self, tabelas, titulo, isFrame) -> None:
    """Método equivalente ao método
 {@link Janelas#mostraTabela(Tabela) mostraTabela} que apresenta mais de
 uma tabela. A janela apresenta em "abas" diferentes as diferentes
 tabelas. O nome de cada aba é o nome de cada tabela (isto é, o nome
 setado pela função {@link Tabela#setNome(String) setNome})."""

    pass


  def mostraTabelas(self, tabelas) -> None:
    """Método equivalente ao método
 {@link Janelas#mostraTabela(Tabela) mostraTabela} que apresenta mais de
 uma tabela. A janela apresenta em "abas" diferentes as diferentes
 tabelas. O nome de cada aba é o nome de cada tabela (isto é, o nome
 setado pela função {@link Tabela#setNome(String) setNome})."""

    pass


  def mostraTabelas(self, tabela1, tabela2) -> None:
    """Método equivalente ao método
 {@link Janelas#mostraTabela(Tabela) mostraTabela} que apresenta duas
 tabelas. A janela apresenta em "abas" diferentes as diferentes tabelas. O
 nome de cada aba é o nome de cada tabela (isto é, o nome setado pela
 função {@link Tabela#setNome(String) setNome}).<BR>
 OBS: Se desejar apresentar mais de duas tabelas, utilize outra função
 variante desta."""

    pass


  def mostraTexto(self, texto) -> None:
    """Exibe o conteúdo texto em uma janela.<BR>
 Corresponde à função
 {@link Janelas#mostraTexto(String, String) mostraTexto} sem título."""

    pass


  def mostraTexto(self, texto, titulo) -> None:
    """Exibe um texto para o usuário, que pode ser um texto comprido (isto é,
 com várias linhas).<BR>
 OBS: Este método é diferente do método
 {@link Janelas#mostraMensagem(String,String) mostraMensagem}, que se
 destina a mensagens curtas (tais como "avisos").<BR>
 Enquanto o usuário não fechar a janela, o método não termina."""

    pass


  def mostraTexto(self, texto, titulo, espera) -> None:
    """Exibe um texto para o usuário, que pode ser um texto comprido (isto é,
 com várias linhas).<BR>
 OBS: Este método é diferente do método
 {@link Janelas#mostraMensagem(String,String) mostraMensagem}, que se
 destina a mensagens curtas (tais como "avisos").<BR>
 Enquanto o usuário não fechar a janela, o método não termina."""

    pass


  def novoSPACE(self) -> SPACE:
    """Cria em memória um objeto que corresponde a uma área de trabalho do SPACE (Espaço Interativo do Script Visual).<BR>
 Nenhuma janela é exibida neste momento, possibilitando que o script inclua os objetos e informações de interesse para exibição no SPACE.<BR>
 Para apresentar a janela, utilize o método {@link #mostraSPACE(SPACE) mostraSPACE}"""

    pass


  def pedeAbrirArquivo(self, titulo, tipoArquivo, extensao) -> Arquivo:
    """Apresenta uma janela para o usuário navegar em subdiretórios e por fim
 escolher um lugar e um nome de arquivo que precisa ser aberto.<BR>
 Esta função é uma das alternativas existentes.<BR>
 Nesta função é possível também informar um tipo de arquivo e uma
 extensão, sendo essas informações úteis para direcionar o usuário para um
 determinado tipo de arquivo.<BR>"""

    pass


  def pedeAbrirArquivo(self, titulo) -> Arquivo:
    """Apresenta uma janela para o usuário navegar em subdiretórios e por fim
 escolher um arquivo que precisa ser aberto."""

    pass


  def pedeAbrirArquivoCSV(self, titulo, diretorio, separador) -> ArquivoCSV:
    """Apresenta uma janela para o usuário navegar em subdiretórios e por fim
 escolher um arquivo que precisa ser aberto. O diretório inicialmente apresentado
 é indicado como parâmetro (o usuário pode navegar para outro diretório, mas é
 sugerido inicialmente o diretório indicado como parâmetro).<BR>
 <BR>
 Esta ação é aplicável somente a arquivos do padrão texto com campos separados por vírgula ou outro caractere. Para solicitar do usuário
 arquivos de outros tipos, utilize outros métodos desta classe.<BR>
 <BR>
 Esta ação tem exatamente o mesmo efeito que executar essas outras duas ações em seqüência:<BR>
 &nbsp;&nbsp;&nbsp;arquivo = janelas.pedeAbrirArquivoNoDiretorio( titulo , diretorio_inicial );<BR>
 &nbsp;&nbsp;&nbsp;arquivo_aberto   = arquivos.abrirCSV( arquivo );<BR>
 <BR>
 Note que o retorno desta ação é o arquivo do padrão texto já "aberto" na memória do ContÁgil.<BR>
 Caso o usuário tenha pressionado o botão "Cancelar" na janela, retorna NULL.<BR>"""

    pass


  def pedeAbrirArquivoExcel(self, titulo, diretorio) -> ArquivoExcel:
    """Apresenta uma janela para o usuário navegar em subdiretórios e por fim
 escolher um arquivo que precisa ser aberto. O diretório inicialmente apresentado
 é indicado como parâmetro (o usuário pode navegar para outro diretório, mas é
 sugerido inicialmente o diretório indicado como parâmetro).<BR>
 <BR>
 Esta ação é aplicável somente a arquivos do padrão Excel. Para solicitar do usuário
 arquivos de outros tipos, utilize outros métodos desta classe.<BR>
 <BR>
 Esta ação tem exatamente o mesmo efeito que executar essas outras duas ações em seqüência:<BR>
 &nbsp;&nbsp;&nbsp;arquivo = janelas.pedeAbrirArquivoNoDiretorio( titulo , diretorio_inicial );<BR>
 &nbsp;&nbsp;&nbsp;arquivo_aberto   = arquivos.abrirExcel( arquivo );<BR>
 <BR>
 Note que o retorno desta ação é o arquivo do padrão Excel já "aberto" na memória do ContÁgil.<BR>
 Caso o usuário tenha pressionado o botão "Cancelar" na janela, retorna NULL.<BR>"""

    pass


  def pedeAbrirArquivoNoDiretorio(self, titulo, tipoArquivo, extensao, diretorio) -> Arquivo:
    """Apresenta uma janela para o usuário navegar em subdiretórios e por fim
 escolher um lugar e um nome de arquivo que precisa ser aberto.<BR>
 Esta função é uma das alternativas existentes.<BR>
 Nesta função é possível também informar um tipo de arquivo e uma
 extensão, sendo essas informações úteis para direcionar o usuário para um
 determinado tipo de arquivo.<BR>"""

    pass


  def pedeAbrirArquivoNoDiretorio(self, titulo, diretorio) -> Arquivo:
    """Apresenta uma janela para o usuário navegar em subdiretórios e por fim
 escolher um arquivo que precisa ser aberto. O diretório inicialmente apresentado
 é indicado como parâmetro (o usuário pode navegar para outro diretório, mas é
 sugerido inicialmente o diretório indicado como parâmetro)."""

    pass


  def pedeAbrirArquivoTexto(self, titulo, diretorio) -> ArquivoTexto:
    """Apresenta uma janela para o usuário navegar em subdiretórios e por fim
 escolher um arquivo que precisa ser aberto. O diretório inicialmente apresentado
 é indicado como parâmetro (o usuário pode navegar para outro diretório, mas é
 sugerido inicialmente o diretório indicado como parâmetro).<BR>
 <BR>
 Esta ação é aplicável somente a arquivos do padrão texto. Para solicitar do usuário
 arquivos de outros tipos, utilize outros métodos desta classe.<BR>
 <BR>
 Importante: caso o arquivo texto possua os campos separados por vírgula (ou outro caractere), utilize
 a ação {@link Janelas#pedeAbrirArquivoCSV(String, String, char) pedeAbrirArquivoCSV} ao invés desta.<BR>
 <BR>
 Esta ação tem exatamente o mesmo efeito que executar essas outras duas ações em seqüência:<BR>
 &nbsp;&nbsp;&nbsp;arquivo = janelas.pedeAbrirArquivoNoDiretorio( titulo , diretorio_inicial );<BR>
 &nbsp;&nbsp;&nbsp;arquivo_aberto   = arquivos.abrirArquivoTexto( arquivo );<BR>
 <BR>
 Note que o retorno desta ação é o arquivo do padrão texto já "aberto" na memória do ContÁgil.<BR>
 Caso o usuário tenha pressionado o botão "Cancelar" na janela, retorna NULL.<BR>"""

    pass


  def pedeAbrirArquivoXML(self, titulo, diretorio) -> ArquivoXML:
    """Apresenta uma janela para o usuário navegar em subdiretórios e por fim
 escolher um arquivo que precisa ser aberto. O diretório inicialmente apresentado
 é indicado como parâmetro (o usuário pode navegar para outro diretório, mas é
 sugerido inicialmente o diretório indicado como parâmetro).<BR>
 <BR>
 Esta ação é aplicável somente a arquivos do padrão XML. Para solicitar do usuário
 arquivos de outros tipos, utilize outros métodos desta classe.<BR>
 <BR>
 Esta ação tem exatamente o mesmo efeito que executar essas outras duas ações em seqüência:<BR>
 &nbsp;&nbsp;&nbsp;arquivo = janelas.pedeAbrirArquivoNoDiretorio( titulo , diretorio_inicial );<BR>
 &nbsp;&nbsp;&nbsp;arquivo_aberto   = arquivos.abrirXML( arquivo );<BR>
 <BR>
 Note que o retorno desta ação é o arquivo do padrão XML já "aberto" na memória do ContÁgil.<BR>
 Caso o usuário tenha pressionado o botão "Cancelar" na janela, retorna NULL.<BR>"""

    pass


  def pedeAbrirProjeto(self) -> str:
    """Exibe uma janela padrão para escolher um projeto que deve ser aberto. Retorna o nome
 do projeto aberto. OBS: se o usuário abortou a operação e já havia um projeto aberto,
 retorna o nome do projeto que continua aberto. Retorna NULL se não há projeto aberto."""

    pass


  def pedeCAPTCHA(self, img) -> str:
    """Exibe uma janela do tipo "teste de CAPTCHA".<BR>
 O que é <B>CAPTCHA</B>: trata-se de um teste muito comum na Internet
 onde é exibida uma imagem contendo números e letras, e é solicitado ao
 usuário que ele digite o que está vendo na imagem (isto é, digitar os
 mesmos números e letras).<BR>
 Esse tipo de "teste" é realizado para evitar que sistemas de extração de
 páginas funcionem sem a intervenção de um ser humano. Isto é, parte-se do
 pressuposto que é muito difícil ou é impossível que um sistema reconheça
 os caracteres existentes na imagem (normalmente a imagem contém também
 outros símbolos e cores com o intuito de dificultar o reconhecimento
 automático).<BR>
 Esta função presta-se a perguntar ao próprio usuário o que ele está
 vendo, de modo que o reconhecimento da imagem "por um ser humano" possa
 ser então utilizado no contexto de um script."""

    pass


  def pedeConfirmacao(self, mensagem) -> bool:
    """Pede uma confirmação para o usuário. O sistema mostra uma mensagem e os
 botões "Sim" e "Não"."""

    pass


  def pedeCriarProjeto(self) -> str:
    """Exibe uma janela padrão para criar um novo projeto. Retorna o nome
 do projeto criado. OBS: se o usuário abortou a operação e já havia um projeto aberto,
 retorna o nome do projeto que continua aberto. Retorna NULL se não há projeto aberto."""

    pass


  def pedeLista(self, mensagem, conteudoInicial, formato) -> list:
    """Pede para o usuário digitar uma lista de valores através de uma janela. A lista pode ser apresentada
 com um conteúdo inicial informado no segundo parâmetro.<BR>
 O terceiro parâmetro indica em qual formato espera encontrar os dados digitados pelo usuário.
 FORMATO:<BR>
 ==========================================<BR>
 O parâmetro "formato" pode assumir um dos seguintes conteúdos:<BR>
 <TABLE border="1">
 <TR><TD><B>TEXTO</B></TD><TD>Admite qualquer texto. Ou seja, não há validação.</TD></TR>
 <TR><TD><B>CNPJ8</B></TD><TD>Código CNPJ de 8 dígitos, pode ser digitado com ou sem formatação.</TD></TR>
 <TR><TD><B>CNPJ14</B></TD><TD>Código CNPJ de 14 dígitos, pode ser digitado com ou sem formatação. É feito o teste de verificação do dígito de validação.</TD></TR>
 <TR><TD><B>CEI</B></TD><TD>Código CEI, pode ser digitado com ou sem formatação. É feito o teste de verificação do dígito de validação.</TD></TR>
 <TR><TD><B>CPF</B></TD><TD>Código CPF, pode ser digitado com ou sem formatação. É feito o teste de verificação do dígito de validação.</TD></TR>
 <TR><TD><B>NIT</B></TD><TD>Código NIT, pode ser digitado com ou sem formatação. É feito o teste de verificação do dígito de validação.</TD></TR>
 <TR><TD><B>CNPJ_CEI</B></TD><TD>Código CNPJ de 14 dígitos ou código CEI de 12 dígitos, pode ser digitado com ou sem formatação. É feito o teste de verificação do dígito de validação.</TD></TR>
 <TR><TD><B>CNPJ_CPF</B></TD><TD>Código CNPJ de 14 dígitos ou código CPF de 11 dígitos, pode ser digitado com ou sem formatação. É feito o teste de verificação do dígito de validação.</TD></TR>
 <TR><TD><B>DATA</B></TD><TD>Deve digitar uma data, com ou sem as barras de separação dos dias, meses e anos. O ano digitado pode ter 2 ou 4 números.</TD></TR>
 <TR><TD><B>MES</B></TD><TD>Deve digitar um mês, admitindo diferentes formas de digitação (ex: "012010", "01/2010", "janeiro de 2010", entre outros).</TD></TR>
 <TR><TD><B>DECENDIO</B></TD><TD>Deve digitar um decêndio. O conteúdo é retornado no formato D/MM/AAAA, onde D é o número do decêndio dentro do mês.</TD></TR>
 <TR><TD><B>QUINZENA</B></TD><TD>Deve digitar uma quinzena. O conteúdo é retornado no formato Q/MM/AAAA, onde Q é o número da quinzena dentro do mês.</TD></TR>
 <TR><TD><B>TRIMESTRE</B></TD><TD>Deve digitar um trimestre. O conteúdo é retornado no formato T/AAAA, onde T é o número do trimestre dentro do ano.</TD></TR>
 <TR><TD><B>SEMESTRE</B></TD><TD>Deve digitar um semestre. O conteúdo é retornado no formato S/AAAA, onde S é o número do semestre dentro do ano.</TD></TR>
 <TR><TD><B>ANO</B></TD><TD>Deve digitar um ano.</TD></TR>
 <TR><TD><B>HORA</B></TD><TD>Deve digitar uma hora. Aceita digitar de diferentes formas.</TD></TR>
 <TR><TD><B>DATAHORA</B></TD><TD>Deve digitar uma data seguido de hora. Aceita digitar de diferentes formas.</TD></TR>
 <TR><TD><B>NÚMERO</B></TD><TD>Deve digitar um número inteiro sem casas decimais.</TD></TR>
 <TR><TD><B>DECIMAL</B></TD><TD>Deve digitar um número que pode conter casas decimais.</TD></TR>
 <TR><TD><B>BOOLEANO</B></TD><TD>Deve escolher entre SIM ou NÃO. Retornará o correspondente booleano a SIM ou NÃO.</TD></TR>
 <TR><TD><I>algum número</I> (ex: 11)</TD><TD>Deve digitar um número com uma determinada quantidade de algarismos.</TD></TR>
 <TR><TD><I>alguma expressão regular</I> (ex: \d{3}\.\d{3})</TD><TD>Deve digitar algo conforme a expressão regular informada.</TD></TR>
 </TABLE>"""

    pass


  def pedeLista(self, mensagem) -> list:
    """Pede para o usuário digitar uma lista de valores através de uma janela."""

    pass


  def pedeLista(self, mensagem, conteudoInicial) -> list:
    """Pede para o usuário digitar uma lista de valores através de uma janela. A lista pode ser apresentada
 com um conteúdo inicial informado no segundo parâmetro."""

    pass


  def pedeListaContribuintes(self, tipo, mensagem, conteudoInicial, ordenacaoManual) -> list:
    """Alternativa aos demais métodos. Aqui é possível indicar se deseja que o usuário tenha a liberdade de escolher a 'posição' de cada
 código de contribuinte na lista. O comportamento padrão (hipótese em que o quarto parâmetro é FALSO) é não dar esta liberdade, mas deixá-los sempre ordenados conforme a ordem
 crescente dos códigos. Se o quarto parâmetro for VERDADEIRO, esta ordenação automática não ocorre e novos botões são apresentados
 para permitir que um código seja movido para cima ou para baixo na lista de códigos.<BR>"""

    pass


  def pedeListaContribuintes(self, tipo, mensagem, conteudoInicial) -> list:
    """Pede para o usuário digitar uma lista de valores através de uma janela. A lista pode ser apresentada
 com um conteúdo inicial informado no terceiro parâmetro.<BR>
 A janela inclui botões que facilitam a construção desta lista (por exemplo, aproveitando os códigos
 configurados no projeto, ou códigos de tabela do usuário, etc.)."""

    pass


  def pedeListaContribuintes(self, tipo, mensagem) -> list:
    """Pede para o usuário digitar uma lista de códigos de contribuintes através de uma janela.<BR>
 A janela inclui botões que facilitam a construção desta lista (por exemplo, aproveitando os códigos
 configurados no projeto, ou códigos de tabela do usuário, etc.)."""

    pass


  def pedeListaProcessos(self, tipo, mensagem) -> list:
    """Pede para o usuário digitar uma lista de códigos de processos através de uma janela.<BR>
 A janela inclui botões que facilitam a construção desta lista (por exemplo, aproveitando os códigos
 códigos de tabela do usuário, etc.)."""

    pass


  def pedeListaProcessos(self, tipo, mensagem, conteudoInicial) -> list:
    """Pede para o usuário digitar uma lista de valores através de uma janela. A lista pode ser apresentada
 com um conteúdo inicial informado no terceiro parâmetro.<BR>
 A janela inclui botões que facilitam a construção desta lista (por exemplo, aproveitando os códigos
 configurados no projeto, ou códigos de tabela do usuário, etc.)."""

    pass


  def pedeListaProcessos(self, tipo, mensagem, conteudoInicial, ordenacaoManual) -> list:
    """Alternativa aos demais métodos. Aqui é possível indicar se deseja que o
 usuário tenha a liberdade de escolher a 'posição' de cada código de
 processo na lista. O comportamento padrão (hipótese em que o quarto
 parâmetro é FALSO) é não dar esta liberdade, mas deixá-los sempre ordenados
 conforme a ordem crescente dos códigos. Se o quarto parâmetro for VERDADEIRO,
 esta ordenação automática não ocorre e novos botões são apresentados para
 permitir que um código seja movido para cima ou para baixo na lista de
 códigos.<BR>"""

    pass


  def pedeOpcao(self, mensagem, opcoes, escolhida_inicialmente, permiteNovaOpcao) -> str:
    """Pede para o usuário escolher uma de várias opções (pode ser mais de
 duas).<BR>
 Ao contrário da outra alternativa deste método, que se limita a duas
 opções e as apresenta na forma de botões, este método apresenta um campo
 do tipo "combo", onde pode-se escolher uma opção dentre várias."""

    pass


  def pedeOpcao(self, mensagem, opcoes) -> str:
    """Pede para o usuário escolher uma de várias opções (pode ser mais de
 duas).<BR>
 Ao contrário da outra alternativa deste método, que se limita a duas
 opções e as apresenta na forma de botões, este método apresenta um campo
 do tipo "combo", onde pode-se escolher uma opção dentre várias."""

    pass


  def pedeOpcao(self, mensagem, opcoes, escolhida_inicialmente) -> str:
    """Pede para o usuário escolher uma de várias opções (pode ser mais de
 duas).<BR>
 Ao contrário da outra alternativa deste método, que se limita a duas
 opções e as apresenta na forma de botões, este método apresenta um campo
 do tipo "combo", onde pode-se escolher uma opção dentre várias."""

    pass


  def pedeOpcao(self, mensagem, opcao1, opcao2) -> str:
    """Pede para o usuário escolher uma de duas opções (além da opção
 "Cancelar").<BR>
 Por exemplo, se as opções forem "Sim" e "Não", a janela disponibiliza
 três botões: "Sim", "Não" e "Cancelar"."""

    pass


  def pedePasta(self, titulo, sugerePasta) -> str:
    """Apresenta uma janela para o usuário escolher uma pasta na árvore de
 pastas acessíveis ao computador.<BR>
 Esta alternativa permite indicar no segundo parâmetro o nome de uma
 pasta que será sugerida inicialmente na janela de escolha da pasta.<BR>"""

    pass


  def pedePasta(self, titulo) -> str:
    """Apresenta uma janela para o usuário escolher uma pasta na árvore de
 pastas acessíveis ao computador.<BR>"""

    pass


  def pedePeriodo(self, mensagem, mesInicio, mesFim) -> Periodo:
    """Pede para o usuário digitar um período, o qual corresponde a uma data
 inicial e uma data final, podendo omitir um dos dois ou ambos. Caso o
 usuário feche a janela sem preencher nada, retorna NULL.<BR>
 Caso o usuário tenha preenchido um campo e deixado o outro vazio, retorna
 um objeto Periodo preenchido parcialmente (isto é, uma das datas vai ser
 nula).<BR>
 Caso o usuário tenha preenchido ambos os campos, retorna um objeto
 Periodo com ambos campos preenchidos."""

    pass


  def pedePeriodo(self, mensagem) -> Periodo:
    """Pede para o usuário digitar um período, o qual corresponde a uma data
 inicial e uma data final, podendo omitir um dos dois ou ambos. Caso o
 usuário feche a janela sem preencher nada, retorna NULL.<BR>
 Caso o usuário tenha preenchido um campo e deixado o outro vazio, retorna
 um objeto Periodo preenchido parcialmente (isto é, uma das datas vai ser
 nula).<BR>
 Caso o usuário tenha preenchido ambos os campos, retorna um objeto
 Periodo com ambos campos preenchidos."""

    pass


  def pedePeriodo(self, mensagem, tipoPeriodo) -> Periodo:
    """Pede para o usuário digitar um período, o qual corresponde a uma data
 inicial (ou mês, ou trimestre, ou ano, ou outro tipo de período) e uma data final (ou outro
 tipo de período), podendo omitir um dos dois ou ambos. Caso o
 usuário feche a janela sem preencher nada, retorna NULL.<BR>
 Caso o usuário tenha preenchido um campo e deixado o outro vazio, retorna
 um objeto Periodo preenchido parcialmente (isto é, uma das datas vai ser
 nula).<BR>
 Caso o usuário tenha preenchido ambos os campos, retorna um objeto
 Periodo com ambos campos preenchidos."""

    pass


  def pedePeriodo(self, mensagem, dataInicio, dataFim) -> Periodo:
    """Pede para o usuário digitar um período, o qual corresponde a uma data
 inicial e uma data final, podendo omitir um dos dois ou ambos. Caso o
 usuário feche a janela sem preencher nada, retorna NULL.<BR>
 Caso o usuário tenha preenchido um campo e deixado o outro vazio, retorna
 um objeto Periodo preenchido parcialmente (isto é, uma das datas vai ser
 nula).<BR>
 Caso o usuário tenha preenchido ambos os campos, retorna um objeto
 Periodo com ambos campos preenchidos."""

    pass


  def pedeSalvarArquivo(self, titulo, tipoArquivo, extensao, diretorioInicial, sugereArquivo) -> Arquivo:
    """Apresenta uma janela para o usuário navegar em subdiretórios e por fim
 escolher um lugar e um nome de arquivo que precisa ser criado (isto é, o
 arquivo pode não existir).<BR>
 Esta função é uma das alternativas existentes.<BR>
 Nesta função é possível também informar um tipo de arquivo e uma
 extensão, sendo essas informações úteis para direcionar o usuário para um
 determinado tipo de arquivo.<BR>
 Além disso, é possível informar um diretório inicial onde a janela deve
 ser aberta."""

    pass


  def pedeSalvarArquivo(self, titulo, tipoArquivo, extensao) -> Arquivo:
    """Apresenta uma janela para o usuário navegar em subdiretórios e por fim
 escolher um lugar e um nome de arquivo que precisa ser criado (isto é, o
 arquivo pode não existir).<BR>
 Esta função é uma das alternativas existentes.<BR>
 Nesta função é possível também informar um tipo de arquivo e uma
 extensão, sendo essas informações úteis para direcionar o usuário para um
 determinado tipo de arquivo.<BR>"""

    pass


  def pedeSalvarArquivo(self, titulo, sugereArquivo) -> Arquivo:
    """Apresenta uma janela para o usuário navegar em subdiretórios e por fim
 escolher um lugar e um nome de arquivo que precisa ser criado (isto é, o
 arquivo pode não existir)."""

    pass


  def pedeSalvarArquivo(self, titulo, tipoArquivo, extensao, diretorioInicial) -> Arquivo:
    """Apresenta uma janela para o usuário navegar em subdiretórios e por fim
 escolher um lugar e um nome de arquivo que precisa ser criado (isto é, o
 arquivo pode não existir).<BR>
 Esta função é uma das alternativas existentes.<BR>
 Nesta função é possível também informar um tipo de arquivo e uma
 extensão, sendo essas informações úteis para direcionar o usuário para um
 determinado tipo de arquivo.<BR>
 Além disso, é possível informar um diretório inicial onde a janela deve
 ser aberta."""

    pass


  def pedeSalvarArquivo(self, titulo) -> Arquivo:
    """Apresenta uma janela para o usuário navegar em subdiretórios e por fim
 escolher um lugar e um nome de arquivo que precisa ser criado (isto é, o
 arquivo pode não existir)."""

    pass


  def pedeSalvarArquivoMultiplasOpcoes(self, titulo, configuracoes, diretorioInicial) -> Arquivo:
    """Apresenta uma janela para o usuário navegar em subdiretórios e por fim
 escolher um lugar e um nome de arquivo que precisa ser criado (isto é, o
 arquivo pode não existir).<BR>
 Ao contrário dos demais métodos 'pedeSalvarArquivo', este método permite
 configurar as opções que são exibidas em um campo na parte inferior.<BR>
 <BR>
 Configurações<BR>
 ==================================<BR>
 O campo 'configurações' é um vetor que deve conter as seguintes informações:<BR>
 1º) Extensão de um tipo de arquivo. Inclua o caractere 'ponto' no início. Ex: ".PNG".<BR>
 2º) Uma breve descrição do tipo (texto que é apresentado no campo para escolha pelo usuário). Ex: "Arquivos PNG (PNG)"<BR>
 Ou seja, para cada 'opção', deve-se informar um par de informações conforme descrito acima."""

    pass


  def pedeTabelaRegistrosCustomizados(self, campos) -> Tabela:
    """Apresenta uma janela para importação de registros customizados que permite a entrada de 
 dados manualmente (formulário), da área de transferência (copiar/colar), por meio de arquivos 
 genéricos (texto e Excel) e tabelas de usuário.<BR>
 <BR>
 Os formatos previstos para os campos são aqueles enumerados na documentação
 do método {@link Tabela#setFormato(int, String) setFormato}.<BR>
 <BR>"""

    pass


  def pedeTexto(self, mensagem, inicial, tamanho_min, tamanho_max) -> str:
    """Pede para o usuário digitar alguma coisa. Caso o usuário feche a janela
 sem preencher nada, retorna NULL.<BR>
 O parâmetro adicional "inicial" permite definir um conteúdo inicial já
 preenchido na janela.<BR>
 O parâmetro adicional "tamanho_min" permite indicar a quantidade mínima de
 caracteres que o texto deve conter. Indique 0 se não quiser este limite.<BR>
 O parâmetro adicional "tamanho_max" permite indicar a quantidade máxima de
 caracteres que o texto deve conter. Indique 0 se não quiser este limite."""

    pass


  def pedeTexto(self, mensagem, inicial) -> str:
    """Pede para o usuário digitar alguma coisa. Caso o usuário feche a janela
 sem preencher nada, retorna NULL.<BR>
 O parâmetro adicional "inicial" permite definir um conteúdo inicial já
 preenchido na janela."""

    pass


  def pedeTexto(self, mensagem) -> str:
    """Pede para o usuário digitar alguma coisa. Caso o usuário feche a janela
 sem preencher nada, retorna NULL."""

    pass


  def pedeTextoNoFormato(self, mensagem, inicial, formato) -> str:
    """Pede para o usuário digitar alguma coisa conforme um determinado formato indicado no terceiro parâmetro.
 Caso o usuário feche a janela sem preencher nada, retorna NULL.<BR>
 O parâmetro "inicial" permite definir um conteúdo inicial já
 preenchido na janela.<BR>
 O parâmetro "formato" deve indicar um formato a ser considerado na 'validação' do campo. Se o conteúdo
 digitado pelo usuário não for considerado válido conforme o formato indicado, a janela é re-exibida
 até que ele digite o conteúdo no formato esperado ou até que ele 'cancele' a operação.<BR>
 <BR>
 FORMATO:<BR>
 ==========================================<BR>
 O parâmetro "formato" pode assumir um dos seguintes conteúdos:<BR>
 <TABLE border="1">
 <TR><TD><B>TEXTO</B></TD><TD>Admite qualquer texto. Ou seja, não há validação.</TD></TR>
 <TR><TD><B>CNPJ8</B></TD><TD>Código CNPJ de 8 dígitos, pode ser digitado com ou sem formatação. Independentemente de como foi digitado, o retorno é sempre um código não formatado com 8 dígitos.</TD></TR>
 <TR><TD><B>CNPJ14</B></TD><TD>Código CNPJ de 14 dígitos, pode ser digitado com ou sem formatação. É feito o teste de verificação do dígito de validação. Independentemente de como foi digitado, o retorno é sempre um código não formatado com 14 dígitos.</TD></TR>
 <TR><TD><B>CEI</B></TD><TD>Código CEI, pode ser digitado com ou sem formatação. É feito o teste de verificação do dígito de validação. Independentemente de como foi digitado, o retorno é sempre um código não formatado com 12 dígitos.</TD></TR>
 <TR><TD><B>CPF</B></TD><TD>Código CPF, pode ser digitado com ou sem formatação. É feito o teste de verificação do dígito de validação. Independentemente de como foi digitado, o retorno é sempre um código não formatado com 11 dígitos.</TD></TR>
 <TR><TD><B>NIT</B></TD><TD>Código NIT, pode ser digitado com ou sem formatação. É feito o teste de verificação do dígito de validação. Independentemente de como foi digitado, o retorno é sempre um código não formatado com 11 dígitos.</TD></TR>
 <TR><TD><B>CNPJ_CEI</B></TD><TD>Código CNPJ de 14 dígitos ou código CEI de 12 dígitos, pode ser digitado com ou sem formatação. É feito o teste de verificação do dígito de validação. Independentemente de como foi digitado, o retorno poderá ser um código de 14 dígitos (se for CNPJ) ou um código de 12 dígitos (se for CEI), ambos sem formatação.</TD></TR>
 <TR><TD><B>CNPJ_CPF</B></TD><TD>Código CNPJ de 14 dígitos ou código CPF de 11 dígitos, pode ser digitado com ou sem formatação. É feito o teste de verificação do dígito de validação. Independentemente de como foi digitado, o retorno poderá ser um código de 14 dígitos (se for CNPJ) ou um código de 11 dígitos (se for CPF), ambos sem formatação.</TD></TR>
 <TR><TD><B>DATA</B></TD><TD>Deve digitar uma data, com ou sem as barras de separação dos dias, meses e anos. O ano digitado pode ter 2 ou 4 números. Independentemente de como foi digitado, o resultado é sempre uma data formatada no padrão DD/MM/AAAA.</TD></TR>
 <TR><TD><B>MES</B></TD><TD>Deve digitar um mês, admitindo diferentes formas de digitação (ex: "012010", "01/2010", "janeiro de 2010", entre outros). Independentemente de como foi digitado, o resultado é sempre um mês formatado no padrão MM/AAAA.</TD></TR>
 <TR><TD><B>DECENDIO</B></TD><TD>Deve digitar um decêndio. O conteúdo é retornado no formato D/MM/AAAA, onde D é o número do decêndio dentro do mês.</TD></TR>
 <TR><TD><B>QUINZENA</B></TD><TD>Deve digitar uma quinzena. O conteúdo é retornado no formato Q/MM/AAAA, onde Q é o número da quinzena dentro do mês.</TD></TR>
 <TR><TD><B>TRIMESTRE</B></TD><TD>Deve digitar um trimestre. O conteúdo é retornado no formato T/AAAA, onde T é o número do trimestre dentro do ano.</TD></TR>
 <TR><TD><B>SEMESTRE</B></TD><TD>Deve digitar um semestre. O conteúdo é retornado no formato S/AAAA, onde S é o número do semestre dentro do ano.</TD></TR>
 <TR><TD><B>ANO</B></TD><TD>Deve digitar um ano.</TD></TR>
 <TR><TD><B>HORA</B></TD><TD>Deve digitar uma hora. Aceita digitar de diferentes formas. O resultado retornado estará sempre no formato HH:MM:SS.</TD></TR>
 <TR><TD><B>DATAHORA</B></TD><TD>Deve digitar uma data seguido de hora. Aceita digitar de diferentes formas. O resultado retornado estará sempre no formato DD/MM/AAAA HH:MM:SS.</TD></TR>
 <TR><TD><B>NÚMERO</B></TD><TD>Deve digitar um número inteiro sem casas decimais.</TD></TR>
 <TR><TD><B>DECIMAL</B></TD><TD>Deve digitar um número que pode conter casas decimais.</TD></TR>
 <TR><TD><B>BOOLEANO</B></TD><TD>Deve escolher entre SIM ou NÃO. Retornará o texto SIM ou NÃO.</TD></TR>
 <TR><TD><I>algum número</I> (ex: 11)</TD><TD>Deve digitar um número com uma determinada quantidade de algarismos.</TD></TR>
 <TR><TD><I>alguma expressão regular</I> (ex: \d{3}\.\d{3})</TD><TD>Deve digitar algo conforme a expressão regular informada.</TD></TR>
 </TABLE>"""

    pass


  def removeBarraProgresso(self) -> None:
    """Remove a barra de progresso que pode ter sido criada pelo método {@link #mostraBarraProgresso() mostraBarraProgresso}"""

    pass


  def setAlternaMonitores(self, alterna) -> None:
    """Indica que deve haver alternância automática de qual monitor será utilizado para exibir uma janela,
 caso existam múltiplos monitores."""

    pass


  def setMonitorPadrao(self, monitor) -> None:
    """Define o monitor a ser utilizado como padrão para exibição das próximas janelas, caso existam
 múltiplos monitores.<BR>
 O número -1 indica que esta escolha é realizada pelo ContÁgil com base nas demais configurações.<BR> 
 Este método não afeta janelas de simples mensagem (avisos ou erros).<BR>"""

    pass


  def setProgresso(self, percentual) -> None:
    """Método que pode ser utilizado por um script comum para atualizar o nível de progresso que é exibido na barra de progresso."""

    pass

class JavaScriptUtils ():
  """Métodos utilitários para tratar um código em 'javascript'"""

  def getFunctions(self, codigo, sourceURI) -> list:
    """Processa um código escrito em javascript e retorna informações sobre as funções declaradas nele."""

    pass

class LinhaArquivo ():
  """Um objeto que representa uma linha qualquer de um arquivo (CSV, Excel ou
 outro).
 
 É utilizado em VisualScript para percorrer as diversas linhas existentes em
 um arquivo."""

  def getCampo(self, campo) -> str:
    """Retorna um determinado campo da linha. O campo é identificado por sua
 posição na linha."""

    pass


  def getLinhaInteira(self) -> str:
    """Conteúdo completo da linha, sem dividi-la em campos"""

    pass


  def getNumeroLinha(self) -> int:
    """Retorna o número da linha a que se refere esta informação. O número da
 linha de um arquivo começa pelo número 1. Ou seja, a primeira linha é a
 linha de número 1, a segunda linha é a linha de número 2, e assim
 sucessivamente."""

    pass


  def getQuantidadeCampos(self) -> int:
    """Retorna a quantidade de campos definidos nesta linha."""

    pass


  def setCampos(self, campos) -> None:
    """Altera a relação de campos que estão associados a este objeto.<BR>
 OBS: este método não altera o conteúdo do arquivo. Altera apenas o
 conteúdo que está em memória.<BR>
 Normalmente é utilizado pelo próprio ContÁgil como parte de outro
 procedimento, não sendo recomendável a utilização direta deste método por
 uma linguagem de script."""

    pass


  def setCampos(self, campos) -> None:
    """Altera a relação de campos que estão associados a este objeto.<BR>
 OBS: este método não altera o conteúdo do arquivo. Altera apenas o
 conteúdo que está em memória.<BR>
 Normalmente é utilizado pelo próprio ContÁgil como parte de outro
 procedimento, não sendo recomendável a utilização direta deste método por
 uma linguagem de script."""

    pass


  def setLinhaInteira(self, linha) -> None:
    pass


  def toString(self) -> str:
    pass

class Lista ():
  """Representa uma lista qualquer que pode receber novos componentes.<BR>
 
 OBS: Esta classe é THREAD-SAFE (isto é, o mesmo objeto pode ser compartilhado
 por execuções paralelas simultâneas)."""

  def adicionar(self, posicao, elemento) -> None:
    """Adiciona um elemento em uma determinada posição da lista. Os elementos
 que existirem na posição indicada e após ela são arrastados para depois."""

    pass


  def adicionar(self, elemento) -> None:
    """Adiciona um elemento ao final da lista"""

    pass


  def adicionarTudo(self, lista) -> None:
    """Adiciona todos os elementos de uma lista em outra lista."""

    pass


  def alterar(self, posicao, elemento) -> None:
    """Altera um determinado elemento da lista identificado por sua posição na
 lista. Caso a posição informada esteja situada além do último elemento
 existente, a lista é ampliada de modo a alcançar a posição desejada. Caso
 contrário, o tamanho da lista permanece o mesmo."""

    pass


  def calculaFormula(self, formula) -> None:
    """Percorre todos os elementos da lista calculando uma fórmula e substituindo os valores originais da lista
 com os resultados."""

    pass


  def converteTipoValores(self, formato) -> None:
    """Converte todos os valores da lista para um novo tipo.<BR>
 Por exemplo, se os valores da lista são 'textos' representando 'datas' e se o novo tipo é 'data', converte
 todos os textos para datas.<BR>
 Se os valores são 'textos' representando códigos 'CNPJ' e se o novo tipo é 'CNPJ', converte todos os
 textos para CNPJ's (independentemente de haver ou não sinais de formatação nos textos).<BR>
 Os valores que não puderem ser convertidos são removidos a lista.<BR>
 Se há algum elemento 'nulo' na lista, ele também é removido da lista.<BR>"""

    pass


  def duplica(self) -> Lista:
    """Retorna uma nova lista com todos os elementos da lista atual. A lista atual não é alterada e é independente da nova lista (isto é, qualquer
 alteração feita na nova lista não afeta a lista atual)."""

    pass


  def embaralhaLista(self) -> None:
    """Embaralha os elementos da lista (isto é, muda a ordem dos elementos de forma a ficar aleatório).<BR>
 O gerador de números pseudo-aleatórios utilizado neste método é o mesmo
 utilizado em criptografia, estando de acordo com o que é especificado em
 FIPS 140-2, Security Requirements for Cryptographic Modules, seção 4.9.1.<BR>
 As execuções sucessivas deste método retornam resultados variados em
 razão da escolha aleatória (deve-se notar que ao executar sucessivamente
 o mesmo método sobre o mesmo conjunto de dados, alguns elementos podem
 ser escolhidos repetidas vezes).<BR>"""

    pass


  def executaJavascript(self, nomeVariavel, codigoJavascript) -> None:
    """Esta função permite executar um código qualquer em JavaScript para cada valor da lista. Isto é, o mesmo código é executado repetidas vezes,
 em cada execução uma determinada variável interna ao código em JavaScript é modificada de acordo com os valores da lista. Isso equivale a executar
 um 'LOOP' sobre os valores da lista e para cada um deles executar o código JavaScript contido no LOOP. Note que o "LOOP" não precisa estar
 explícito no código JavaScript (isto é, não inclua nada como 'for ...' no parâmetro a este método, a menos que seja desejável realizar um LOOP
 dentro de outro LOOP).<BR>
 <BR>
 EXEMPLO:<BR>
 ===============================<BR>
 Suponha que você tenha uma '{@link Lista Lista}' contendo nomes de arquivos:<BR>
 <I>lista_arquivos = { arquivo1, arquivo2, arquivo3 }</I><BR>
 Suponha que para cada arquivo desta lista queremos executar a função {@link GerenciadorArquivos#apagaArquivo(String, String) apagaArquivo}, passando
 como segundo parâmetro o nome de cada arquivo contido nesta lista.<BR>
 Podemos fazer isso utilizando um só método, assim:<BR>
 <PRE>
 lista_arquivos.executaJavascript("X", "arquivos.apagaArquivo(null,X)" )
 </PRE>
 O código acima irá executar o seguinte código javascript que neste exemplo possui uma só instrução:<BR>
 <PRE>
 arquivos.apagaArquivo(null,X)
 </PRE>
 Este código será executado três vezes. Na primeira vez a variável 'X' assumirá o nome do arquivo1. Na segunda vez a variável 'X' assumirá o nome
 do arquivo2. Na terceira vez a variável 'X' assumirá o nome do arquivo3.<BR>
 Ou seja, é como se na verdade tivéssemos executado as seguintes instruções em Javascript:<BR>
 <PRE>
 arquivos.apagaArquivo(null,"arquivo1")
 arquivos.apagaArquivo(null,"arquivo2")
 arquivos.apagaArquivo(null,"arquivo3")
 </PRE>
 <BR>
 Esta função pode ser utilizada mesmo que o script não tenha sido criado na linguagem JavaScript. Por exemplo, poderia ser um Script Visual executando esta função 'executaSubRotina'
 sobre elementos de uma lista, passando como parâmetro um código em JavaScript."""

    pass


  def executaSubRotina(self, nomeSubRotina) -> None:
    """Dada uma sub-rotina do script atual que recebe um único parâmetro de entrada e retorna ou não algum resultado como saída, este método
 permite aplicar a mesma sub-rotina sobre todos os elementos da lista. Cada elemento da lista é passado individualmente como parâmetro da
 rotina. Se a rotina retorna algum resultado, o resultado sobrescreve o valor original da lista, na mesma posição.<BR>
 Por exemplo, se a lista possui 100 elementos, a rotina é executada 100 vezes, uma vez para cada elemento, em cada vez considerando-se
 o valor da lista e sobrescrevendo-o com o resultado.
 <BR>
 ATENÇÃO:<BR>
 =============================
 Este método recebe como parâmetro apenas um <B>nome</B> de sub-rotina. Existe uma outra função chamada {@link Lista#executaJavascript(String, String) executaJavascript}
 que se destina a executar um <B>código</B> em JavaScript que é informado como parâmetro (ou seja, é informado o próprio código, não o nome da sub-rotina)."""

    pass


  def getListaElementosDistintos(self) -> Lista:
    """Retorna uma nova lista onde os elementos da lista original são incluídos de forma
 a evitar repetições. A lista original não precisa estar ordenada e não é afetada por
 esta ação.<BR>
 Caso a lista original possua elementos brancos ou nulos, eles são descartados da nova lista.<BR>
 Se a lista é composta de textos, não é feita distinção quanto a letras maiúsculas ou minúsculas e nem pelos caracteres de espaço
 em branco que eventualmente apareçam antes ou depois dos textos.<BR>"""

    pass


  def getListaElementosDuplicados(self) -> Lista:
    """Retorna uma nova lista onde estão incluídos apenas os elementos da lista original que são 'repetidos'.<BR>
 A lista original não precisa estar ordenada e não é afetada por esta ação.<BR>
 Caso a lista original possua elementos brancos ou nulos, eles são descartados da nova lista.<BR>
 Se a lista é composta de textos, não é feita distinção quanto a letras maiúsculas ou minúsculas e nem pelos caracteres de espaço
 em branco que eventualmente apareçam antes ou depois dos textos.<BR>
 Para cada situação de repetição de contéudo, a nova lista gerada apresenta uma única ocorrência do conteúdo repetido.<BR>
 Por exemplo, digamos que a lista original possui o conteúdo: A; A; B; C; D; D; D<BR>
 A lista retornada por este método apresentará o conteúdo: A; D<BR>"""

    pass


  def getListaElementosDuplicados(self, incluiRepeticoes) -> Lista:
    """Método alternativo onde é possível indicar no parâmetro 'incluiRepeticoes' se é ou não desejável incluir
 na lista de resultado todas as ocorrências do mesmo conteúdo repetido. Se for FALSO, este método tem
 o mesmo comportamento que o método 'getListaElementosDuplicados' sem este parâmetro adicional."""

    pass


  def getPrimeiro(self) -> T:
    """Obtém o primeiro elemento da lista. Se a lista estiver vazia, retorna
 NULL."""

    pass


  def getUltimo(self) -> T:
    """Obtém o último elemento da lista. Se a lista estiver vazia, retorna NULL."""

    pass


  def indexOf(self, elemento, posicaoInicial) -> int:
    """Retorna o índice de um determinado elemento da lista, começando a partir de uma determinada posição.<BR>
 Se o elemento não for encontrado, retorna -1. <BR>
 Se o elemento for encontrado, retorna sua posição."""

    pass


  def indexOfExpressao(self, expressao) -> int:
    """Retorna o índice de um determinado elemento da lista utilizando 'expressão regular'.\n
 Se o elemento não for encontrado, retorna -1.<BR>
 Se o elemento for encontrado, retorna sua posição .<BR>
 Se houver mais de um elemento na lista que corresponde à mesma expressão regular, retorna apenas a posição do primeiro."""

    pass


  def indexesOf(self, elemento) -> int:
    """Retorna na forma de um vetor a relação de índices em que um determinado elemento aparece na lista.<BR>
 Se o elemento não aparece nenhuma vez na lista, retorna um vetor vazio.<BR>
 Se o elemento aparece uma única vez na lista, retorna um vetor com um único valor indicando a posição do elemento na lista (0 = primeira posição).<BR>
 Se o elemento aparece duas ou mais vezes na lista, o vetor indica todas as posições em que ele aparece."""

    pass


  def novaListaTipoValores(self, formato) -> Lista:
    """Retorna uma nova lista com os elementos desta lista que estiverem no formato especificado no parâmetro ou que puderem ser convertidos
 para este formato. A lista atual não é afetada."""

    pass


  def ordena(self) -> None:
    """Coloca os elementos da lista em ordem ascendente."""

    pass


  def paraMatrizColuna(self) -> Matriz:
    """Converte a lista para uma {@link Matriz Matriz} contendo uma única
 coluna (pode conter mais de uma coluna caso a lista contenha 'linhas de uma tabela'). 
 Os valores da lista são relacionados ao longo da primeira coluna
 da matriz. Cada valor ocupa uma linha da matriz.
 Os valores da lista que não são numéricos e não possam ser convertidos para números
 são convertidos para zero."""

    pass


  def paraMatrizLinha(self) -> Matriz:
    """Converte a lista para uma {@link Matriz Matriz} contendo uma única
 linha (pode conter mais de uma linha caso a lista contenha 'linhas de uma tabela', neste caso teríamos uma linha para cada coluna da tabela). 
 Os valores da lista são relacionados ao longo da primeira linha
 da matriz. Cada valor ocupa uma coluna da matriz.
 Os valores da lista que não são numéricos e não possam ser convertidos para números
 são convertidos para zero."""

    pass


  def paraTabela(self, quebraColuna) -> Tabela:
    """Converte a lista para uma {@link Tabela Tabela} contendo uma ou mais colunas.<BR>
 O parâmetro 'quebraColuna' define quantas informações são inseridas em uma mesma coluna.<BR>
 Inicialmente é preenchida a primeira coluna da tabela com as informações iniciais da lista. Ao alcançar o 
 limite indicado em 'quebraColuna', começa a preencher a segunda coluna da tabela, e assim em diante, até
 ter percorrido todos os elementos da lista."""

    pass


  def paraTabela(self) -> Tabela:
    """Converte a lista para uma {@link Tabela Tabela} contendo uma única
 coluna. Os valores da lista são relacionados ao longo da primeira coluna
 da tabela. Cada valor ocupa uma linha da tabela."""

    pass


  def paraTexto(self, separador) -> str:
    """Converte uma lista em um texto, separando os elementos da lista através de um caractere
 separador que é indicado no parâmetro."""

    pass


  def paraTexto(self, separador, encapsuladorTextos) -> str:
    """Converte uma lista em um texto, separando os elementos da lista através de um caractere
 separador que é indicado no parâmetro."""

    pass


  def paraVetor(self) -> Object:
    """Converte a lista para um "vetor" cujo tamanho é fixo e definido pelo
 tamanho atual da lista.<BR>
 Ao incluir ou excluir elementos na lista original não afeta a relação de
 elementos existentes no vetor após a sua criação.<BR>
 Ao alterar os componentes do vetor após sua criação não afeta a lista
 original.<BR>
 Se a lista está vazia, é criado um vetor de tamanho zero.<BR>"""

    pass


  def removeFormatacao(self) -> None:
    """Se a lista possui 'textos', remove a formatação de todos eles. Por exemplo, se um elemento
 da lista é o texto '000.000.000-00', ele passa a ser '00000000000'.<BR>
 Se a lista não possui textos (isto é, se possui datas, valores, etc.), converte-os primeiro
 para textos e depois remove formatação. Por exemplo, se a lista contém uma data '01/01/2010',
 o resultado será o texto '01012010'."""

    pass


  def removeLinhasVazias(self) -> int:
    """Remove todas as linhas 'vazias' que existirem na lista.<BR>
 Uma linha é considerada 'vazia' se ela não possuir valor algum ou possui apenas 'espaços em branco'.<BR>
 Atenção: o conteúdo '0' (zero) não é considerado como 'vazio'."""

    pass


  def remover(self, posicao) -> None:
    """Remove um determinado elemento da lista. Os elementos que existirem após
 a posição ocupada pelo elemento excluído são arrastados uma posição para
 frente."""

    pass


  def remover(self, elemento) -> None:
    """Remove um determinado elemento da lista. Os elementos que existirem após
 a posição ocupada pelo elemento excluído são arrastados uma posição para
 frente."""

    pass


  def toString(self) -> str:
    pass


  def trocaValores(self, de_valor, para_valor) -> None:
    """Troca os valores de uma lista por outros valores.<BR>
 Indique neste método o valor que deseja procurar na lista.<BR>
 Caso o valor não seja encontrado, nada é alterado na lista.<BR>
 Caso o valor seja encontrado, ele é substituído pelo novo valor.<BR>
 Se houver o mesmo valor em mais de uma posição na lista, todos eles são alterados.<BR>"""

    pass

class Listas ():
  """Objeto utilizado para criar no script uma nova "LISTA" de valores.<BR>
 
 Uma "lista" pode conter qualquer quantidade de elementos. Os elementos podem
 ser inseridos gradativamente na lista.<BR>
 
 Na linguagem de script este objeto "Listas" é chamado de "listas". A partir
 dele pode-se criar novas listas (ele não é por si só uma lista).<BR>
 
 Além de "listas", podem ser trabalhados também no script do ContÁgil outras
 estruturas de dados, por exemplo:<BR> - {@link Tabela Tabela} criada pelo
 objeto {@link Tabelas Tabelas}<BR> - "vetor" criado pelo objeto
 {@link Vetores Vetores}<BR> - {@link Agregador Agregador} criada pelo objeto
 {@link Agregador Agregador}<BR>"""

  def compara(self, lista1, lista2) -> bool:
    """Compara o conteúdo de duas listas quaisquer para saber se são iguais.<BR>
 Duas listas serão consideradas iguais se possuírem o mesmo tamanho e se seus elementos
 nas posições equivalentes forem os mesmos (isto é, compara o primeiro elemento de uma lista
 com o primeiro elemento da segunda, depois o segundo elemento de uma lista com o segundo
 elemento da segunda, e assim em diante). Note, portanto, que a ordem dos elementos na lista
 é relevante."""

    pass


  def hasExpressaoRegular(self, lista, expressao) -> bool:
    """Verifica se uma lista de objetos contém uma determinada expressão regular.<BR>
 OBS: a lista pode conter qualquer tipo de objeto, não apenas texto. No entanto, para
 efeitos de aplicação do critério de pesquisa, os objetos são convertidos para textos
 utilizando a convenção interna do ContÁgil. Por exemplo, objetos do tipo "valores"
 são convertidos para a notação com vírgula separando casas decimais e objetos do tipo
 "data" são convertidos para o formato "dd/mm/aaaa". Esta "conversão" ocorre apenas
 durante a utilização deste método, não afeta a lista.<BR>"""

    pass


  def moveElementos(self, lista, primeiroElemento, ultimoElemento, posicoes) -> None:
    """Move um conjunto de elementos da lista algumas posições para frente ou para trás. Os 'espaços deixados para trás' são ocupados
 pelos elementos posteriores ou anteriores.<BR>
 Por exemplo, se a lista possui os números "1", "2", "3" e "4" e se o segundo e o terceiro elementos são 'movidos'
 uma posição para frente (isto é, para o final da lista), então a lista passa a listar elementos com conteúdos "1", "4", "2" e "3".<BR>
 Se os elementos forem movidos para uma posição anterior ao primeiro, mantém na primeira posição. Se forem movidos para uma posição posterior
 à última, mantém na última posição. Para mover um único elemento, informe o mesmo número nos parâmetros 'primeiroElemento' e 'ultimoElemento'"""

    pass


  def novaLista(self, valores) -> Lista:
    """Cria uma nova lista com os valores passados por parâmetro"""

    pass


  def novaLista(self, primeiroMes, ultimoMes) -> Lista:
    """Cria uma nova lista já preenchida com meses de um intervalo. A lista
 cronológica pode ser ascendente ou descendente dependendo se o primeiro
 mês é menor ou maior que o último.<BR>
 A 13a competência nunca é incluída na relação."""

    pass


  def novaLista(self, primeiraData, ultimaData, intervalo) -> Lista:
    """Cria uma nova lista já preenchida com datas de um intervalo. A lista
 cronológica pode ser ascendente ou descendente dependendo se a primeira
 data é menor ou maior que a última."""

    pass


  def novaLista(self, primeiroNumero, ultimoNumero) -> Lista:
    """Cria uma nova lista já preenchida com números de um intervalo. A lista
 numérica pode ser ascendente ou descendente dependendo se o primeiro
 número é menor ou maior que o último."""

    pass


  def novaLista(self, primeiraData, ultimaData) -> Lista:
    """Cria uma nova lista já preenchida com datas de um intervalo. A lista
 cronológica pode ser ascendente ou descendente dependendo se a primeira
 data é menor ou maior que a última."""

    pass


  def novaLista(self) -> Lista:
    """Cria uma nova "lista" inicialmente vazia.<BR>
 Para mais informações sobre o que são "listas", consulte na documentação
 pela referência {@link Listas Listas}."""

    pass


  def novaLista(self, primeiroNumero, ultimoNumero, intervalo) -> Lista:
    """Cria uma nova lista já preenchida com números de um intervalo. A lista
 numérica pode ser ascendente ou descendente dependendo se o primeiro
 número é menor ou maior que o último."""

    pass


  def novaLista(self, primeiroMes, ultimoMes, intervalo) -> Lista:
    """Cria uma nova lista já preenchida com meses de um intervalo. A lista
 cronológica pode ser ascendente ou descendente dependendo se o primeiro
 mês é menor ou maior que o último.<BR>
 A 13a competência nunca é incluída na relação."""

    pass


  def novaListaAleatoria(self, quantidade, menorNumero, maiorNumero) -> Lista:
    """Cria uma nova lista já preenchida com números aleatórios.<BR>
 Os números aleatórios seguem uma distribuição contínua e uniforme (isto
 é, a probabilidade de se escolher qualquer número do intervalo é a
 mesma).<BR>"""

    pass


  def novaListaAleatoriaCategorias(self, quantidade, categorias) -> Lista:
    """Cria uma nova lista já preenchida com categorias distribuídas de forma aleatória.<BR>
 As diferentes categorias são escolhidas conforme um critério aleatório que escolhe
 qualquer categoria com igual probabilidade.<BR>"""

    pass


  def novaListaAleatoriaDistribuicaoBeta(self, quantidade, alfa, beta, min, max) -> Lista:
    """Idem ao método
 {@link Listas#novaListaAleatoriaDistribuicaoBeta(int, double, double) novaListaAleatoriaDistribuicaoBeta},
 com a inclusão de dois parâmetros para indicar o valor mínimo e o valor
 máximo de variação (a distribuição padrão varia entre 0 e 1)."""

    pass


  def novaListaAleatoriaDistribuicaoBeta(self, quantidade, alfa, beta) -> Lista:
    """Cria uma nova lista já preenchida com números aleatórios.<BR>
 Os números aleatórios seguem uma distribuição beta.<BR>
 Para mais informações sobre a distribuição beta, consulte
 http://mathworld.wolfram.com/BetaDistribution.html<BR>
 Os números são gerados utilizando o método da transformação inversa (isto
 é, utilizando a função inversa da função distribuição acumulada sobre uma
 variável aleatória de distribuição uniforme).<BR>
 A distribuição "beta" é considerada como a "priori conjugada" da
 distribuição binomial.<BR>
 A distribuição "beta" de parâmetros (alfa = 1 e beta = 1) corresponde à
 distribuição uniforme contínua no invervalo entre 0 e 1."""

    pass


  def novaListaAleatoriaDistribuicaoBinomial(self, quantidade, N, p) -> Lista:
    """Cria uma nova lista já preenchida com números aleatórios.<BR>
 Os números aleatórios seguem uma distribuição binomial.<BR>
 Para mais informações sobre a distribuição binomial, consulte
 http://mathworld.wolfram.com/BinomialDistribution.html<BR>
 Os números são gerados utilizando o método da transformação inversa (isto
 é, utilizando a função inversa da função distribuição acumulada sobre uma
 variável aleatória de distribuição uniforme).<BR>
 Esta distribuição representa a quantidade de "sucessos" após a execução
 de "N" tentativas de Bernouli (tais como lances consecutivos de moeda),
 onde a probabilidade de um "sucesso" em uma tentativa é dada por "p".<BR>"""

    pass


  def novaListaAleatoriaDistribuicaoCauchy(self, quantidade, mediana, escala) -> Lista:
    """Cria uma nova lista já preenchida com números aleatórios.<BR>
 Os números aleatórios seguem uma distribuição Cauchy.<BR>
 Para mais informações sobre a distribuição Cauchy, consulte
 http://mathworld.wolfram.com/CauchyDistribution.html<BR>
 Os números são gerados utilizando o método da transformação inversa (isto
 é, utilizando a função inversa da função distribuição acumulada sobre uma
 variável aleatória de distribuição uniforme).<BR>
 A distribuição "Cauchy" é também conhecida como distribuição de Lorentz.<BR>
 Ela é considerada como uma distribuição "patológica", pois a média (valor
 esperado) não existe e sua variância é infinita. Apesar disso, possui uma
 mediana bem definida.<BR>
 Esta é a distribuição obtida quando se dividem duas variáveis aleatórias
 X e Y, cada uma regida por uma distribuição normal padrão. Isto é, se X e
 Y ~ N(0,1), então X/Y ~ Cauchy(0,1).<BR>"""

    pass


  def novaListaAleatoriaDistribuicaoChiQuadrado(self, quantidade, k) -> Lista:
    """Cria uma nova lista já preenchida com números aleatórios.<BR>
 Os números aleatórios seguem uma distribuição Chi Quadrado.<BR>
 Para mais informações sobre a distribuição Chi Quadrado, consulte
 http://mathworld.wolfram.com/Chi-SquaredDistribution.html<BR>
 Os números são gerados utilizando o método da transformação inversa (isto
 é, utilizando a função inversa da função distribuição acumulada sobre uma
 variável aleatória de distribuição uniforme).<BR>
 A distribuição "Chi Quadrado" com "k" graus de liberdade corresponde à
 distribuição da soma dos quadrados de "k" variáveis aleatórias
 independentes que seguem, cada uma, uma distribuição normal padrão.<BR>
 Ela é bastante utilizada em estatística inferencial e em testes de
 hipóteses.<BR>
 A soma de duas ou mais variáveis com distribuição Chi Quadrado também
 possui uma distribuição da forma Chi Quadrado, cujo parâmetro "k" é a
 soma dos parâmetros individuais de cada uma.<BR>"""

    pass


  def novaListaAleatoriaDistribuicaoExponencial(self, quantidade, lambda) -> Lista:
    """Cria uma nova lista já preenchida com números aleatórios.<BR>
 Os números aleatórios seguem uma distribuição exponencial.<BR>
 Para mais informações sobre a distribuição exponencial, consulte
 http://mathworld.wolfram.com/ExponentialDistribution.html<BR>
 Os números são gerados utilizando o método da transformação inversa (isto
 é, utilizando a função inversa da função distribuição acumulada sobre uma
 variável aleatória de distribuição uniforme).<BR>
 Esta função é o análogo "contínuo" da distribuição de variáveis
 aleatórias discretas "geométrica".<BR>
 Trata-se da distribuição que reflete os intervalos contínuos entre dois
 eventos sucessivos gerados pela distribuição de Poisson."""

    pass


  def novaListaAleatoriaDistribuicaoExponencial(self, quantidade, lambda, posicao) -> Lista:
    """Idem ao método
 {@link Listas#novaListaAleatoriaDistribuicaoExponencial(int, double) novaListaAleatoriaDistribuicaoExponencial}
 com a inclusão de um parâmetro adicional para informar a posição
 (deslocamento no eixo X)."""

    pass


  def novaListaAleatoriaDistribuicaoF(self, quantidade, d1, d2) -> Lista:
    """Cria uma nova lista já preenchida com números aleatórios.<BR>
 Os números aleatórios seguem uma distribuição F.<BR>
 Para mais informações sobre a distribuição F, consulte
 http://mathworld.wolfram.com/F-Distribution.html<BR>
 Os números são gerados utilizando o método da transformação inversa (isto
 é, utilizando a função inversa da função distribuição acumulada sobre uma
 variável aleatória de distribuição uniforme).<BR>
 A distribuição "F" também é conhecida como distribuição F de Snedecor ou
 a distribuição de Fisher-Snedecor.<BR>
 Ela surge naturalmente a partir da razão entre duas distribuições Chi
 Quadrada independentes de graus de liberdade d1 e d2, respectivamente. Ou
 seja, (U1 / d1) / ( U2 / d2).<BR>
 Ela é empregada em análise de variância (teste "F")."""

    pass


  def novaListaAleatoriaDistribuicaoGamma(self, quantidade, alfa, beta) -> Lista:
    """Cria uma nova lista já preenchida com números aleatórios.<BR>
 Os números aleatórios seguem uma distribuição gamma.<BR>
 Para mais informações sobre a distribuição gamma, consulte
 http://mathworld.wolfram.com/GammaDistribution.html<BR>
 Os números são gerados utilizando o método da transformação inversa (isto
 é, utilizando a função inversa da função distribuição acumulada sobre uma
 variável aleatória de distribuição uniforme).<BR>
 Esta distribuição se relaciona com a distribuição exponencial e com a
 distribuição de Poisson no sentido que, para "alfa" inteiro, ela
 representa a "soma dos intervalos" de espera entre diversos eventos
 consecutivos que seguem o processo de Poisson (neste contexto, "alfa"
 pode ser interpretado como a "quantidade de intervalos").<BR>
 Esta função é o análogo "contínuo" da distribuição de variáveis
 aleatórias discretas "binomial negativa".<BR>"""

    pass


  def novaListaAleatoriaDistribuicaoHipergeometrica(self, quantidade, n, m, N) -> Lista:
    """Cria uma nova lista já preenchida com números aleatórios.<BR>
 Os números aleatórios seguem uma distribuição HIPERGEOMÉTRICA.<BR>
 Para mais informações sobre a distribuição HIPERGEOMÉTRICA, consulte
 http://mathworld.wolfram.com/HypergeometricDistribution.html<BR>
 Os números são gerados utilizando o método da transformação inversa (isto
 é, utilizando a função inversa da função distribuição acumulada sobre uma
 variável aleatória de distribuição uniforme).<BR>
 Ela corresponde à quantidade de "sucessos" em uma amostra de tamanho
 definido obtida de uma população onde o conjunto total de "sucessos" é
 conhecido.<BR>
 Uma distribuição hipergeométrica pode ser comparada com uma distribuição
 binomial no sentido que a primeira é a quantidade de sucessos "sem
 reposição" (após "n" tentativas com probabilidade p=m/N) e a segunda é a
 quantidade de sucessos "com reposição" (após "n" tentativas com
 probabilidade p)."""

    pass


  def novaListaAleatoriaDistribuicaoLaplace(self, quantidade, media, beta) -> Lista:
    """Cria uma nova lista já preenchida com números aleatórios.<BR>
 Os números aleatórios seguem uma distribuição Laplace.<BR>
 Para mais informações sobre a distribuição Laplace, consulte
 http://mathworld.wolfram.com/LaplaceDistribution.html<BR>
 Os números são gerados utilizando o método da transformação inversa (isto
 é, utilizando a função inversa da função distribuição acumulada sobre uma
 variável aleatória de distribuição uniforme).<BR>
 A distribuição "Laplace" é também conhecida como distribuição exponencial
 dupla, pois pode ser imaginada como sendo a junção de duas distribuições
 exponenciais (uma de frente para a outra).<BR>
 Ela corresponde à diferença entre duas variáveis aleatórias independentes
 com distribuição exponencial.<BR>"""

    pass


  def novaListaAleatoriaDistribuicaoLogNormal(self, quantidade, media, desvioPadrao) -> Lista:
    """Cria uma nova lista já preenchida com números aleatórios.<BR>
 Os números aleatórios seguem uma distribuição log-normal (isto é, em
 escala logaritmica ela tem uma distribuição normal).<BR>
 Para mais informações sobre a distribuição lognormal, consulte
 http://mathworld.wolfram.com/LogNormalDistribution.html<BR>
 Os números são gerados utilizando o método da transformação inversa (isto
 é, utilizando a função inversa da função distribuição acumulada sobre uma
 variável aleatória de distribuição uniforme).<BR>
 Assim como uma distribuição normal pode ser interpretada como uma soma de
 uma grande quantidade de variáveis aleatórias independentes, a
 distribuição log-normal pode ser interpretada como o produto de uma
 grande quantidade de variáveis aleatórias independentes.<BR>
 Tanto a distribuição Lognormal como a distribuição Pareto são
 distribuições que podem ser interpretadas como sendo o exponencial de uma
 variável aleatória X, sendo que na distribuição Pareto esta variável X
 segue a distribuição exponencial e na distribuição Lognormal ela segue a
 distribuição normal."""

    pass


  def novaListaAleatoriaDistribuicaoLogistica(self, quantidade, media, beta) -> Lista:
    """Cria uma nova lista já preenchida com números aleatórios.<BR>
 Os números aleatórios seguem uma distribuição Logística.<BR>
 Para mais informações sobre a distribuição Logística, consulte
 http://mathworld.wolfram.com/LogisticDistribution.html<BR>
 Os números são gerados utilizando o método da transformação inversa (isto
 é, utilizando a função inversa da função distribuição acumulada sobre uma
 variável aleatória de distribuição uniforme).<BR>
 A distribuição "Logística" se aparenta com a distribuição normal, mas
 possui uma curtose mais elevada.<BR>
 Ela é bastante empregada em áreas como regressão logística e redes
 neurais do tipo sem realimentação (feedforward)."""

    pass


  def novaListaAleatoriaDistribuicaoNormal(self, quantidade, media, desvioPadrao) -> Lista:
    """Cria uma nova lista já preenchida com números aleatórios.<BR>
 Os números aleatórios seguem uma distribuição normal (também chamada de
 gaussiana).<BR>
 Para mais informações sobre a distribuição normal, consulte
 http://mathworld.wolfram.com/NormalDistribution.html<BR>
 Os números são gerados utilizando o método da transformação inversa (isto
 é, utilizando a função inversa da função distribuição acumulada sobre uma
 variável aleatória de distribuição uniforme).<BR>
 Conforme o Teorema do Limite Central, após somarmos uma grande quantidade
 de variáveis aleatórias independentes, qualquer que seja a função de
 distribuição dessas variáveis, o resultado final tenderá a seguir uma
 distribuição normal."""

    pass


  def novaListaAleatoriaDistribuicaoPareto(self, quantidade, alfa, minimo) -> Lista:
    """Cria uma nova lista já preenchida com números aleatórios.<BR>
 Os números aleatórios seguem uma distribuição Pareto (tipo I).<BR>
 Para mais informações sobre a distribuição Pareto, consulte
 http://mathworld.wolfram.com/ParetoDistribution.html<BR>
 Os números são gerados utilizando o método da transformação inversa (isto
 é, utilizando a função inversa da função distribuição acumulada sobre uma
 variável aleatória de distribuição uniforme).<BR>
 A distribuição "Pareto" é também conhecida como distribuição "Bradford".<BR>
 Ela tem aplicações em diversas áreas.<BR>
 Uma de suas aplicações refere-se à distribuição de rendimentos em uma
 população, baseado na idéia que a grande parte das riquezas estão
 concentradas em uma pequena porcentagem da sociedade.<BR>
 A distribuição Pareto, quando observada em escala logaritmica, se
 assemelha a uma distribuição exponencial.<BR>
 Tanto a distribuição Pareto como a distribuição Lognormal são
 distribuições que podem ser interpretadas como sendo o exponencial de uma
 variável aleatória X, sendo que na distribuição Pareto esta variável X
 segue a distribuição exponencial e na distribuição Lognormal ela segue a
 distribuição normal."""

    pass


  def novaListaAleatoriaDistribuicaoPascal(self, quantidade, r, p) -> Lista:
    """Cria uma nova lista já preenchida com números aleatórios.<BR>
 Os números aleatórios seguem uma distribuição PASCAL.<BR>
 Para mais informações sobre a distribuição PASCAL, consulte
 http://mathworld.wolfram.com/NegativeBinomialDistribution.html<BR>
 Os números são gerados utilizando o método da transformação inversa (isto
 é, utilizando a função inversa da função distribuição acumulada sobre uma
 variável aleatória de distribuição uniforme).<BR>
 Ela também é conhecida como distribuição BINOMIAL NEGATIVA.<BR>
 Ela pode ser interpretada como sendo o número de "fracassos" que
 antecedem um determinado número de "sucessos" após diversas "tentativas",
 tendo cada tentativa uma determinada probabilidade de sucesso e mesma
 distribuição (eventos independentes).<BR>
 Caso o parâmetro r seja igual a 1, esta distribuição equivale à
 distribuição geométrica.<BR>
 Esta distribuição pode ser considerada o análogo discreto à distribuição
 contínua GAMMA."""

    pass


  def novaListaAleatoriaDistribuicaoPoisson(self, quantidade, lambda) -> Lista:
    """Cria uma nova lista já preenchida com números aleatórios.<BR>
 Os números aleatórios seguem uma distribuição de Poisson.<BR>
 Para mais informações sobre a distribuição de Poisson, consulte
 http://mathworld.wolfram.com/PoissonDistribution.html<BR>
 Os números são gerados utilizando dois tipos de algoritmos. Para valores
 pequenos de média, utiliza o processo de Poisson. Para valores grandes de
 média, utiliza o algoritmo descrito por Devroye, Luc. (1981).The Computer
 Generation of Poisson Random Variables Computing vol. 26 pp. 197-207.<BR>
 A distribuição de Poisson pode ser associada a uma distribuição binomial
 quando "n" se torna cada vez maior com "p" cada vez menor.<BR>
 Geralmente ela é utilizada quando há uma pequena probabilidade de ocorrer
 um evento, mas há uma grande quantidade de "tentativas" de ocorrência do
 evento. Geralmente é associado ao conceito de "taxa de ocorrências de um
 evento no tempo" (ex: gotas de chuva em uma pequena área)."""

    pass


  def novaListaAleatoriaDistribuicaoRayleigh(self, quantidade, sigma) -> Lista:
    """Cria uma nova lista já preenchida com números aleatórios.<BR>
 Os números aleatórios seguem uma distribuição Rayleigh.<BR>
 Para mais informações sobre a distribuição Rayleigh, consulte
 http://mathworld.wolfram.com/RayleighDistribution.html<BR>
 Os números são gerados utilizando o método da transformação inversa (isto
 é, utilizando a função inversa da função distribuição acumulada sobre uma
 variável aleatória de distribuição uniforme).<BR>
 Uma das formas de obtenção da distribuição Rayleigh ocorre quando se
 computam os valores absolutos de diversos números complexos onde as
 componentes real e imaginária desses números complexos seguem
 distribuição normal de desvio padrão sigma e média 0.<BR>
 A distribuição Chi Quadrado de parâmetro 2 corresponde à distribuição do
 quadrado de uma distribuição Rayleigh de parâmetro 1.<BR>
 A distribuição Weibull é uma generalização da distribuição Rayleigh."""

    pass


  def novaListaAleatoriaDistribuicaoStudentT(self, quantidade, r) -> Lista:
    """Cria uma nova lista já preenchida com números aleatórios.<BR>
 Os números aleatórios seguem uma distribuição T de Student.<BR>
 Para mais informações sobre a distribuição T de Student, consulte
 http://mathworld.wolfram.com/Studentst-Distribution.html<BR>
 Os números são gerados utilizando o método da transformação inversa (isto
 é, utilizando a função inversa da função distribuição acumulada sobre uma
 variável aleatória de distribuição uniforme).<BR>
 A distribuição "T" de Student (onde "Student" é o pseudônimo do autor que
 a publicou originalmente em 1908) surge naturalmente ao se determinar a
 partir de uma amostra a média de uma população que segue a distribuição
 normal."""

    pass


  def novaListaAleatoriaDistribuicaoWeibull(self, quantidade, alfa, beta) -> Lista:
    """Cria uma nova lista já preenchida com números aleatórios.<BR>
 Os números aleatórios seguem uma distribuição Weibull.<BR>
 Para mais informações sobre a distribuição Weibull, consulte
 http://mathworld.wolfram.com/WeibullDistribution.html<BR>
 Os números são gerados utilizando o método da transformação inversa (isto
 é, utilizando a função inversa da função distribuição acumulada sobre uma
 variável aleatória de distribuição uniforme).<BR>
 Quando o parâmetro "alfa" (forma) é igual a 1, esta distribuição toma a
 mesma forma que a distribuição exponencial com média "beta" (escala).<BR>
 Quando alfa é igual a 2, esta distribuição tem a mesma forma que a
 distribuição Rayleigh (neste caso o parâmetro beta se relaciona com o
 parâmetro "sigma" de Rayleigh através de uma constante 1/raiz(2)).<BR>"""

    pass


  def novaListaAleatoriaDistribuicaoZipf(self, quantidade, N, exponente) -> Lista:
    """Cria uma nova lista já preenchida com números aleatórios.<BR>
 Os números aleatórios seguem uma distribuição ZIPF.<BR>
 Para mais informações sobre a distribuição ZIPF, consulte
 http://mathworld.wolfram.com/ZipfDistribution.html<BR>
 Os números são gerados utilizando o método da transformação inversa (isto
 é, utilizando a função inversa da função distribuição acumulada sobre uma
 variável aleatória de distribuição uniforme).<BR>
 Ela também é conhecida como distribuição ZETA (a distribuição ZETA é um
 caso especial da distribuição ZIPF quando N é infinito).<BR>
 É geralmente aplicada em determinados tipos de análises linguísticas.<BR>"""

    pass


  def novaListaAleatoriaNumerosInteiros(self, quantidade, menorNumero, maiorNumero) -> Lista:
    """Cria uma nova lista já preenchida com números aleatórios.<BR>
 Os números aleatórios seguem uma distribuição contínua e uniforme (isto
 é, a probabilidade de se escolher qualquer número do intervalo é a
 mesma), porém os números são arredondados para os números inteiros mais próximos.<BR>"""

    pass


  def novaListaFuncao(self, equacao, min, max, intervalo) -> Lista:
    """Cria uma nova lista já preenchidas com valores calculados por uma
 determinada "função". Isto é, cada valor corresponde a um valor de uma
 "função" de "x".<BR>
 Por exemplo, para computar os valores "y" de uma parábola com "x"
 variando entre -10 e +10, pode-se executar:<BR>
 novaListaFuncao( "X^2", -10.0, 10.0, 1.0);<BR>"""

    pass


  def novaListaInterseccao(self, lista1, lista2) -> Lista:
    """Retorna em uma nova lista o resultado da 'intersecção' de uma lista com outra lista.<BR>
 As listas indicadas como parâmetro não são afetadas pela operação.<BR>
 A nova lista retornada é obtida a partir da intersecção das outras listas. Isto é, inclui
 apenas os elementos da primeira lista que também se encontram na segunda lista."""

    pass


  def novaListaNumerosDecimais(self, primeiroNumero, ultimoNumero, intervalo) -> Lista:
    """Cria uma nova lista já preenchida com números de um intervalo. A lista
 numérica pode ser ascendente ou descendente dependendo se o primeiro
 número é menor ou maior que o último."""

    pass


  def novaListaNumerosDecimais(self, primeiroNumero, ultimoNumero, quantidadeNumeros, tipoProgressao) -> Lista:
    """Cria uma nova lista já preenchida com números de um intervalo. A lista
 numérica pode ser ascendente ou descendente dependendo se o primeiro
 número é menor ou maior que o último. Além disso, pode-se indicar
 como os valores aumentam ou diminuem escolhendo o 'tipo de progressão',
 podendo ser uma dentre as seguir:<BR>
 ARIMETICA - Soma ou subtrai o mesmo valor a cada iteração. O valor somado ou subtraído é igual ao intervalo total dividido pela quantidade de números -1.<BR>
 GEOMETRICA - Multiplica ou divide o mesmo valor a cada iteração. O valor multiplicado ou dividido é igual ao intervalo total na escala logaritmica dividido pela quantidade de números -1.<BR>
 HARMONICA - Considera a progressão harmônica, onde os inversos dos números seguem uma progressão aritmética (ex: 1/1; 1/2; 1/3;...)."""

    pass


  def novaListaSubtracao(self, listaMinuendo, listaSubtraendo) -> Lista:
    """Retorna em uma nova lista o resultado da 'subtração' de uma lista de outra lista.<BR>
 As listas indicadas como parâmetro não são afetadas pela operação.<BR>
 A nova lista retornada é obtida a partir dos elementos da lista indicada no primeiro parâmetro (listaMinuendo),
 mas sem incluir os elementos da lista indicada no segundo parâmetro (listaSubtraendo).<BR>
 Elementos existentes na lista (listaSubtraendo) e não existentes na lista (listaMinuendo) não são considerados."""

    pass


  def novaListaUniao(self, lista1, lista2) -> Lista:
    """Retorna em uma nova lista o resultado da 'adição' de uma lista em outra lista.<BR>
 As listas indicadas como parâmetro não são afetadas pela operação.<BR>
 A nova lista retornada é obtida a partir da união das outras listas. Isto é, todos os elementos
 da primeira lista acrescido de todos os elementos da segunda lista.<BR>
 Se há elementos iguais em ambas as listas, eles permanecem na lista final em duplicidade."""

    pass


  def paraTabelaArquivos(self, arquivos, campos) -> Tabela:
    """Dada uma lista contendo nomes de arquivos ou objetos do tipo {@link Arquivo Arquivo}, retorna uma tabela com informações
 detalhadas sobre esses arquivos (cada linha correspondendo a um arquivo). As informações pretendidas devem ser indicadas no parâmetro 'campos' conforme explicado abaixo:<BR>
 DIRETORIO - indica que deve incluir na tabela uma coluna com o nome do diretório onde está o arquivo.<BR>
 NOME - indica que deve incluir na tabela uma coluna com o nome do arquivo, incluindo extensão, mas excluindo o nome do diretório.<BR>
 EXTENSAO - indica que deve incluir na tabela uma coluna com apenas a extensão do nome do arquivo, sem incluir o ponto.<BR>
 TAMANHO - indica que deve incluir na tabela uma coluna com o tamanho do arquivo em bytes.<BR>
 DATA - indica que deve incluir na tabela uma coluna com a data (sem a hora) de última modificação do arquivo.<BR>
 HORA - indica que deve incluir na tabela uma coluna com a hora (sem a data) de última modificação do arquivo.<BR>
 NOME_COMPLETO - indica que deve incluir na tabela uma coluna com o nome completo do arquivo, incluindo nome de diretório e também a extensão do nome do arquivo.<BR>"""

    pass


  def paraTexto(self, lista, separador, encapsuladorTextos) -> str:
    """Converte uma lista em um texto, separando os elementos da lista através de um caractere
 separador que é indicado no parâmetro."""

    pass


  def paraTexto(self, lista, separador) -> str:
    """Converte uma lista em um texto, separando os elementos da lista através de um caractere
 separador que é indicado no parâmetro."""

    pass

class MADLeiaute ():
  """Representa um leiaute de Modelo Analítico Dinâmico que pode ser utilizado
 para execução pelo Script.<BR>
 
 Geralmente este tipo de objeto é disponibilizado para uma linguagem de script
 quando há um <B>ANEXO</B> no script do tipo \"MAD\".<BR>
 
 Note que há também a possibilidade de executar um leiaute qualquer do MAD,
 salvo no ContÁgil, bastando indicar o nome do leiaute e o tipo da base na
 função {@link ContAgilEngine#getMAD(String, String, boolean) getMAD}. Isto
 é, não é necessário obter um objeto {@link MADLeiaute MADLeiaute} sempre que
 for desejável executar um MAD pelo script. Isso apenas se torna necessário
 quando é desejável executar um MAD cujo leiaute está dentro do próprio
 script, e não armazenado no ContÁgil junto com os demais leiautes do usuário.<BR>"""

  def compareTo(self, ref) -> int:
    pass


  def getAtributos(self) -> Tabela:
    """Retorna em uma tabela informações sobre os atributos utilizados como colunas
 de agregação neste leiaute MAD.<BR>
 A tabela retornada apresenta as seguintes colunas<BR>
 1a coluna (índice 0): nome do atributo conforme definido no catálogo de atributos<BR>
 2a coluna (índice 1): tipo do atributo (ex: TEXTO, CNPJ8, CNPJ14, etc.)<BR>
 3a coluna (índice 2): rótulo da coluna no MAD (conforme definido no catálogo de atributos ou conforme alterado pelo usuário no MAD)<BR>
 4a coluna (índice 3): nome da base de onde o atributo foi obtido.<BR>
 <BR>
 A ordem dos atributos segue a mesma ordem com que são apresentados no MAD."""

    pass


  def getAtributos(self, incluiDescricoes) -> Tabela:
    """Retorna em uma tabela informações sobre os atributos utilizados como colunas
 de agregação neste leiaute MAD.<BR>"""

    pass


  def getBasePrimaria(self) -> str:
    """Caso tenha sido definida uma 'base primária' para este MAD, retorna o nome da base MAD que foi configurada.<BR>
 Base primária é a base onde a consulta se inicia.<BR>
 Para consultas em bases locais, esta opção não faz diferença.<BR>
 Para consultas MAD sobre uma só base, esta opção não faz diferença, mesmo que a base estabeleça internamente junções com outras tabelas em um banco de dados.<BR>
 Para consultas em múltiplas bases, onde as bases são mantidas em tabelas de banco de dados, esta opção pode fazer alguma diferença. Geralmente deve indicar como 'base primária' aquela base 
 onde se inicia a pesquisa, podendo encontrar ou não correspondência em outras bases.<BR>
 Se for NULO (isto é, se a base primária não for definida), o MAD irá determinar automaticamente, utilizando para isso uma heurística sobre a estrutura utilizada na pesquisa."""

    pass


  def getBases(self) -> Lista:
    """Retorna uma lista contendo os tipos de todas as bases utilizadas neste leiaute MAD
 e também em outros leiautes MAD que são utilizados de forma aninhada a este."""

    pass


  def getCopia(self) -> MADLeiaute:
    """Retorna uma cópia do leiaute atual. Qualquer alteração posterior realizada aqui não é refletida
 no objeto original e qualquer alteração posterior realizada no objeto original não é refletida aqui."""

    pass


  def getCriarTabelaServidorNome(self) -> str:
    """Caso tenha indicado a opção para criar tabela com o resultado do MAD no servidor, indica o nome que a tabela de resultado deve assumir no servidor.<BR>
 Caso não seja fornecido um nome, utiliza o próprio nome do leiaute.<BR>
 OBS: o servidor pode modificar este nome para atender a um padrão de nomenclatura (ex: incluindo o CPF do usuário como parte do nome)."""

    pass


  def getDescricao(self) -> str:
    """Obtém a descrição/comentário que foi informada pelo usuário no momento em que o
 leiaute MAD foi salvo em disco.<BR>
 OBS: não se trata necessariamente do mesmo comentário que foi utilizado no
 momento do "compartilhamento", caso o leiaute tenha sido baixado da área de
 compartilhamento.<BR>"""

    pass


  def getFiltros(self) -> Tabela:
    """Retorna em uma tabela informações sobre os filtros utilizados neste leiaute MAD.
 A tabela retornada apresenta as seguintes colunas<BR>
 1a coluna (índice 0): nome do atributo ou métrica sobre o qual se aplica o filtro<BR>
 2a coluna (índice 1): predicado do filtro<BR>
 3a coluna (índice 2): indicador E/OU<BR>
 4a coluna (índice 3): nome da base de onde o atributo ou métrica relacionado ao filtro foi obtido.<BR>
 5a coluna (índice 4): precedência numérica do filtro em relação aos demais. Números maiores 
 tem precedência sobre os filtros de números menores a ele (isto é, a conexão 'E' ou 'OU' é considerada antes dos demais).<BR>
 6a coluna (índice 5): indica se o filtro necessita uma resposta do usuário
 <BR>
 A ordem dos filtros segue a mesma ordem com que são apresentados no MAD."""

    pass


  def getFormulas(self) -> Tabela:
    """Retorna em uma tabela informações sobre as fórmulas utilizadas neste leiaute MAD.
 A tabela retornada apresenta as seguintes colunas<BR>
 1a coluna (índice 0): nome da fórmula<BR>
 2a coluna (índice 1): tipo da fórmula (ex: MOEDA, DECIMAL, etc.)<BR>
 3a coluna (índice 2): fórmula<BR>"""

    pass


  def getLimiteLinhas(self) -> long:
    """Limite de linhas para realização da consulta, apenas se este conceito estiver implementado no MAD (ex: para consultas MAD em servidores)"""

    pass


  def getMetricas(self) -> Tabela:
    """Retorna em uma tabela informações sobre as métricas utilizadas como colunas
 neste leiaute MAD.<BR>
 A tabela retornada apresenta as seguintes colunas<BR>
 1a coluna (índice 0): nome da métrica conforme definido no catálogo de atributos<BR>
 2a coluna (índice 1): tipo da métrica (ex: MOEDA, DECIMAL, etc.)<BR>
 3a coluna (índice 2): rótulo da coluna no MAD (conforme definido no catálogo de atributos ou conforme alterado pelo usuário no MAD)<BR>
 4a coluna (índice 3): nome da base de onde a métrica foi obtida.<BR>
 5a coluna (índice 4): nome da função de agregação utilizada (ex: SOMA, MINIMO, etc.).<BR>
 <BR>
 A ordem das métricas segue a mesma ordem com que são apresentadas no MAD."""

    pass


  def getMetricas(self, incluiDescricoes) -> Tabela:
    """Retorna em uma tabela informações sobre as métricas utilizadas como colunas
 neste leiaute MAD.<BR>"""

    pass


  def getNome(self) -> str:
    """Retorna o nome deste leiaute"""

    pass


  def isAguardarConsulta(self) -> bool:
    """Indica se deve aguardar a realização da consulta no servidor. Esta opção apenas é considerada caso a consulta seja realizada no servidor (isto é, caso não seja
 um MAD executado localmente) e caso esteja criando uma tabela de resultado (isto é, caso o método {@link #setCriarTabelaServidor(boolean) setCriarTabelaServidor} também tenha sido chamado com a opção TRUE).<BR>
 O padrão é aguardar a consulta.<BR>
 Caso seja ajustado para 'não aguardar' a consulta, o script continua a execução local sem aguardar a conclusão da consulta no servidor."""

    pass


  def isAplicaLimiteAntesAgrupamento(self) -> bool:
    """Caso tenha sido indicado algum limite de linhas, indica se o limite deve ser aplicado antes do agrupamento ou depois do agrupamento."""

    pass


  def isCriarTabelaServidor(self) -> bool:
    """Criar tabela com resultado do MAD no servidor, apenas se este conceito estiver implementado no MAD (ex: para consultas MAD em servidores)"""

    pass


  def isFiltrosNasJuncoes(self) -> bool:
    """Retorna a indicação de que para este MAD os filtros configurados devem ser utilizados, quando possível,
 durante as próprias junções com outras tabelas.<BR>
 Por exemplo, digamos que o MAD se refere a duas tabelas: EFDC e CTE.<BR>
 Digamos que a tabela EFDC é a 'base primária' e digamos que existem filtros no MAD sobre a tabela de CTE (por exemplo, um filtro que compara a chave de CTE com um valor).<BR>
 Em tal hipótese, por padrão, o MAD busca dados da tabela EFDC e faz uma junção com a tabela CTE utilizando o critério 'LEFT JOIN' (isto é,
 admite que não exista correspondência na tabela de CTE).
 Se a configuração 'filtros nas junções' for FALSE (isto é, não incluir filtros nas junções), então a consulta irá desconsiderar todos os
 dados omissos de CTE, pois por padrão os filtros são inseridos na cláusula 'WHERE' da consulta SQL.<BR>
 Se a configuração 'filtros nas junções' for TRUE (isto é, deve incluir filtros nas junções), então a consulta irá admitir eventuais dados
 omissos de CTE, pois neste caso o filtro configurado sobre CTE será inserido na cláusula 'LEFT JOIN', que faz a junção da tabela EFDC com a tabela CTE.<BR>
 Esta configuração é ignorada em consultas MAD que não utilizam SQL em banco de dados, ou consultas MAD que não tenham filtros, ou consultas MAD
 que não se refiram a múltiplas bases."""

    pass


  def isIgnoraResultadoAnteriorServidor(self) -> bool:
    """Indica se deve desconsiderar algum resultado anterior de consulta igual, que tenha sido armazenado no servidor. Apenas se aplica a MAD que é executado em servidores."""

    pass


  def isJuncaoAposAgrupamento(self) -> bool:
    """Retorna a indicação de que este MAD requer que os agrupamentos dos dados em consulta a múltiplas
 tabelas ocorram antes da junção entre essas bases.<BR>
 Se retornar FALSE, os agrupamentos ocorrem após juntar as bases.<BR>
 Isso apenas afeta consultas realizadas em banco de dados."""

    pass


  def isJuncaoInternaObrigatoria(self) -> bool:
    """Retorna a indicação de que este MAD requer a presença de informação em todas as bases
 juntadas (o equivalente a um 'INNER JOIN' em SQL)."""

    pass


  def setAguardarConsulta(self, aguardarConsulta) -> None:
    """Indica se deve aguardar a realização da consulta no servidor. Esta opção apenas é considerada caso a consulta seja realizada no servidor (isto é, caso não seja
 um MAD executado localmente) e caso esteja criando uma tabela de resultado (isto é, caso o método {@link #setCriarTabelaServidor(boolean) setCriarTabelaServidor} também tenha sido chamado com a opção TRUE.<BR>
 O padrão é aguardar a consulta.<BR>
 Caso seja ajustado para 'não aguardar' a consulta, o script continua a execução local sem aguardar a conclusão da consulta no servidor."""

    pass


  def setAplicaLimiteAntesAgrupamento(self, aplicaLimiteAntesAgrupamento) -> None:
    """Caso tenha sido indicado algum limite de linhas, indica se o limite deve ser aplicado antes do agrupamento ou depois do agrupamento."""

    pass


  def setCriarTabelaServidor(self, criarTabelaServidor) -> None:
    """Criar tabela com resultado do MAD no servidor, apenas se este conceito estiver implementado no MAD (ex: para consultas MAD em servidores)"""

    pass


  def setCriarTabelaServidorNome(self, criarTabelaServidorNome) -> None:
    """Caso tenha indicado a opção para criar tabela com o resultado do MAD no servidor, indica o nome que a tabela de resultado deve assumir no servidor.<BR>
 Caso não seja fornecido um nome, utiliza o próprio nome do leiaute.<BR>
 OBS: o servidor pode modificar este nome para atender a um padrão de nomenclatura (ex: incluindo o CPF do usuário como parte do nome)."""

    pass


  def setIgnoraResultadoAnteriorServidor(self, ignoraResultadoAnteriorServidor) -> None:
    """Indica se deve desconsiderar algum resultado anterior de consulta igual, que tenha sido armazenado no servidor. Apenas se aplica a MAD que é executado em servidores."""

    pass


  def setLimiteLinhas(self, limiteLinhas) -> None:
    """Limite de linhas para realização da consulta, apenas se este conceito estiver implementado no MAD (ex: para consultas MAD em servidores)"""

    pass


  def toLeiauteEditavel(self) -> MADLeiauteEditavel:
    """Obtém um novo leiaute editável a partir deste leiaute. As alterações realizadas no objeto retornado
 não afetam este leiaute."""

    pass


  def toString(self) -> str:
    pass


  def trocaMADAninhado(self, nomeAnterior, novoNome) -> bool:
    """Altera o leiaute MAD construído de modo a substituir todas as referências
 a atributos ou métricas de um "MAD aninhado" (um outro leiaute MAD que é utilizado pelo atual)
 para outro "MAD aninhado" (isto é, substitui o nome do "leiaute MAD" que é utilizado no
 leiaute MAD atual sem alterar os nomes dos atributos e métricas).<BR>
 Este método é útil quando se migra um 'MAD aninhado' de um lugar para outro e se deseja
 alterar os nomes dos demais MAD's que são referenciados por ele.<BR>
 A alteração é realizada sobre as colunas do relatório (atributos e
 métricas), sobre os filtros, sobre critérios de junção e também sobre as
 fórmulas (isto é, em qualquer parte que possa conter referência ao MAD
 aninhado que se pretende substituir).<BR>
 Caso o mesmo leiaute faça referência a outros MADs aninhados, com
 outros nomes, essas outras referências permanecem inalteradas.<BR>
 <BR>
 EXEMPLO:<BR>
 =====================================<BR>
 Digamos que o script possui como anexos os relatórios MAD chamados "DADOS_A", "DADOS_B", "DADOS_A_NOVO" e "DADOS_B_NOVO".<BR>
 Digamos que o script possui também como anexo o relatório MAD chamado "AGREGADOR", que utiliza
 como base o resultado dos MADs "DADOS_A" e "DADOS_B" (isto é, "DADOS_A" e "DADOS_B" estão 'aninhados'
 a "AGREGADOR").<BR>
 Vamos supor que o MAD "DADOS_A" possui exatamente a mesma estrutura de colunas que "DADOS_A_NOVO", e que "DADOS_B" possui
 a mesma estrutura de colunas que "DADOS_B_NOVO", e digamos que queremos alterar o MAD "AGREGADOR" de modo que ele passe a referenciar
 o MAD "DADOS_A_NOVO" no lugar de "DADOS_A" e o MAD "DADOS_B_NOVO" no lugar de "DADOS_B".<BR>
 Pode-se fazer isso utilizando esta função sobre o leiaute "AGREGADOR". Uma vez para trocar o nome "DADOS_A" para "DADOS_A_NOVO" e
 outra vez para trocar o nome "DADOS_B" para "DADOS_B_NOVO".<BR>
 <BR>
 Depois da execução deste método, este objeto representando o leiaute MAD é
 alterado. Qualquer outra alteração de nome realizada posteriormente a esta
 irá considerar as alterações previamente já realizadas sobre este objeto.<BR>
 Caso queira preservar o objeto atual antes da troca de nomes, faça uma cópia
 antes utilizado o método 'getCopia'.<BR>"""

    pass


  def trocaTabelaUsuario(self, nomeAnterior, novoNome) -> bool:
    """Altera o leiaute MAD construído de modo a substituir todas as referências
 a atributos ou métricas de uma "tabela do usuário" para outra "tabela do
 usuário" (isto é, substitui o nome da "tabela do usuário" utilizada no
 leiaute MAD sem alterar os nomes dos atributos e métricas).<BR>
 Este método não se aplica a leiaute MAD construído sobre outros tipos de
 bases (isto é, sobre bases que não são do tipo "tabela do usuário").<BR>
 Este método é útil quando há duas ou mais tabelas do usuário, com dados
 distintos, mas com a mesma "estrutura" de colunas (ou com "estrutura"
 compatível com o relatório MAD).<BR>
 A alteração é realizada sobre as colunas do relatório (atributos e
 métricas), sobre os filtros, sobre critérios de junção e também sobre as
 fórmulas (isto é, em qualquer parte que possa conter referência à tabela
 do usuário que se pretende substituir).<BR>
 Caso o mesmo leiaute faça referência a outras tabelas de usuários, com
 outros nomes, essas outras referências permanecem inalteradas.<BR>
 <BR>
 ATENÇÃO: caso este leiaute MAD faça uso de outros MAD's aninhados, esses
 MAD's aninhados não são afetados pela troca do nome. Se você desejar trocar
 os nomes das tabelas também nesses MAD's aninhados, utilize o método alternativo
 com três parâmetros, indicando 'TRUE' no terceiro parâmetro.<BR>
 <BR>
 Depois da execução deste método, este objeto representando o leiaute MAD é
 alterado. Qualquer outra alteração de nome realizada posteriormente a esta
 irá considerar as alterações previamente já realizadas sobre este objeto.<BR>
 Caso queira preservar o objeto atual antes da troca de nomes, faça uma cópia
 antes utilizado o método 'getCopia'.<BR>"""

    pass


  def trocaTabelaUsuario(self, nomeAnterior, novoNome, propagaMudancas) -> bool:
    """Método alternativo que faz a substituição das referências a nomes de tabelas
 do usuário, porém inclui um parâmetro adicional através do qual pode-se indicar
 se deseja ou não propagar as mudanças de nomes também para os MAD's aninhados a este.<BR>
 Note que, caso se opte por propagar as mudanças, elas ocorrem apenas sobre os nomes
 de tabelas de usuário referenciadas pelos MAD's, sem afetar os nomes dos próprios MAD's.<BR>
 A alteração ocorre somente durante a execução deste MAD. Não afeta outras execuções realizadas
 diretamente sobre os MAD's aninhados.<BR>
 <BR>
 Depois da execução deste método, este objeto representando o leiaute MAD é
 alterado. Qualquer outra alteração de nome realizada posteriormente a esta
 irá considerar as alterações previamente já realizadas sobre este objeto.<BR>
 Caso queira preservar o objeto atual antes da troca de nomes, faça uma cópia
 antes utilizado o método 'getCopia'.<BR>"""

    pass

class MADLeiauteEditavel ():
  """Define um leiaute MAD que pode ser criado e editado em um script."""

  def addAtributo(self, nomeAtributo) -> None:
    """Adiciona ao final da relação de atributos utilizados como colunas do relatório MAD (critérios de agregação)
 um atributo do catálogo de atributos da base consultada."""

    pass


  def addAtributoCalculado(self, nome, formula, incluiColuna) -> None:
    """Adiciona ao leiaute uma fórmula que pode ser utilizada como se fosse um atributo calculado."""

    pass


  def addAtributoCalculado(self, nome, formula, incluiColuna, formato) -> None:
    """Adiciona ao leiaute uma fórmula que pode ser utilizada como se fosse um atributo calculado. Indica também o formato deste atributo (isto é,
 se é TEXTO, ou NUMERO, ou DATA, etc.), o que é importante para possibilitar o correto uso de 'filtros' com este atributo calculado."""

    pass


  def addCriterioJuncao(self, atributo1, atributo2, atributo3, atributo4) -> None:
    """Adiciona um critério de junção entre quatro bases utilizadas neste leiaute MAD.<BR>
 Os demais critérios de junção anteriormente adicionados são preservados.<BR>
 O nome de cada atributo deve estar completamente qualificado, incluindo o nome da correspondente base, assim como é apresentado no catálogo de atributos do MAD Completo."""

    pass


  def addCriterioJuncao(self, atributos) -> None:
    """Adiciona um critério de junção entre duas ou mais bases utilizadas neste leiaute MAD.<BR>
 Os demais critérios de junção anteriormente adicionados são preservados.<BR>
 O nome de cada atributo deve estar completamente qualificado, incluindo o nome da correspondente base, assim como é apresentado no catálogo de atributos do MAD Completo."""

    pass


  def addCriterioJuncao(self, atributo1, atributo2) -> None:
    """Adiciona um critério de junção entre duas bases utilizadas neste leiaute MAD.<BR>
 Os demais critérios de junção anteriormente adicionados são preservados.<BR>
 O nome de cada atributo deve estar completamente qualificado, incluindo o nome da correspondente base, assim como é apresentado no catálogo de atributos do MAD Completo."""

    pass


  def addCriterioJuncao(self, atributo1, atributo2, atributo3) -> None:
    """Adiciona um critério de junção entre três bases utilizadas neste leiaute MAD.<BR>
 Os demais critérios de junção anteriormente adicionados são preservados.<BR>
 O nome de cada atributo deve estar completamente qualificado, incluindo o nome da correspondente base, assim como é apresentado no catálogo de atributos do MAD Completo."""

    pass


  def addFiltroAtributo(self, nomeAtributo, criterio, argumento) -> None:
    """Adiciona um filtro ao relatório utilizando um atributo do catálogo de atributos da base consultada e um critério de filtragem sobre ele.<BR>
 Caso existam outros critérios de filtragem, o novo filtro é adicionado com o conectivo 'E' (isto é, um critério cumulativo aos demais).<BR>
 O critério de filtragem é informado no segundo parâmetro.<BR>
 ATENÇÃO: nem todos os atributos aceitam todos os critérios de filtragem. Dependendo do tipo de atributo (se é texto, data ou número), alguns 
 critérios de filtragem são aplicáveis e outros não. Por exemplo, atributos do tipo DATA não aceitam o critério de filtragem 'CONTÉM'."""

    pass


  def addFiltroAtributoTabela(self, nomeAtributo, criterio, nomesTabelas, coluna) -> None:
    """Adiciona ao relatório um filtro do tipo TABELA"""

    pass


  def addFiltroMetrica(self, nomeMetrica, funcaoMetrica, menorValor, maiorValor) -> None:
    """Adiciona um filtro ao relatório utilizando uma métrica do catálogo de métricas da base consultada e um critério de filtragem sobre ela.<BR>
 A filtragem é geralmente aplicada após a consolidação dos valores da métrica. Por exemplo, se 'funcaoMetrica' é igual a 'SOMA', primeiro
 são somados os valores e depois é aplicado o filtro sobre o resultado da soma conforme os critérios de agregação.<BR>
 Caso queira filtrar pelos valores das métricas antes da consolidação, indique em 'funcaoMetrica' a função 'VALOR INDIVIDUAL'.<BR>
 Caso existam outros critérios de filtragem, o novo filtro é adicionado com o conectivo 'E' (isto é, um critério cumulativo aos demais)."""

    pass


  def addMetrica(self, nomeMetrica, funcao) -> None:
    """Adiciona ao final da relação de métricas utilizados como colunas do relatório MAD (valores consolidados)
 uma métrica do catálogo de métricas da base consultada."""

    pass


  def addMetricaCalculada(self, nome, formula, incluiColuna) -> None:
    """Adiciona ao leiaute uma fórmula que pode ser utilizada como se fosse uma métrica calculada."""

    pass


  def getAtributo(self, posicao) -> str:
    """Retorna o nome do atributo que foi incluído na coluna indicada pela posição"""

    pass


  def getNomesAtributosNoCatalogo(self) -> list:
    """Retorna os nomes de todos os atributos que estão disponíveis no catálogo de atributos
 associado ao contexto MAD que pode ser utilizado por este leiaute."""

    pass


  def getNomesMetricasNoCatalogo(self) -> list:
    """Retorna os nomes de todas as métricas que estão disponíveis no catálogo de métricas
 associado ao contexto MAD que pode ser utilizado por este leiaute."""

    pass


  def getPosicaoAtributo(self, nomeAtributo) -> int:
    """Retorna a posição do atributo inserido como coluna no relatório MAD. Caso o atributo
 não tenha sido inserido ainda como coluna do relatório,  retorna -1.<BR>
 OBS: o número 0 representa 'primeira coluna', e assim sucessivamente."""

    pass


  def removeAtributo(self, nomeAtributo) -> None:
    """Remove da relação de atributos utilizados como critérios de agregação do relatório MAD o atributo indicado no parâmetro."""

    pass


  def removeAtributoCalculado(self, nome) -> None:
    """Remove do leiaute um atributo calculado identificado pelo nome indicado."""

    pass


  def removeAtributos(self) -> None:
    """Remove todos os atributos do leiaute MAD"""

    pass


  def removeAtributosCalculados(self) -> None:
    pass


  def removeCriteriosJuncao(self) -> None:
    """Remove todos os critérios de junção previamente informados neste leiaute."""

    pass


  def removeFiltros(self) -> None:
    """Remove todos os filtros já incluídos no leiaute MAD"""

    pass


  def removeMetrica(self, nomeMetrica) -> None:
    """Remove da relação de métricas utilizadas como colunas de consolidação de valores do relatório MAD a métrica indicada no parâmetro. Se a mesma
 métrica é utilizada mais de uma vez com diferentes funções de consolidação, todas elas são removidas do leiaute. Caso o nome da métrica indicado
 como parâmetro indique também o nome da função utilizada na consolidação (ex: 'SOMA'), apenas esta ocorrência da métrica é removida do relatório MAD."""

    pass


  def removeMetricaCalculada(self, nome) -> None:
    """Remove do leiaute uma métrica calculada identificado pelo nome indicado."""

    pass


  def removeMetricas(self) -> None:
    """Remove todas as métricas do leiaute MAD"""

    pass


  def removeMetricasCalculadas(self) -> None:
    pass


  def setAtributo(self, posicao, nomeAtributo) -> None:
    """Substitui um atributo utilizado como critério de agregação do relatório MAD por outro existente
 no catálogo de atributos da base consultada."""

    pass


  def setBasePrimaria(self, basePrimaria) -> None:
    """Define uma 'base primária' para este MAD, que deve corresponder ao nome da base MAD, podendo escolher qualquer uma dentre aquelas que estão sendo utilizadas na pesquisa.<BR>
 Base primária é a base onde a consulta se inicia.<BR>
 Para consultas em bases locais, esta opção não faz diferença.<BR>
 Para consultas MAD sobre uma só base, esta opção não faz diferença, mesmo que a base estabeleça internamente junções com outras tabelas em um banco de dados.<BR>
 Para consultas em múltiplas bases, onde as bases são mantidas em tabelas de banco de dados, esta opção pode fazer alguma diferença. Geralmente deve indicar como 'base primária' aquela base 
 onde se inicia a pesquisa, podendo encontrar ou não correspondência em outras bases.<BR>
 Se for NULO (isto é, se a base primária não for definida), o MAD irá determinar automaticamente, utilizando para isso uma heurística sobre a estrutura utilizada na pesquisa.<BR>
 Se for indicado um nome incorreto (isto é, um nome diferente das bases que são utilizadas), esta configuração fica sem efeito.<BR>
 Para saber quais nomes de bases estão presentes no leiaute MAD, utilize o método {@link MADLeiaute#getBases() getBases}."""

    pass


  def setCriterioEscolhaValores(self, nomeAtributo, criterioEscolha, tratamentoDemaisMetricas) -> None:
    """Inclui uma configuração no relatório sobre um atributo que foi incluído como coluna
 (atributo para agregação) com o objetivo de restringir o resultado a um único valor,
 dentre os vários valores que o atributo pode assumir, preservados os valores dos
 demais atributos que estão posicionados nas colunas à esquerda dele no relatório.<BR>
 Por exemplo, digamos que um relatório apresenta as seguintes colunas:<BR>
 ANO      CPF         NOME      VALOR<BR>
 Digamos que ANO, CPF e NOME são três atributos, utilizados para agregação dos resultados, e
 VALOR seja uma métrica que está sendo somada.<BR>
 Considere a possibilidade deste relatório indicar nomes diferentes associados a um mesmo CPF.<BR>
 Sem configurações adicionais, esses diferentes nomes seriam apresentados no resultado do MAD
 como linhas diferentes.<BR>
 Alternativamente, utilizando este método, podemos configurar o atributo 'NOME' de modo a escolher
 apenas o 'primeiro', ou o 'último', ou o 'menor', ou o 'maior', dentre todos os nomes que se apresentam
 a um mesmo CPF e ANO.<BR>
 Existem alguns parâmetros de configuração:<BR>
 <BR>
 Critério de Escolha<BR>
 ===================<BR>
 Esta configuração indica como escolher um dentre vários valores que o ATRIBUTO pode assumir.<BR>
 PRIMEIRO: irá apresentar apenas o primeiro valor assumido pelo atributo, dada a ordem crescente desses valores (ex: o primeiro nome)<BR>
 ÚLTIMO: irá apresentar apenas o último valor assumido pelo atributo, dada a ordem crescente desses valores (ex: o último nome)<BR>
 MENOR: irá apresentar apenas o valor cuja quantidade de caracteres seja a menor (ou seja, o texto mais curto).<BR>
 MAIOR: irá apresentar apenas o valor cuja quantidade de caracteres seja a maior (ou seja, o texto mais longo).<BR>
 <BR>
 Tratamento às Demais Métricas<BR>
 =============================<BR>
 Esta configuração indica o que fazer com os valores das MÉTRICAS caso venha a reduzir a quantidade de linhas do relatório.<BR>
 CONSOLIDA: caso venha a reduzir a quantidade de linhas do relatório, indica que deve considerar todos os valores de métricas das linhas que foram
 suprimidas (ex: se estiver 'somando', deve somar todos eles).<BR>
 IGNORA: caso venha a reduzir a quantidade de linhas do relatório, indica que deve desprezar os valores que se associam com as linhas suprimidas."""

    pass


  def setDescricao(self, descricao) -> None:
    """Atribui uma descrição a este leiaute MAD"""

    pass


  def setFiltroAtributo(self, posicao, nomeAtributo, criterio, argumento) -> None:
    """Altera um filtro do relatório utilizando um atributo do catálogo de atributos da base consultada e um critério de filtragem sobre ele.<BR>
 Caso existam outros critérios de filtragem, o novo filtro é adicionado com o conectivo 'E' (isto é, um critério cumulativo aos demais).<BR>
 O critério de filtragem é informado no segundo parâmetro.<BR>
 ATENÇÃO: nem todos os atributos aceitam todos os critérios de filtragem. Dependendo do tipo de atributo (se é texto, data ou número), alguns 
 critérios de filtragem são aplicáveis e outros não. Por exemplo, atributos do tipo DATA não aceitam o critério de filtragem 'CONTÉM'."""

    pass


  def setFiltroMetrica(self, posicao, nomeMetrica, funcaoMetrica, menorValor, maiorValor) -> None:
    """Altera um filtro do relatório utilizando uma métrica do catálogo de métricas da base consultada e um critério de filtragem sobre ela.<BR>
 A filtragem é geralmente aplicada após a consolidação dos valores da métrica. Por exemplo, se 'funcaoMetrica' é igual a 'SOMA', primeiro
 são somados os valores e depois é aplicado o filtro sobre o resultado da soma conforme os critérios de agregação.<BR>
 Caso queira filtrar pelos valores das métricas antes da consolidação, indique em 'funcaoMetrica' a função 'VALOR INDIVIDUAL'.<BR>
 Caso existam outros critérios de filtragem, o novo filtro é adicionado com o conectivo 'E' (isto é, um critério cumulativo aos demais)."""

    pass


  def setFiltrosNasJuncoes(self, filtrosNasJuncoes) -> None:
    """Retorna a indicação de que para este MAD os filtros configurados devem ser utilizados, quando possível,
 durante as próprias junções com outras tabelas.<BR>
 Por exemplo, digamos que o MAD se refere a duas tabelas: EFDC e CTE.<BR>
 Digamos que a tabela EFDC é a 'base primária' e digamos que existem filtros no MAD sobre a tabela de CTE (por exemplo, um filtro que compara a chave de CTE com um valor).<BR>
 Em tal hipótese, por padrão, o MAD busca dados da tabela EFDC e faz uma junção com a tabela CTE utilizando o critério 'LEFT JOIN' (isto é,
 admite que não exista correspondência na tabela de CTE).
 Se a configuração 'filtros nas junções' for FALSE (isto é, não incluir filtros nas junções), então a consulta irá desconsiderar todos os
 dados omissos de CTE, pois por padrão os filtros são inseridos na cláusula 'WHERE' da consulta SQL.<BR>
 Se a configuração 'filtros nas junções' for TRUE (isto é, deve incluir filtros nas junções), então a consulta irá admitir eventuais dados
 omissos de CTE, pois neste caso o filtro configurado sobre CTE será inserido na cláusula 'LEFT JOIN', que faz a junção da tabela EFDC com a tabela CTE.<BR>
 Esta configuração é ignorada em consultas MAD que não utilizam SQL em banco de dados, ou consultas MAD que não tenham filtros, ou consultas MAD
 que não se refiram a múltiplas bases."""

    pass


  def setJuncaoAposAgrupamento(self, juncaoApos) -> None:
    """Altera a indicação de que este MAD requer que os agrupamentos dos dados em consulta a múltiplas
 tabelas ocorram antes da junção entre essas bases.<BR>
 Se indicar FALSE, os agrupamentos ocorrem após juntar as bases.<BR>
 Isso apenas afeta consultas realizadas em banco de dados."""

    pass


  def setJuncaoInternaObrigatoria(self, innerJoin) -> None:
    """Altera a indicação de que este MAD requer a presença de informação em todas as bases
 juntadas (o equivalente a um 'INNER JOIN' em SQL)."""

    pass


  def setMetrica(self, posicao, nomeMetrica, funcao) -> None:
    """Substitui uma métrica utilizada para consolidação de valores no relatório MAD por outra métrica existente
 no catálogo de atributos da base consultada ou por outra função de consolidação da mesma métrica utilizada."""

    pass


  def setNome(self, nome) -> None:
    """Altera o nome deste leiaute"""

    pass


  def setTitulo(self, posicao, titulo) -> None:
    """Altera o título de uma coluna do leiaute MAD. Este texto sobrescreve
 o nome original do atributo ou métrica que ocupa esta posição no leiaute MAD."""

    pass

class MV2 ():
  """Classe que faz a comunicação com o MV2 via web, também chamado de plataforma baixa e ambiente migrado"""

  def autentica(self) -> None:
    """Autentica utilizando certificado"""

    pass


  def desconecta(self) -> None:
    """Termina a conexão com o servidor"""

    pass


  def envia(self) -> bool:
    """Envia o formulário/tela para o servidor e retorna indicador de transmissão com sucesso.<BR>
 Infelizmente costuma ocorrer problema na comunicação com certa frequência, por isso o script deve monitorar
 o sucesso da transmissão, tomando as atitudes necessárias para dar o prosseguimento, sendo que a retransmissão
 do formulário pode não funcionar como esperado."""

    pass


  def envia(self, formulario) -> bool:
    """Envia o formulário/tela para o servidor e retorna indicador de transmissão com sucesso.<BR>
 Infelizmente costuma ocorrer problema na comunicação com certa frequência, por isso o script deve monitorar
 o sucesso da transmissão, tomando as atitudes necessárias para dar o prosseguimento, sendo que a retransmissão
 do formulário pode não funcionar como esperado."""

    pass


  def enviaACAO(self, acao) -> bool:
    """Junção das ações {@link MV2#setACAO(String) setACAO} e {@link MV2#envia() envia}.<BR>
 Para mais informações, consulte a documentação desses outros dois métodos."""

    pass


  def enviaCHOICE(self, choice) -> bool:
    """Junção das ações {@link MV2#setCHOICE(String) setCHOICE} e {@link MV2#envia() envia}.<BR>
 Para mais informações, consulte a documentação desses outros dois métodos."""

    pass


  def enviaESCOLHA(self, escolha) -> bool:
    """Junção das ações {@link MV2#setESCOLHA(String) setESCOLHA} e {@link MV2#envia() envia}.<BR>
 Para mais informações, consulte a documentação desses outros dois métodos."""

    pass


  def enviaFormularioComCampo(self, campo) -> bool:
    """Envia o formulário/tela para o servidor e retorna indicador de transmissão com sucesso.<BR>
 Infelizmente costuma ocorrer problema na comunicação com certa frequência, por isso o script deve monitorar
 o sucesso da transmissão, tomando as atitudes necessárias para dar o prosseguimento, sendo que a retransmissão
 do formulário pode não funcionar como esperado.<BR>
 <BR>
 Diferentemente da ação {@link MV2#envia() envia}, esta ação primeiro procura na página atual pelo formulário
 que contém o campo cujo nome é indicado no parâmetro.<BR>"""

    pass


  def executaJavaScript(self, comando) -> Object:
    """Executa um comando javascript na página.<BR>
 ATENÇÃO: esta ação apenas está disponível durante o uso do 'espaço interativo'. Não a utilize diretamente via script!!!"""

    pass


  def exportaConteudoBinario(self, nomeArquivo) -> bool:
    """Caso a última requisição ao servidor tenha retornado algum conteúdo em
 formato binário (ex: conteúdo de um arquivo PDF), permite salvar este
 conteúdo em um arquivo local."""

    pass


  def getCampo(self, nome) -> str:
    """Obtém a informação de um campo da tela atual, inclusive relativo à informações retornadas.  Deve-se utilizar o nome de campo interno.  Pode-se utilizar o método
 getCampos() para se conhecer os campos disponíveis e respectivos conteúdos."""

    pass


  def getCampoRepetido(self, nome, indice) -> str:
    """Obtém a informação de um campo repetido da tela atual.  Funciona como o método getCampo, mas permite que se indique o índice de repetição do campo, que normalmente
 relacionado com a ordem das linhas na tela."""

    pass


  def getCampos(self) -> Tabela:
    """Retorna uma tabela contendo os campos da tela atual, que inclui os campos editáveis e e também as informações da tela já separadas.  Útil para verificar 
 o nome dos campos que devem ser preenchidos como para se obter as informações da tela."""

    pass


  def getCodigoTela(self) -> str:
    """Obtém o código que identifica a tela atual."""

    pass


  def getFormularioComCampo(self, campo) -> WebFormulario:
    """Retorna um objeto que representa um formulário na página atual do MV2."""

    pass


  def getFormularioComNome(self, nome) -> WebFormulario:
    """Retorna um objeto que representa um formulário na página atual do MV2."""

    pass


  def getPaginaHTML(self) -> str:
    """Obtém o contéudo HTML da página atual"""

    pass


  def getTamanhoConteudoBinario(self) -> int:
    """Caso a última requisição ao servidor tenha retornado algum conteúdo em
 formato binário (ex: conteúdo de um arquivo PDF), retorna o tamanho em
 bytes deste conteúdo."""

    pass


  def getTempoMaximoEspera(self) -> int:
    """Obtém o tempo máximo de espera (timeout) que o ContÁgil irá aguardar
 para que o servidor retorne alguma informação."""

    pass


  def hasCampo(self, nome) -> bool:
    """Verifica se a página atual possui um campo com um determinado nome."""

    pass


  def hasConteudoBinario(self) -> bool:
    """Retorna a indicação de que a última requisição ao servidor retornou algum
 conteúdo no formato binário (ex: conteúdo de um arquivo PDF)."""

    pass


  def isTratarErroComunicacao(self) -> bool:
    """Obtém indicação se os erros na comunicação serão tratados no momento de enviar o formulário ou
 se serão propagados.  Quando for verdadeiro, o método envia() retorna um indicador de sucesso ou erro."""

    pass


  def setACAO(self, acao) -> None:
    """Define o valor para o campo AÇÃO, que fica na parte superior da janela quando já se está na aplicação. Não funciona para telas de menu iniciais."""

    pass


  def setCHOICE(self, choice) -> None:
    """Define a opção para o campo CHOICE, existente nas telas de menu iniciais"""

    pass


  def setCampo(self, nome, valor) -> None:
    """Define o valor de um campo do formulário"""

    pass


  def setCampoRepetido(self, nome, indice, valor) -> None:
    """Define o valor de um campo repetido do formulário.  Usado em telas que repetem os campos em várias linhas, como para selecionar os registros desejados."""

    pass


  def setESCOLHA(self, escolha) -> None:
    """Define o valor para o campo ESCOLHA, que fica na parte inferior da janela quando já se está na aplicação.  Não funciona para telas de menu iniciais, 
 em que deve-se utilizar setCHOICE."""

    pass


  def setOpcaoUserCodeLogin(self, code) -> None:
    pass


  def setTempoMaximoEspera(self, esperaEmSegundos) -> None:
    """Define o tempo máximo de espera (timeout) que o ContÁgil irá aguardar 
 para que o servidor retorne alguma informação.  O valor padrão é 15 segundos."""

    pass


  def setTratarErroComunicacao(self, tratarErroComunicacao) -> None:
    """Define se os erros na comunicação serão tratados no momento de enviar o formulário ou
 se serão propagados.  Quando for verdadeiro, o método envia() retorna um indicador de sucesso ou erro."""

    pass

class Mail ():
  """Objeto que pode ser utilizado por uma linguagem de script para fazer
 operações de transferências de e-mails com um servidor SMTP (para envio) 
 ou um servidor IMAP (para recepção).<BR>
 <BR>
 Este objeto está acessível para a linguagem de script através do nome "mail".<BR>
 <BR>
 Exemplo de utilização:<BR>
 <BR>
 Digamos que o usuário possua uma conta de e-mail no serviço "GMAIL" do Google.<BR>
 Vamos supor que a conta do usuário é "minha.conta@gmail.com".<BR>
 Os endereços dos servidores utilizados para envio e para recepção de mensagens no GMAIL
 são, respectivamente:<BR>
 smtp.gmail.com<BR>
 imap.gmail.com<BR>
 <BR>
 Além disso, o serviço "GMAIL" requer a utilização de porta segura (SSL).<BR>
 <BR>
 De posse dessas informações, pode-se enviar ou receber e-mails através das seguintes linhas
 de código:<BR>
 <CODE>
 // Obtém login e senha da conta do usuário no GMAIL<BR>
 chave = chaves.getChaveImportacao("GMail","")<BR>
 <BR>
 // Autentica-se através de porta segura SSL nos servidores de e-mail<BR>
 mail.autentica("smtp.gmail.com", "imap.gmail.com", chave, true)<BR>
 <BR>
 // Envia um e-mail simples<BR>
 mail.enviaMensagem("Titulo", "Essa é uma mensagem de teste", "minha.conta@gmail.com", "Meu Nome", "destinatario@algum.lugar.com", "Destinatário")<BR>
 <BR>
 // Verifica os e-mails não lidos<BR>
 mensagens = mail.getMensagensNaoLidas()<BR>
 for each (mensagem in mensagens.toArray())<BR>
 {<BR>
 &nbsp;&nbsp;&nbsp;println("Mensagem: "+mensagem.getAssunto() )<BR>
 }<BR>
 </CODE>"""

  def autentica(self, urlSMTP, urlIMAP, chave, ssl, porta) -> None:
    """Autentica o usuário em um servidor SMTP (para envio de mensagens) e/ou em um servidor IMAP (para recepção de mensagens)."""

    pass


  def autentica(self, urlSMTP, urlIMAP, chave, ssl) -> None:
    """Autentica o usuário em um servidor SMTP (para envio de mensagens) e/ou em um servidor IMAP (para recepção de mensagens)."""

    pass


  def autentica(self, urlSMTP) -> None:
    """Autentica anonimamente em um servidor SMTP (isto é, sem uma conta de usuário e apenas para envio de mensagens, não para recepção)."""

    pass


  def autentica(self, urlSMTP, chave) -> None:
    """Autentica o usuário em um servidor SMTP (isto é, apenas para envio de mensagens, não para recepção)."""

    pass


  def autentica(self, urlSMTP, urlIMAP, chave) -> None:
    """Autentica o usuário em um servidor SMTP (para envio de mensagens) e/ou em um servidor IMAP (para recepção de mensagens).<BR>
 OBS: caso o servidor necessite de conexão segura (SSL), utilize o método alternativo de autenticação onde se define o parâmetro "ssl".<BR>"""

    pass


  def autentica(self, urlSMTP, porta) -> None:
    """Autentica anonimamente em um servidor SMTP (isto é, sem uma conta de usuário e apenas para envio de mensagens, não para recepção)."""

    pass


  def desconecta(self) -> None:
    """Caso esteja com uma conexão ativa no servidor de mensagem, desconecta. Caso
 contrário, não faz nada."""

    pass


  def enviaMensagem(self, assunto, mensagem, emailRemetente, nomeRemetente, emailsDestinatarios) -> None:
    """Envia uma mensagem de e-mail utilizando um servidor de SMTP previamente configurado através do método
 {@link Mail#autentica(String, Chave) autentica} ou uma de suas alternativas.<BR>
 Este método permite enviar uma mesma mensagem para múltiplos destinatários."""

    pass


  def enviaMensagem(self, assunto, mensagem, emailRemetente, nomeRemetente, emailDestinatario, nomeDestinatario, tipoConteudo) -> None:
    """Envia uma mensagem de e-mail utilizando um servidor de SMTP previamente configurado através do método
 {@link Mail#autentica(String, Chave) autentica} ou uma de suas alternativas.<BR>
 Este método envia uma mensagem para um único destinatário."""

    pass


  def enviaMensagem(self, assunto, mensagem, emailRemetente, nomeRemetente, emailsDestinatarios, tipoConteudo) -> None:
    """Envia uma mensagem de e-mail utilizando um servidor de SMTP previamente configurado através do método
 {@link Mail#autentica(String, Chave) autentica} ou uma de suas alternativas.<BR>
 Este método permite enviar uma mesma mensagem para múltiplos destinatários."""

    pass


  def enviaMensagemComAnexos(self, assunto, mensagem, emailRemetente, nomeRemetente, emailDestinatario, nomeDestinatario, tipoConteudo, arquivos) -> None:
    """Envia uma mensagem de e-mail utilizando um servidor de SMTP previamente configurado através do método
 {@link Mail#autentica(String, Chave) autentica} ou uma de suas alternativas.<BR>
 Este método permite enviar mensagem com anexos."""

    pass


  def enviaMensagemComAnexos(self, assunto, mensagem, emailRemetente, nomeRemetente, emailsDestinatarios, tipoConteudo, arquivos) -> None:
    """Envia uma mensagem de e-mail utilizando um servidor de SMTP previamente configurado através do método
 {@link Mail#autentica(String, Chave) autentica} ou uma de suas alternativas.<BR>
 Este método permite enviar mensagem com anexos.<BR>
 Este método permite enviar a mesma mensagem para múltiplos destinatários."""

    pass


  def getMensagens(self, pasta) -> list:
    """Retorna a relação de todas as mensagens armazenadas em uma determinada pasta associada à caixa de mensagens do usuário.<BR>
 OBS: é necessário que o servidor tenha sido previamente definido através do método {@link Mail#autentica(String, String, Chave) autentica}.<BR>
 Este método retorna todas as mensagens, inclusive as mensagens que já foram lidas."""

    pass


  def getMensagensNaoLidas(self) -> list:
    """Retorna a relação de mensagens não lidas que estão disponíveis na caixa de entrada.<BR>
 OBS: é necessário que o servidor tenha sido previamente definido através do método {@link Mail#autentica(String, String, Chave) autentica}.<BR>"""

    pass


  def getQtdMensagensNaoLidas(self) -> int:
    """Retorna a quantidade de mensagens não lidas que estão disponíveis na caixa de entrada.<BR>
 OBS: é necessário que o servidor tenha sido previamente definido através do método {@link Mail#autentica(String, String, Chave) autentica}."""

    pass

class MailMensagem ():
  """Objeto que pode ser utilizado por uma linguagem de script
 para o propósito de representar uma mensagem de e-mail recebida
 de um servidor de e-mails.<BR>
 <BR>
 Veja mais informações em {@link Mail Mail}.<BR>
 <BR>"""

  def getAnexos(self) -> list:
    """Retorna a relação de arquivos "anexos" à mensagem (apenas traz
 a indicação dos nomes dos arquivos sem trazer os seus conteúdos)."""

    pass


  def getAssunto(self) -> str:
    """Retorna o título da mensagem"""

    pass


  def getDataEnvio(self) -> Data:
    """Retorna a data em que a mensagem foi enviada"""

    pass


  def getDataRecepcao(self) -> Data:
    """Retorna a data em que a mensagem foi recebida"""

    pass


  def getEmailDestinatarios(self) -> list:
    """Retorna o endereço de e-mail de todos os destinatários (inclusive aqueles
 que foram "copiados" no campo "CC" do cabeçalho do e-mail)."""

    pass


  def getEmailRemetente(self) -> str:
    """Retorna o endereço de e-mail do remetente da mensagem"""

    pass


  def getHoraEnvio(self) -> Hora:
    """Retorna a hora em que a mensagem foi enviada"""

    pass


  def getHoraRecepcao(self) -> Hora:
    """Retorna a hora em que a mensagem foi recebida"""

    pass


  def getMensagem(self) -> str:
    """Retorna o conteúdo da mensagem no formato texto."""

    pass


  def getNomeDestinatarios(self) -> list:
    """Retorna o nome de todos os destinatários (inclusive aqueles
 que foram "copiados" no campo "CC" do cabeçalho do e-mail)."""

    pass


  def getNomeRemetente(self) -> str:
    """Retorna o nome do remetente da mensagem"""

    pass


  def hasAnexo(self) -> bool:
    """Retorna a indicação de que a mensagem possui algum anexo"""

    pass


  def toString(self) -> str:
    pass

class MarcadorExecucao ():
  """Este objeto pode ser utilizado para "marcar" os passos de uma execução que envolve
 muitos registros e que pode demorar muito tempo para concluir.<BR>
 <BR>
 Por exemplo, se um script precisa obter informações sobre uma lista de 1000 contribuintes,
 este objeto pode ser utilizado para indicar quantos contribuintes da lista já foram
 "processados" pelo script, permitindo assim que em caso de recuperação de falha o script
 continue a partir do ponto onde parou.<BR>
 <BR>
 Note que este objeto pode ser utilizado para muitos propósitos distintos, portanto
 ele requer diversas "configurações" que irão indicar o seu comportamento.<BR>
 <BR>
 Cada "passo" executado, reportado por meio deste objeto, é armazenado em um arquivo em disco.
 Deste modo, mesmo que o aplicativo seja fechado de forma inesperada, os passos já executados
 são preservados.<BR>
 <BR>
 Caso exista mais de uma subrotina sendo executada ao mesmo tempo (em "paralelo") utilizando
 o mesmo arquivo para "marcar" os passos, utilize o mesmo objeto "MarcadorExecucao" como parâmetro
 a essas subrotinas, de modo que não exista "conflito" na indicação dos passos.<BR>
 <BR>
 Durante a utilização deste objeto, o arquivo onde ele armazena as informações é mantido "aberto"
 para seu uso interno, o que significa que não pode ser excluído ou renomeado ou utilizado em outro
 objeto "MarcadorExecucao". Para remover este bloqueio, "feche" o arquivo através do método 
 {@link MarcadorExecucao#fechar() fechar}. Note que, ao fazer isso, o objeto "MarcadorExecucao" que
 foi "fechado" não pode mais ser utilizado para leitura ou escrita.<BR>
 <BR>
 <BR>
 FORMA DE UTILIZAÇÃO DESTE OBJETO:<BR>
 =======================================================<BR>
 <BR>
 Digamos que você tem uma lista de "contabilidades" a "percorrer" (digamos que são objetos do tipo "Contabilidade").<BR>
 Vamos supor que para cada "contabilidade" da lista é desejável fazer algum tipo de "processamento".<BR>
 No lugar do bloco "PERCORRER CONTABILIDADES", você fará algo diferente caso queira ter o controle do que já foi "processado".<BR>
 1) Em primeiro lugar, antes de fazer qualquer processamento, é necessário verificar se algo já foi processado antes.
 Para fazer isso, obtenha de {@link ExecutorScript ExecutorScript} um objeto do tipo {@link MarcadorExecucao MarcadorExecucao}, utilizando
 para isso o método {@link ExecutorScript#getMarcadorExecucao(String) getMarcadorExecucao}, passando como "parâmetro" um nome de
 um arquivo que seu script irá utilizar para manter este controle. Se o arquivo não existe, ele é criado para este propósito nesta mesma etapa.<BR>
 2) Caso não tenha sido processado nada ainda (isso pode ser verificado através do método {@link MarcadorExecucao#isExistente() isExistente} ou
 através do método {@link MarcadorExecucao#getQuantidade() getQuantidade}), obtenha então a "lista completa" de "tudo que deve ser processado" (neste
 exemplo, esta seria a lista das "contabilidades", ou apenas dos seus correspondentes "CNPJ's"). Feito isso, associe esta lista ao objeto "MarcadorExecucao"
 utilizando o método {@link MarcadorExecucao#setListaMonitorar(List) setListaMonitorar}. Perceba que isso somente deve ser feito caso nenhum processamento
 anterior tenha sido realizado (ou seja, deve-se inserir isso dentro de uma CONDIÇÃO que teste primeiro se não há algo pendente, conforme orientado acima).<BR>
 3) Após os passos anteriores, independentemente de qual seja a situação do processamento (isto é, independentemente de ter havido ou não um processamento
 anterior), utilize um bloco "PERCORRER" sobre o retorno do método {@link MarcadorExecucao#getPendentes() getPendentes}. Este é o bloco do tipo "LOOP"
 que será utilizado para efetivamente percorrer os itens a serem processados (por exemplo, para percorrer as "contabilidades", ou seus "CNPJ's").<BR>
 4) Dentro do "LOOP", trate o elemento {@link Pendente Pendente} como sendo do mesmo "tipo" que foi indicado na "lista completa", originalmente. Ou seja,
 se foram inseridas "contabilidades" na lista, trate-o como sendo uma "contabilidade". Se foram inseridos códigos "CNPJ", trate-os como sendo códigos "CNPJ".<BR>
 5) Faça dentro do "LOOP" todo o "processamento" que seria feito originalmente. Ou seja, o script determina o que deve ser feito sobre cada elemento "pendente".<BR>
 6) No final do "LOOP", mas ainda dentro do "LOOP", indique como deseja "marcar" este item. Se houver algum "erro", indique esta situação utilizando
 o método {@link Pendente#marcarErro marcarErro}. Se não houve erro, não é necessário marcar nada, pois o próprio sistema irá automaticamente marcar o item
 como "concluído" (ou seja, o método {@link Pendente#marcarConclusao marcarConclusao} é dispensável, portanto não precisa ser chamado, exceto se por algum motivo
 especial quiser indicar esta situação de forma antecipada dentro do LOOP).<BR>
 <BR>
 Isso é tudo que precisa ser feito.<BR>
 Caso o script seja interrompido no meio do processamento (isto é, após alguns elementos da lista de pendência terem sido processados, mas não todos), ao 
 executar novamente o mesmo script, apenas os elementos restantes é que serão processados. Nenhum controle adicional precisa ser feito pelo script.<BR>
 <BR>
 Existem vários outros métodos que permitem obter várias informações, incluindo: relação de itens concluídos com erro,
 relação de itens concluídos sem erro, relação de todos os itens, etc.<BR>"""

  def fechar(self) -> None:
    """Fecha o "arquivo" mantido aberto para uso deste objeto. Após "fechar" o arquivo, nenhuma operação de leitura ou escrita é permitida, a menos
 que ele seja "reaberto" posteriormente através da construção de um novo objeto do tipo "MarcadorExecucao"."""

    pass


  def getConcluidosQuantidade(self) -> int:
    """Retorna a quantidade de registros marcados por este objeto como "concluídos" (com ou sem erro)"""

    pass


  def getData(self) -> Data:
    """Retorna data de criação ou modificação do arquivo"""

    pass


  def getDiretorio(self) -> str:
    """Retorna o nome do diretório do arquivo"""

    pass


  def getErrosQuantidade(self) -> int:
    """Retorna a quantidade de registros marcados por este objeto como "erro"."""

    pass


  def getExtensao(self) -> str:
    """Retorna a extensão do nome do arquivo"""

    pass


  def getListaComErro(self) -> list:
    """Retorna a lista de itens que foram adicionados a este "MarcadorExecucao" e que receberam a marcação de "erro" em algum estágio do processamento.<BR>
 A marcação de "erro" é feita enquanto se percorre a lista retornada em {@link MarcadorExecucao#getPendentes() getPendentes} e se
 executa o método {@link Pendente#marcarErro() marcarErro} em algum item da lista.<BR>"""

    pass


  def getListaCompleta(self) -> list:
    """Retorna a lista completa de itens que foram adicionados a este "MarcadorExecucao", incluindo os itens que já foram
 processados anteriormente (com ou sem erro) e os itens pendentes de processamento.<BR>
 OBS: não utilize este método para o propósito de "processamento" dos elementos da lista, pois fazendo assim não haverá
 qualquer tipo de "marcação" dos itens que foram "processados". Ao invés disso, utilize o método {@link MarcadorExecucao#getPendentes() getPendentes}
 caso queira ter este controle."""

    pass


  def getListaConcluidos(self) -> list:
    """Retorna a lista de itens que foram adicionados a este "MarcadorExecucao" e que já foram "concluídos" (com ou sem erro).<BR>
 A marcação de "concluído" é feita enquanto se percorre a lista retornada em {@link MarcadorExecucao#getPendentes() getPendentes} e se
 executa o método {@link Pendente#marcarConclusao() marcarConclusao} ou o método {@link Pendente#marcarErro() marcarErro} em algum item da lista.<BR>
 É também feito de forma "automática" enquanto se "percorre" a lista retornada em {@link MarcadorExecucao#getPendentes() getPendentes}.<BR>"""

    pass


  def getListaSemErro(self) -> list:
    """Retorna a lista de itens que foram adicionados a este "MarcadorExecucao" e que foram concluídos sem receber a marcação de "erro" em algum estágio do processamento.<BR>
 A marcação de "erro" é feita enquanto se percorre a lista retornada em {@link MarcadorExecucao#getPendentes() getPendentes} e se
 executa o método {@link Pendente#marcarErro() marcarErro} em algum item da lista.<BR>
 Os itens da lista são considerados "concluídos" de forma automática na medida em que se "percorre" a lista retornada em {@link MarcadorExecucao#getPendentes() getPendentes}."""

    pass


  def getLotePendentes(self, tamanhoLote) -> list:
    """Retorna uma lista com um conjunto de elementos pendentes para processamento, indicado para os casos
 em que se desejado processar em lote."""

    pass


  def getNome(self) -> str:
    """Retorna o nome do arquivo sem incluir o nome do diretório"""

    pass


  def getNomeCompleto(self) -> str:
    """Retorna o nome completo do arquivo, incluindo diretório"""

    pass


  def getNomeCompletoSemExtensao(self) -> str:
    """Retorna o nome completo do arquivo, sem indicar sua extensão"""

    pass


  def getNomeSemExtensao(self) -> str:
    """Retorna o nome do arquivo, sem diretório e nem extensão"""

    pass


  def getPendentes(self) -> Iterator:
    """Retorna um componente que pode ser utilizado para "percorrer" os elementos "pendentes" da lista que foi fornecida
 através do método {@link MarcadorExecucao#setListaMonitorar(List) setListaMonitorar}.<BR>
 Caso a execução anterior da rotina tenha sido interrompida, é possível continuar de onde "parou" utilizando este método.<BR>
 Os objetos retornados nesta relação são do mesmo tipo que foram informados originalmente. A rotina deve "tratar" os elementos
 como se fossem do tipo original (ex: se a lista continha "datas", deve tratar como "datas").<BR>
 Se não há nenhum elemento "pendente" (ou seja, se todos os elementos já foram concluídos, com ou sem erro), retorna uma relação vazia.<BR>
 OBS: para cada novo item que é "percorrido", o item anterior é automaticamente marcado como "concluído". Se este comportamento
 não for desejável, utilize o método alternativo {@link MarcadorExecucao#getPendentes(boolean) getPendentes}."""

    pass


  def getPendentes(self, marcacaoAutomatica) -> Iterator:
    """Retorna um componente que pode ser utilizado para "percorrer" os elementos "pendentes" da lista que foi fornecida
 através do método {@link MarcadorExecucao#setListaMonitorar(List) setListaMonitorar}.<BR>
 Caso a execução anterior da rotina tenha sido interrompida, é possível continuar de onde "parou" utilizando este método.<BR>
 Os objetos retornados nesta relação são do mesmo tipo que foram informados originalmente. A rotina deve "tratar" os elementos
 como se fossem do tipo original (ex: se a lista continha "datas", deve tratar como "datas").<BR>
 Se não há nenhum elemento "pendente" (ou seja, se todos os elementos já foram concluídos, com ou sem erro), retorna uma relação vazia."""

    pass


  def getPendentesEmLotes(self, tamanhoLote, marcacaoAutomatica) -> Iterator:
    """Este método faz quase a mesma coisa que o método {@link MarcadorExecucao#getPendentes() getPendentes}, com a diferença
 que aqui são retornados "lotes" de itens pendentes, ao invés dos itens individuais.<BR>
 Com isso, pode-se fazer com que em cada "processamento" sejam considerados múltiplos itens, ao invés de itens individuais."""

    pass


  def getPendentesQuantidade(self) -> int:
    """Retorna a quantidade de registros que ainda não foram marcados por este objeto como "concluídos" (com ou sem erros)."""

    pass


  def getPendentesRestantesQuantidade(self) -> int:
    """Retorna a quantidade de registros pendentes que ainda não foram retornados para processamento."""

    pass


  def getProximoObjetoPendente(self) -> Object:
    """Retorna o próximo objeto original pendente (isto é, a data, ou número, ou texto, ou o que quer se tenha sido incluído na lista)"""

    pass


  def getProximoPendente(self) -> Pendente:
    """Retorna o próximo elemento pendente para processamento. Todos elementos já concluídos ou que já tenham sido
 retornados como pendentes nessa sessão não são mais retornados. <BR>
 A cada chamada, o próximo pendente será retornado, independentemente de os anteriores terem sido marcados ou não."""

    pass


  def getQuantidade(self) -> int:
    """Retorna a quantidade de registros que foram relacionados na lista (sejam concluídos ou não)"""

    pass


  def getTabelaSituacao(self) -> Tabela:
    """Retorna uma "tabela" contendo a "situação" atual da lista de processamento. Isto é, indicando para cada item da lista de processamento
 quais itens foram "concluídos" com erro, quais foram concluídos sem erro e quais estão pendentes."""

    pass


  def getTamanho(self) -> long:
    """Retorna o tamanho do arquivo em bytes"""

    pass


  def hasConcluidos(self) -> bool:
    """Retorna a indicação de que existem registros marcados por este objeto como "concluídos" (com ou sem erro)"""

    pass


  def hasErros(self) -> bool:
    """Retorna a indicação de que não existem registros marcados por este objeto como "erro"."""

    pass


  def hasPendentes(self) -> bool:
    """Retorna a indicação de que existem registros ainda não marcados por este objeto como "concluídos" (com ou sem erros)."""

    pass


  def hasPendentesRestantes(self) -> bool:
    """Retorna a indicação de que existem registros pendentes que ainda não foram retornados para processamento"""

    pass


  def isExistente(self) -> bool:
    """Verifica se o arquivo já existe e já foi inicializado com algum conteúdo (isto é, já possui uma lista de informações que devem
 ser "monitoradas").<BR>
 Trata-se de um método útil para ser verificado no início da execução do script, com o propósito de determinar se deve continuar
 de onde parou ou se deve obter uma nova lista de "objetos" a serem percorridos.<BR>
 OBS: se o arquivo existe, mas está "vazio", esta função retorna FALSE."""

    pass


  def isFechado(self) -> bool:
    """Indica se o "arquivo" mantido aberto para uso deste objeto já foi fechado. O arquivo é fechado através da execução do método
 {@link MarcadorExecucao#fechar() fechar} ou sempre que o script termina de executar."""

    pass


  def isVazio(self) -> bool:
    """Retorna a indicação de que a lista de processamento está "vazia" (isto é, que nenhum elemento foi
 relacionado para ser marcado). Ou seja, não há itens pendentes e nem concluídos, com erro ou sem erro."""

    pass


  def marcarConclusao(self, lote) -> None:
    """Marca os itens pendentes da lista como concluídos, sem erro. Note que com isso o item não se torna mais "pendente", mas passa a constar
 na relação de itens concluídos."""

    pass


  def marcarErro(self, lote, mensagem) -> None:
    """Marca os itens pendentes da lista como concluídos com "erro". Note que com isso o item não se torna mais "pendente", mas passa a constar
 na relação de itens "com erro"."""

    pass


  def reprocessarRegistrosComErro(self) -> int:
    """Passa todos os registros marcados com erro para a situação pendente. <BR>
 Isso permite tentar novamente os registros em que ocorreu algum erro."""

    pass


  def setListaMonitorar(self, objetos) -> None:
    """Atribui a este "marcador" uma lista de "objetos" que precisam ser "percorridos" por outra rotina.<BR>
 Ou seja, esta é a lista de "controle", como um "índice" que precisa ser "percorrido" para se concluir uma determinada tarefa.<BR>
 Os objetos precisam ser de um dos seguintes tipos:<BR>
 - Textos (percorre em ordem alfabética)<BR>
 - Números (percorre em ordem numérica)<BR>
 - Datas (percorre em ordem cronológica)<BR>
 - Meses (percorre em ordem cronológica)<BR>
 - Objetos que são do tipo "{@link DadoIdentificaContribuinte DadoIdentificaContribuinte}" (percorre na ordem dos CNPJ's correspondentes)<BR>
 - Objetos que são do tipo "{@link DadoTemporalTipo1 DadoTemporalTipo1}" (percorre na ordem das datas iniciais/finais)<BR>
 - Objetos que são do tipo "{@link DadoTemporalTipo2 DadoTemporalTipo2}" (percorre na ordem das competências)<BR>
 - Objetos que são do tipo "{@link DadoTemporalTipo3 DadoTemporalTipo3}" (percorre na ordem das competências iniciais/finais)<BR>
 - Combinação de mais de uma informação (isto é, pode ser um objeto do tipo {@link Criterio Criterio}).<BR> 
 Não é permitido "misturar" na mesma lista objetos de "tipos diferentes" (isto é, números com datas, ou outras combinações diferentes), a menos
 que os tipos diferentes sejam informados como "componentes" de um objeto do tipo {@link Criterio Criterio} (ou seja, a menos que seja uma lista
 de objetos {@link Criterio Criterio}, não é permitido misturar objetos de tipos diferentes na lista).<BR>
 <BR>
 IMPORTANTE: este método deve ser utilizado apenas na "inicialização" do "MarcadorExecucao". Se ele for executado sobre um arquivo já existente
 de uma execução anterior, o conteúdo anterior é integralmente substituído pelo novo."""

    pass


  def setNomeCompleto(self, fullpath) -> None:
    """Este método não é implementado neste tipo de objeto."""

    pass


  def setTabelaMonitorar(self, tabela) -> None:
    """Vincula uma 'tabela' a este objeto de monitoramento. Este método é similar ao método {@link MarcadorExecucao#setListaMonitorar(List) setListaMonitorar},
 com a diferença que aqui é indicada uma 'tabela'. Ou seja, são monitoradas as 'linhas' desta tabela (uma linha de cada vez).<BR>
 <BR>
 Ao vincular uma {@link Tabela Tabela}, cada 'item' monitorado neste 'marcador' passa a ser do tipo {@link LinhaDados LinhaDados}. Isto é, ao 'percorrer'
 a relação de itens retornados pelo método {@link MarcadorExecucao#getPendentes() getPendentes} (ou qualquer outro método alternativo a este), cada
 elemento 'pendente' apresenta como conteúdo (isto é, como retorno da função {@link Pendente#getObjeto() getObjeto} algo do tipo {@link LinhaDados LinhaDados}.<BR>
 <BR>
 Note que desta maneira é possível continuar acessando o conteúdo original da tabela. Isto é, todas as colunas de uma determinada linha, uma linha de cada
 vez.<BR>
 <BR>
 A tabela original, que é indicada como parâmetro a esta ação, não precisa ser recriada toda vez que for aproveitar o mesmo conteúdo 'pendente' de um
 objeto {@link MarcadorExecucao MarcadorExecucao} criado em uma execução anterior do script.<BR> 
 <BR>
 Para mais comentários, consulte a documentação em {@link MarcadorExecucao#setListaMonitorar(List) setListaMonitorar}."""

    pass

class Matriz ():
  """Objeto que representa uma 'MATRIZ'. Isto é, um conjunto de valores
 numéricos dispostos na forma de linhas e colunas.<BR>
 <BR>
 Este tipo de objeto é diferente de um objeto {@link Tabela Tabela} por vários motivos:<BR><BR>
 - Uma {@link Tabela Tabela} pode conter qualquer tipo de informação, incluindo datas, números, textos, códigos CNPJ, etc.<BR>
 Uma {@link Matriz Matriz} pode conter apenas números.<BR><BR>
 - Uma {@link Tabela Tabela} apresenta títulos em suas colunas que são úteis para identificar essas colunas. Por exemplo, podemos ter uma coluna "NOME".<BR>
 Uma {@link Matriz Matriz} referencia suas linhas e colunas através de números, começando em 0 (ex: se há 10 colunas, elas são identificadas pelos números 0, 1, 2, ... 9).<BR>
 Podem haver títulos tanto em linhas como também em colunas da matriz, porém esses títulos servem apenas para visualização (não se destinam a buscar alguma informação dentro da matriz).<BR><BR>
 - Podemos realizar diversas operações matemáticas sobre <B>matrizes</B> que não são possíveis sobre <B>tabelas</B>, tais como:<BR>
 <UL>
 <LI>Multiplicação e soma de matrizes</LI>
 <LI>Calcular a matriz 'inversa'</LI>
 <LI>Calcular o 'determinante'</LI>
 <LI>Calcular a matriz 'covariância'</LI>
 </UL>
 OBS: há alguns métodos convenientes para transformar uma {@link Matriz Matriz} em uma {@link Tabela Tabela} e vice-versa, porém pode haver alguma
 perda de informação quando se faz o sentido contrário (isto é, quando se converte de uma {@link Tabela Tabela} para uma {@link Matriz Matriz}), tendo
 em vista que nem todo tipo de informação pode ser armazenada em uma {@link Matriz Matriz} (ex: não armazenamos textos, datas, códigos CNPJ, nem nada
 que não seja número).<BR>
 <BR>
 OBS: Esta classe é THREAD-SAFE (isto é, o mesmo objeto pode ser compartilhado
 por execuções paralelas simultâneas)."""

  def addColuna(self, coluna) -> None:
    """Insere uma coluna nova no meio da matriz. As colunas existentes na posição indicada e também as colunas existentes à direita da coluna indicada são deslocadas para a direita.<BR>
 Se a coluna indicada não existe, a matriz é ampliada de modo a considerar a coluna indicada (ex: se a matriz possui 3 colunas e é indicado o número 4, a matriz é ampliada de modo
 a conter 5 colunas, pois o número 4 representa a quinta coluna)."""

    pass


  def addLinha(self, linha) -> None:
    """Insere uma linha nova no meio da matriz. As linhas existentes na posição indicada e também as linhas existentes abaixo da linha indicada são deslocadas para baixo.<BR>
 Se a linha indicada não existe, a matriz é ampliada de modo a considerar a linha indicada (ex: se a matriz possui 3 linhas e é indicado o número 4, a matriz é ampliada de modo
 a conter 5 linhas, pois o número 4 representa a quinta linha)."""

    pass


  def aplicaPrincipalComponentAnalysis(self, dimensao, calculaCovariancia, normaliza) -> PrincipalComponentAnalysis:
    """Aplica a técnica conhecida como "Principal Component Analysis" (PCA) destinada a reduzir
 a dimensão de um conjunto de dados de tal modo a reduzir as "redundâncias".<BR>
 As colunas e os valores da matriz original (atual) não são afetados por este método.<BR>
 Antes de calcular o PCA, este método faz uma "normalização" dos dados (isto é, transforma
 os valores de cada coluna de tal modo que a "média" seja zero e o "desvio padrão"
 seja unitário).<BR>
 O propósito é elaborar uma nova tabela que contenha "menos" colunas do que a matriz original, mas
 de tal forma que os números dessas colunas sejam relações lineares sobre uma nova "base
 ortogonal" construída de tal modo a deixar a maior "variância" possível sobre cada "projeção"
 das colunas originais.<BR>"""

    pass


  def calculaFormula(self, formula, colunaResultado, primeiraLinha, quantidadeLinhas) -> None:
    """Método alternativo onde é possível indicar a primeira linha da matriz onde a fórmula deve ser calculada e também a quantidade total de linhas
 que devem ser calculadas. Se a matriz possui menos linhas do que é indicado, a matriz aumenta de tamanho de modo a acomodar as novas
 linhas.<BR>
 Veja mais comentários na documentação do método alternativo."""

    pass


  def calculaFormula(self, formula) -> None:
    """Percorre todos os elementos da matriz calculando uma fórmula e preenchendo as células com os valores."""

    pass


  def calculaFormula(self, formula, colunaResultado) -> None:
    """Percorre todas as linhas da matriz calculando uma fórmula e preenchendo as células
 de uma coluna com os resultados."""

    pass


  def getANOVA(self, colunasAmostras, valorRejeitar) -> ANOVA:
    """Executa o processamento estatístico conhecido como ANOVA (Análise da Variância) que
 tem o propósito de testar (para aceitar ou rejeitar) a hipótese de que os dados coletados e condicionados sob duas ou mais
 "categorias" possuem variação explicada pelo "acaso" (chamada de hipótese "nula" neste tipo de teste).<BR>
 Caso a hipótese seja "rejeitada", então pode-se concluir que existe pelo menos uma das sub-populações
 cuja média difere das médias das demais sub-populações com um determinado nível de certeza (embora não seja
 possível identificar qual delas, caso existam mais de duas categorias diferentes).<BR>
 Esta implementação é a chamada "One-Factor ANOVA" ou "One-Way ANOVA" pelo fato de haver
 apenas um único "fator" de divisão dos dados (presume-se que as diferentes COLUNAS da matriz separam os diferentes níveis do fator).<BR>
 Existem algums PRESSUPOSTOS para utilização desta técnica:<BR>
 1 - As sub-populações possuem a mesma variância.<BR>
 2 - As observações são independentes<BR>
 3 - A distribuição é aproximadamente NORMAL<BR>"""

    pass


  def getAssimetria(self, coluna) -> float:
    """Retorna o coeficiente de assimetria (calculado a partir dos momentos de
 ordem 3, não se tratando do coeficiente de Pearson) com base nos valores
 de uma determinada coluna."""

    pass


  def getAutoValores(self) -> Matriz:
    """Retorna uma matriz de 'auto-valores' relacionados à matriz atual. Trata-se de uma matriz 'diagonal', onde os elementos
 da diagonal são os 'auto-valores' correspondentes.<BR>
 OBS: Se a matriz atual é simétrica (e ela sempre será caso seja uma matriz de correlação ou de covariância), então
 é de se esperar autovalores 'números reais' (isto é, não são 'números complexos', do tipo 'a+bi'). Porém, se a matriz
 atual não for simétrica, seus autovalores em tese seriam 'números complexos'. Porém, este método, mesmo neste caso,
 retornaria apenas a 'parte real' de tais números, o que ensejaria uma resposta 'incompleta' neste caso.<BR>
 Atenção: se você estiver querendo aplicar a técnica dos componentes principais (PCA), utilize o método {@link Matriz#aplicaPrincipalComponentAnalysis(int, boolean) aplicaPrincipalComponentAnalysis}."""

    pass


  def getAutoValoresImaginarios(self) -> Matriz:
    """Retorna uma matriz de 'auto-valores' relacionados à matriz atual, mas apenas a parcela que corresponde aos 'números imaginários'
 (em números complexos na notação 'a+bi', corresponderia aos coeficientes 'b').<BR>
 Trata-se de uma matriz 'diagonal', onde os elementos da diagonal são as parcelas 'imaginárias' dos 'auto-valores' correspondentes.<BR>
 OBS: Se a matriz atual é simétrica (e ela sempre será caso seja uma matriz de correlação ou de covariância), então
 é de se esperar autovalores 'números reais' (isto é, não são 'números complexos', do tipo 'a+bi'), portanto neste caso esta função
 retornará sempre uma matriz de números zeros. Porém, se a matriz atual não for simétrica, seus autovalores em tese seriam 'números complexos'. 
 Neste caso, esta função retornará a parcela de números 'imaginários'. A função alternativa {@link Matriz#getAutoValores() getAutoValores} retorna
 a parcela 'real' desses mesmos 'números complexos'.<BR>
 Atenção: se você estiver querendo aplicar a técnica dos componentes principais (PCA), utilize o método {@link Matriz#aplicaPrincipalComponentAnalysis(int, boolean) aplicaPrincipalComponentAnalysis}."""

    pass


  def getAutoVetores(self) -> Matriz:
    """Retorna uma matriz de 'auto-vetores' relacionados à matriz atual. Cada 'coluna' desta matriz é um 'auto-vetor'.<BR>
 Atenção: se você estiver querendo aplicar a técnica dos componentes principais (PCA), utilize o método {@link Matriz#aplicaPrincipalComponentAnalysis(int, boolean) aplicaPrincipalComponentAnalysis}."""

    pass


  def getCelula(self, linha, coluna) -> float:
    """Retorna o conteúdo de uma célula da matriz (isto é, algo armazenado em
 uma determinada linha e em uma determinada coluna)."""

    pass


  def getCoeficienteVariacao(self, coluna) -> float:
    """Calcula o valor do coeficiente de variação (medida relativa dada pela divisão do desvio padrão pela média) dos valores de uma determinada coluna da matriz.<BR>
 Para o cálculo do desvio-padrão, utiliza-se a convenção onde o denominador é N-1 (isto é, considera fator de correção da amostra para a população)."""

    pass


  def getCoeficienteVariacaoColunas(self) -> Matriz:
    """Calcula o coeficiente de variação (medida relativa dada pela divisão do desvio padrão pela média) considerando todos os valores de uma mesma coluna.<BR>
 O resultado é uma matriz-linha onde cada coluna é um desvio padrão.<BR>
 Para o cálculo do desvio-padrão, utiliza-se a convenção onde o denominador é N-1 (isto é, considera fator de correção da amostra para a população)."""

    pass


  def getCoeficienteVariacaoLinhas(self) -> Matriz:
    """Calcula o coeficiente de variação (medida relativa dada pela divisão do desvio padrão pela média) considerando todos os valores de uma mesma linha.<BR>
 O resultado é uma matriz-coluna onde cada linha é um desvio padrão.<BR>
 Para o cálculo do desvio-padrão, utiliza-se a convenção onde o denominador é N-1 (isto é, considera fator de correção da amostra para a população)."""

    pass


  def getColuna(self, coluna) -> Matriz:
    """Retorna uma das colunas da matriz atual. O resultado é uma matriz-coluna, contendo uma só coluna e todos
 os valores desta coluna.<BR>
 Alterações na matriz retornada não têm efeitos sobre a matriz atual, e alterações na matriz atual não
 têm efeitos sobre a matriz retornada."""

    pass


  def getColunas(self) -> list:
    """Retorna o conteúdo desta matriz na forma de uma lista de matrizes-colunas. Cada elemento da lista
 corresponde a uma coluna da matriz, representado por sua vez na forma de uma matriz-coluna. O primeiro
 elemento da lista será, portanto, a primeira coluna da matriz. Alterações feitas nessas matrizes-colunas
 têm efeitos sobre a matriz atual, e vice-versa."""

    pass


  def getCopia(self) -> Matriz:
    """Retorna uma cópia da matriz atual."""

    pass


  def getCorrelacao(self) -> Matriz:
    """Retorna a matriz 'correlação' da matriz atual. Trata-se de uma matriz quadrada, simétrica, consistindo
 dos coeficientes de correlação. Os elementos da diagonal principal são iguais a 1."""

    pass


  def getCovariancia(self) -> Matriz:
    """Retorna a matriz 'covariância' da matriz atual. Trata-se de uma matriz quadrada, simétrica, consistindo
 dos coeficientes de covariância. Os elementos da diagonal principal correspondem às variâncias."""

    pass


  def getCurtose(self, coluna) -> float:
    """Retorna o coeficiente de curtose (calculado a partir do momento de ordem
 4, subtraindo o resultado por 3 para fins de comparação com a curva
 normal) com base nos valores de uma determinada coluna."""

    pass


  def getDesvioPadrao(self) -> float:
    """Calcula o valor do desvio padrão de todos os valores da matriz.<BR>
 Se desejar o desvio padrão individualizado por linhas ou colunas, utilize os métodos alternativos."""

    pass


  def getDesvioPadrao(self, coluna) -> float:
    """Calcula o valor do desvio padrão dos valores de uma determinada coluna da matriz.<BR>
 Utiliza-se a convenção onde o denominador é N-1 (isto é, considera fator de correção da amostra para a população)."""

    pass


  def getDesvioPadraoColunas(self) -> Matriz:
    """Calcula o desvio padrão considerando todos os valores de uma mesma coluna.<BR>
 O resultado é uma matriz-linha onde cada coluna é um desvio padrão.<BR>
 Utiliza-se a convenção onde o denominador é N-1 (isto é, considera fator de correção da amostra para a população)."""

    pass


  def getDesvioPadraoLinhas(self) -> Matriz:
    """Calcula o desvio padrão considerando todos os valores de uma mesma linha.<BR>
 O resultado é uma matriz-coluna onde cada linha é um desvio padrão.<BR>
 Utiliza-se a convenção onde o denominador é N-1 (isto é, considera fator de correção da amostra para a população)."""

    pass


  def getDeterminante(self) -> float:
    """Calcula o 'determinante' da matriz. Isto é, dada a matriz A, retorna |A|."""

    pass


  def getDiagonal(self) -> Matriz:
    """Retorna a diagonal principal da matriz. O resultado é uma matriz-coluna contendo uma só coluna e todos
 os valores da diagonal principal dispostos em linhas.<BR>
 Alterações na matriz retornada não têm efeitos sobre a matriz atual, e alterações na matriz atual não
 têm efeitos sobre a matriz retornada."""

    pass


  def getDistribuicaoAjustada(self, coluna) -> DistribuicaoAjustada:
    """Retorna a distribuição de números aleatórios que melhor descreve o
 conjunto de valores de uma coluna da matriz.<BR>
 Para mais informações sobre esta técnica, consulte comentários
 relacionados à classe {@link DistribuicaoAjustada DistribuicaoAjustada}."""

    pass


  def getErroPadrao(self, coluna) -> float:
    """Calcula o valor do erro padrão (divisão do desvio padrão pela raiz quadrada da quantidade de elementos) dos valores de uma determinada coluna da matriz.<BR>
 Para o cálculo do desvio padrão utiliza-se a convenção onde o denominador é N-1 (isto é, considera fator de correção da amostra para a população)."""

    pass


  def getErroPadraoColunas(self) -> Matriz:
    """Calcula o erro padrão (divisão do desvio padrão pela raiz quadrada da quantidade de elementos) considerando todos os valores de uma mesma coluna.<BR>
 O resultado é uma matriz-linha onde cada coluna é um erro padrão.<BR>
 Para o cálculo do desvio padrão utiliza-se a convenção onde o denominador é N-1 (isto é, considera fator de correção da amostra para a população)."""

    pass


  def getErroPadraoLinhas(self) -> Matriz:
    """Calcula o erro padrão (divisão do desvio padrão pela raiz quadrada da quantidade de elementos) considerando todos os valores de uma mesma linha.<BR>
 O resultado é uma matriz-coluna onde cada linha é um erro padrão.<BR>
 Para o cálculo do desvio padrão utiliza-se a convenção onde o denominador é N-1 (isto é, considera fator de correção da amostra para a população)."""

    pass


  def getInversa(self) -> Matriz:
    """Retorna uma matriz 'inversa' em relação à matriz atual.<BR>
 Se a matriz atual não for uma matriz 'quadrada' (isto é, se a quantidade de linhas não
 for igual à quantidade de colunas), retorna uma matriz 'pseudo-inversa'.<BR>
 Se a matriz não for inversível (isto é, se seu determinante é zero), gera erro."""

    pass


  def getKolmogorovSmirnovEstatistica(self, coluna1, coluna2) -> float:
    """Aplica o teste 'Kolmogorov-Smirnov' para testar a hipótese de que uma relação de valores se
 distribui conforme a mesma distribuição que outra relação de valores.<BR>
 O valor retornado por esta função é a 'estatística' que pode ser depois comparada com uma
 tabela de distribuição D(n) conforme explicado em: http://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test.<BR>"""

    pass


  def getKolmogorovSmirnovEstatistica(self, formula, coluna) -> float:
    """Aplica o teste 'Kolmogorov-Smirnov' para testar a hipótese de que uma relação de valores se
 distribui conforme uma determinada distribuição.<BR>
 O valor retornado por esta função é a 'estatística' que pode ser depois comparada com uma
 tabela de distribuição D(n) conforme explicado em: http://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test.<BR>
 ATENÇÃO: a fórmula indicada deve ser uma fórmula no padrão do ContÁgil sobre uma variável independente X que retorne algo
 compatível com uma 'função distribuição acumulada'. Por exemplo, "NORMAL.ACUM(X;0;1)" pode ser utilizado para comparar com
 a distribuição NORMAL de média 0 e desvio padrão 1."""

    pass


  def getKolmogorovSmirnovValorP(self, formula, coluna) -> float:
    """Aplica o teste 'Kolmogorov-Smirnov' para testar a hipótese de que uma relação de valores se
 distribui conforme uma determinada distribuição.<BR>
 O valor retornado por esta função é o valor 'P' obtido após comparação da estatística com a tabela de distribuição D(n) conforme explicado em: http://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test.<BR>
 Geralmente um valor inferior a 0,05 indica que 'rejeitamos' a hipótese de que os valores seguem a distribuição informada no primeiro parâmetro com 95% de confiança, e um valor superior a 0,05
 indica que não rejeitamos (isto é, que mantemos a hipótese de que os valores seguem esta distribuição).<BR>
 ATENÇÃO: a fórmula indicada deve ser uma fórmula no padrão do ContÁgil sobre uma variável independente X que retorne algo
 compatível com uma 'função distribuição acumulada'. Por exemplo, "NORMAL.ACUM(X;0;1)" pode ser utilizado para comparar com
 a distribuição NORMAL de média 0 e desvio padrão 1."""

    pass


  def getKolmogorovSmirnovValorP(self, coluna1, coluna2) -> float:
    """Aplica o teste 'Kolmogorov-Smirnov' para testar a hipótese de que uma relação de valores se
 distribui conforme a mesma distribuição que outra relação de valores.<BR>
 O valor retornado por esta função é o valor 'P' obtido após comparação da estatística com a tabela de distribuição D(n) conforme explicado em: http://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test.<BR>
 Geralmente um valor inferior a 0,05 indica que 'rejeitamos' a hipótese de que os valores seguem a distribuição informada no primeiro parâmetro com 95% de confiança, e um valor superior a 0,05
 indica que não rejeitamos (isto é, que mantemos a hipótese de que os valores seguem esta distribuição).<BR>"""

    pass


  def getLinha(self, linha) -> Matriz:
    """Retorna uma das linhas da matriz atual. O resultado é uma matriz-linha, contendo uma só linha e todos
 os valores desta linha.<BR>
 Alterações na matriz retornada não têm efeitos sobre a matriz atual, e alterações na matriz atual não
 têm efeitos sobre a matriz retornada."""

    pass


  def getLinhas(self) -> list:
    """Retorna o conteúdo desta matriz na forma de uma lista de matrizes-linhas. Cada elemento da lista
 corresponde a uma linha da matriz, representado por sua vez na forma de uma matriz-linha. O primeiro
 elemento da lista será, portanto, a primeira linha da matriz. Alterações feitas nessas matrizes-linhas
 têm efeitos sobre a matriz atual, e vice-versa."""

    pass


  def getMaximo(self) -> float:
    """Retorna o maior dos valores da matriz."""

    pass


  def getMaximo(self, coluna) -> float:
    """Calcula o valor máximo dos valores de uma determinada coluna da matriz"""

    pass


  def getMaximoColunas(self) -> Matriz:
    """Calcula o valor máximo considerando todos os valores de uma mesma coluna.<BR>
 O resultado é uma matriz-linha onde cada coluna é um valor máximo."""

    pass


  def getMaximoLinhas(self) -> Matriz:
    """Calcula o valor máximo considerando todos os valores de uma mesma linha.<BR>
 O resultado é uma matriz-coluna onde cada linha é um valor máximo."""

    pass


  def getMedia(self, coluna) -> float:
    """Calcula o valor médio dos valores de uma determinada coluna da matriz"""

    pass


  def getMediaColunas(self) -> Matriz:
    """Calcula o valor médio considerando todos os valores de uma mesma coluna.<BR>
 O resultado é uma matriz-linha onde cada coluna é um valor médio."""

    pass


  def getMediaLinhas(self) -> Matriz:
    """Calcula o valor médio considerando todos os valores de uma mesma linha.<BR>
 O resultado é uma matriz-coluna onde cada linha é um valor médio."""

    pass


  def getMediana(self, coluna) -> float:
    """Calcula a mediana dos valores de uma determinada coluna da matriz"""

    pass


  def getMedianaColunas(self) -> Matriz:
    """Calcula a mediana considerando todos os valores de uma mesma coluna.<BR>
 O resultado é uma matriz-linha onde cada coluna é uma mediana."""

    pass


  def getMedianaLinhas(self) -> Matriz:
    """Calcula a mediana considerando todos os valores de uma mesma linha.<BR>
 O resultado é uma matriz-coluna onde cada linha é uma mediana."""

    pass


  def getMinimo(self) -> float:
    """Retorna o menor dos valores da matriz."""

    pass


  def getMinimo(self, coluna) -> float:
    """Calcula o valor mínimo dos valores de uma determinada coluna da matriz"""

    pass


  def getMinimoColunas(self) -> Matriz:
    """Calcula o valor mínimo considerando todos os valores de uma mesma coluna.<BR>
 O resultado é uma matriz-linha onde cada coluna é um valor mínimo."""

    pass


  def getMinimoLinhas(self) -> Matriz:
    """Calcula o valor mínimo considerando todos os valores de uma mesma linha.<BR>
 O resultado é uma matriz-coluna onde cada linha é um valor mínimo."""

    pass


  def getNorma(self) -> float:
    """Calcula a 'norma' da matriz (conforme 'L2'). Para matrizes linhas ou matrizes colunas (vetores), corresponde à norma 'euclidiana' (raiz quadrada do produto do vetor por ele mesma).
 Para matrizes de dimensão MxN (M>1 e N>1), corresponde ao maior valor singular obtido na decomposição SVD (single value decomposition)."""

    pass


  def getNormaFrobenius(self) -> float:
    """Calcula a 'norma de Frobenius' da matriz"""

    pass


  def getNormaL1(self) -> float:
    """Calcula a 'norma' da matriz (conforme 'L1'). Corresponde ao valor da coluna cuja soma dos valores absolutos é a maior."""

    pass


  def getNormaL1Elementos(self) -> float:
    """Calcula a 'norma' dos elementos da matriz (conforme 'L1'). Corresponde à soma dos valores absolutos da matriz."""

    pass


  def getNormaL2Elementos(self) -> float:
    """Calcula a 'norma' dos elementos da matriz (conforme 'L2'). Corresponde à raiz quadrada da soma dos quadrados dos valores da matriz."""

    pass


  def getNormaQuadratica(self) -> float:
    """Calcula a 'norma quadrática' da matriz, que é o quadrado da norma."""

    pass


  def getNumColunas(self) -> int:
    """Retorna a quantidade de colunas na tabela"""

    pass


  def getNumLinhas(self) -> int:
    """Retorna a quantidade de linhas na tabela"""

    pass


  def getParte(self, linha, coluna, altura, largura) -> Matriz:
    """Retorna uma parte da matriz atual. O resultado é uma outra matriz cujas dimensões são dadas nos últimos
 dois parâmetros.<BR>
 Alterações na matriz retornada não têm efeitos sobre a matriz atual, e alterações na matriz atual não
 têm efeitos sobre a matriz retornada."""

    pass


  def getParteSemColunas(self, colunasExcluir) -> Matriz:
    """Retorna uma parte da matriz atual sem as colunas indicadas no parâmetro."""

    pass


  def getParteSemLinhas(self, linhasExcluir) -> Matriz:
    """Retorna uma parte da matriz atual sem as linhas indicadas no parâmetro."""

    pass


  def getProdutoElemento(self, matriz) -> Matriz:
    """Realiza o chamado 'produto elemento por elemento' entre a matriz atual e a matriz indicada no parâmetro. Trata-se da operação
 onde cada elemento Aij de uma matriz é multiplicado pelo correspondente Bij da outra matriz (isto é, na mesma posição).
 Ambas matrizes precisam ter exatamente as mesmas dimensões (mesma quantidade de linhas e colunas).<BR>
 É diferente do chamado 'produto matricial', o qual é realizado pela função {@link Matriz#multiplica(Matriz) multiplica}."""

    pass


  def getQtdColunas(self) -> int:
    """Idem ao método {@link Matriz#getNumColunas() getNumColunas}"""

    pass


  def getQtdLinhas(self) -> int:
    """Idem ao método {@link Matriz#getNumLinhas getNumLinhas}"""

    pass


  def getRaizQuadradaMatricial(self) -> Matriz:
    """Retorna a 'matriz raiz quadrada' da matriz atual, dada que a matriz atual é uma matriz quadrada e simétrica.<BR>
 A 'matriz raiz quadrada' R de uma matriz A é uma matriz quadrada tal que R*R = A (ou seja, o produto matricial dela com ela mesma resulta na matriz A).<BR>
 OBS: esta operação retorna apenas 'números reais'. Caso os elementos da 'matriz raiz quadrada' sejam números 'complexos' (do tipo 'a+bi'), utilize
 a função {@link Matriz#getRaizQuadradaMatricialImaginarios() getRaizQuadradaMatricialImaginarios} para obter os componentes imaginários.<BR>
 Internamente o cálculo é feito utilizando o método de decomposição da matriz quadrada em uma matriz diagonal de autovalores e matrizes de autovetores."""

    pass


  def getRaizQuadradaMatricialImaginarios(self) -> Matriz:
    """Retorna os componentes imaginários da 'matriz raiz quadrada' da matriz atual, dada que a matriz atual é uma matriz quadrada e simétrica.<BR>
 Para mais informações, consulte o comentário de {@link Matriz#getRaizQuadradaMatricial() getRaizQuadradaMatricial}."""

    pass


  def getRegressaoLinearMultipla(self, colunasX, colunaY, calculaInterseccao) -> RegressaoMultipla:
    """Dadas mais de duas colunas da matriz contendo valores numéricos, onde uma
 das colunas depende das demais, aplica o método estatístico da regressão
 linear múltipla (a relação entre a variável e as dependentes pode ser
 aproximada por um "hiperplano").<BR>
 As variáveis são as "colunas" da matriz indicadas nos parâmetros. As
 variáveis "independentes" são as colunas "X" e a variável dependente é a
 coluna "Y".<BR>
 Se alguma célula nas colunas informadas não contiver um valor numérico
 válido (isto é, se for um valor "omisso"), considera que seu valor é 0.<BR>"""

    pass


  def getRegressaoLinearMultipla(self, colunasX, colunaY) -> RegressaoMultipla:
    """Dadas mais de duas colunas da matriz contendo valores numéricos, onde uma
 das colunas depende das demais, aplica o método estatístico da regressão
 linear múltipla (a relação entre a variável e as dependentes pode ser
 aproximada por um "hiperplano").<BR>
 As variáveis são as "colunas" da matriz indicadas nos parâmetros. As
 variáveis "independentes" são as colunas "X" e a variável dependente é a
 coluna "Y".<BR>
 Se alguma célula nas colunas informadas não contiver um valor numérico
 válido (isto é, se for um valor "omisso"), considera que seu valor é 0.<BR>
 OBS: este método procura um modelo de regressão onde não há o termo 'intersecção' (isto é,
 o hiperplano encontrado passa pela origem). Caso queira considerar o termpo 'intersecção'
 no modelo de regressão, utilize a outra alternativa deste método."""

    pass


  def getRegressaoLinearSimples(self, colunaX, colunaY) -> RegressaoSimples:
    """Dadas duas colunas da matriz contendo valores numéricos, aplica o método
 estatístico da regressão linear simples (melhor reta que passa por todos
 os pontos). Cada "ponto" é definido utilizando um valor da coluna
 identificada pelo parâmetro "colunaX" e um valor correspondente da coluna
 identificada pelo parâmetro "colunaY"."""

    pass


  def getSVDMatrizS(self) -> Matriz:
    """Aplica a decomposição em valores singulares (SVD) sobre a matriz e retorna a matriz 'S', que
 corresponde à matriz diagonal com os valores singulares."""

    pass


  def getSVDMatrizU(self) -> Matriz:
    """Aplica a decomposição em valores singulares (SVD) sobre a matriz e retorna a matriz 'U', que
 corresponde à matriz ortogonal cujas colunas correspondem aos vetores singulares à esquerda."""

    pass


  def getSVDMatrizV(self) -> Matriz:
    """Aplica a decomposição em valores singulares (SVD) sobre a matriz e retorna a matriz 'V', que
 corresponde à matriz ortogonal cujas colunas correspondem aos vetores singulares à direita."""

    pass


  def getSoma(self, coluna) -> float:
    """Calcula a soma dos valores de uma determinada coluna da matriz"""

    pass


  def getSoma(self) -> float:
    """Calcula a soma de todos os elementos da matriz (isto é, todas as
 linhas e todas as colunas). O resultado é um escalar representando
 esta soma.<BR>
 OBS: se quiser que a soma seja individualizada por linhas ou
 por colunas, utilize os métodos alternativos."""

    pass


  def getSomaColunas(self) -> Matriz:
    """Calcula a soma considerando todos os valores de uma mesma coluna.<BR>
 O resultado é uma matriz-linha onde cada coluna é uma somatória."""

    pass


  def getSomaLinhas(self) -> Matriz:
    """Calcula a soma considerando todos os valores de uma mesma linha.<BR>
 O resultado é uma matriz-coluna onde cada linha é uma somatória."""

    pass


  def getTituloColuna(self, coluna) -> str:
    """Retorna o título que foi previamente atribuído a uma determinada coluna da matriz"""

    pass


  def getTituloLinha(self, linha) -> str:
    """Retorna o título que foi previamente atribuído a uma determinada linha da matriz"""

    pass


  def getTitulosColunas(self) -> list:
    """Retorna todos os títulos de colunas que foram previamente atribuídos a esta matriz. Cada posição da lista corresponde
 a uma coluna."""

    pass


  def getTitulosLinhas(self) -> list:
    """Retorna todos os títulos de linhas que foram previamente atribuídos a esta matriz. Cada posição da lista corresponde
 a uma linha."""

    pass


  def getTraco(self) -> float:
    """Calcula o 'traço' da matriz, que é a 'soma' dos valores na diagonal principal da matriz."""

    pass


  def getTransposta(self) -> Matriz:
    """Retorna uma matriz 'transposta' em relação à matriz atual. Isto é, as linhas se tornam
 colunas e as colunas se tornam linhas. A diagonal principal não é afetada por esta operação.<BR>
 A matriz atual não é afetada por esta operação."""

    pass


  def hasTitulosColunas(self) -> bool:
    """Retorna a indicação de que pelo menos um título de coluna já foi atribuído."""

    pass


  def hasTitulosLinhas(self) -> bool:
    """Retorna a indicação de que pelo menos um título de linha já foi atribuído."""

    pass


  def inverteColunas(self) -> None:
    """Inverte todas as colunas da matriz, de modo que a primeira coluna troque de lugar com a última coluna, a segunda coluna
 troque de lugar com a penúltima coluna, e assim sucessivamente."""

    pass


  def inverteColunas(self, coluna1, coluna2) -> None:
    """Troca de posição as duas colunas indicadas como parâmetro. As demais colunas são mantidas como estão."""

    pass


  def inverteLinhas(self, linha1, linha2) -> None:
    """Troca de posição as duas linhas indicadas como parâmetro. As demais linhas são mantidas como estão."""

    pass


  def inverteLinhas(self) -> None:
    """Inverte todas as linhas da matriz, de modo que a primeira linha troque de lugar com a última linha, a segunda linha
 troque de lugar com a penúltima linha, e assim sucessivamente."""

    pass


  def isDiagonal(self) -> bool:
    """Retorna a indicação de que esta matriz é uma matriz 'diagonal'. Ou seja,
 indica que todos os elementos fora da diagonal principal são iguais a 0."""

    pass


  def isOrtogonal(self) -> bool:
    """Retorna a indicação de que esta matriz é uma matriz 'ortogonal'. Ou seja,
 indica que é uma matriz quadrada e que A * A' = I."""

    pass


  def isPositivaDefinida(self) -> bool:
    """Retorna a indicação de que esta matriz é uma matriz simétrica 'positiva definida'. Ou seja,
 se denotarmos esta matriz pela letra "A" e se denotarmos por "z" qualquer 'vetor' de números
 reais, então o resultado da operação matricial z' * A * z é sempre positivo, para qualquer "z"."""

    pass


  def isSimetrica(self) -> bool:
    """Retorna a indicação de que esta matriz é uma matriz 'simétrica'. Ou seja,
 o elemento Aij (i-ésima linha da j-ésima coluna) é igual ao elemento Aji (j-ésima
 linha da i-ésima coluna)."""

    pass


  def isSingular(self) -> bool:
    """Retorna a indicação de que esta matriz é uma matriz 'singular'. Ou seja,
 indica que ela não possui 'inversa'. Ou seja, indica que seu determinante é zero."""

    pass


  def moveLinhas(self, primeiraLinha, ultimaLinha, posicoes) -> None:
    """Move um conjunto de linhas da tabela algumas posições para frente ou para trás. Os 'espaços deixados para trás' são ocupados
 pelas linhas posteriores ou anteriores.<BR>
 Por exemplo, se a matriz possui em linhas diferentes os números "1", "2", "3" e "4" e se a segunda e terceira linhas são 'movidas'
 uma posição para frente (isto é, para 'baixo' na matriz), então a matriz passa a listar linhas com conteúdos "1", "4", "2" e "3".<BR>
 Se as linhas forem movidas para uma posição anterior à primeira, mantém na primeira linha. Se forem movidas para uma posição posterior
 à última, mantém na última linha. Para mover uma única linha, informe o mesmo número nos parâmetros 'primeiraLinha' e 'ultimaLinha'"""

    pass


  def multiplica(self, matriz) -> Matriz:
    """Multiplica a matriz atual com outra matriz, indicada no parâmetro, e retorna o resultado na forma
 de uma nova matriz. Se a quantidade de colunas da matriz atual não coincidir com a quantidade de linhas da matriz
 indicada no parâmetro, gera erro.<BR>
 Note que a ordem da multiplicação matricial é relevante. Se a matriz atual é "A" e a matriz indicada no parâmetro
 é "B", este método calcula A x B.<BR>
 A nova matriz resultante possuirá a quantidade de linhas da matriz atual e a quantidade de colunas da matriz indicada
 como parâmetro.
 A matriz atual e a matriz indicada no parâmetro não são afetadas por esta operação."""

    pass


  def multiplicaConstante(self, valor) -> Matriz:
    """Multiplica um mesmo valor constante em todas as células da matriz."""

    pass


  def padronizaColuna(self, coluna) -> None:
    """Padroniza os valores de uma coluna específica. Isto é, dados os valores da coluna, subtrai pela média da coluna e divide pelo
 desvio padrão da coluna."""

    pass


  def padronizaColunas(self) -> None:
    """Padroniza os valores de cada coluna. Isto é, dados os valores de uma coluna, subtrai pela média da coluna e divide pelo
 desvio padrão da coluna."""

    pass


  def padronizaColunas(self, subtraendo, denominador) -> None:
    """Padroniza os valores de cada coluna utilizando os valores indicados nos parâmetros.<BR>
 OBS: se quiser padronizar as colunas subtraindo pela média e dividindo pelo desvio padrão de cada coluna, utilize o método alternativo sem parâmetros.<BR>
 O presente método é útil quando se deseja aplicar uma mesma transformação sobre um novo conjunto de dados que podem ter médias diferentes e desvios padrões diferentes
 de um outro conjunto de dados anterior de onde foram calculadas estas estatísticas."""

    pass


  def paraDiagonal(self) -> None:
    """Transforma o conteúdo da matriz atual (supondo que seja uma matriz-linha ou uma matriz-coluna) em uma matriz diagonal
 onde os elementos da diagonal principal são os elementos da matriz atual (da linha ou da coluna). Se a matriz atual
 não for uma matriz-linha ou uma matriz-coluna (isto é, se houver mais de uma linha e mais de uma coluna), esta função gera erro.<BR>"""

    pass


  def paraMatrizColuna(self) -> None:
    """Transforma o conteúdo da matriz atual em uma matriz coluna, onde todos os dados da matriz são dispostos em uma única coluna.<BR>
 Começa pelos dados da primeira coluna da metriz, continuando com os dados da segunda coluna da matriz, e assim sucessivamente."""

    pass


  def paraMatrizLinha(self) -> None:
    """Transforma o conteúdo da matriz atual em uma matriz linha, onde todos os dados da matriz são dispostos em uma única linha.<BR>
 Começa pelos dados da primeira linha da metriz, continuando com os dados da segunda linha da matriz, e assim sucessivamente."""

    pass


  def paraTabela(self) -> Tabela:
    """Converte a matriz para um objeto do tipo {@link Tabela Tabela}. As linhas da tabela
 criada são as linhas da matriz atual e as colunas da tabela criada são as colunas da
 matriz atual. Todas as colunas da tabela são definidas com o formato 'DECIMAL'. Não há títulos
 para as colunas e nem nome para a tabela."""

    pass


  def potencia(self, potencia) -> Matriz:
    """Aplica um cálculo análogo à 'elevação a uma determinada potência'. A operação depende da potência indicada no parâmetro.<BR>
 Supondo que a matriz atual seja identificada pela letra "A", o resultado desta operação será um dos seguintes dependendo
 da potência 'p':<BR>
 se p >= 1, calcula A*A*...*A.<BR>
 se p == 0, retorna a matriz identidade.<BR>
 se p < 0,  calcula invA * invA * ... * invA (onde invA é a inversa da matriz A).<BR>
 A matriz atual não é afetadas por esta operação.<BR>
 OBS: caso a potência seja negativa e caso a matriz atual não seja inversível (isto é, caso seu determinante seja 0), esta função
 resulta em erro."""

    pass


  def preencheColuna(self, coluna, lista, ampliaSeNecessario) -> None:
    """Preenche uma coluna da matriz com valores de uma lista, substituindo os valores existentes na coluna por novos valores.<BR>
 Caso a coluna existente na matriz possua mais linhas do que elementos existentes na lista, os elementos excedentes existentes na matriz
 são preservados.<BR>"""

    pass


  def preencheColuna(self, coluna, lista, ampliaSeNecessario, linhaInicial) -> None:
    """Preenche uma coluna da matriz com valores de uma lista, substituindo os valores existentes na coluna por novos valores.<BR>
 Caso a coluna existente na matriz possua mais linhas do que elementos existentes na lista, os elementos excedentes existentes na matriz
 são preservados.<BR>"""

    pass


  def preencheColuna(self, coluna, lista) -> None:
    """Preenche uma coluna da matriz com valores de uma lista, substituindo os valores existentes na coluna por novos valores.<BR>
 Caso a coluna existente na matriz possua mais linhas do que elementos existentes na lista, os elementos excedentes existentes na matriz
 são preservados.<BR>"""

    pass


  def preencheLinha(self, linha, lista) -> None:
    """Preenche uma linha da matriz com valores de uma lista, substituindo os valores existentes na linha por novos valores.<BR>
 Caso a linha existente na matriz possua mais colunas do que elementos existentes na lista, os elementos excedentes existentes na matriz
 são preservados.<BR>"""

    pass


  def preencheLinha(self, linha, lista, ampliaSeNecessario) -> None:
    """Preenche uma linha da matriz com valores de uma lista, substituindo os valores existentes na linha por novos valores.<BR>
 Caso a linha existente na matriz possua mais colunas do que elementos existentes na lista, os elementos excedentes existentes na matriz
 são preservados.<BR>"""

    pass


  def preencheLinha(self, linha, lista, ampliaSeNecessario, colunaInicial) -> None:
    """Preenche uma linha da matriz com valores de uma lista, substituindo os valores existentes na linha por novos valores.<BR>
 Caso a linha existente na matriz possua mais colunas do que elementos existentes na lista, os elementos excedentes existentes na matriz
 são preservados.<BR>"""

    pass


  def preencheParte(self, colunaInicial, linhaInicial, parte, ampliaSeNecessario) -> None:
    """Preenche uma parte da matriz, compreendendo uma ou mais linhas e uma ou mais colunas.<BR>
 Substitui os valores da matriz pelos valores de outra matriz que é indicada no parâmetro.<BR>"""

    pass


  def removeColuna(self, coluna) -> bool:
    """Remove uma determinada coluna da matriz"""

    pass


  def removeLinha(self, linha) -> bool:
    """Remove uma determinada linha da matriz"""

    pass


  def removeTitulosColunas(self) -> None:
    """Remove todos os 'títulos de colunas' que foram previamente atribuídos a esta matriz"""

    pass


  def removeTitulosLinhas(self) -> None:
    """Remove todos os 'títulos de linhas' que foram previamente atribuídos a esta matriz"""

    pass


  def setCelula(self, linha, coluna, valor) -> None:
    """Insere um valor na matriz, em uma determinada linha e uma determinada
 coluna."""

    pass


  def setCelulas(self, linha, coluna, valores) -> None:
    """Dada uma determinada posição da matriz, começando em uma determinada linha e coluna,
 altera um ou mais valores na mesma linha."""

    pass


  def setDimensoes(self, linhas, colunas) -> None:
    """Altera a quantidade de linhas e de colunas da matriz. Se for um número maior, preenche com zeros.<BR>
 Se for um número menor de colunas, corta as colunas à direita.<BR>
 Se for um número menor de linhas, corta as linhas inferiores."""

    pass


  def setNumColunas(self, colunas) -> None:
    """Altera a quantidade de colunas da matriz. Se for um número maior, preenche com zeros. Se for um número menor, corta as colunas à direita."""

    pass


  def setNumLinhas(self, linhas) -> None:
    """Altera a quantidade de linhas da matriz. Se for um número maior, preenche com zeros. Se for um número menor, corta as linhas inferiores."""

    pass


  def setTituloColuna(self, coluna, titulo) -> None:
    """Atribui um título para uma determinada coluna da matriz."""

    pass


  def setTituloLinha(self, linha, titulo) -> None:
    """Atribui um título para uma determinada linha da matriz."""

    pass


  def setTitulosColunas(self, colunas) -> None:
    """Atribui novos títulos para todas as colunas da matriz. Cada coluna corresponde a uma posição do vetor
 indicado no parâmetro (o primeiro elemento corresponde ao título da coluna 0, o segundo corresponde à coluna 1, e assim em diante).<BR>
 Caso sejam fornecidos mais títulos do que há colunas disponíveis, os títulos remanescentes não são considerados."""

    pass


  def setTitulosLinhas(self, linhas) -> None:
    """Atribui novos títulos para todas as linhas da matriz. Cada linha corresponde a uma posição do vetor
 indicado no parâmetro (o primeiro elemento corresponde ao título da linha 0, o segundo corresponde à linha 1, e assim em diante).<BR>
 Caso sejam fornecidos mais títulos do que há linhas disponíveis, os títulos remanescentes não são considerados."""

    pass


  def setTodasCelulas(self, valor) -> None:
    """Insere um mesmo valor em todas as células da matriz."""

    pass


  def soma(self, matriz) -> Matriz:
    """Soma a matriz atual com outra matriz, indicada no parâmetro, e retorna o resultado na forma
 de uma nova matriz. Se as matrizes não tiverem a mesma quantidade de linhas e colunas, gera erro.<BR>
 A matriz atual e a matriz indicada no parâmetro não são afetadas por esta operação."""

    pass


  def somaConstante(self, valor) -> Matriz:
    """Soma um mesmo valor constante em todas as células da matriz."""

    pass


  def somaFormula(self, formula, primeiraLinha, quantidadeLinhas) -> float:
    """Método alternativo onde é possível indicar a primeira linha da matriz onde a fórmula deve ser calculada e também a quantidade total de linhas
 que devem ser calculadas.<BR>
 Veja mais comentários na documentação do método alternativo."""

    pass


  def somaFormula(self, formula) -> float:
    """Percorre todas as linhas da matriz calculando uma fórmula. Retorna a somatória de todos os valores calculados.<BR>"""

    pass


  def subtrai(self, matriz) -> Matriz:
    """Subtrai da matriz atual uma outra matriz, indicada no parâmetro, e retorna o resultado na forma
 de uma nova matriz. Se as matrizes não tiverem a mesma quantidade de linhas e colunas, gera erro.<BR>
 A matriz atual e a matriz indicada no parâmetro não são afetadas por esta operação."""

    pass


  def trocaValoresInfinitos(self, novoValor) -> bool:
    """Se a matriz possui alguma célula contendo um valor numérico que represente 'infinito' (geralmente
 resultado de alguma divisão por zero), esta função pode ser utilizada para trocar esses valores por outro. O 
 valor para o qual eles devem ser trocados é o valor indicado no parâmetro."""

    pass

class Matrizes ():
  """Objeto que pode ser utilizado por um script para criar outros objetos do tipo {@link Matriz Matriz}.<BR>
 Na linguagem de script este objeto 'gerador de matrizes' é identificado pelo nome de variável 'matrizes'.<BR>"""

  def comparaMatrizes(self, m1, m2, tolerancia) -> bool:
    """Compara os elementos de uma matriz com os elementos de outra matriz.<BR>
 Se os elementos de uma matriz forem iguais ou muito próximos aos elementos de outra matriz,
 retorna VERDADEIRO. Caso contrário, retorna FALSO.<BR>
 Se a quantidade de linhas e colunas de uma matriz forem diferentes em relação à outra matriz, retorna FALSO independentemente de seu conteúdo.<BR>
 Nesta comparação indica-se um valor de 'tolerância'. Se ele é igual a 0, a comparação é feita com a precisão numérica da máquina."""

    pass


  def juntaMatrizesHorizontal(self, esquerda, direita) -> Matriz:
    """Dadas duas matrizes quaisquer, cria uma nova matriz com o conteúdo de ambas, considerando
 a segunda matriz à direita da primeira matriz (isto é, suas colunas sucedem as colunas da primeira matriz).<BR>
 A quantidade de colunas na matriz resultado é a soma das quantidades de colunas das duas matrizes.<BR>
 A quantidade de linhas na matriz resultado é a igual à quantidade de linhas da primeira matriz, a menos que a
 segunda matriz tenha mais linhas. Nesta última hipótese, considera a mesma quantidade de linhas da segunda matriz."""

    pass


  def juntaMatrizesVertical(self, acima, abaixo) -> Matriz:
    """Dadas duas matrizes quaisquer, cria uma nova matriz com o conteúdo de ambas, considerando
 a segunda matriz abaixo da primeira matriz (isto é, suas linhas sucedem as linhas da primeira matriz).<BR>
 A quantidade de linhas na matriz resultado é a soma das quantidades de linhas das duas matrizes.<BR>
 A quantidade de colunas na matriz resultado é a igual à quantidade de colunas da primeira matriz, a menos que a
 segunda matriz tenha mais colunas. Nesta última hipótese, considera a mesma quantidade de colunas da segunda matriz."""

    pass


  def novaMatriz(self, linhas, colunas, valores) -> Matriz:
    """Cria uma nova 'matriz' com um determinado número de linhas e colunas, já informando também seus valores.<BR>
 Os valores são indicados no terceiro parâmetro e são interpretados da seguinte forma: primeiro os valores da
 primeira linha da matriz, depois os valores da segunda linha da matriz, e assim sucessivamente.<BR>"""

    pass


  def novaMatriz(self, linhas, colunas) -> Matriz:
    """Cria uma nova 'matriz' com um determinado número de linhas e colunas.<BR>
 OBS: caso queira criar uma matriz muito grande (digamos, com milhões de linhas ou colunas), onde a maior
 parte dela seja composta de zeros, utilize o método {@link Matrizes#novaMatrizEsparsa(int, int) novaMatrizEsparsa} no lugar
 deste, pois assim há maior economia de memória na representação interna da matriz. Por outro lado, se a matriz contém bastante
 números 'não zero', este método é melhor."""

    pass


  def novaMatrizDiagonal(self, valores) -> Matriz:
    """Cria uma nova matriz 'diagonal', indicando como parâmetro os valores que devem ser preenchidos na diagonal da matriz (os demais
 valores são preenchidos com zeros)."""

    pass


  def novaMatrizEsparsa(self, linhas, colunas) -> Matriz:
    """Cria uma nova 'matriz' com um determinado número de linhas e colunas.<BR>
 Este método é preferível quando se deseja criar uma matriz 'esparsa'. Por matriz 'esparsa', entende-se uma matriz
 onde a maior parte dela seja povoada por 'zeros'. É muito comum quando se trabalha com cálculos de probabilidades
 em situações envolvendo muitos dados 'raros' (isto é, onde a probabilidade é próxima de zero ou igual a zero).<BR>"""

    pass


  def novaMatrizIdentidade(self, tamanho) -> Matriz:
    """Cria uma nova 'matriz identidade', que é uma matriz 'quadrada', com a quantidade de linhas igual à quantidade
 de colunas, igual ao parâmetro indicado, onde os elementos da 'diagonal principal' são iguais a 1 e todos
 os demais são iguais a zero."""

    pass


  def novaMatrizIdentidade(self, tamanho, esparsa) -> Matriz:
    """Cria uma nova 'matriz identidade', que é uma matriz 'quadrada', com a quantidade de linhas igual à quantidade
 de colunas, igual ao parâmetro indicado, onde os elementos da 'diagonal principal' são iguais a 1 e todos
 os demais são iguais a zero."""

    pass


  def novaMatrizRotacao(self, tamanho, col1, col2, angulo) -> Matriz:
    """Cria uma nova 'matriz rotação'.<BR>
 Uma 'matriz rotação' é uma matriz que, quando multiplicada por um vetor ou outra matriz, produz o efeito correspondente a uma 'rotação de eixos'.<BR>
 Por exemplo, dado um vetor de dimensão 2 identificado pelos valores [1 0], que pode ser interpretado geometricamente como sendo o 'ponto' localizado sobre o 'plano'
 com coordenada 'x' igual a 1 e coordenada 'y' igual a 0, podemos 'rotacioná-lo' em torno da 'origem' (ponto [0 0]) em 45 graus no sentido anti-horário
 se multiplicarmos a matriz rotação a ele, sendo a matriz rotação gerada por esta função, indicando como parâmetro 'angulo' o valor correspondente a -pi/4 (onde pi/4 corresponde a 45 graus em radianos)."""

    pass


  def novoVetor(self, valores) -> Matriz:
    """Cria um novo 'vetor' (no sentido matemático), que aqui é implementado na forma de uma 'matriz-coluna', onde há uma só
 coluna e diversos valores dispostos em linhas distintas. Inicialmente o 'vetor' está preenchido com os valores indicados no parâmetro."""

    pass


  def novoVetor(self, tamanho) -> Matriz:
    """Cria um novo 'vetor' (no sentido matemático), que aqui é implementado na forma de uma 'matriz-coluna', onde há uma só
 coluna e diversos valores dispostos em linhas distintas. Inicialmente o 'vetor' está preenchido com zeros."""

    pass

class MensagemTexto ():
  """Interface de script que representa uma mensagem de texto que deve ser exibida de alguma forma
 ao usuário do script. Pode ser alguma mensagem de aviso normal, ou uma mensagem de erro, ou algum
 texto simples."""

  def getCorFundo(self) -> Cor:
    """Cor a ser apresentada no painel de fundo do texto. Se for NULL, utiliza a cor padrão. É ignorado se a mensagem for do tipo 'erro'."""

    pass


  def getCorTexto(self) -> Cor:
    """Cor a ser apresentada no texto. Se for NULL, utiliza a cor padrão. É ignorado se a mensagem for do tipo 'erro'."""

    pass


  def getMensagem(self) -> str:
    """Mensagem que deve ser exibida"""

    pass


  def getTamanhoFonte(self) -> int:
    """Tamanho a ser utilizado na fonte com que o texto é apresentado. Se for 0, utiliza o tamanho padrão. É ignorado se a mensagem for do tipo 'erro'."""

    pass


  def hasQuebraLinhaAutomatica(self) -> bool:
    """Indica que deve haver quebra de linha automática sobre o texto durante sua exibição"""

    pass


  def isHTML(self) -> bool:
    """Indica se o conteúdo do texto deve ser tratado como um conteúdo HTML (isto é, as 'tags' devem ser interpretadas de acordo com o padrão HTML, e não como texto simples). É ignorado se a mensagem for do tipo 'erro'."""

    pass


  def isTipoErro(self) -> bool:
    """Indica que a mensagem é indicativa de 'erro' e deve ser exibida conforme o padrão de exibição de mensagens de erro."""

    pass


  def setCorFundo(self, corFundo) -> None:
    """Cor a ser apresentada no painel de fundo do texto. Se for NULL, utiliza a cor padrão. É ignorado se a mensagem for do tipo 'erro'."""

    pass


  def setCorTexto(self, corTexto) -> None:
    """Cor a ser apresentada no texto. Se for NULL, utiliza a cor padrão. É ignorado se a mensagem for do tipo 'erro'."""

    pass


  def setHTML(self, html) -> None:
    """Indica se o conteúdo do texto deve ser tratado como um conteúdo HTML (isto é, as 'tags' devem ser interpretadas de acordo com o padrão HTML, e não como texto simples). É ignorado se a mensagem for do tipo 'erro'."""

    pass


  def setMensagem(self, mensagem) -> None:
    """Mensagem que deve ser exibida"""

    pass


  def setQuebraLinhaAutomatica(self, quebraLinhaAutomatica) -> None:
    """Indica que deve haver quebra de linha automática sobre o texto durante sua exibição"""

    pass


  def setTamanhoFonte(self, tamanhoFonte) -> None:
    """Tamanho a ser utilizado na fonte com que o texto é apresentado. Se for 0, utiliza o tamanho padrão. É ignorado se a mensagem for do tipo 'erro'."""

    pass


  def setTipoErro(self, tipoErro) -> None:
    """Indica que a mensagem é indicativa de 'erro' e deve ser exibida conforme o padrão de exibição de mensagens de erro."""

    pass

class Menu ():
  """Interface de script que representa um 'menu' com várias opções."""

  def getItens(self) -> str:
    """Itens do menu"""

    pass


  def getMensagem(self) -> str:
    """Mensagem exibida na parte superior do menu"""

    pass


  def getResposta(self) -> str:
    """Retorna o item de menu que foi escolhido"""

    pass


  def getSubrotinas(self) -> str:
    """Retorna as subrotinas que estão associadas a cada um dos itens de menu isoladamente (isto é, são executadas para cada item)<BR>
 Podem ser indicados simplesmente os nomes das subrotinas.<BR>
 Caso seja desejável passar parâmetros para execução da subrotina, os parâmetros podem ser indicados entre parentesis, após o nome da subrotina.<BR>
 Caso seja desejável executar subrotina definida em outro script, pode-se indicar o nome do script antes do nome da subrotina, separando-os com o caractere '|'."""

    pass


  def isTeclasAtalho(self) -> bool:
    """Indica se associa ou não teclas de atalho (F1, F2, etc.) aos 10 primeiros itens de menu"""

    pass


  def setItens(self, itens) -> None:
    """Itens do menu"""

    pass


  def setMensagem(self, mensagem) -> None:
    """Mensagem exibida na parte superior do menu"""

    pass


  def setSubrotinas(self, subrotinas) -> None:
    """Define subrotinas para cada um dos itens de menu isoladamente (isto é, cada subrotina corresponde a cada item)<BR>
 Podem ser indicados simplesmente os nomes das subrotinas.<BR>
 Caso seja desejável passar parâmetros para execução da subrotina, os parâmetros podem ser indicados entre parentesis, após o nome da subrotina.<BR>
 Caso seja desejável executar subrotina definida em outro script, pode-se indicar o nome do script antes do nome da subrotina, separando-os com o caractere '|'."""

    pass


  def setTeclasAtalho(self, teclasAtalho) -> None:
    """Indica se associa ou não teclas de atalho (F1, F2, etc.) aos 10 primeiros itens de menu"""

    pass

class MenuImagens ():
  """Interface de script que representa um 'menu' com várias opções incluindo imagens."""

  def getImagens(self) -> Imagem:
    """Retorna a relação de imagens que foram definidas aos itens de menu (uma imagem para cada item, podendo repetir a mesma imagem em vários itens)"""

    pass


  def getMensagem(self) -> str:
    """Mensagem adicional exibida no menu"""

    pass


  def getResposta(self) -> str:
    """Retorna o item de menu que foi escolhido"""

    pass


  def getSubrotinas(self) -> str:
    """Retorna as subrotinas que estão associadas a cada um dos itens de menu isoladamente (isto é, são executadas para cada item)"""

    pass


  def getTextos(self) -> str:
    """Textos que devem ser exibidos ao lado das imagens. O texto retornado pelo método será uma dessas opções, ou NULL se o usuário desistiu ou cancelou."""

    pass


  def setImagens(self, imagens) -> None:
    """Define a relação de imagens que foram definidas aos itens de menu (uma imagem para cada item, podendo repetir a mesma imagem em vários itens)"""

    pass


  def setImagensInternas(self, imagens, larguraImagens, alturaImagens) -> None:
    """Define a relação de imagens que foram definidas aos itens de menu (uma imagem para cada item, podendo repetir a mesma imagem em vários itens)<BR>
 Neste método são indicados os nomes das imagens que devem ser apresentadas, indicando apenas os nomes de ícones internos do Contágil<BR>
 Para utilizar imagens externas, mantidas em arquivos ou na Web, utilize o outro método com objetos {@link Imagem Imagem}<BR>"""

    pass


  def setMensagem(self, mensagem) -> None:
    """Mensagem adicional exibida no menu"""

    pass


  def setSubrotinas(self, subrotinas) -> None:
    """Define subrotinas para cada um dos itens de menu isoladamente (isto é, cada subrotina corresponde a cada item)"""

    pass


  def setTextos(self, textos) -> None:
    """Textos que devem ser exibidos ao lado das imagens. O texto retornado pelo método será uma dessas opções, ou NULL se o usuário desistiu ou cancelou."""

    pass

class ModeloRelatorio ():
  """Este objeto representa um "modelo de relatório".<BR>
 Isto é: algo que pode ser utilizado como um "modelo" para gerar relatórios.
 <P>
 
 Atualmente apenas arquivos do padrão OpenOffice (ou BROffice) de extensão
 "ODT" podem ser utilizados como "modelos de relatórios".
 <P>
 
 Você pode abrir um arquivo existente deste padrão através do método
 {@link GerenciadorArquivos#abrirModelo(String, String) abrirModelo}.
 <P>
 
 Você pode também trabalhar com um arquivo que foi <B>anexado</B> ao script
 (neste caso ele já se encontra <I>aberto</I> e associado a um nome de
 variável, que é o mesmo nome atribuído ao anexo).
 <P>
 
 Depois de aberto, você pode "alterar" o conteúdo de alguns "campos" deste
 modelo através de métodos como
 {@link ModeloRelatorio#setCampo(String, Object) setCampo} e
 {@link ModeloRelatorio#setTabela(String, Tabela) setTabela}.
 <P>
 
 IMPORTANTE: é necessário que o arquivo do padrão OpenOffice (ou BROffice)
 defina e posicione os "campos" que estão sendo utilizados pelo script. Se
 isso não for feito, não há como saber onde esses "campos" devem aparecer no
 relatório.
 <P>
 
 COMO GERAR CAMPOS DE VALORES SINGULARES NO ARQUIVO DE "MODELO" PELO BR
 OFFICE:<BR>
 ==============================================================================<BR>
 Para criar um campo no BROffice que poderá ser depois utilizado pelo script
 do ContÁgil para preencher um determinado valor, siga as instruções abaixo:<BR>
 1) Com o documento aberto no BROffice, posicione o cursor no lugar do
 relatório onde pretende inserir o campo.<BR>
 2) Clique no menu "Inserir", item "Campos", item "Outros", ou simplesmente
 pressione CTRL+F2.<BR>
 3) Na janela "Campos" do BROffice, clique na aba "Funções".<BR>
 4) Na aba "Funções" da janela "Campos", na lista "Tipo", escolha a opção
 "Campo de entrada".<BR>
 5) Na aba "Funções" da janela "Campos", no campo "Referência", preencha o
 nome do campo. Por exemplo: "NOME".<BR>
 6) Pressione o botão "Inserir" da janela "Campos". Abre-se uma nova janela.<BR>
 7) Na nova janela "Campo de entrada" que é apresentada, no campo vazio logo
 abaixo do nome, repita o mesmo nome do campo. Por exemplo: "NOME".<BR>
 8) Pressione o botão "OK" para fechar a janela "Campo de entrada".<BR>
 9) Pressione o botão "Fechar" para fechar a janela "Campos".<BR>
 10) Você vai notar que agora, no relatório, aparece um texto pintado de cinza
 com o mesmo nome que foi preenchido nos passos anteriores. Este conteúdo será
 substituído por outro conforme o que for passado pelo script na função
 {@link ModeloRelatorio#setCampo(String, Object) setCampo}.
 <P>
 
 COMO INCLUIR NO MENU "INSERIR" O COMANDO "SCRIPT" (VERSÕES A PARTIR DA 5.1.1):<BR>
 ==============================================================================<BR>
 Nas versões do BROffice que, após a sua instalação, não possuírem no menu 
 "Inserir" o comando "Script...", deverão ser utilizados os passos a seguir.<BR>
 para que seja feita a sua inclusão:<br>
 1) usando a opção "Ferramentas/Personalizar...", selecionar a ficha "Menus".
 2) Na caixa "Menus do BROffice/Menu", selecionar "Inserir".
 3) Acionar o botão "Adicionar".<B>
 4) Na janela "Adicionar Comandos", escolher a categoria "Inserir" e o comando 
 "Script", e acionar o botão "Adicionar".<BR>
 5) Com isso, o item de menu "Inserir/Script" ficará disponível.<BR>
 A inclusão de "Inserir/Script..." viabilizará os procedimentos descritos a seguir 
 para complementação do arquivo de "modelo" em elaboração no BROffice.
 <P>
 
 COMO GERAR CAMPOS DE TABELAS NO ARQUIVO DE "MODELO" PELO BR OFFICE:<BR>
 ===================================================================<BR>
 Para criar um campo que na realidade representa uma "tabela" (isto é, uma
 relação de valores dispostos em linhas e colunas e que são preenchidos pelo
 script do ContÁgil), siga as instruções abaixo:<BR>
 1) Com o documento aberto no BROffice, desenhe o "modelo" da tabela. Isto é,
 aplique alguma moldura (se desejar moldura), defina a quantidade de colunas
 (se houver mais de uma coluna), defina uma linha de cabeçalho (se desejar ter
 um) e, por fim, insira uma única linha nesta tabela (isto é, além da linha de
 cabeçalho, caso exista alguma). Fique à vontade para definir cores ou outros
 elementos visuais sobre a tabela.<BR>
 2) Com o cursor posicionado sobre a primeira célula da linha vazia (isto é,
 se há uma linha de cabeçalho, então será a segunda linha da tabela), clique
 no menu "Inserir", item "Script...". Abre-se a janela "Inserir Script".<BR>
 3) Na janela "Inserir Script", preencha no campo "Tipo do script" o conteúdo
 "JODScript" (note que não é "JavaScript", é "JODScript").<BR>
 4) Marque a opção "Texto" (se a opção "URL" estava marcada, ela ficará
 desmarcada).<BR>
 5) Preencha o campo vazio com o seguinte conteúdo, trocando a palavra
 MEU-CAMPO-TABELA pelo nome do seu campo tabela (ex: "TABELA"):<BR>
 <CODE> &lt;forEach items="MEU-CAMPO-TABELA"<BR>
 &nbsp;&nbsp;&nbsp;var="m"<BR>
 &nbsp;&nbsp;&nbsp;element="table-row"/&gt;<BR>
 </CODE> 6) Pressione o botão "OK" para fechar a janela "Inserir Script".<BR>
 7) Note que agora aparece um pequeno retângulo verde-escuro na posição onde
 está o cursor. Isso representa o "script" que acabou de ser inserido no
 relatório (trata-se de um script do próprio BROffice, não tem relação com o
 script do ContÁgil). Este "script" será responsável por "multiplicar" as
 linhas, fazendo a tabela crescer, até acomodar a quantidade de linhas que o
 script do ContÁgil irá inserir depois. Ou seja, o tamanho da tabela é
 dinâmico, por isso você não precisa se preocupar de antemão em "reservar
 linhas vazias" na tabela. Elas irão aparecer automaticamente.<BR>
 8) Supondo que o cursor continua sobre a primeira célula da linha (agora
 existe um retângulo verde dentro dela), clique no menu "Inserir", item
 "Campos", item "Outros", ou simplesmente pressione CTRL+F2.<BR>
 9) Na janela "Campos" do BROffice, clique na aba "Funções".<BR>
 10) Na aba "Funções" da janela "Campos", na lista "Tipo", escolha a opção
 "Campo de entrada".<BR>
 11) Na aba "Funções" da janela "Campos", no campo "Referência", preencha o
 seguinte: "m.get('COLUNA1')". OBS: não coloque espaços em branco entre
 "COLUNA" e o número "1", e nem utilize letras minúsculas na palavra "COLUNA"
 (escreva exatamente como está escrito aqui).<BR>
 12) Pressione o botão "Inserir" da janela "Campos". Abre-se uma nova janela.<BR>
 13) Na nova janela "Campo de entrada" que é apresentada, no campo vazio logo
 abaixo do nome, escreva "COLUNA1".<BR>
 14) Pressione o botão "OK" para fechar a janela "Campo de entrada".<BR>
 15) Pressione o botão "Fechar" para fechar a janela "Campos".<BR>
 16) Observe agora que além do retângulo verde aparece agora também um texto
 pintado de cinza, escrito "COLUNA1". Isso será substituído pelo script do
 ContÁgil pelo conteúdo da primeira coluna para cada linha da tabela.<BR>
 17) Se a tabela possui mais de uma coluna, as demais colunas desta linha
 devem estar vazias. Repita em cada uma dessas outras colunas os passos
 descritos nos itens 8 a 16 (isto é, apenas os passos necessários para se
 inserir "campos", e não para inserir "script": o script é inserido uma única
 vez na tabela). A diferença é que desta vez você deve utilizar os números
 seguintes na palvra "COLUNA". Por exemplo, para a segunda coluna utilize
 "COLUNA2", e assim em diante (o conteúdo do campo "referência" também tem que
 corresponder ao mesmo número de coluna).<BR>
 18) Terminado o trabalho acima sobre todas as colunas da tabela, repita o
 mesmo procedimento (dos itens 1 a 17) para outras tabelas, lembrando que cada
 tabela do mesmo relatório deve ter um nome diferente. Por exemplo, se na
 primeira tabela, ao executar o passo 5 você utilizou o nome "TABELA", na
 segunda tabela você deve utilizar um nome diferente (ex: TABELA2), e assim em
 diante. Os nomes das colunas, porém devem seguir exatamente o padrão que foi
 comentado acima (ou seja, diferentes tabelas possuirão a coluna "COLUNA1",
 poderão possuir a coluna "COLUNA2", e assim em diante).<BR>
 19) Ao escrever o script do ContÁgil, utilize o método
 {@link ModeloRelatorio#setTabela(String, Tabela) setTabela} para definir o
 conteúdo de cada tabela. Basta associar um objeto do tipo
 {@link Tabela Tabela} ao correspondente campo "TABELA". <BR>
 20) Ao executar o script, o relatório estará com cada tabela preenchida
 conforme os dados apresentados.
 <P>
 
 COMO FAZER COM QUE PARÁGRAFOS DO ARQUIVO ODT POSSAM SER EXIBIDOS OU OCULTADOS:<BR>
 ==============================================================================<BR>
 Os métodos {@link ModeloRelatorio#apresentaParagrafo(String) apresentaParagrafo} e 
 {@link ModeloRelatorio#escondeParagrafo(String) escondeParagrafo} permitem
 apresentar ou ocultar parágrafos do arquivo ODT, o que é particularmente útil quando se pretende
 condicionar a apresentação de tais parágrafos à existência de algum critério no
 script.<BR>
 No entanto, para que isso funcione, é necessário que o parágrafo no arquivo ODT
 contenha um pequeno "script" no seu início (isto é, antes do primeiro caractere
 do parágrafo).<BR>
 O procedimento para inserir este "script" neste parágrafo é bastante similar ao
 que foi apresentado nos tópicos anteriores, mas é um pouco mais simples pois não
 precisamos definir "campos". Definimos apenas um script no ODT, que é utilizado para
 esconder o parágrafo caso o script do ContÁgil assim o determine.<BR>
 1) Com o cursor posicionado sobre o início do parágrafo(isto é,
 antes do primeiro caractere do parágrafo), clique
 no menu "Inserir", item "Script...". Abre-se a janela "Inserir Script".<BR>
 2) Na janela "Inserir Script", preencha no campo "Tipo do script" o conteúdo
 "JODScript" (note que não é "JavaScript", é "JODScript").<BR>
 3) Marque a opção "Texto" (se a opção "URL" estava marcada, ela ficará
 desmarcada).<BR>
 4) Preencha o campo vazio com o seguinte conteúdo, trocando a palavra
 MEU-PARAGRAFO pelo nome do seu parágrafo (ex: "p1"):<BR>
 <CODE> 
 &lt;if test="showParagraph_MEU-PARAGRAFO" element="p"/&gt;<BR>
 </CODE> 6) Pressione o botão "OK" para fechar a janela "Inserir Script".<BR>
 5) Note que agora aparece um pequeno retângulo verde-escuro na posição onde
 está o cursor. Isso representa o "script" que acabou de ser inserido no
 relatório (trata-se de um script do próprio BROffice, não tem relação com o
 script do ContÁgil). Este "script" será responsável por "esconder" o parágrafo
 dependendo do que o script do ContÁgil fizer.<BR>
 6) Feito isso, no script do ContÁgil programe a situação em que o parágrafo
 deve ser apresentado (o padrão é ser ocultado). Para apresentar o parágrafo, basta indicar o "nome" do parágrafo
 que foi preenchido no passo 4 (atentar para diferença de maiúsculas/minúsculas).<BR>
 Ex: se o nome do parágrafo era "p1", então indicar este nome na execução do método 
 {@link ModeloRelatorio#apresentaParagrafo(String) apresentaParagrafo}.<BR>
 <P>
 COMO FAZER COM QUE SESSÕES MAIORES DO ARQUIVO ODT POSSAM SER EXIBIDOS OU OCULTADOS:<BR>
 ===================================================================================<BR>
 A dica anterior ensinou como "esconder" ou "apresentar" um parágrafo de cada vez. Aqui
 ensinaremos como fazer o mesmo com "trechos" maiores (incluindo vários parágrafos, tabelas, etc.).<BR>
 <BR>
 Para fazer isso, utilizaremos o conceito de "sessões" no arquivo ODT.<BR>
 Utilize a opção de menu "Inserir", "Seção..." para inserir uma nova sessão no arquivo. Faça isso na posição 
 anterior à região que pretende ocultar/apresentar no relatório.<BR>
 ATENÇÃO: diferentemente do que ocorre no aplicativo "Word" da "Microsoft", onde é inserida uma "quebra de seção",
 no aplicativo "Writer" do "BR Office" é inserida uma seção "dentro de outra". Isto é, o pequeno retângulo que é
 desenhado ao "inserir seção" é ele próprio a seção inteira! O que vem antes e o que vem depois deste retângulo se
 refere à seção original (é como uma caixa dentro de outra caixa). Deste modo, você precisará também "mover" todo
 o conteúdo que desejar para "dentro" deste retângulo.<BR>
 Logo no início da sessão que pretende ocultar/apresentar, repita quase os mesmos passos descritos na dica
 anterior, mas com uma única diferença: o "JOD Script" do passo 4 deverá ser criado conforme o seguinte padrão:<BR> 
 <CODE> 
 &lt;if test="showParagraph_MEU-PARAGRAFO" element="section"/&gt;<BR>
 </CODE>
 Note que a palavra "showParagraph" permance, mas a palavra "p" foi substituída por "section".<BR>
 <BR>
 Basta seguir os mesmos passos descritos na dica anterior para apresentar/esconder a sessão (no script será tratado
 como se fosse um "parágrafo").<BR> 
 <P>
 <P>"""

  def apresentaItemLista(self, nome) -> None:
    """Exibe um item de uma lista do modelo que é identificado um determinado nome."""

    pass


  def apresentaLinhaTabela(self, nome) -> None:
    """Exibe uma linha de uma tabela do modelo que é identificado um determinado nome."""

    pass


  def apresentaParagrafo(self, nome) -> None:
    """Exibe um parágrafo do modelo que é identificado por um determinado nome."""

    pass


  def apresentaSecao(self, nome) -> None:
    """Exibe uma seção do modelo que é identificada um determinado nome."""

    pass


  def apresentaTabela(self, nome) -> None:
    """Exibe uma tabela do modelo que é identificada um determinado nome."""

    pass


  def criaRelatorio(self, nomeArquivo) -> Arquivo:
    """Exporta o conteúdo deste modelo de relatório, já com os campos alterados,
 para um novo arquivo (o qual segue o mesmo padrão do modelo),
 sobrescrevendo o arquivo que porventura já exista.<BR>"""

    pass


  def escondeItemLista(self, nome) -> None:
    """Esconde um item de uma lista do modelo que é identificado um determinado nome."""

    pass


  def escondeLinhaTabela(self, nome) -> None:
    """Esconde uma linha de uma tabela do modelo que é identificado um determinado nome."""

    pass


  def escondeParagrafo(self, nome) -> None:
    """Esconde um parágrafo do modelo que é identificado por um determinado
 nome."""

    pass


  def escondeSecao(self, nome) -> None:
    """Esconde uma seção do modelo que é identificada um determinado nome."""

    pass


  def escondeTabela(self, nome) -> None:
    """Esconde uma tabela do modelo que é identificada um determinado nome."""

    pass


  def getNome(self) -> str:
    """Retorna o nome que foi definido para este modelo.<BR>
 Se o modelo foi obtido a partir de um arquivo, corresponde ao nome do
 arquivo.<BR>
 Se o modelo foi obtido a partir de um anexo, corresponde ao nome do
 anexo.<BR>"""

    pass


  def novo(self) -> ModeloRelatorio:
    """Cria um novo modelo de relatório a partir do modelo atual."""

    pass


  def setCampo(self, nome, valor) -> None:
    """Atribui um valor a um campo do modelo.<BR>
 OBS: se este campo não existe no modelo, então esta função fica sem
 efeito."""

    pass


  def setImagem(self, nome, imagem, tipo) -> None:
    """Substitui, por uma nova imagem, uma imagem existente em um quadro do modelo.<BR>
 OBS: se o nome da imagem não existir no modelo, então esta função fica sem
 efeito.<BR>
 A imagem deve estar incorporada ao modelo, ou seja, não deverá estar vinculada
 a um arquivo externo."""

    pass


  def setTabela(self, nome, tabela) -> None:
    """Atribui o conteúdo de uma tabela para um campo definido no modelo.<BR>
 OBS: ao contrário de um campo comum, que é ajustado pelo método
 {@link ModeloRelatorio#setCampo(String, Object) setCampo}, este campo
 "tabela" deve ter sido criado no modelo de uma forma especial. Consulte a
 documentação no cabeçalho desta classe para mais informações."""

    pass


  def toString(self) -> str:
    pass

class Ofuscador ():
  """Esta classe pode ser utilizada por uma linguagem de scripting para "ofuscar"
 dados. Isto é, "embaralhar" alguns dados de tal modo que seja impossível
 reconhecer a sua origem.
 <P>

 Este objeto está acessível para a linguagem de script através do nome
 "ofuscador".
 <P>

 OBS: o procedimento realizado por esta classe é diferente da "criptografia".
 Quando se criptografa uma informação (geralmente com o uso de uma chave de
 criptografia), o conteúdo que foi criptografado pode ser recuperado pelo
 processo inverso. Por outro lado, o "ofuscamento" realizado por esta classe
 não requer uso de chave e não pode ser recuperado (isto é, não existe o
 processo inverso).
 <P>

 Por exemplo, digamos que um arquivo contém informações consideradas
 sigilosas, tais como movimentação financeira. Uma forma de compartilhar esses
 dados para o propósito de treinamento, ou suporte, ou testes, consiste em
 embaralhar as informações que identificam o titular (embaralhar o CPF, o
 nome, o número da conta, o número da agência) e também eventualmente
 embaralhar o campo histórico dos lançamentos bancários, restando apenas os
 valores e outras informações que não possam ser utilizadas para rastrear a
 origem.
 <P>

 Esta classe tem comportamento similar à classe {@link Conversor Conversor},
 com a diferença que os resultados produzidos por esta classe estão
 embaralhados (isto é, estão ofuscados).
 <P>

 Utilize nesta classe apenas aquelas informações que deseja ofuscar. As demais
 informações que não se deseja ofuscar não devem ser aplicadas a esta classe.
 Isto é, seja seletivo ao avaliar o que é passível de ofuscamento e o que não
 é.
 <P>

 Por exemplo, em muitas situações pode não ser uma boa idéia ofuscar
 "valores", pois ao fazer isso, esses dados não estarão mais consistentes com
 outros valores que estejam relacionados a ele. Um exemplo clássico é o de um
 arquivo que apresenta três tipos de valores: base de cálculo, alíquota e
 valor calculado do imposto. Se qualquer um dos três valores for "ofuscado",
 eles estarão inconsistentes entre si (isto é, o produto da base de cálculo
 pela alíquota não mais produzirá o valor informado).
 <P>

 Também tenha cuidado ao escolher as "datas" que serão ofuscadas. Geralmente
 uma data que simboliza uma "entrega" pode ser ofuscada sem maiores problemas.
 No entanto, uma data que por definição antecede outra data (ex: data de
 início e de término de apuração) pode acabar ficando inconsistente se ela for
 ofuscada.
 <P>

 <B>OBSERVAÇÃO</B>: Exceto nos casos expressamente indicados de forma
 contrária, os métodos desta classe empregram técnicas de ofuscamento que
 atendem aos seguintes requisitos:<BR>
 1) O que foi ofuscado não pode ser revertido para o conteúdo original, não
 importe quanto esforço é empregado (a menos, é claro, que já se saiba de
 antemão qual é o conteúdo original).<BR>
 2) Se a mesma técnica é aplicada sobre o mesmo conteúdo em momentos
 distintos, o mesmo resultado é sempre gerado.<BR>
 3) Cada técnica contempla características adicionais para se preservar ao
 máximo a consistência da informação (por exemplo, um número CNPJ "ofuscado"
 possui DV válido).<BR>

 Para atender ao objetivo (1) emprega-se na maioria dos casos uma técnica
 conhecida como "<I>message digest</I>" (ou "resumo da mensagem"). Trata-se
 de uma técnica muito empregada em assinaturas digitais, onde por meio de um
 processo numérico é obtida uma seqüência de caracteres de tamanho fixo que
 representa o conteúdo original. Se pouca coisa é alterada no conteúdo
 original, o resultado pode ficar bastante diferente. Não é possível reverter
 o processo (isto é, dado o "resumo da mensagem", obter o conteúdo original).
 <P>"""

  def de(self, data) -> ObjetoOfuscar:
    """Cria um mecanismo de conversão partindo de uma data qualquer."""

    pass


  def de(self, mes) -> ObjetoOfuscar:
    """Cria um mecanismo de conversão partindo de um mês qualquer."""

    pass


  def de(self, numero) -> ObjetoOfuscar:
    """Cria um mecanismo de conversão partindo de um número qualquer (pode ser
 inteiro ou pode ser com casas decimais)."""

    pass


  def de(self, lista) -> ObjetoOfuscar:
    """Cria um mecanismo de conversão partindo de uma lista de objetos (a lista
 será convertida)."""

    pass


  def de(self, texto) -> ObjetoOfuscar:
    """Cria um mecanismo de conversão partindo de um texto qualquer."""

    pass


  def de(self, crit) -> ObjetoOfuscar:
    """Cria um mecanismo de conversão partindo de um critério qualquer de
 agregação."""

    pass


  def paraBooleano(self) -> bool:
    """Escolhe "aleatoriamente" um novo booleano, não importa qual tenha sido o
 objeto original. Ou seja, a mesma entrada pode resultar em diferentes
 respostas.
 <P>
 Trata-se na realidade de um processo pseudo-aleatório, mas para o
 propósito de "ofuscamento" é suficiente, pois o resultado não guarda
 qualquer correlação com o dado original.
 <P>"""

    pass


  def paraCEITexto(self) -> str:
    """Ofusca uma informação que representa um número CEI de tal maneira que seu
 dígito verificador continua válido mesmo após ter sido ofuscado (o dígito
 verificador pode inclusive ser outro)."""

    pass


  def paraCNPJBaseTexto(self) -> str:
    """Ofusca uma informação que representa um número CNPJ de 8 dígitos de tal
 maneira que ele corresponda exatamente aos mesmos primeiros 8 dígitos de
 outro número CNPJ, de 14 dígitos, que foi também ofuscado (ou seja, o
 resultado deste método guarda consistência com o resultado do método
 {@link Ofuscador#paraCNPJTexto() paraCNPJTexto}."""

    pass


  def paraCNPJTexto(self) -> str:
    """Ofusca uma informação que representa um número CNPJ de 14 dígitos de tal
 maneira que seu dígito verificador continua válido mesmo após ter sido
 ofuscado (o dígito verificador pode inclusive ser outro).<BR>
 Além disso, preserva a parte do número que corresponde ao sequencial de
 estabelecimento (isto é, os quatro dígitos que diferencial a matriz de
 suas filiais não é ofuscado).<BR>
 O resultado deste método guarda consistência com o resultado do método
 {@link Ofuscador#paraCNPJBaseTexto() paraCNPJBaseTexto}."""

    pass


  def paraCPFTexto(self) -> str:
    """Ofusca uma informação que representa um número CPF de tal maneira que seu
 dígito verificador continua válido mesmo após ter sido ofuscado (o dígito
 verificador pode inclusive ser outro)."""

    pass


  def paraData(self) -> Data:
    """Ofusca uma informação que representa uma data de tal maneira que o mês e
 o ano permanecem os mesmos (isto é, apenas o dia no mês é que pode ficar
 diferente)."""

    pass


  def paraDecimal(self) -> float:
    """Ofusca o número de forma a produzir um número diferente com a mesma ordem
 de grandeza, exceto o número 0 que permanece 0.<BR>
 Os valores onde as casas decimais são iguais a 0 permanecem assim, com as
 casas decimais iguais a 0.<BR>
 OBS: as casas decimais após a segunda são desprezadas."""

    pass


  def paraDia(self) -> Data:
    """Faz o mesmo que a função {@link Ofuscador#paraData() paraData}"""

    pass


  def paraDigitos(self) -> str:
    """Ofusca uma informação que representa um código (ex: número NCM ou número
 de declaração).<BR>
 O código resultante permanece com a mesma quantidade de dígitos."""

    pass


  def paraInteiro(self) -> long:
    """Ofusca o número de forma a produzir um número diferente com a mesma ordem
 de grandeza, exceto o número 0 que permanece 0."""

    pass


  def paraListaCNPJBaseNumerico(self) -> list:
    """Converte a lista, conforme comentado no método
 {@link Conversor#paraListaCNPJBaseNumerico() paraListaCNPJBaseNumerico},
 com a particularidade de que cada CNPJ desta lista está ofuscado com o
 mesmo critério definido em
 {@link Ofuscador#paraCNPJBaseTexto() paraCNPJBaseTexto}."""

    pass


  def paraListaCNPJBaseTexto(self) -> list:
    """Converte a lista, conforme comentado no método
 {@link Conversor#paraListaCNPJBaseTexto() paraListaCNPJBaseTexto}, com a
 particularidade de que cada CNPJ desta lista está ofuscado com o mesmo
 critério definido em
 {@link Ofuscador#paraCNPJBaseTexto() paraCNPJBaseTexto}."""

    pass


  def paraListaCNPJNumerico(self) -> list:
    """Converte a lista, conforme comentado no método
 {@link Conversor#paraListaCNPJNumerico() paraListaCNPJNumerico}, com a
 particularidade de que cada CNPJ desta lista está ofuscado com o mesmo
 critério definido em {@link Ofuscador#paraCNPJTexto() paraCNPJTexto}."""

    pass


  def paraListaCNPJTexto(self) -> list:
    """Converte a lista, conforme comentado no método
 {@link Conversor#paraListaCNPJTexto() paraListaCNPJTexto}, com a
 particularidade de que cada CNPJ desta lista está ofuscado com o mesmo
 critério definido em {@link Ofuscador#paraCNPJTexto() paraCNPJTexto}."""

    pass


  def paraListaCPFTexto(self) -> list:
    """Converte a lista, conforme comentado no método
 {@link Conversor#paraListaCPFTexto() paraListaCPFTexto}, com a
 particularidade de que cada CPF desta lista está ofuscado com o mesmo
 critério definido em {@link Ofuscador#paraCPFTexto() paraCPFTexto}."""

    pass


  def paraListaNITTexto(self) -> list:
    """Converte a lista, conforme comentado no método
 {@link Conversor#paraListaNITTexto() paraListaNITTexto}, com a
 particularidade de que cada NIT desta lista está ofuscado com o mesmo
 critério definido em {@link Ofuscador#paraNITTexto() paraNITTexto}."""

    pass


  def paraMes(self) -> Mes:
    """Ofusca um mês de modo a escolher outro mês do mesmo ano.<BR>
 OBS: sempre que este mesmo método for aplicado a meses do mesmo ano, o
 resultado será sempre o mesmo para aquele ano. Portanto, se alguém souber
 a correspondência de um determinado mês original para um mês convertido
 dentro de um determinado ano, saberá que as demais ocorrências do mesmo
 mês para o mesmo ano sempre produzirão o mesmo resultado.<BR>
 OBS2: a forma com que os meses estão embaralhados em um determinado ano
 não guarda relação com a forma com que os meses estão embaralhados em
 outro ano. Por exemplo, o mês JANEIRO de 2010 pode ser convertido para um
 mês diferente do mês JANEIRO de 2011."""

    pass


  def paraNITTexto(self) -> str:
    """Ofusca uma informação que representa um número NIT de tal maneira que seu
 dígito verificador continua válido mesmo após ter sido ofuscado (o dígito
 verificador pode inclusive ser outro)."""

    pass


  def paraNomePessoa(self) -> str:
    """Ofusca o nome de uma pessoa, convertendo um nome completo para outro nome
 completo totalmente diferente do original.<BR>
 OBS: sempre que o mesmo nome for apresentado a esta função, o resultado
 será sempre o mesmo.<BR>
 OBS2: se houver alguma variação no nome original, por menor que seja (ex:
 uma letra foi omitida ou acrescentada), o resultado pode ficar bastante
 diferente. Ex: MATIAS produz um nome muito diferente de MATHIAS.<BR>
 OBS3: não há qualquer correspondência quanto ao "gênero" do nome. Isto é,
 nomes femininos podem se transformar em nomes masculinos, e vice-versa.
 OBS4: o tamanho em quantidade de letras do nome gerado pode variar
 bastante em relação ao tamanho do nome original, inclusive na quantidade
 de nomes (considerando um nome completo, com vários nomes e sobrenomes)."""

    pass


  def paraRazaoSocial(self) -> str:
    """Ofusca a razão social de uma empresa, convertendo um nome para outro nome
 totalmente diferente do original.<BR>
 OBS: sempre que o mesmo nome for apresentado a esta função, o resultado
 será sempre o mesmo.<BR>
 OBS2: se houver alguma variação no nome original, por menor que seja (ex:
 uma letra foi omitida ou acrescentada), o resultado pode ficar bastante
 diferente. Ex: BRASIMAX produz um nome muito diferente de BRASILMAX.<BR>
 OBS3: o tamanho em quantidade de letras do nome gerado pode variar
 bastante em relação ao tamanho do nome original, inclusive na quantidade
 de nomes (considerando um nome completo, com vários nomes e sobrenomes)."""

    pass


  def paraTexto(self) -> str:
    """Ofusca um texto genérico, tal como um histórico de lançamento contábil,
 uma rubrica da folha, uma descrição de operação, um nome de uma conta, um
 histórico de lançamento bancário, entre outras possibilidades.<BR>
 Palavras comuns tais como CAIXA, SALÁRIO, RECEITA, etc. (existem mais de
 mil delas) não são ofuscadas. As demais palavras que não são consideradas
 comuns são substituídas por XXXX, inclusive os números existentes no
 texto.<BR>
 OBS: Caso o nome de alguma empresa utilize palavras comuns (ex: "DINHEIRO
 S.A."), este nome não estará ofuscado por se tratar de uma palavra
 "comum". Portanto é importante estar atento à possibilidade de
 eventualmente alguns nomes permanecerem não-ofuscados pelo fato de serem
 palavras comuns."""

    pass


  def paraValor(self) -> float:
    """Faz a mesma coisa que a função
 {@link Ofuscador#paraDecimal() paraDecimal}"""

    pass


  def paraXXX(self) -> str:
    """Ofusca um texto genérico (tal como um e-mail) para uma série de XXXX,
 onde cada "X" substitui qualquer coisa que não for espaço em branco.<BR>
 Note que este método substitui tudo, inclusive palavras comuns como
 CAIXA, SALÁRIO, RECEITA, etc. Isso pode não ser desejável caso seja
 importante preservar alguma característica essencial do texto original
 (por exemplo, se a intenção é aproveitar este texto posteriormente em
 algum mecanismo de reconhecimento de palavras, a intenção estará
 comprometida com o uso deste método).<BR>"""

    pass

class PDFExtrator ():
  """Objeto de scirpt que disponibiliza diversos recursos avançados para extrair textos
 a partir de arquivos PDF.<BR>
 <BR>
 Existem diversos métodos mais simples de converter arquivo PDF em texto, implementados
 em {@link GerenciadorArquivos GerenciadorArquivos}. Por exemplo, o método {@link GerenciadorArquivos#abrirPDFComoTexto(String) abrirPDFComoTexto}.<BR>
 <BR>
 Porém, existem situações em que se quer utilizar alguns critérios mais avançados. Por exemplo,
 para considerar somente textos que apresentam uma determinada fonte, dado o nome da fonte. Esta
 classe se destina a realizar esses critérios avançados.<BR>
 <BR>
 ATENÇÃO: não se trata de converter imagens e texto! Se o PDF possui imagens que se parecem
 com textos, este objeto não irá funcionar! Para converter imagens em textos é necessário
 utilizar um OCR.<BR>
 <BR>
 COMO UTILIZAR ESTE OBJETO:<BR>
 ===============================================<BR>
 Existem várias formas de filtrar o texto que se quer extrair do PDF. Pode-se desconsiderar
 textos que apresentem algum nome de fonte, ou textos que apresentem algum tamanho (ex: em cabeçalhos), ou textos
 que apresentem algum ângulo de rotação (ex: em marca d'água'), ou textos que estejam posicionados na parte
 inferior de cada página (ex: em rodapé), etc.<BR>
 Porém, esses parâmetros variam de arquivo para arquivo.<BR>
 Inicialmente você provavelmente irá querer saber quais são as fontes, tamanhos rotações e posições para todos
 os textos de todas as páginas do arquivo PDF.<BR>
 Você pode obter essas informações utilizando o método {@link #abrirPDFComoTexto(String, String) abrirPDFComoTexto} uma
 vez, sobre o arquivo PDF, e depois utilizar as informações coletadas pelo objeto {@link DadosUltimaExtracao DadosUltimaExtracao}
 que é retornado pelo método {@link #getDadosUltimaExtracao() getDadosUltimaExtracao}.<BR>
 Com isso, serão exibidas várias informações sobre o PDF. Por exemplo, você saberá quantas vezes são utilizados diferentes
 tamanhos, diferentes fontes, diferentes rotações de texto, etc. Você também poderá obter algumas pequenas amostras de textos
 para cada uma dessas características (o tamanho dessas amostras é configurável através do método {@link #setTamanhoAmostra(int) setTamanhoAmostra}).<BR>
 Com essas informações, você poderá utilizar os filtros necessários para extrair o texto que interessa. Isto é, utilizar
 métodos como {@link #addRotacaoDesprezar(int) addRotacaoDesprezar}, {@link #addTamanhoDesprezar(float) addTamanhoDesprezar}, entre
 tantos outros, para indicar o texto que quer extrair na próxima execução de {@link #abrirPDFComoTexto(String, String) abrirPDFComoTexto}<BR>
 <BR>
 <BR>
 FORMULÁRIOS NO PDF:<BR>
 ===============================================<BR>
 Caso o arquivo PDF contenha 'formulários' (trata-se de um tipo de estrutura específico que não se confude com textos), você pode extrair também
 esses dados, bastando indicar 'TRUE' no método {@link #setColetaDadosFormularios(boolean) setColetaDadosFormularios}. Neste caso, os campos dos formulários
 (os nomes e os valores) serão preenchidos em um objeto do tipo {@link Formulario Formulario} e, após execução do método {@link #abrirPDFComoTexto(String, String) abrirPDFComoTexto},
 será retornado através do método {@link #getFormularioUltimaExtracao() getFormularioUltimaExtracao}."""

  def abrirPDFComoTexto(self, diretorio, nomeArquivo) -> ArquivoTexto:
    """Abre um arquivo de conteúdo PDF previamente armazenado no computador
 local e apresenta-o na forma de um arquivo TEXTO (isto é, um objeto do
 tipo {@link ArquivoTexto ArquivoTexto}.<BR>
 Todas as configurações realizadas neste objeto {@link PDFExtrator PDFExtrator}
 são consideradas (isto é, os filtros por nome de fonte, tamanho, posição
 do texto, etc.).<BR>
 Se o arquivo não existe, retorna NULL.<BR>
 Se o conteúdo não pode ser obtido no formato texto por algum motivo,
 retorna NULL.<BR>
 OBS: alguns arquivos PDF não apresentam conteúdo do tipo "texto", mas sim
 "imagens" (ainda que elas se pareçam com texto). Esses tipos de arquivos
 não podem ser utilizados com este método.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o conteúdo aberto (por exemplo, para apresentar
 as diversas linhas, ou quebrar cada linha em "campos" em função dos
 espaços em branco que os separam).<BR>"""

    pass


  def abrirPDFComoTexto(self, arquivo) -> ArquivoTexto:
    """Abre um arquivo de conteúdo PDF previamente armazenado no computador
 local e apresenta-o na forma de um arquivo TEXTO (isto é, um objeto do
 tipo {@link ArquivoTexto ArquivoTexto}.<BR>
 Todas as configurações realizadas neste objeto {@link PDFExtrator PDFExtrator}
 são consideradas (isto é, os filtros por nome de fonte, tamanho, posição
 do texto, etc.).<BR>
 Se o arquivo não existe, retorna NULL.<BR>
 Se o conteúdo não pode ser obtido no formato texto por algum motivo,
 retorna NULL.<BR>
 OBS: alguns arquivos PDF não apresentam conteúdo do tipo "texto", mas sim
 "imagens" (ainda que elas se pareçam com texto). Esses tipos de arquivos
 não podem ser utilizados com este método.<BR>
 A partir do objeto retornado por esta função é possível executar outras
 funções diretamente sobre o conteúdo aberto (por exemplo, para apresentar
 as diversas linhas, ou quebrar cada linha em "campos" em função dos
 espaços em branco que os separam).<BR>"""

    pass


  def addFonteConsiderar(self, fonteConsiderar) -> None:
    """Indica que deve considerar todos os textos que apresentarem no nome da fonte a palavra aqui indicada.<BR>
 Se outras palavras foram indicadas por outras execuções deste método ou de outros métodos relacionados a este, elas também são consideradas.<BR>
 OBS: a busca é feita por partes do nome. Por exemplo, se for indicada a palavra 'Arial', se considera também alguma fonte com nome 'ArialMT'.<BR>
 Não se distingue diferença de letra maiúscula/minúscula.<BR>
 O comportamento deste tipo de filtro é alterado pela presença ou ausência do critério de fontes a 'desprezar'.<BR>
 Aplica as regras nesta ordem:<BR>
 1o) Verifica se a fonte se enquadra em algumas das expressões de 'fontes a considerar'. Se encontrar, então considera o texto, independentemente da
 mesma fonte se enquadrar também em algum critério de fonte a 'desprezar'.<BR>
 2o) Se a fonte não se enquadra nas expressões de 'fontes a considerar', e se não existem critérios de 'fontes a desprezar', então despreza o texto.<BR>
 3o) Se a fonte não se enquadra nas expressões de 'fontes a considerar', mas existem critérios de 'fontes a desprezar', aplica esses critérios. O texto
 será rejeitado se estiver presente em algum critério de 'fontes a desprezar' e será admitido caso contrário. Notar que neste caso os critérios de
 'fonte a considerar' funcionam como 'exceção' aos critérios de 'fontes a desprezar'.<BR>
 4o) Se não havia critérios de 'fontes a considerar', mas há critérios de 'fontes a desprezar', serão admitidos apenas os textos que não incidirem em
 um dos critérios de 'fontes a desprezar'.<BR>"""

    pass


  def addFonteDesprezar(self, fonteDesprezar) -> None:
    """Indica que deve desprezar todos os textos que apresentarem no nome da fonte a palavra aqui indicada.<BR>
 Se outras palavras foram indicadas por outras execuções deste método ou de outros métodos relacionados a este, elas também são desprezadas.<BR>
 OBS: a busca é feita por partes do nome. Por exemplo, se for indicada a palavra 'Arial', se despreza também alguma fonte com nome 'ArialMT'.<BR>
 Não se distingue diferença de letra maiúscula/minúscula.<BR>
 O comportamento deste tipo de filtro é alterado pela presença ou ausência do critério de fontes a 'considerar'.<BR>
 Aplica as regras nesta ordem:<BR>
 1o) Verifica se a fonte se enquadra em algumas das expressões de 'fontes a considerar'. Se encontrar, então considera o texto, independentemente da
 mesma fonte se enquadrar também em algum critério de fonte a 'desprezar'.<BR>
 2o) Se a fonte não se enquadra nas expressões de 'fontes a considerar', e se não existem critérios de 'fontes a desprezar', então despreza o texto.<BR>
 3o) Se a fonte não se enquadra nas expressões de 'fontes a considerar', mas existem critérios de 'fontes a desprezar', aplica esses critérios. O texto
 será rejeitado se estiver presente em algum critério de 'fontes a desprezar' e será admitido caso contrário. Notar que neste caso os critérios de
 'fonte a considerar' funcionam como 'exceção' aos critérios de 'fontes a desprezar'.<BR>
 4o) Se não havia critérios de 'fontes a considerar', mas há critérios de 'fontes a desprezar', serão admitidos apenas os textos que não incidirem em
 um dos critérios de 'fontes a desprezar'.<BR>"""

    pass


  def addRotacaoDesprezar(self, angulo) -> None:
    """Indica que deve desprezar todos os textos que apresentam a rotação aqui indicada (ângulos em graus).<BR>
 Se este método for chamado mais de uma vez com outros ângulos, despreza todos os ângulos indicados.<BR>
 Útil quando se quer desconsiderar partes do PDF que são utilizados como 'marca d'água', caso a diferença entre eles e o restante
 do texto seja o ângulo de rotação."""

    pass


  def addTamanhoDesprezar(self, tamanho) -> None:
    """Indica que deve desprezar todos os textos que apresentarem o tamanho aqui indicado.<BR>
 Se este método for chamado mais de uma vez com outros tamanhos, despreza todos os tamanhos indicados.<BR>
 OBS: caso tenha também indicado um 'tamanho mínimo' e um 'tamanho máximo', serão excluídos tanto os textos que tiverem tamanhos
 fora do intervalo definidos pelo critérios mínimo e máximo, como também os textos que tiverem os tamanhos específicos indicados
 aqui. Útil quando se quer desconsiderar partes do PDF que representam cabeçalhos ou contagem de páginas que se distinguem do restante
 do texto através do tamanho, caso isso de fato ocorra."""

    pass


  def getDadosUltimaExtracao(self) -> DadosUltimaExtracao:
    """Dados da última execução do método de extração de texto (isto é, após executar o método {@link PDFExtrator#abrirPDFComoTexto(String, String) abrirPDFComoTexto})<BR>
 OBS: se foram aplicados critérios de filtragem sobre o conteúdo PDF (ex: filtrar por tamanho de fonte), os dados aqui informados se referem apenas aos textos considerados."""

    pass


  def getFontesConsiderar(self) -> list:
    """Indica que deve considerar todos os textos que apresentarem no nome da fonte as palavras aqui indicadas.<BR>
 OBS: a busca é feita por partes do nome. Por exemplo, se for indicada a palavra 'Arial', se considera também alguma fonte com nome 'ArialMT'.<BR>
 Não se distingue diferença de letra maiúscula/minúscula.<BR>
 O comportamento deste tipo de filtro é alterado pela presença ou ausência do critério de fontes a 'desprezar'.<BR>
 Aplica as regras nesta ordem:<BR>
 1o) Verifica se a fonte se enquadra em algumas das expressões de 'fontes a considerar'. Se encontrar, então considera o texto, independentemente da
 mesma fonte se enquadrar também em algum critério de fonte a 'desprezar'.<BR>
 2o) Se a fonte não se enquadra nas expressões de 'fontes a considerar', e se não existem critérios de 'fontes a desprezar', então despreza o texto.<BR>
 3o) Se a fonte não se enquadra nas expressões de 'fontes a considerar', mas existem critérios de 'fontes a desprezar', aplica esses critérios. O texto
 será rejeitado se estiver presente em algum critério de 'fontes a desprezar' e será admitido caso contrário. Notar que neste caso os critérios de
 'fonte a considerar' funcionam como 'exceção' aos critérios de 'fontes a desprezar'.<BR>
 4o) Se não havia critérios de 'fontes a considerar', mas há critérios de 'fontes a desprezar', serão admitidos apenas os textos que não incidirem em
 um dos critérios de 'fontes a desprezar'.<BR>"""

    pass


  def getFontesDesprezar(self) -> list:
    """Indica que deve desprezar todos os textos que apresentarem no nome da fonte as palavras aqui indicadas.<BR>
 OBS: a busca é feita por partes do nome. Por exemplo, se for indicada a palavra 'Arial', se despreza também alguma fonte com nome 'ArialMT'.<BR>
 Não se distingue diferença de letra maiúscula/minúscula.<BR>
 O comportamento deste tipo de filtro é alterado pela presença ou ausência do critério de fontes a 'considerar'.<BR>
 Aplica as regras nesta ordem:<BR>
 1o) Verifica se a fonte se enquadra em algumas das expressões de 'fontes a considerar'. Se encontrar, então considera o texto, independentemente da
 mesma fonte se enquadrar também em algum critério de fonte a 'desprezar'.<BR>
 2o) Se a fonte não se enquadra nas expressões de 'fontes a considerar', e se não existem critérios de 'fontes a desprezar', então despreza o texto.<BR>
 3o) Se a fonte não se enquadra nas expressões de 'fontes a considerar', mas existem critérios de 'fontes a desprezar', aplica esses critérios. O texto
 será rejeitado se estiver presente em algum critério de 'fontes a desprezar' e será admitido caso contrário. Notar que neste caso os critérios de
 'fonte a considerar' funcionam como 'exceção' aos critérios de 'fontes a desprezar'.<BR>
 4o) Se não havia critérios de 'fontes a considerar', mas há critérios de 'fontes a desprezar', serão admitidos apenas os textos que não incidirem em
 um dos critérios de 'fontes a desprezar'.<BR>"""

    pass


  def getFormularioUltimaExtracao(self) -> Formulario:
    """Formulário obtido na última extração caso tenha indicado o interesse em extrair campos de formulários utilizando o método {@link #setColetaDadosFormularios(boolean) setColetaDadosFormularios}"""

    pass


  def getPosicaoXMaxima(self) -> Float:
    """Se for diferente de NULL, considera somente os textos cuja coordenada X de sua posição for inferior ou igual a este número."""

    pass


  def getPosicaoXMinima(self) -> Float:
    """Se for diferente de NULL, considera somente os textos cuja coordenada X de sua posição for superior ou igual a este número."""

    pass


  def getPosicaoYMaxima(self) -> Float:
    """Se for diferente de NULL, considera somente os textos cuja coordenada Y de sua posição for inferior ou igual a este número."""

    pass


  def getPosicaoYMinima(self) -> Float:
    """Se for diferente de NULL, considera somente os textos cuja coordenada Y de sua posição for superior ou igual a este número."""

    pass


  def getRotacaoMaxima(self) -> Integer:
    """Se for diferente de NULL, considera somente os textos cuja rotação (em graus) seja inferior ou igual a este número."""

    pass


  def getRotacaoMinima(self) -> Integer:
    """Se for diferente de NULL, considera somente os textos cuja rotação (em graus) seja superior ou igual a este número."""

    pass


  def getRotacoesDesprezar(self) -> list:
    """Indica que deve desprezar todos os textos que apresentam as rotações aqui relacionadas (ângulos em graus).<BR>
 Útil quando se quer desconsiderar partes do PDF que são utilizados como 'marca d'água', caso a diferença entre eles e o restante
 do texto seja o ângulo de rotação."""

    pass


  def getSeparadorPaginas(self) -> str:
    """Para cada 'quebra de página' que houver no PDF, insere no 'texto' resultante uma linha compreendendo este texto."""

    pass


  def getTamanhoAmostra(self) -> int:
    """Tamanho da amostra de textos por 'fonte' e textos por 'tamanho' que deve coletar e disponibilizar no objeto {@link DadosUltimaExtracao DadosUltimaExtracao} após realizar
 uma extração de texto de um PDF. Por padrão coleta até 20 partes de texto para cada fonte e cada tamanho, o que pode ser útil para examinar o tipo de conteúdo que há
 no PDF. Isso não afeta o texto em si que é retornado pelo método de extração de texto. Trata-se apenas de uma informação adicional que pode ser apresentada
 através de métodos do objeto {@link DadosUltimaExtracao DadosUltimaExtracao} que é retornado pelo método {@link #getDadosUltimaExtracao() getDadosUltimaExtracao}<BR>
 OBS: dependendo do PDF, um 'trecho de texto' pode ser um parágrafo, uma frase, uma parte de uma frase ou uma única letra. Não há um mesmo padrão."""

    pass


  def getTamanhoMaximo(self) -> Float:
    """Se for diferente de NULL, considera somente os textos cujo tamanho de fonte seja inferior ou igual a este número."""

    pass


  def getTamanhoMinimo(self) -> Float:
    """Se for diferente de NULL, considera somente os textos cujo tamanho de fonte seja superior ou igual a este número."""

    pass


  def getTamanhosDesprezar(self) -> list:
    """Indica que deve desprezar todos os textos que apresentarem os tamanhos aqui relacionados.<BR>
 OBS: caso tenha também indicado um 'tamanho mínimo' e um 'tamanho máximo', serão excluídos tanto os textos que tiverem tamanhos
 fora do intervalo definidos pelo critérios mínimo e máximo, como também os textos que tiverem os tamanhos específicos indicados
 aqui. Útil quando se quer desconsiderar partes do PDF que representam cabeçalhos ou contagem de páginas que se distinguem do restante
 do texto através do tamanho, caso isso de fato ocorra."""

    pass


  def isColetaDadosExtracao(self) -> bool:
    """Indica se deve ou não coletar dados ({@link DadosUltimaExtracao DadosUltimaExtracao}) sobre a extração, durante a extração de texto de PDF. Os dados coletados podem 
 ser obtidos por meio de {@link #getDadosUltimaExtracao() getDadosUltimaExtracao}. Por padrão coleta os dados, a menos que seja configurado de modo a não coletar.<BR>
 OBS: caso esteja utilizando o mesmo objeto {@link PDFExtrator PDFExtrator} em múltiplas threads, recomenda-se NÃO coletar esses dados."""

    pass


  def isColetaDadosFormularios(self) -> bool:
    """Indica se deve ou não coletar dados de formulários, caso o arquivo PDF contenha formulários (trata-se de um tipo especial de estrutura que pode ou não ser implementado
 em um arquivo PDF)."""

    pass


  def setColetaDadosExtracao(self, coletaDadosExtracao) -> None:
    """Indica se deve ou não coletar dados ({@link DadosUltimaExtracao DadosUltimaExtracao}) sobre a extração, durante a extração de texto de PDF. Os dados coletados podem 
 ser obtidos por meio de {@link #getDadosUltimaExtracao() getDadosUltimaExtracao}. Por padrão coleta os dados, a menos que seja configurado de modo a não coletar.<BR>
 OBS: caso esteja utilizando o mesmo objeto {@link PDFExtrator PDFExtrator} em múltiplas threads, recomenda-se NÃO coletar esses dados."""

    pass


  def setColetaDadosFormularios(self, coletaDadosFormularios) -> None:
    """Indica se deve ou não coletar dados de formulários, caso o arquivo PDF contenha formulários (trata-se de um tipo especial de estrutura que pode ou não ser implementado
 em um arquivo PDF)."""

    pass


  def setFontesConsiderar(self, fontesConsiderar) -> None:
    """Indica que deve considerar todos os textos que apresentarem no nome da fonte as palavras aqui indicadas.<BR>
 OBS: a busca é feita por partes do nome. Por exemplo, se for indicada a palavra 'Arial', se considera também alguma fonte com nome 'ArialMT'.<BR>
 Não se distingue diferença de letra maiúscula/minúscula.<BR>
 O comportamento deste tipo de filtro é alterado pela presença ou ausência do critério de fontes a 'desprezar'.<BR>
 Aplica as regras nesta ordem:<BR>
 1o) Verifica se a fonte se enquadra em algumas das expressões de 'fontes a considerar'. Se encontrar, então considera o texto, independentemente da
 mesma fonte se enquadrar também em algum critério de fonte a 'desprezar'.<BR>
 2o) Se a fonte não se enquadra nas expressões de 'fontes a considerar', e se não existem critérios de 'fontes a desprezar', então despreza o texto.<BR>
 3o) Se a fonte não se enquadra nas expressões de 'fontes a considerar', mas existem critérios de 'fontes a desprezar', aplica esses critérios. O texto
 será rejeitado se estiver presente em algum critério de 'fontes a desprezar' e será admitido caso contrário. Notar que neste caso os critérios de
 'fonte a considerar' funcionam como 'exceção' aos critérios de 'fontes a desprezar'.<BR>
 4o) Se não havia critérios de 'fontes a considerar', mas há critérios de 'fontes a desprezar', serão admitidos apenas os textos que não incidirem em
 um dos critérios de 'fontes a desprezar'.<BR>"""

    pass


  def setFontesDesprezar(self, fontesDesprezar) -> None:
    """Indica que deve desprezar todos os textos que apresentarem no nome da fonte as palavras aqui indicadas.<BR>
 OBS: a busca é feita por partes do nome. Por exemplo, se for indicada a palavra 'Arial', se despreza também alguma fonte com nome 'ArialMT'.<BR>
 Não se distingue diferença de letra maiúscula/minúscula.<BR>
 O comportamento deste tipo de filtro é alterado pela presença ou ausência do critério de fontes a 'considerar'.<BR>
 Aplica as regras nesta ordem:<BR>
 1o) Verifica se a fonte se enquadra em algumas das expressões de 'fontes a considerar'. Se encontrar, então considera o texto, independentemente da
 mesma fonte se enquadrar também em algum critério de fonte a 'desprezar'.<BR>
 2o) Se a fonte não se enquadra nas expressões de 'fontes a considerar', e se não existem critérios de 'fontes a desprezar', então despreza o texto.<BR>
 3o) Se a fonte não se enquadra nas expressões de 'fontes a considerar', mas existem critérios de 'fontes a desprezar', aplica esses critérios. O texto
 será rejeitado se estiver presente em algum critério de 'fontes a desprezar' e será admitido caso contrário. Notar que neste caso os critérios de
 'fonte a considerar' funcionam como 'exceção' aos critérios de 'fontes a desprezar'.<BR>
 4o) Se não havia critérios de 'fontes a considerar', mas há critérios de 'fontes a desprezar', serão admitidos apenas os textos que não incidirem em
 um dos critérios de 'fontes a desprezar'.<BR>"""

    pass


  def setPosicaoXMaxima(self, posicaoXMaxima) -> None:
    """Se for diferente de NULL, considera somente os textos cuja coordenada X de sua posição for inferior ou igual a este número."""

    pass


  def setPosicaoXMinima(self, posicaoXMinima) -> None:
    """Se for diferente de NULL, considera somente os textos cuja coordenada X de sua posição for superior ou igual a este número."""

    pass


  def setPosicaoYMaxima(self, posicaoYMaxima) -> None:
    """Se for diferente de NULL, considera somente os textos cuja coordenada Y de sua posição for inferior ou igual a este número."""

    pass


  def setPosicaoYMinima(self, posicaoYMinima) -> None:
    """Se for diferente de NULL, considera somente os textos cuja coordenada Y de sua posição for superior ou igual a este número."""

    pass


  def setRotacaoMaxima(self, rotacaoMaxima) -> None:
    """Se for diferente de NULL, considera somente os textos cuja rotação (em graus) seja inferior ou igual a este número."""

    pass


  def setRotacaoMinima(self, rotacaoMinima) -> None:
    """Se for diferente de NULL, considera somente os textos cuja rotação (em graus) seja superior ou igual a este número."""

    pass


  def setRotacoesDesprezar(self, rotacoesDesprezar) -> None:
    """Indica que deve desprezar todos os textos que apresentam as rotações aqui relacionadas (ângulos em graus).<BR>
 Útil quando se quer desconsiderar partes do PDF que são utilizados como 'marca d'água', caso a diferença entre eles e o restante
 do texto seja o ângulo de rotação."""

    pass


  def setSenha(self, senha) -> None:
    """Permite indicar uma senha para abertura do PDF caso ele esteja protegido com senha."""

    pass


  def setSeparadorPaginas(self, separadorPaginas) -> None:
    """Para cada 'quebra de página' que houver no PDF, insere no 'texto' resultante uma linha compreendendo este texto."""

    pass


  def setTamanhoAmostra(self, tamanhoAmostra) -> None:
    """Tamanho da amostra de textos por 'fonte' e textos por 'tamanho' que deve coletar e disponibilizar no objeto {@link DadosUltimaExtracao DadosUltimaExtracao} após realizar
 uma extração de texto de um PDF. Por padrão coleta até 20 partes de texto para cada fonte e cada tamanho, o que pode ser útil para examinar o tipo de conteúdo que há
 no PDF. Isso não afeta o texto em si que é retornado pelo método de extração de texto. Trata-se apenas de uma informação adicional que pode ser apresentada
 através de métodos do objeto {@link DadosUltimaExtracao DadosUltimaExtracao} que é retornado pelo método {@link #getDadosUltimaExtracao() getDadosUltimaExtracao}<BR>
 OBS: dependendo do PDF, um 'trecho de texto' pode ser um parágrafo, uma frase, uma parte de uma frase ou uma única letra. Não há um mesmo padrão."""

    pass


  def setTamanhoMaximo(self, tamanhoMaximo) -> None:
    """Se for diferente de NULL, considera somente os textos cujo tamanho de fonte seja inferior ou igual a este número."""

    pass


  def setTamanhoMinimo(self, tamanhoMinimo) -> None:
    """Se for diferente de NULL, considera somente os textos cujo tamanho de fonte seja superior ou igual a este número."""

    pass


  def setTamanhosDesprezar(self, tamanhosDesprezar) -> None:
    """Indica que deve desprezar todos os textos que apresentarem os tamanhos aqui relacionados.<BR>
 OBS: caso tenha também indicado um 'tamanho mínimo' e um 'tamanho máximo', serão excluídos tanto os textos que tiverem tamanhos
 fora do intervalo definidos pelo critérios mínimo e máximo, como também os textos que tiverem os tamanhos específicos indicados
 aqui. Útil quando se quer desconsiderar partes do PDF que representam cabeçalhos ou contagem de páginas que se distinguem do restante
 do texto através do tamanho, caso isso de fato ocorra."""

    pass

class PrincipalComponentAnalysis ():
  """Classe que representa o resultado da aplicação da técnica PCA (Principal Component Analysis).<BR>
 <BR>
 Este objeto é retornado após aplicação do método {@link Tabela#aplicaPrincipalComponentAnalysis(int) aplicaPrincipalComponentAnalysis}
 sobre uma tabela.<BR>
 <BR>
 Para mais informações, consulte o referido método.<BR>
 <BR>"""

  def getDimensao(self) -> int:
    """Indica a "dimensão" (corresponde à 'quantidade de componentes principais') que foi indicada como parâmetro na execução do PCA. Este número indica a quantidade de colunas
 que serão exibidas pelo método {@link PrincipalComponentAnalysis#getTabelaComponentesPrincipais() getTabelaComponentesPrincipais}
 em acréscimo às colunas da tabela original que são do tipo não-numérico."""

    pass


  def getDimensaoMaxima(self) -> int:
    """Retorna a maior quantidade de 'componentes principais' que pode ser indicada neste método tendo em vista o conjunto de dados
 de onde se originou esta análise. Corresponde à quantidade de colunas numéricas nos dados, que por sua vez é igual à quantidade de
 colunas ou de linhas na matriz covariância relacionada."""

    pass


  def getListaAutoValores(self) -> list:
    """Retorna a relação de "autovalores", já ordenadas do maior para o menor, referentes aos "autovetores" obtidos
 pela decomposição da matriz de correlação.<BR>
 O tamanho desta lista é definido pelo parâmetro "dimensão" indicado como parâmetro na execução do PCA."""

    pass


  def getListaComunalidade(self, componentes) -> list:
    """Retorna em uma lista a "comunalidade", que indica o quanto de cada variável (variável original, que é uma das colunas do tipo numérico da tabela de dados)
 é "explicado" pelos componentes principais (onde a quantidade de componentes principais é definida pelo parâmetro
 deste método).<BR>
 Por exemplo, se o primeiro elemento da lista é 0,8662, isso indica que os "n" primeiros componentes principais
 "explicam" 86,62% da primeira variável (primeira coluna de tipo numérico da tabela de dados).<BR>
 Note que se "componentes" é igual à quantidade total de colunas de tipo numérico da tabela original, então todos
 os elementos desta lista são iguais a "1" pois todos eles "explicam" 100% de todos os dados.<BR>"""

    pass


  def getListaComunalidade(self) -> list:
    """Retorna em uma lista a "comunalidade", que indica o quanto de cada variável (variável original, que é uma das colunas do tipo numérico da tabela de dados)
 é "explicado" pelos componentes principais (onde a quantidade de componentes principais é definida pelo parâmetro
 "dimensão" indicado como parâmetro na execução do PCA).<BR>
 Por exemplo, se o primeiro elemento da lista é 0,8662, isso indica que os "n" primeiros componentes principais
 "explicam" 86,62% da primeira variável (primeira coluna de tipo numérico da tabela de dados).<BR>
 Note que se a "dimensão" é igual à quantidade total de colunas de tipo numérico da tabela original, então todos
 os elementos desta lista são iguais a "1" pois todos eles "explicam" 100% de todos os dados.<BR>"""

    pass


  def getMatrizCarregamentosPrincipaisAntesRotacao(self) -> Matriz:
    """Retorna em uma matriz a relação de "carregamentos principais" que são obtidos em "análise fatorial", antes de aplicação
 de alguma técnica de "rotação" (ex: VARIMAX).<BR>
 Trata-se dos próprios auto-vetores divididos pela raiz quadrada dos correspondentes auto-valores.<BR>
 As colunas da matriz estão associadas a cada um desses componentes principais (os auto-vetores divididos pela raiz quadrada dos correspondentes auto-valores).<BR>
 As linhas da matriz representam as variáveis originais que são explicadas por esses componentes principais."""

    pass


  def getMatrizCarregamentosPrincipaisAposRotacao(self, metodo) -> Matriz:
    """Retorna em uma matriz a relação de "carregamentos principais" que são obtidos em "análise fatorial", após aplicação
 de alguma técnica de "rotação" (ex: VARIMAX).<BR>
 Em geral se utilizam essas informações para verificar como as variáveis se relacionam com os fatores. A "rotação" se destina a deixar mais evidente os grupos 
 de variáveis que se relacionam para compor algum dos "fatores". Por exemplo, se o primeiro fator apresenta números próximos de +1 ou -1 (ex: 0,98) para determinadas
 variáveis X1 e X2, e números próximos de 0 (ex: 0,001) para variáveis X3 e X4, então podemos supor que as variáveis "X1" e "X2" estão mais relacionadas entre si e que sua 
 variabilidade pode ser explicada pelo primeiro fator. A "rotação" não afeta as comunalidades correspondentes aos "fatores", mas redistribui a soma dos quadrados de cada carregamento (que antes da rotação se iguala ao correspondente autovalor).<BR>
 As colunas da matriz estão associadas a cada um desses carregamentos (que estão relacionados aos fatores).<BR>
 As linhas da matriz representam as variáveis originais que são explicadas por esses fatores."""

    pass


  def getMatrizDesviosDadosOriginais(self) -> Matriz:
    """Faz o mesmo que a função {@link PrincipalComponentAnalysis#getMatrizDesviosDadosOriginais() getMatrizDesviosDadosOriginais}, porém
 retorna os dados na forma de uma matriz-linha, contendo uma só linha, com uma coluna para cada coluna numérica original. Os valores
 são os desvios padrões. Veja mais comentários na outra função ({@link PrincipalComponentAnalysis#getMatrizDesviosDadosOriginais() getMatrizDesviosDadosOriginais})."""

    pass


  def getMatrizMediasDadosOriginais(self) -> Matriz:
    """Faz o mesmo que a função {@link PrincipalComponentAnalysis#getTabelaMediasDadosOriginais() getTabelaMediasDadosOriginais}, porém
 retorna os dados na forma de uma matriz-linha, contendo uma só linha, com uma coluna para cada coluna numérica original. Os valores
 são as médias. Veja mais comentários na outra função ({@link PrincipalComponentAnalysis#getTabelaMediasDadosOriginais() getTabelaMediasDadosOriginais})."""

    pass


  def getPontuacoes(self, valores) -> float:
    """Dado um vetor qualquer, retorna um vetor de 'pontuações' correspondentes após aplicação da transformação
 para o sub-espaço de componentes principais. No vetor retornado a quantidade de colunas é determinada pelo parâmetro 'dimensao' definido no PCA.<BR>
 OBS: caso tenha ocorrido 'padronização' dos dados originais durante obtenção deste objeto PCA (isto é, se o método que gerou este
 objeto 'PCA' adotou um procedimento de zerar as médias e tornar os desvios padrões unitários), essas mesmas estatísticas (média
 e desvio padrão dos dados originais) são utilizadas sobre os novos dados para que a mesma transformação seja aplicada sobre eles."""

    pass


  def getPontuacoes(self, m) -> Matriz:
    """Dada uma matriz qualquer (pode até ser uma matriz diferente daquela que foi utilizada para calcular os componentes principais),
 retorna uma matriz de 'pontuações' correspondentes, onde para cada linha da matriz indicada no parâmetro é feita a transformação
 para o sub-espaço de componentes principais. A matriz retornada tem a mesma quantidade de linhas que a matriz original, porém
 a quantidade de colunas é determinada pelo parâmetro 'dimensao' definido no PCA.<BR>
 OBS: caso tenha ocorrido 'padronização' dos dados originais durante obtenção deste objeto PCA (isto é, se o método que gerou este
 objeto 'PCA' adotou um procedimento de zerar as médias e tornar os desvios padrões unitários), essas mesmas estatísticas (média
 e desvio padrão dos dados originais) são utilizadas sobre os novos dados para que a mesma transformação seja aplicada sobre eles."""

    pass


  def getPontuacoes(self) -> Matriz:
    """Retorna em um objeto "matriz" as "pontuações" conforme os "componentes principais" (isto é, o resultado da aplicação da técnica PCA).<BR>
 A matriz resultante apresenta dimensão N x M, onde N é a quantidade de variáveis (colunas de tipo numérico) que havia na tabela original e M é
 a quantidade de componentes principais (se a tabela original apresentava colunas de tipo não-numérico, essas colunas
 não são apresentadas na matriz).<BR>
 Em gráficos do tipo "score plot" geralmente se utilizam as duas primeiras colunas dessa matriz."""

    pass


  def getQtdColunasIdentificacao(self) -> int:
    """Retorna a quantidade de colunas da tabela original que estão sendo utilizadas como mera identificação dos dados. Isto é, que são
 apresentados em tabelas por outros métodos aqui expostos para identificar as linhas de dados às quais se referem."""

    pass


  def getQuantidadeComponentesPrincipais(self, tolerancia) -> int:
    """Retorna a quantidade de componentes principais que foram calculados pela técnica PCA e cujos "autovalores" são maiores ou iguais
 à "tolerancia" (em módulo).<BR>
 Por exemplo, se "tolerancia" é igual a zero, este método retorna a quantidade de colunas numéricas que não são completamente
 redundantes entre si.<BR>
 Este valor independe da "dimensão" que foi indicada como parâmetro na execução do PCA e pode ser um número superior a ele.<BR>
 Este valor varia de 1 até N, onde N é a quantidade de colunas numéricas que foram analisados na tabela original.<BR>
 OBS: o chamado 'critério de Kaiser' consiste em executar este método com o parâmetro "1". Isto é, retornar a quantidade de componentes
 para os quais o correspondente 'autovalor' é superior a 1."""

    pass


  def getTabelaAutoValores(self) -> Tabela:
    """Retorna a relação de "autovalores" na forma de uma tabela, contendo informações adicionais para cada um deles.<BR>
 1ª coluna: indica o número do componente principal (1 = primeiro componente, 2 = segundo componente, etc.)<BR>
 2ª coluna: indica o autovalor associado ao componente<BR>
 3ª coluna: porcentagem de variação<BR>
 4ª coluna: porcentagem acumulada"""

    pass


  def getTabelaAutoVetores(self, dimensao) -> Tabela:
    """Método alternativo que permite indicar como parâmetro um número de componentes (dimensão) diferente daquele
 que foi especificado inicialmente para aplicação desta técnica."""

    pass


  def getTabelaAutoVetores(self) -> Tabela:
    """Retorna em um objeto "tabela" os "autovetores" obtidos após execução do PCA.<BR>
 Cada coluna desta tabela corresponde a um "autovetor" e cada linha corresponde a um componente do autovetor.<BR>
 A quantidade de colunas é igual ao parâmetro "dimensão" indicado como parâmetro na execução do PCA.<BR>
 A quantidade de linhas é igual à quantidade de colunas de tipo numérico existentes no conjunto de dados original.<BR>
 A primeira coluna corresponde ao autovetor com o maior autovalor correspondente (isto é, corresponde à "dimensão" que produz a maior variância nos dados).<BR>
 As demais colunas correspondem aos demais autovetores com valores cada vez menores de autovalores (isto é, que produzem progressivamente menos variância nos dados).<BR>
 Em gráficos do tipo "loading plot" geralmente se utilizam as duas primeiras colunas dessa tabela."""

    pass


  def getTabelaCarregamentosPrincipaisAntesRotacao(self) -> Tabela:
    """Retorna em uma tabela a relação de "carregamentos principais" que são obtidos em "análise fatorial", antes de aplicação
 de alguma técnica de "rotação" (ex: VARIMAX).<BR>
 Trata-se dos próprios auto-vetores divididos pela raiz quadrada dos correspondentes auto-valores.<BR>
 As colunas da tabela estão associadas a cada um desses componentes principais (os auto-vetores divididos pela raiz quadrada dos correspondentes auto-valores).<BR>
 As linhas da tabela representam as variáveis originais que são explicadas por esses componentes principais."""

    pass


  def getTabelaCarregamentosPrincipaisAposRotacao(self, metodo) -> Tabela:
    """Retorna em uma tabela a relação de "carregamentos principais" que são obtidos em "análise fatorial", após aplicação
 de alguma técnica de "rotação" (ex: VARIMAX).<BR>
 Em geral se utilizam essas informações para verificar como as variáveis se relacionam com os fatores. A "rotação" se destina a deixar mais evidente os grupos 
 de variáveis que se relacionam para compor algum dos "fatores". Por exemplo, se o primeiro fator apresenta números próximos de +1 ou -1 (ex: 0,98) para determinadas
 variáveis X1 e X2, e números próximos de 0 (ex: 0,001) para variáveis X3 e X4, então podemos supor que as variáveis "X1" e "X2" estão mais relacionadas entre si e que sua 
 variabilidade pode ser explicada pelo primeiro fator. A "rotação" não afeta as comunalidades correspondentes aos "fatores", mas redistribui a soma dos quadrados de cada carregamento (que antes da rotação se iguala ao correspondente autovalor).<BR>
 As colunas da tabela estão associadas a cada um desses carregamentos (que estão relacionados aos fatores). A primeira coluna apresenta os nomes das variáveis (isto é, os títulos das colunas da tabela original).<BR>
 As linhas da tabela representam as variáveis originais que são explicadas por esses fatores."""

    pass


  def getTabelaComponentesPrincipais(self) -> Tabela:
    """Retorna em um objeto "tabela" as "pontuações" conforme os "componentes principais" (isto é, o resultado da aplicação da técnica PCA).<BR>
 A tabela resultante apresenta dimensão N x M, onde N é a quantidade de linhas que havia na tabela original e M é
 a quantidade de componentes principais (se a tabela original apresentava colunas de tipo não-numérico, essas colunas
 são também apresentadas na tabela resultante em acréscimo aos componentes principais).<BR>
 Em gráficos do tipo "score plot" geralmente se utilizam as duas primeiras colunas dessa tabela."""

    pass


  def getTabelaDesviosDadosOriginais(self) -> Tabela:
    """Caso este objeto tenha sido originado a partir de um conjunto de dados que passaram por um pre-processamento de 'padronização' (isto é,
 foram transformados de forma a assumirem média zero e desvio padrão unitário), retorna nesta tabela a relação de valores correspondentes
 ao 'desvio padrão' de cada uma das colunas numéricas da tabela original.<BR>
 Note que, dependendo de como esta 'padronização' foi feita, é possível que nenhuma informação seja apresentada aqui. Serão apresentadas
 informações somente se a 'padronização' ocorreu durante a aplicação da técnica 'PCA' (isto é, se o parâmetro 'normaliza' do método
 correspondente era 'verdadeiro', como em {@link Tabela#aplicaPrincipalComponentAnalysis(int, boolean) aplicaPrincipalComponentAnalysis} ou
 em {@link Matriz#aplicaPrincipalComponentAnalysis(int, boolean, boolean) aplicaPrincipalComponentAnalysis}).<BR>
 Caso o objeto PCA tenha sido obtido diretamente a partir de uma matriz de covariância, esta informação não está disponível.<BR>"""

    pass


  def getTabelaFatoresPrincipaisNormalizados(self) -> Tabela:
    """Retorna em um objeto "tabela" os "fatores principais normalizados" (isto é, o resultado da aplicação da técnica PCA seguido 
 da "fatoração" para estabelecer variância unitária)."""

    pass


  def getTabelaMediasDadosOriginais(self) -> Tabela:
    """Caso este objeto tenha sido originado a partir de um conjunto de dados que passaram por um pre-processamento de 'padronização' (isto é,
 foram transformados de forma a assumirem média zero e desvio padrão unitário), retorna nesta tabela a relação de valores correspondentes
 à 'média' de cada uma das colunas numéricas da tabela original.<BR>
 Note que, dependendo de como esta 'padronização' foi feita, é possível que nenhuma informação seja apresentada aqui. Serão apresentadas
 informações somente se a 'padronização' ocorreu durante a aplicação da técnica 'PCA' (isto é, se o parâmetro 'normaliza' do método
 correspondente era 'verdadeiro', como em {@link Tabela#aplicaPrincipalComponentAnalysis(int, boolean) aplicaPrincipalComponentAnalysis} ou
 em {@link Matriz#aplicaPrincipalComponentAnalysis(int, boolean, boolean) aplicaPrincipalComponentAnalysis}).<BR>
 Caso o objeto PCA tenha sido obtido diretamente a partir de uma matriz de covariância, esta informação não está disponível.<BR>"""

    pass


  def getTesteEsfericidadeBartlett(self) -> float:
    """Aplica o chamado 'Teste de Esfericidade de Bartlett' para verificar se para um determinado
 conjunto de dados é apropriado aplicar uma técnica de redução de variáveis, tais como PCA 
 (Principal Component Analysis) e FA (Factor Analysis).<BR> 
 Este teste basicamente testa a 'hipótese nula' de que matriz de correlação dos dados
 observados é a matriz identidade. Caso esta hipótese seja rejeitada, então considera-se
 que há correlações entre as variáveis originais, o que pode ser um indicativo de que pode
 ser útil empregar PCA ou FA para redução das variáveis. Porém, caso a hipótese não seja
 rejeitada, é provável que PCA ou FA não seja tão útil para este propósito. <BR>
 Ou seja, utilizamos este teste para saber se uma determinada situação se beneficiará da 'redução
 de variáveis' utilizando a técnica PCA ou FA.<BR>
 OBS: segundo algumas pessoas (http://eric.univ-lyon2.fr/~ricco/tanagra/fichiers/en_Tanagra_KMO_Bartlett.pdf), este
 'teste' possui um ponto fraco: ela tende a ser estatisticamente significante quando o número 
 de instâncias no conjunto de dados observados aumenta. Recomenda-se a utilização deste teste somente 
 quando a razão n/p (n = número de instâncias observadas, p = número de variáveis originais) é inferior a 5."""

    pass


  def getTesteKMO(self) -> float:
    """Aplica o chamado 'Teste KMO', onde KMO são as iniciais dos nomes dos autores da técnica: Kaiser-Mayer-Olkin.<BR>
 Assim como o 'teste de esfericidade de Bartlett', o teste 'KMO' também se propõe a indicar se para um 
 determinado conjunto de dados observados haveria algum ganho em aplicar PCA ou FA como técnica de redução
 de variáveis.<BR>
 No entanto, diferentemente do outro teste, o teste KMO compara a matriz de correlação original com uma
 matriz de correlação 'parcial', onde é amenizado o efeito de correlação de múltiplas variáveis sobre um
 par qualquer de variáveis.<BR>
 O resultado varia de 0 a 1.<BR>
 Se o resultado é alto (próximo de 1), supõe-se que a técnica PCA (ou FA) pode ser útil para o propósito de
 redução de variáveis.<BR>
 Porém, se o resultado é baixo (próximo de 0), a técnica PCA (ou FA) pode não ser relevante.<BR>
 Alguns autores (MINGOTI, S.A.) sugerem uma 'tabela de interpretação' deste indicador:<BR>
 <TABLE BORDER=1>
 <TR><TH>Valor</TH><TH>Grau de Adequação</TH></TR>
 <TR><TD>&gt; 0,90</TD><TD>Ótima</TD></TR>
 <TR><TD>de 0,80 a 0,90</TD><TD>Boa</TD></TR>
 <TR><TD>de 0,70 a 0,80</TD><TD>Razoável</TD></TR>
 <TR><TD>de 0,60 a 0,70</TD><TD>Baixa</TD></TR>
 <TR><TD>&lt; 0,60 Inadequada</TD></TR>
 </TABLE>"""

    pass


  def novoGraficoScree(self) -> Grafico:
    """Cria um gráfico do tipo 'scree', que exibe a relação de auto-valores associado a cada componente principal, na ordem do maior para o menor.<BR>
 Este gráfico é utilizado para auxiliar na escolha da quantidade de componentes principais. Geralmente se escolhem componentes principais
 com base em mais de um critério. Um dos critérios é aquele onde o acréscimo de componentes principais praticamente não alteram muito a proporção
 da variância explicada (isto é, quando a 'curva Scree' passa por um ponto de inflexão a partir do qual passa a variar pouco)."""

    pass


  def novoGraficoVariaveis(self, rotacao) -> Grafico:
    """Cria um gráfico que exibe as 'variáveis' estimadas pela técnica PCA através de 'setas', uma seta para cada variável (coluna de tipo numérico na tabela de dados),
 onde a orientação de cada seta indica os 'carregamentos' da variável correspondente em relação aos dois primeiros componentes principais (dois principais auto-vetores da análise PCA).<BR>
 Os carregamentos considerados são aqueles obtidos após rotação pela técnica indicada no parâmetro (ex: VARIMAX), ou nenhuma rotação se o parâmetro for deixado em branco.<BR>
 Você pode posteriormente adicionar este gráfico a outro gráfico utilizando {@link Grafico#addOutroGrafico(Grafico) addOutroGrafico} ou pode alternativamente inserir diretamente a ele
 dados para serem exibidos através de um 'gráfico dispersão'.<BR>
 O raio da circunferência é calculado utilizando a estatística chi-quadrado para 2 graus de liberdade e para 95% de confiança."""

    pass


  def setDimensao(self, dimensao) -> None:
    """Indica a "dimensão", isto é, a quantidade de "componentes principais" que se deseja utilizar para 'explicar' a variância dos dados"""

    pass


  def setTitulosCaracteristicasNumericas(self, titulos) -> None:
    """Define os títulos das variáveis (coluna da tabela do tipo numérico), que podem ser exibidas em algumas das tabelas
 retornadas por este objeto.<BR>
 Caso este objeto tenha sido originado a partir de uma {@link Tabela Tabela}, não há necessidade de executar este método,
 pois os títulos já são por padrão definidos como sendo os títulos correspondentes na tabela de origem.<BR>
 Porém, se este objeto foi originado a partir de uma {@link Matriz Matriz}, não temos 'títulos' para as 'variáveis', sendo
 então adotado o título genérico "VARIÁVEL #xx", a menos que os títulos sejam definidos através deste método."""

    pass

class PromptValue ():
  """Classe utilizada para armazenar a resposta ao um prompt de relatório"""

  def add(self, lista) -> None:
    """Inclui uma lista de valores para a resposta ao prompt"""

    pass


  def add(self, valor) -> None:
    """Inclui um valor como resposta ao prompt"""

    pass


  def add(self, lista) -> None:
    pass


  def addValor(self, valor) -> None:
    """Inclui um valor como resposta ao prompt"""

    pass


  def addValores(self, lista) -> None:
    """Inclui uma lista de valores para a resposta ao prompt"""

    pass


  def apagarValores(self) -> None:
    """Apaga os valores definidos como resposta ao prompt"""

    pass


  def getNomeFormulario(self) -> str:
    """Obtém o nome do formulário a ser utilizado na expressão de qualificação do
 atributo"""

    pass


  def getOperador(self) -> str:
    """Obtém o operador a ser utilizado em prompt do tipo expressão"""

    pass


  def getValores(self) -> list:
    """Obtém a lista de valores a ser utilizado na resposta ao prompt"""

    pass


  def isNumber(self) -> bool:
    pass


  def setNomeFormulario(self, nomeFormulario) -> None:
    """Define o nome do formulário a ser utilizado na expressão de qualificação
 do atributo."""

    pass


  def setOperador(self, operador) -> None:
    """Define o operador a ser utilizado no prompt do tipo expressão"""

    pass

class RegistroAgendamentoDossie ():
  """Representa um registro de agendamento no Dossiê Integrado
 
 O agendamento é feito em um dia para receber os dados no dia seguinte.
 
 Apenas algumas bases exigem o agendamento, porém todas podem ser baixadas dessa forma."""

  def getAnoFinal(self) -> int:
    pass


  def getAnoInicial(self) -> int:
    pass


  def getBases(self) -> list:
    pass


  def getData(self) -> Data:
    pass


  def getHora(self) -> Hora:
    pass


  def getListaBases(self) -> str:
    pass


  def getNI(self) -> CNPJ_CPF:
    pass


  def getRazaoSocial(self) -> str:
    pass


  def isProcessado(self) -> bool:
    pass


  def setAnoFinal(self, anoFinal) -> None:
    """Define o último ano para o qual serão baixados os dados"""

    pass


  def setAnoInicial(self, anoInicial) -> None:
    """Define o primeiro ano para o qual serão baixados os dados"""

    pass


  def setBases(self, bases) -> None:
    """Define a relação das bases agendadas"""

    pass


  def setData(self, data) -> None:
    pass


  def setHora(self, hora) -> None:
    pass


  def setNI(self, ni) -> None:
    """Define o NI do contribuinte"""

    pass


  def setNI(self, ni) -> None:
    """Define o NI do contribuinte"""

    pass


  def setNI(self, codigo) -> None:
    """Define o NI do contribuinte"""

    pass


  def setNI(self, codigo, pf) -> None:
    """Define o NI do contribuinte"""

    pass


  def setProcessado(self, processado) -> None:
    """Define se o pedido foi processado ou não"""

    pass

class RegraNcmPisCofins ():

  def getAliquotaCofins(self) -> Double:
    """Retorna um valor em ponto flutuante com a alíquota do PIS vigente no
 período"""

    pass


  def getAliquotaPis(self) -> Double:
    """Retorna um valor em ponto flutuante com a alíquota do PIS vigente no
 período"""

    pass


  def getBaseLegal(self) -> str:
    """Base legal"""

    pass


  def getDataFim(self) -> Date:
    """Informa a data do final da vigência da regra. Caso esta data seja
 nula, a regra continua vigente."""

    pass


  def getDataInicio(self) -> Date:
    """Informa a data a partir da qual a regra está em vigência"""

    pass


  def getDescricao(self) -> str:
    """Retorna a descrição da regra de tributação."""

    pass


  def getEx(self) -> Integer:
    """retorna um inteiro com o Ex da mercadoria"""

    pass


  def getForma(self) -> int:
    """Retorna a forma de tributação com um código numérico."""

    pass


  def getFormaTributacao(self) -> str:
    """Retorna qual a regra de tributacao por extenso"""

    pass


  def getNCM(self) -> str:
    """Retorna um string com o NCM da mercadoria"""

    pass


  def getSCC(self) -> byte:
    """Tipo de processamento a ser feito no SCC"""

    pass


  def getTributacao(self) -> str:
    """Este indicador informa qual a forma de tributação. Estando nulo, a
 tributação é normal, ou seja não cumulativa"""

    pass


  def getUnidade(self) -> str:
    """Unidade de venda do produto. Usada especialmente na tributação por
 unidade de medida"""

    pass


  def isAgrupado(self) -> Boolean:
    """Caso a regra envolva um agrupamento de NCM, ela valerá para todos os
 NCMs abaixo do indicado. Assim, se o NCM for 40000000, a regra valetá
 paa todo o capítulo 40"""

    pass

class RegraNcmPisCofinsImpl ():

  def compareTo(self, o) -> int:
    pass


  def equals(self, o) -> bool:
    pass


  def getAliquotaCofins(self) -> Double:
    """Retorna um valor em ponto flutuante com a alíquota do PIS vigente no
 período"""

    pass


  def getAliquotaPis(self) -> Double:
    """Retorna um valor em ponto flutuante com a alíquota do PIS vigente no
 período"""

    pass


  def getBaseLegal(self) -> str:
    pass


  def getDataFim(self) -> Date:
    """Informa a data do final da vigência da regra. Caso esta data seja
 nula, a regra continua vigente."""

    pass


  def getDataInicio(self) -> Date:
    """Informa a data a partir da qual a regra está em vigência"""

    pass


  def getDescricao(self) -> str:
    """Retorna a descrição da regra de tributação."""

    pass


  def getEx(self) -> Integer:
    """retorna um inteiro com o Ex da mercadoria"""

    pass


  def getForma(self) -> int:
    """Retorna a forma de tributação com um código numérico."""

    pass


  def getFormaTributacao(self) -> str:
    """Retorna qual a regra de tributacao por extenso"""

    pass


  def getNCM(self) -> str:
    """Retorna um string com o NCM da mercadoria"""

    pass


  def getSCC(self) -> byte:
    pass


  def getTributacao(self) -> str:
    """Este indicador informa qual a forma de tributação. Estando nulo, a
 tributação é normal, ou seja não cumulativa"""

    pass


  def getUnidade(self) -> str:
    """Unidade de venda do produto. Usada especialmente na tributação por
 unidade de medida"""

    pass


  def hashCode(self) -> int:
    pass


  def isAgrupado(self) -> Boolean:
    """Caso a regra envolva um agrupamento de NCM, ela valerá para todos os
 NCMs abaixo do indicado. Assim, se o NCM for 40000000, a regra valetá
 paa todo o capítulo 40"""

    pass


  def setBaseLegal(self, baseLegal) -> None:
    pass


  def toString(self) -> str:
    pass

class RegressaoMultipla ():
  """Classe que apresenta o resultado de uma regressão linear múltipla.<BR>
 
 A regressão linear múltipla é um método estatístico utilizado para estimar a
 relação entre uma variável dependente "y" e duas ou mais variáveis
 independentes "x".<BR>
 
 O método escolhe o melhor "hiperplano" que passa pelos pontos de tal modo a
 minimizar o "erro", que é medido pelo quadrado das diferenças de "y" ao
 resultado do produto matricial X x B (onde X é a matriz que apresenta os
 valores "independentes" e "B" é vetor contendo os parâmetros que se pretende
 determinar).<BR>"""

  def getCoeficienteDeterminacaoMultipla(self) -> float:
    """Retorna o coeficiente de determinação múltipla ("R" quadrado).<BR>
 Ele é indicativo de quanto da variância da variável dependente pode ser
 explicado pelas variáveis independentes."""

    pass


  def getCoeficienteDeterminacaoMultiplaAjustado(self) -> float:
    """Retorna o coeficiente de determinação múltipla ajustado ("R" quadrado ajustado).<BR>
 Geralmente será menor que o coeficiente de determinação não ajustado. A razão disso
 é que com o aumento no número de variáveis independentes que não são significantes para a análise, o coeficiente não ajustado
 geralmente aumenta e o coeficiente ajustado diminui."""

    pass


  def getErroPadrao(self) -> float:
    """Retorna o erro padrão da regressão"""

    pass


  def getGrafico(self, k) -> Grafico:
    """Obtém um gráfico que representa a reta definida pelo método de regressão
 linear com relação a uma das variáveis independentes.<BR>"""

    pass


  def getInterceptacao(self) -> float:
    """Indica o parâmetro de interceptação do modelo de regressão."""

    pass


  def getParametros(self) -> float:
    """Retorna o resultado da estimativa dos parâmetros da regressão linear
 (isto é, o vetor que é multiplicado à matriz X de modo a obter a melhor
 estimativa para Y)."""

    pass


  def getPrevisao(self, x) -> float:
    """Retorna o valor "previsto" de "y" para um conjunto de variáveis preditoras "x".<BR>
 Aplica a equação da regressão conforme mantida por este objeto (isto é, multiplica cada componente
 de "x" pelo correspondente coeficiente e soma o coeficiente de interceptação caso exista algum)."""

    pass


  def getPrevisoes(self, matriz, colunasX, colunaY) -> None:
    """Utilizando o modelo atual de regressão, realiza 'previsões' sobre os dados relacionados em uma MATRIZ.<BR>
 Considera-se os valores das variáveis independentes X indicados nas colunas cujos índices são informados no parâmetro 'colunasX'.<BR>
 Para cada linha, emprega o modelo de regressão para 'prever' o valor da variável dependente Y.<BR>
 O valor 'previsto' é preenchido na mesma MATRIZ, na coluna cujo índice é informado no parâmetro 'colunaY'.<BR>
 Caso a matriz não possua a coluna informada em 'colunaY', ela é ampliada de modo a incluir tal coluna.<BR>
 Se a coluna já existe na matriz, seus valores anteriores são ignorados."""

    pass


  def getPrevisoes(self, tabela, colunasX, colunaY) -> None:
    """Utilizando o modelo atual de regressão, realiza 'previsões' sobre os dados relacionados em uma TABELA.<BR>
 Considera-se os valores das variáveis independentes X indicados nas colunas cujos índices são informados no parâmetro 'colunasX'.<BR>
 Para cada linha, emprega o modelo de regressão para 'prever' o valor da variável dependente Y.<BR>
 O valor 'previsto' é preenchido na mesma TABELA, na coluna cujo índice é informado no parâmetro 'colunaY'.<BR>
 Caso a tabela não possua a coluna informada em 'colunaY', ela é ampliada de modo a incluir tal coluna.<BR>
 Se a coluna já existe na tabela, seus valores anteriores são ignorados."""

    pass


  def getQuantidadeLinhas(self) -> int:
    """Retorna a quantidade de linhas que foram consideradas na regressão
 linear."""

    pass


  def getQuantidadeParametros(self) -> int:
    """Retorna a quantidade de parâmetros da regressão linear. Será igual à quantidade
 de atributos independentes + 1 caso o modelo inclua um valor de 'interceptação'."""

    pass


  def getQuantidadeVariaveisIndependentes(self) -> int:
    """Retorna a quantidade de atributos "independentes" (colunas X)."""

    pass


  def getResiduos(self) -> float:
    """Retorna o vetor de "resíduos". Isto é, se representarmos os dados da
 regressão linear múltipla na forma matricial Y = X x B + R, então "R" é o
 vetor de "resíduos" retornado por este método (isto é, a diferença para
 cada linha entre o valor real da variável independente e o produto entre
 as variáveis independentes e os respectivos parâmetros obtidos por
 regressão linear)."""

    pass


  def getVarianciaParametros(self) -> Tabela:
    """Retorna em uma "tabela" a variância dos parâmetros de regressão linear."""

    pass


  def getVarianciaRegressando(self) -> float:
    """Retorna a variância do "regressando" (isto é, de Y)."""

    pass

class RegressaoSimples ():
  """Classe que apresenta o resultado de uma regressão linear simples.<BR>
 
 A regressão linear simples é um método estatístico utilizado para estimar a
 relação entre uma variável dependente "y" e uma variável independente "x",
 tomando como base uma relação de "pontos" do tipo (x,y).<BR>
 
 O método escolhe a melhor "reta" que passa pelos pontos de tal modo a
 minimizar o "erro", que é medido pelo quadrado das diferenças de "y" de cada
 ponto em relação ao correspondente ponto sobre a reta considerada.<BR>
 
 A "reta" é então definida pela expressão: y = a + x * b<BR>
 Onde a = interceptação da reta com o eixo vertical<BR>
 e b = declive da reta<BR>"""

  def getCoeficienteDeterminacao(self) -> float:
    """Retorna o coeficiente de determinação ("R" quadrado).<BR>
 Ele é indicativo de quanto da variância da variável dependente pode ser
 explicado pela variável independente. Se há menos de três pontos
 observados, este método retorna um número inválido."""

    pass


  def getCoeficientePearson(self) -> float:
    """Retorna o coeficiente de correlação de Pearson (coeficiente de correlação
 produto-momento), que mede o grau de correlação entre as duas variáveis
 X,Y observadas.<BR>
 Geralmente ele é chamado de "R" em técnicas que empregam regressão linear
 simples.<BR>
 Se há menos de três pontos observados, este método retorna um número
 inválido."""

    pass


  def getDeclive(self) -> float:
    """Indica o declive da reta"""

    pass


  def getDecliveErroPadrao(self) -> float:
    """Retorna o erro padrão na estimativa do coeficiente de declive da reta"""

    pass


  def getErroQuadraticoMedio(self) -> float:
    """Retorna o erro quadrático médio, que corresponde à soma dos quadrados dos
 erros dividido pelos graus de liberdade (abreviado para MSE na
 nomenclatura em inglês).<BR>
 Se há menos de três pontos observados, ou se não há variação em "x", este
 método retorna um número inválido."""

    pass


  def getGrafico(self) -> Grafico:
    """Obtém um gráfico que representa a reta definida pelo método de regressão
 linear.<BR>
 Este gráfico apresentará inicialmente apenas a linha correspondente ao
 modelo linear ajustado aos dados.<BR>
 Trata-se de um gráfico do tipo 'dispersão', porém os pontos correspondentes aos
 dados não são exibidos.<BR>
 Você poderá, se quiser, adicionar os pontos a este objeto gráfico. Ou, se quiser,
 poderá adicionar este a outro gráfico.<BR> 
 Pode também ser exibido diretamente em uma janela, pode ser armazenado em um arquivo,
 etc."""

    pass


  def getInterceptacao(self) -> float:
    """Indica a interceptação da reta com o eixo vertical."""

    pass


  def getInterceptacaoErroPadrao(self) -> float:
    """Retorna o erro padrão na estimativa do coeficiente de interceptação da
 reta com o eixo vertical."""

    pass


  def getIntervaloConfianca(self, x, novo, grauConfianca) -> float:
    """Retorna o 'intervalo de confiança' para um determinado valor."""

    pass


  def getIntervalosConfianca(self, matriz, colunaX, colunaLimitesInferiores, colunaLimitesSuperiores, novo, grauConfianca) -> None:
    """Retorna os 'intervalos de confiança' para os valores de uma MATRIZ.<BR>
 Considera-se o valor X indicado na coluna cujo índice é informado no parâmetro 'colunaX'.<BR>
 Para cada linha, calcula o 'intervalo de confiança' correspondente ao valor X.<BR>
 O intervalo de confiança comprende dois valores: o limite inferior e o limite superior. Ambos são preenchidos na mesma linha da MATRIZ, nas colunas indicadas
 no terceiro e quarto parâmetros.<BR>
 Caso a matriz não possua as colunas informadas em 'colunaLimitesInferiores' ou em 'colunaLimitesSuperiores', ela é ampliada de modo a incluir tais colunas.<BR>
 Se as colunas já existem na matriz, seus valores anteriores são ignorados."""

    pass


  def getIntervalosConfianca(self, tabela, colunaX, colunaLimitesInferiores, colunaLimitesSuperiores, novo, grauConfianca) -> None:
    """Retorna os 'intervalos de confiança' para os valores de uma TABELA.<BR>
 Considera-se o valor X indicado na coluna cujo índice é informado no parâmetro 'colunaX'.<BR>
 Para cada linha, calcula o 'intervalo de confiança' correspondente ao valor X.<BR>
 O intervalo de confiança comprende dois valores: o limite inferior e o limite superior. Ambos são preenchidos na mesma linha da TABELA, nas colunas indicadas
 no terceiro e quarto parâmetros.<BR>
 Caso a tabela não possua as colunas informadas em 'colunaLimitesInferiores' ou em 'colunaLimitesSuperiores', ela é ampliada de modo a incluir tais colunas.<BR>
 Se as colunas já existem na tabela, seus valores anteriores são ignorados."""

    pass


  def getPrevisao(self, x) -> float:
    """Retorna o valor "previsto" de "y" para um dado "x". Aplica a equação da
 reta (isto é, multiplica "x" pelo coeficiente de declive e soma o
 coeficiente de interceptação)."""

    pass


  def getPrevisoes(self, matriz, colunaX, colunaY) -> None:
    """Utilizando o modelo atual de regressão, realiza 'previsões' sobre os dados relacionados em uma MATRIZ.<BR>
 Considera-se o valor X indicado na coluna cujo índice é informado no parâmetro 'colunaX'.<BR>
 Para cada linha, emprega o modelo de regressão para 'prever' o valor da variável dependente Y.<BR>
 O valor 'previsto' é preenchido na mesma MATRIZ, na coluna cujo índice é informado no parâmetro 'colunaY'.<BR>
 Caso a matriz não possua a coluna informada em 'colunaY', ela é ampliada de modo a incluir tal coluna.<BR>
 Se a coluna já existe na matriz, seus valores anteriores são ignorados."""

    pass


  def getPrevisoes(self, tabela, colunaX, colunaY) -> None:
    """Utilizando o modelo atual de regressão, realiza 'previsões' sobre os dados relacionados em uma TABELA.<BR>
 Considera-se o valor X indicado na coluna cujo índice é informado no parâmetro 'colunaX'.<BR>
 Para cada linha, emprega o modelo de regressão para 'prever' o valor da variável dependente Y.<BR>
 O valor 'previsto' é preenchido na mesma TABELA, na coluna cujo índice é informado no parâmetro 'colunaY'.<BR>
 Caso a tabela não possua a coluna informada em 'colunaY', ela é ampliada de modo a incluir tal coluna.<BR>
 Se a coluna já existe na tabela, seus valores anteriores são ignorados."""

    pass


  def getQtdObservacoes(self) -> long:
    """Retorna a quantidade de pontos que foram observados para o propósito da
 regressão linear"""

    pass


  def getSSE(self) -> float:
    """Retorna a soma dos erros quadrados (abreviado para SSE na nomenclatura em
 inglês).<BR>
 Se há menos de três pontos observados, ou se não há variação em "x", este
 método retorna um número inválido."""

    pass


  def getSSM(self) -> float:
    """Retorna a soma dos quadrados dos desvios das previsões de "y" em relação à média
 (abreviado para SSM na nomenclatura em inglês, também chamado de SSR por outros autores).<BR>
 Se há menos de três pontos observados, ou se não há variação em "x", este
 método retorna um número inválido."""

    pass


  def getSST(self) -> float:
    """Retorna a total soma dos quadrados, que corresponde à variância total na variável dependente y
 (abreviado para SST na nomenclatura em inglês)."""

    pass


  def getSignificancia(self) -> float:
    """Retorna a significância do coeficiente de correlação."""

    pass


  def hasInterceptacao(self) -> bool:
    """Retorna a indicação de que existe uma interceptação entre a reta e o eixo
 vertical."""

    pass

class SPACE ():
  """Representa uma área de trabalho do SPACE (Espaço Interativo do Script Visual) que pode ser utilizado
 para execução pelo Script.<BR>
 
 Geralmente este tipo de objeto é disponibilizado para uma linguagem de script
 quando há um <B>ANEXO</B> no script do tipo \"SPACE\".<BR>"""

  def addComponente(self, nome, componente) -> None:
    """Acrescenta um componente qualquer, podendo ser uma TABELA, um GRAFICO, uma MATRIZ, um MAD, ou outro objeto qualquer criado pelo script.<BR>
 Será apresentado um painel correspondente a este componente dentro do SPACE.<BR>
 Se já existir um componente com o nome indicado na área de trabalho do SPACE, ele será substituído pelo novo, com a mesma posição e dimensões. Isso
 também se aplica a componentes de tipos diferentes (ex: substituir uma tabela por um gráfico)."""

    pass


  def atualizaComponente(self, nome) -> None:
    """Caso a janela tenha sido construída, atualiza o painel exibido sobre um determinado componente. Presume que já foi inserido no SPACE um componente cujo nome é
 indicado no parâmetro. Isso é útil quando o script realiza alguma alteração de alguma propriedade do componente enquanto a janela está sendo exibida e se deseja
 que esta alteração se torne aparente ao usuário."""

    pass


  def atualizaJanela(self) -> None:
    """Caso a janela já tenha sido construída, faz com que o conteúdo exibido seja atualizado, para refletir mudanças
 realizadas pelo script sobre os componentes internos."""

    pass


  def fecha(self) -> None:
    """Fecha a janela, caso ela esteja sendo exibida"""

    pass


  def getComponente(self, nome) -> Object:
    """Retorna o componente presente neste SPACE ou acessível por ele, dado o nome do componente. O objeto retornado pode ser uma TABELA, um GRAFICO, ou qualquer outro
 tipo de objeto conforme interfaces de script."""

    pass


  def getComponenteAltura(self, nome) -> Integer:
    """Dado o nome de um componente exibido neste SPACE, retorna a algura em pixels, 
 ou retorna NULL se não encontrou um componente com este nome."""

    pass


  def getComponenteBotoes(self, nome) -> Botoes:
    """Retorna o componente presente neste SPACE ou acessível por ele, dado o nome do componente. Este método apenas funciona se o componente é do tipo BOTÕES. Para
 outros tipos de componentes, utilize outros métodos."""

    pass


  def getComponenteEntradaCampo(self, nome) -> EntradaCampo:
    """Retorna o componente presente neste SPACE ou acessível por ele, dado o nome do componente. Este método apenas funciona se o componente é do tipo ENTRADA COM CAMPO SIMPLES. Para
 outros tipos de componentes, utilize outros métodos."""

    pass


  def getComponenteGrafico(self, nome) -> Grafico:
    """Retorna o componente presente neste SPACE ou acessível por ele, dado o nome do componente. Este método apenas funciona se o componente é do tipo GRAFICO. Para
 outros tipos de componentes, utilize outros métodos."""

    pass


  def getComponenteLargura(self, nome) -> Integer:
    """Dado o nome de um componente exibido neste SPACE, retorna a largura em pixels, 
 ou retorna NULL se não encontrou um componente com este nome."""

    pass


  def getComponenteMensagemTexto(self, nome) -> MensagemTexto:
    """Retorna o componente presente neste SPACE ou acessível por ele, dado o nome do componente. Este método apenas funciona se o componente é do tipo MENSAGEM DE TEXTO. Para
 outros tipos de componentes, utilize outros métodos."""

    pass


  def getComponenteMenu(self, nome) -> Menu:
    """Retorna o componente presente neste SPACE ou acessível por ele, dado o nome do componente. Este método apenas funciona se o componente é do tipo MENU. Para
 outros tipos de componentes, utilize outros métodos."""

    pass


  def getComponenteMenuComImagens(self, nome) -> MenuImagens:
    """Retorna o componente presente neste SPACE ou acessível por ele, dado o nome do componente. Este método apenas funciona se o componente é do tipo MENU COM IMAGENS. Para
 outros tipos de componentes, utilize outros métodos."""

    pass


  def getComponentePosicaoX(self, nome) -> Integer:
    """Dado o nome de um componente exibido neste SPACE, retorna a posição X em pixels do canto superior esquerdo, 
 ou retorna NULL se não encontrou um componente com este nome."""

    pass


  def getComponentePosicaoY(self, nome) -> Integer:
    """Dado o nome de um componente exibido neste SPACE, retorna a posição Y em pixels do canto superior esquerdo, 
 ou retorna NULL se não encontrou um componente com este nome."""

    pass


  def getComponenteTabela(self, nome) -> Tabela:
    """Retorna o componente presente neste SPACE ou acessível por ele, dado o nome do componente. Este método apenas funciona se o componente é do tipo TABELA. Para
 outros tipos de componentes, utilize outros métodos."""

    pass


  def getComponentes(self) -> list:
    """Retorna todos os componentes presentes neste SPACE, ou acessíveis por ele. Os objetos retornados podem ser de variados tipos, incluindo TABELAS, GRAFICOS, etc."""

    pass


  def getNomesComponentes(self) -> list:
    """Retorna os nomes de todos os componentes presentes neste SPACE, ou acessíveis por ele."""

    pass


  def getRespostaUsuario(self, nome) -> str:
    """Retorna a resposta escolhida ou digitada pelo usuário para um determinado componente exibido na janela do SPACE.<BR>
 Isto é, se o componente for:<BR>
 a) um menu (com ou sem imagens), retorna a opção de menu escolhida<BR>
 b) um campo simples de entrada de texto, retorna o texto digitado<BR>
 c) um campo simples de múltipla escolha (tipo 'combo-box'), retorna a opção escolhida<BR>
 Nos demais casos, retorna NULL."""

    pass


  def isJanelaAtiva(self) -> bool:
    """Retorna a indicação de que a janela está ativa (isto é, detém o foco do mouse)"""

    pass


  def isJanelaVisivel(self) -> bool:
    """Retorna a indicação de que a janela está sendo apresentada neste momento"""

    pass


  def novaEntradaCampo(self, nome) -> EntradaCampo:
    """Cria um novo componente do tipo 'campo simples' para entrada de dados pelo usuário (ex: para digitar um texto ou para escolher uma dentre várias opções).<BR>
 Este componente será incluído na janela do SPACE e ficará associado ao nome indicado no parâmetro, que deve ser um nome único dentro da mesma janela e é utilizado
 para identificar este campo.<BR>
 Este método retorna o próprio componente que foi criado, possibilitando que o script preencha as demais configurações do campo (ex: para informar quais opções estarão
 disponíveis para escolha, caso seja necessário definir desta forma)."""

    pass


  def novaMensagemTexto(self, nome) -> MensagemTexto:
    """Cria um novo componente do tipo 'mensagem de texto', podendo ser uma mensagem simples, um aviso ou uma mensagem de erro.<BR>
 Este componente será incluído na janela do SPACE e ficará associado ao nome indicado no parâmetro, que deve ser um nome único dentro da mesma janela e é utilizado
 para identificar este componente.<BR>
 Este método retorna o próprio componente que foi criado, possibilitando que o script preencha as demais configurações da mensagem (ex: para informar qual é a mensagem)."""

    pass


  def novaMensagemTexto(self, nome, mensagem) -> MensagemTexto:
    """Alternativa do método para criar nova mensagem de texto. Nesta alternativa já é indicada qual é a mensagem que deseja exibir."""

    pass


  def novoBotoes(self, nome) -> Botoes:
    """Cria um novo componente do tipo 'botões' para apresentar uma relação de botões.<BR>
 Este componente será incluído na janela do SPACE e ficará associado ao nome indicado no parâmetro, que deve ser um nome único dentro da mesma janela e é utilizado
 para identificar este campo.<BR>
 Este método retorna o próprio componente que foi criado, possibilitando que o script preencha as demais configurações do campo (ex: para informar quais opções estarão
 disponíveis para escolha, caso seja necessário definir desta forma)."""

    pass


  def novoMenu(self, nome) -> Menu:
    """Cria um novo componente do tipo 'menu'.<BR>
 Este componente será incluído na janela do SPACE e ficará associado ao nome indicado no parâmetro, que deve ser um nome único dentro da mesma janela e é utilizado
 para identificar este componente.<BR>
 Este método retorna o próprio componente que foi criado, possibilitando que o script preencha as demais configurações do menu (ex: para informar quais serão os itens do menu)."""

    pass


  def novoMenuComImagens(self, nome) -> MenuImagens:
    """Cria um novo componente do tipo 'menu com imagens'.<BR>
 Este componente será incluído na janela do SPACE e ficará associado ao nome indicado no parâmetro, que deve ser um nome único dentro da mesma janela e é utilizado
 para identificar este componente.<BR>
 Este método retorna o próprio componente que foi criado, possibilitando que o script preencha as demais configurações do menu (ex: para informar quais serão os itens do menu e quais
 serão suas imagens)."""

    pass


  def readExternal(self, in) -> None:
    pass


  def removeComponente(self, nome) -> None:
    """Remove um componente presente neste SPACE, dado o nome com que ele foi inserido."""

    pass


  def removeComponentes(self) -> None:
    """Remove todos os elementos visuais inseridos na área de trabalho"""

    pass


  def setComponentePosicaoTamanho(self, nome, x, y, largura, algura) -> None:
    """Altera a posição e o tamanho de um componente exibido neste SPACE"""

    pass


  def setCorFundo(self, cor) -> None:
    """Define a cor de fundo da janela. O padrão é a cor cinza."""

    pass


  def setJanelaAtiva(self) -> None:
    """Caso a janela já tenha sido construída, mas não esteja com o foco, faz com que ela assuma o foco.<BR>
 OBS: caso a janela não tenha sido ainda construída, nada é feito."""

    pass


  def setMensagemTexto(self, nome, mensagem) -> None:
    """Altera o texto que é exibido em um campo do tipo 'MENSAGEM DE TEXTO'.<BR>
 Presume que já foi inserido no SPACE um componente do tipo 'MENSAGEM DE TEXTO' com o nome indicado no primeiro parâmetro. Caso isso não tenha
 ocorrido, nenhuma mensagem será alterada.<BR>
 OBS: caso queira alterar outras características da 'MENSAGEM DE TEXTO' (ex: alterar a fonte ou a subrotina), utilize o método {@link #getComponenteMensagemTexto(String) getComponenteMensagemTexto} 
 para obter o objeto do tipo {@link MensagemTexto MensagemTexto}, o qual expõe diversos outros métodos para customizar."""

    pass


  def setTextoEntradaCampo(self, nome, conteudo) -> None:
    """Altera o texto que é exibido em um campo do tipo 'ENTRADA COM CAMPO SIMPLES'.<BR>
 Presume que já foi inserido no SPACE um componente do tipo 'ENTRADA COM CAMPO SIMPLES' com o nome indicado no primeiro parâmetro. Caso isso não tenha
 ocorrido, nenhum conteúdo será alterado.<BR>
 OBS: caso queira alterar outras características da 'ENTRADA COM CAMPO SIMPLES' (ex: alterar o tamanho ou o formato), utilize o método {@link #getComponenteEntradaCampo(String) getComponenteEntradaCampo} 
 para obter o objeto do tipo {@link EntradaCampo EntradaCampo}, o qual expõe diversos outros métodos para customizar."""

    pass


  def writeExternal(self, out) -> None:
    pass

class ScriptPromptHandler ():

  def addPrompt(self, nome, valores) -> None:
    pass


  def addPrompt(self, nome, valor) -> None:
    """Acrescenta um valor a ser considerado em resposta a um "prompt" de
 usuário.<BR>
 Caso este método tenha sido executado outra vez para o mesmo "prompt",
 todos os valores passados como parâmetro nas sucessivas chamadas de
 função são considerados.<BR>
 Veja mais informações na função
 {@link DW#setPrompt(String, Object) setPrompt}."""

    pass


  def apagaPrompt(self, nome) -> None:
    """Remove o conteúdo a ser passado em um "prompt" identificado por um
 determinado nome.<BR>
 Esta função desfaz o que foi feito em chamadas anteriores a addPrompt()
 ou setPrompt().<BR>
 Observação: se o conteúdo do "prompt" não for fornecido por um método
 setPrompt() ou addPrompt() previamente a execução do relatório, o
 ContÁgil recusará o preenchimento do prompt quando for solicitado durante
 a execução do relatório do DW."""

    pass


  def apagaPrompts(self) -> None:
    pass


  def getPrompt(self, nome, create) -> PromptValue:
    pass


  def getPromptsNaoRespondidos(self) -> list:
    pass


  def getResposta(self, nome) -> PromptValue:
    pass


  def getRespostas(self) -> dict:
    pass


  def getSolicitarPrompts(self) -> bool:
    pass


  def handlePrompt(self, p) -> bool:
    """Método chamado pelas rotinas de execuçãoo do DW para tratar o uso do
 "prompt" do relatório."""

    pass


  def handlePrompt(self, p) -> bool:
    """Método chamado pelas rotinas de execuçãoo do DW para tratar o uso do
 "prompt" do relatório."""

    pass


  def isFullVerbose(self) -> bool:
    pass


  def isReterRespostaDoUsuario(self) -> bool:
    pass


  def isReterRespostasDoUsuario(self) -> bool:
    pass


  def isUtilizarRespostasPadrao(self) -> bool:
    pass


  def setFullVerbose(self, fullVerbose) -> None:
    pass


  def setPrompt(self, nome, valores, nomeFormulario) -> None:
    """Durante a execução de um relatório do DW, caso o relatório que está sendo
 executado possua algum filtro do tipo "prompt de usuário", o valor deste
 filtro é preenchido com o conteúdo apresentado neste método.<BR>
 Observação: se o conteúdo do "prompt" não for fornecido por um método
 setPrompt() ou addPrompt() previamente à execução do relatório, o
 ContÁgil recusará o preenchimento do prompt quando for solicitado durante
 a execução do relatório do DW."""

    pass


  def setPrompt(self, nome, valor, nomeFormularioAtributo, operador) -> None:
    """Durante a execução de um relatório do DW, caso o relatório que está sendo
 executado possua algum filtro do tipo "prompt de usuário", o valor deste
 filtro é preenchido com o conteúdo apresentado neste método.<BR>
 Observação: se o conteúdo do "prompt" não for fornecido por um método
 setPrompt() ou addPrompt() previamente à execução do relatório, o
 ContÁgil recusará o preenchimento do prompt quando for solicitado durante
 a execução do relatório do DW. Operadores disponíveis: =,>,>=,<,<=,<>,começa
 com,não começa com,na lista"""

    pass


  def setPrompt(self, nome, valor) -> None:
    """Durante a execução de um relatório do DW, caso o relatório que está sendo
 executado possua algum filtro do tipo "prompt de usuário", o valor deste
 filtro é preenchido com o conteúdo apresentado neste método.<BR>
 Observação: se o conteúdo do "prompt" não for fornecido por um método
 setPrompt() ou addPrompt() previamente à execução do relatório, o
 ContÁgil recusará o preenchimento do prompt quando for solicitado durante
 a execução do relatório do DW."""

    pass


  def setPrompt(self, nome, valores, nomeFormulario, operador) -> None:
    """Durante a execução de um relatório do DW, caso o relatório que está sendo
 executado possua algum filtro do tipo "prompt de usuário", o valor deste
 filtro é preenchido com o conteúdo apresentado neste método.<BR>
 Observação: se o conteúdo do "prompt" não for fornecido por um método
 setPrompt() ou addPrompt() previamente à execução do relatório, o
 ContÁgil recusará o preenchimento do prompt quando for solicitado durante
 a execução do relatório do DW."""

    pass


  def setPrompt(self, nome, valores) -> None:
    """Durante a execução de um relatório do DW, caso o relatório que está sendo
 executado possua algum filtro do tipo "prompt de usuário", o valor deste
 filtro é preenchido com o conteúdo apresentado neste método.<BR>
 Observação: se o conteúdo do "prompt" não for fornecido por um método
 setPrompt() ou addPrompt() previamente à execução do relatório, o
 ContÁgil recusará o preenchimento do prompt quando for solicitado durante
 a execução do relatório do DW."""

    pass


  def setPrompt(self, nome, valor, nomeFormularioAtributo) -> None:
    """Durante a execução de um relatório do DW, caso o relatório que está sendo
 executado possua algum filtro do tipo "prompt de usuário", o valor deste
 filtro é preenchido com o conteúdo apresentado neste método.<BR>
 Observação: se o conteúdo do "prompt" não for fornecido por um método
 setPrompt() ou addPrompt() previamente à execução do relatório, o
 ContÁgil recusará o preenchimento do prompt quando for solicitado durante
 a execução do relatório do DW."""

    pass


  def setReterRespostasDoUsuario(self, reterRespostasDoUsuario) -> None:
    pass


  def setSolicitarPrompts(self, solicitarPrompts) -> None:
    pass


  def setUtilizarRespostasPadrao(self, utilizarRespostasPadrao) -> None:
    pass

class TIPI ():
  """Representação da tabela TIPI Histórica acessível via script"""

  def contemNCM(self, ncm) -> Boolean:
    """Verifica se consta a NCM na tabela"""

    pass


  def contemNCM(self, ncm) -> Boolean:
    """Verifica se consta a NCM na tabela"""

    pass


  def getDataFinalConsulta(self) -> Data:
    """A data final da consulta da tabela TIPI histórica"""

    pass


  def getDataInicialConsulta(self) -> Data:
    """A data inicial da consulta da tabela TIPI histórica"""

    pass


  def getHistoricoNCM(self, ncm, ex, data) -> TIPIEntry:
    """Obtém a informação da TIPI relacionada a uma dada NCM, EX e data"""

    pass


  def getHistoricoNCM(self, ncm, ex, data, verificaDataFinal) -> TIPIEntry:
    """Obtém a informação da TIPI relacionada a uma dada NCM, EX e data"""

    pass


  def getHistoricoNCM(self, ncm, ex) -> list:
    """Obtém uma lista de entradas da TIPI para um determinado par de NCM e EX."""

    pass


  def getMaximoAliquotaNCM(self, ncm, data) -> TIPIEntry:
    """Obtém a informação da TIPI relacionada a uma dada NCM e data. <br>
 Não considera o código EX. <br>
 Obtém aquela informação que apresenta a maior alíquota IPI, caso existam várias alternativas possíveis pelo EX."""

    pass


  def getMinimoAliquotaNCM(self, ncm, data) -> TIPIEntry:
    """Obtém a informação da TIPI relacionada a uma dada NCM e data. <br>
 Não considera o código EX. <br>
 Obtém aquela informação que apresenta a menor alíquota IPI, caso existam várias alternativas possíveis pelo EX."""

    pass


  def getNumeroAtosLegais(self) -> int:
    """A quantidade de atos legais considerados nesta tabela"""

    pass


  def getNumeroNCM(self) -> int:
    """A quantidade de nomenclaturas NCM previstas nesta tabela"""

    pass


  def getQuantidadeEX(self, ncm) -> int:
    """A quantidade de EX para uma data NCM"""

    pass

class TIPIEntry ():
  """A representação de uma entrada na tabela TIPI contendo a NCM, EX, descrição da NCM,
 ato legal, alíquota, datas de início e fim."""

  def getAtoLegal(self) -> str:
    """O ato legal que determinou a alíquota para esta NCM/EX"""

    pass


  def getDataFim(self) -> Data:
    """A data de fim dessa informação para o par NCM/EX"""

    pass


  def getDataInicio(self) -> Data:
    """A data de início dessa informação para o par NCM/EX"""

    pass


  def getDescricao(self) -> str:
    """A descrição da posição (NCM)"""

    pass


  def getEx(self) -> str:
    """A EX"""

    pass


  def getIpiAliquota(self) -> Double:
    """A líquota do IPI (1 = 100%)"""

    pass


  def getIpiAliquotaFormatada(self) -> str:
    """A alíquota do IPI formatada"""

    pass


  def getNCM(self) -> str:
    """O código NCM"""

    pass


  def getNCMFormatada(self) -> str:
    """O código NCM formatado"""

    pass

class Tabela ():
  """Classe utilizada por linguagem de scripting para facilitar o armazenamento de
 dados temporariamente em memória na forma de tabela (isto é, com linhas e
 colunas).
 <P>
 
 Também é uma facilidade para transportar dados de um lugar para outro, pois
 se trata de um objeto intermediário entre várias outras operações (por
 exemplo, de um arquivo TXT para uma "tabela do usuário", ou de uma "tabela do
 usuário" para um arquivo EXCEL, ou de um objeto "agregador" para uma "tabela
 do usuário", etc). Isso se deve ao fato de que todos esse demais objetos
 possuem alguma rotina que coloca os dados em um objeto do tipo "tabela" (não
 confundir {@link Tabela Tabela} com "tabela do usuário", que é um objeto
 {@link TabelaUsuario TabelaUsuario}) e também uma rotina que faz o inverso,
 isto é, que transporta dos dados de uma "tabela" para dentro de outra
 representação.
 <P>
 
 A tabela representada por este objeto fica armazenada somente em memória. Se
 for desejável manter os dados armazenados em disco, deve-se utilizar um dos
 métodos de exportação dos dados da tabela para outro dispositivo (tais como
 arquivos ou tabelas do usuário).
 <P>
 
 Pode-se consultar os dados de um objeto Tabela e também inserir novos dados a
 ela.
 <P>
 
 Importante: ao contrário do que ocorre com os objetos
 {@link ArquivoCSV ArquivoCSV} e {@link ArquivoExcel ArquivoExcel}, os
 métodos do objeto {@link Tabela Tabela} que utilizam números de linhas ou
 colunas trabalham com números que consideram o zero (0) como indicação da
 primeira linha ou coluna. Naqueles outros objetos utiliza-se o um (1) para
 indicar os primeiros elementos. Deve-se ter cuidado na utilização desses
 métodos na linguagem de script para evitar erros.
 <P>
 
 Pode-se gerar uma nova Tabela a partir de um objeto
 {@link Agregador Agregador}, utilizando o método
 {@link Agregador#getTabela() getTabela}.
 <P>
 
 Pode-se gerar uma nova Tabela a partir de um arquivo EXCEL
 {@link ArquivoExcel ArquivoExcel}, utilizando o método
 {@link ArquivoExcel#getTabela(int, int, int, int, int) getTabela}.
 <P>
 
 Pode-se visualizar o conteúdo da Tabela em uma janela utilizando o método
 {@link Janelas#mostraTabela(Tabela) mostraTabela}.
 <P>
 
 A tabela pode ser ampliada na medida que novos dados vão sendo inseridos.
 Isto é, o tamanho da tabela em termos de "quantidade de colunas" corresponde
 ao maior tamanho observado em qualquer uma de suas linhas.
 <P>
 
 Pode-se também remover linhas da tabela, de tal modo que as linhas
 posteriores à linha excluída são reposicionadas uma posição para cima.
 <P>
 
 O limite máximo em número de linhas é de 2.147.483.647. Idem para o número
 máximo de colunas em cada linha. No entanto é necessário observar também o
 limite de memória (uma tabela que possua o limite máximo de linhas e o limite
 máximo de colunas precisaria de espaço para alocar bilhões de bilhões de
 valores, o que certamente não cabe na memória RAM de um computador moderno).
 <P>
 
 Exemplo de utilização:
 <P> // Obtém um objeto Tabela<BR>
 t = tabelas.nova();
 <P> // Insere dois valores em uma linha da tabela<BR>
 t.setCelula( 0 , 0 , "AZUL" );<BR>
 t.setCelula( 0 , 1 , 123 );
 <P> // Retorna quantidade de linhas e colunas<BR>
 println("Linhas: "+t.getNumLinhas()+", Colunas: "+t.getNumColunas());
 <P> // Retorna o valor de uma célula<BR>
 println("Valor: "+t.getCelula( 0 , 1));
 <P>
 <BR>
 
 Observação: para o propósito de "agregar" informações conforme alguns
 critérios, existe outro objeto chamado {@link Agregador Agregador}, que é
 mais adequado que este, pois possui métodos que facilitam a agregação
 conforme critérios definidos pelo usuário. O objeto {@link Tabela Tabela}
 simplesmente dispõe os dados em linhas e colunas, sem agregar (isto é, pode
 haver replicação de linhas com o mesmo conteúdo em uma tabela, mas não em um
 agregador).<BR>
 
 OBS: Esta classe é THREAD-SAFE (isto é, o mesmo objeto pode ser compartilhado
 por execuções paralelas simultâneas)."""

  def addColuna(self, coluna, lista, titulo, formato) -> None:
    """Adiciona uma lista como sendo uma nova coluna na tabela e também define
 seu título e formato. Caso exista alguma coluna na posição indicada, ou a
 direita dela, essas colunas existentes são arrastadas para a direita da
 nova coluna.<BR>
 Os elementos da lista correspondem às diferentes linhas da mesma coluna."""

    pass


  def addColuna(self, coluna, lista) -> None:
    """Adiciona uma lista como sendo uma nova coluna na tabela. Caso exista
 alguma coluna na posição indicada, ou a direita dela, essas colunas
 existentes são arrastadas para a direita da nova coluna.<BR>
 Os elementos da lista correspondem às diferentes linhas da mesma coluna."""

    pass


  def addColuna(self, coluna, titulo, formato) -> None:
    """Insere uma coluna vazia na tabela, arrastando para a direita outras
 colunas pre-existentes localizadas à direita da posição desejada
 (inclusive ela)."""

    pass


  def addFormatacaoCondicionalDesvioPadrao(self, nomeColuna, desvioCorMinima, desvioCorMaxima, gradienteCores, cores) -> None:
    """Configura um padrão de 'formatação condicional' sobre os valores de uma determinada coluna da tabela
 com base no 'desvio padrão' e na 'média' dos valores desta coluna."""

    pass


  def addFormatacaoCondicionalEntreDoisValores(self, nomeColuna, menorValor, maiorValor, gradienteCores, cores) -> None:
    """Configura um padrão de 'formatação condicional' sobre os valores de uma determinada coluna da tabela
 com base no 'quartil' dos valores desta coluna."""

    pass


  def addFormatacaoCondicionalFormula(self, nomeColuna, formula, valorCorMinima, valorCorMaxima, gradienteCores, cores) -> None:
    """Configura um padrão de 'formatação condicional' sobre os valores de uma determinada coluna da tabela
 com base em uma 'fórmula' que pode versar sobre outras colunas da tabela. Nesta alternativa de método, a fórmula
 pode retornar qualquer valor, sendo este valor depois comparado com um valor 'mínimo' e um valor 'máximo' para o propósito
 de decisão das cores."""

    pass


  def addFormatacaoCondicionalFormula(self, nomeColuna, formula, cores) -> None:
    """Configura um padrão de 'formatação condicional' sobre os valores de uma determinada coluna da tabela
 com base em uma 'fórmula' que pode versar sobre outras colunas da tabela. Nesta alternativa de método, a fórmula
 deve retornar um número inteiro, começando pelo número 1, indicando qual a 'cor' dentre as cores enumeradas no último
 parâmetro deve ser considerada para uma dada linha. Por exemplo, se há três cores diferentes configuradas no último parâmetro,
 a fórmula pode retornar o número 1 para indicar a primeira cor, o número 2 para indicar a segunda cor, ou o número 3 para indicar
 a terceira cor."""

    pass


  def addFormatacaoCondicionalIgualdade(self, nomeColuna, valorReferencia, corDiferenca, corIgualdade) -> None:
    """Configura um padrão de 'formatação condicional' sobre os valores de uma determinada coluna da tabela
 com base na simples comparação com um valor de referência (isto é, se são iguais ou diferentes a ele)."""

    pass


  def addFormatacaoCondicionalMaiorMenor(self, nomeColuna, valorReferencia, corAbaixo, corAcima) -> None:
    """Configura um padrão de 'formatação condicional' sobre os valores de uma determinada coluna da tabela
 com base na simples comparação com um valor de referência (isto é, se está acima ou abaixo do valor de referência)."""

    pass


  def addFormatacaoCondicionalMedia(self, nomeColuna, corAbaixo, corAcima) -> None:
    """Configura um padrão de 'formatação condicional' sobre os valores de uma determinada coluna da tabela
 com base na 'média' dos valores desta coluna."""

    pass


  def addFormatacaoCondicionalPercentil(self, nomeColuna, percentilCorMinima, percentilCorMaxima, gradienteCores, cores) -> None:
    """Configura um padrão de 'formatação condicional' sobre os valores de uma determinada coluna da tabela
 com base no 'percentil' dos valores desta coluna."""

    pass


  def addFormatacaoCondicionalQuartil(self, nomeColuna, quartilCorMinima, quartilCorMaxima, gradienteCores, cores) -> None:
    """Configura um padrão de 'formatação condicional' sobre os valores de uma determinada coluna da tabela
 com base no 'quartil' dos valores desta coluna."""

    pass


  def addLinha(self, linha) -> None:
    """Adiciona uma linha vazia na tabela em uma determinada posição, arrastando
 para baixo as linhas existentes localizadas abaixo da posição deseja,
 inclusive na posição."""

    pass


  def addLinha(self, linha, valores) -> None:
    """Adiciona uma linha preenchida na tabela em uma determinada posição,
 arrastando para baixo as linhas existentes localizadas abaixo da posição
 deseja, inclusive na posição.<BR>
 O vetor passado como parâmetro a esta função indica os valores que devem
 ser preenchidos na linha (um valor em cada coluna).<BR>
 Esta função tem o mesmo comportamento que executar essas duas funções:<BR>
 addLinha(linha); // adiciona uma linha vazia<BR>
 addValores(linha,0,valores); // preenche a linha com os valores indicados<BR>"""

    pass


  def addTabela(self, tabela) -> None:
    """Insere o conteúdo de uma tabela dentro de outra tabela, colocando todos
 os dados após a última linha da tabela atual."""

    pass


  def addTabela(self, linha, coluna, tabela) -> None:
    """Insere o conteúdo de uma tabela dentro de outra tabela, começando em uma
 determinada posição.<BR>
 Esta função pode sobrescrever quaisquer valores que porventura
 pre-existam na tabela que recebe os dados, nas mesmas posições a serem
 ocupadas com novos dados."""

    pass


  def addTabelaPelosTitulos(self, tabela) -> None:
    """Adiciona uma outra tabela dentro desta tabela, começando a partir da última linha,
 mas de tal modo a "alinhar" as colunas conforme os "títulos".<BR>
 Se uma coluna da outra tabela possui o mesmo título que uma coluna da tabela atual,
 os dados daquela coluna são inseridos na coluna da tabela atual de mesmo título (mesmo que
 sua posição na tabela seja diferente).<BR>
 Se uma coluna da outra tabela possui um título que não existe na tabela atual, é criada
 uma nova coluna na tabela atual, com o título indicado e os valores correspondentes.<BR>
 Este método é útil quando se pretende juntar duas ou mais tabelas entre si, sem se preocupar
 com a ordem das colunas em cada uma delas.<BR>
 Note que para funcionar adequadamente é necessário que os "títulos" das colunas das tabelas
 estejam definidos de forma apropriada.<BR>
 Se uma coluna da tabela indicada como parâmetro não possui título, seus dados são copiados para
 a coluna de mesma posição na tabela atual.<BR>
 Se duas ou mais colunas da tabela possuem o mesmo título, seus dados são reunidos na mesma coluna.<BR>
 Não há diferenciação de título em relação a letras maiúsculas/minúsculas ou acentuação."""

    pass


  def addValores(self, linha, coluna, valores) -> None:
    """Adiciona um ou mais valores em uma tabela, começando em uma determinada
 posição. Os valores são inseridos em uma mesma linha da tabela, começando
 em uma determinada coluna e se propagando para as colunas seguintes. Se
 as colunas que estão sendo preenchidas na tabela já possuem algum
 conteúdo, eles são sobrepostos com o novo conteúdo."""

    pass


  def addValores(self, linha, coluna, criterio) -> None:
    """Adiciona um ou mais critérios em uma tabela, começando em uma determinada
 posição. Os critérios são inseridos em uma mesma linha da tabela,
 começando em uma determinada coluna e se propagando para as colunas
 seguintes. Se as colunas que estão sendo preenchidas na tabela já possuem
 algum conteúdo, eles são sobrepostos com o novo conteúdo."""

    pass


  def addValores(self, valores) -> None:
    """Adiciona um ou mais valores em uma tabela, começando na primeira coluna
 da última linha da tabela (isto é, após a última linha da tabela).<BR>
 Os valores são inseridos em uma mesma linha da tabela."""

    pass


  def agregaColuna(self, nomesColunasCriteriosAgregacao, agregarMesmoNivel) -> Agregador:
    """Alternativa onde é possível indicar mais de uma coluna como critério de agregação.<BR>
 <BR>
 Retorna um objeto do tipo {@link Agregador Agregador} que é montado sobre
 os dados de uma tabela agregando os dados conforme uma ou mais
 colunas da tabela.<BR>
 É importante destacar alguns aspectos relacionados a este processo:<BR>
 Os valores das colunas informadas como primeiro parâmetro são os critérios de
 agregação.<BR>
 Por exemplo, digamos que uma tabela possui três colunas: "MARCA", "ANO" e "VALOR".<BR>
 Digamos que se deseja obter as agregações de valores da coluna "VALOR" para cada combinação
 distinta de "MARCA" e "ANO". Pode-se utilizar este método, indicando os nomes das colunas
 "MARCA" e "ANO" como "critérios de agregação". Fazendo isso, os valores contidos na coluna
 "VALOR" serão somados para cada combinação distinta de "MARCA" e "ANO". OBS: o "formato"
 da coluna "VALOR" deve ser previamente definido como sendo do tipo "DECIMAL" ou "NÚMERO" ou
 "MOEDA". Caso contrário, esta coluna não será considerada como algo que pode ser 'somado'.<BR>
 <BR>
 Note que ao definir a 'agregação' podemos ter neste exemplo duas situações possíveis:<BR>
 1) As agregações ocorrem sobre os 'pares' de MARCA e ANO. Para que posteriormente se possa obter o valor correspondente,
 deve-se consultar o objeto de agregação fornecendo sempre os pares de MARCA e ANO. Aqui temos um único nível de agregação 
 definido pelo par MARCA e ANO.<BR>
 2) As agregações ocorrem primeiro sobre as diferentes MARCAS, para cada MARCA agregam-se os diferentes ANOS, e para este
 segundo nível (isto é, para a MARCA e para o ANO dentro da MARCA) obtém-se o correspondente valor somado. Aqui temos 
 dois níveis de agregação definidos primeiro pela MARCA (primeiro nível) e depois pelo ANO (segundo nível). A vantagem é que
 assim pode-se saber o total para cada MARCA sem diferenciar o ANO. Pode-se também saber quais são os diferentes ANOS para
 cada MARCA.<BR>
 <BR>
 As duas possíveis situações ilustradas acima podem ser obtidas através do segundo parâmetro deste método.<BR>
 Se 'agregarMesmoNivel' é VERDADEIRO, entende-se a primeira situação (aquela onde os diferentes critérios de agregação
 são tratados conjuntamente no mesmo nível). Se é FALSO, entende-se a segunda situação (aquela onde os diferentes critérios
 de agregação são tratados de formas sucessivas em diferentes níveis de agregação).<BR>
 <BR>
 A quantidade de linhas da tabela que atendem a cada critério são
 "contados", de modo que o método "getContagemTotal" do objeto "Agregador"
 pode ser utilizado sobre cada critério de agregação para se obter a
 contagem correspondente. Por exemplo: resultado.getContagemTotal("PR")<BR>
 <BR>
 Quanto às demais colunas existentes na tabela, elas podem ser
 aproveitadas ou não no objeto Agregador dependendo do tipo de informação
 contida em cada uma delas (isto é, depende do "formato" de cada coluna),
 sendo que:<BR>
 Colunas do formato "DECIMAL" ou "NÚMERO" ou "MOEDA" são inseridas no
 objeto Agregador de modo a permitir a utilização dos métodos
 getSomaTotal, getDesvioPadrao, getMaximo, etc.<BR>
 <BR>
 Colunas dos demais formatos são ignoradas (isto é, texto, data, mês,
 genérico, etc.).<BR>"""

    pass


  def agregaColuna(self, nomeColuna) -> Agregador:
    """Retorna um objeto do tipo {@link Agregador Agregador} que é montado sobre
 os dados de uma tabela agregando os dados conforme uma determinada
 coluna.<BR>
 É importante destacar alguns aspectos relacionados a este processo:<BR>
 Os valores da coluna informada como parâmetro são os critérios de
 agregação. Por exemplo, se uma tabela possui uma coluna chamada "UF" e se
 esta tabela possui 10 linhas onde o valor da coluna "UF" é igual a "PE" e
 20 linhas onde o valor é "PR", então este método resulta em dois valores
 distintos que são os valores do critério de agregação: PE e PR.<BR>
 A quantidade de linhas da tabela que atendem a cada critério são
 "contados", de modo que o método "getContagemTotal" do objeto "Agregador"
 pode ser utilizado sobre cada critério de agregação para se obter a
 contagem correspondente. Por exemplo: resultado.getContagemTotal("PR")<BR>
 Quanto às demais colunas existentes na tabela, elas podem ser
 aproveitadas ou não no objeto Agregador dependendo do tipo de informação
 contida em cada uma delas (isto é, depende do "formato" de cada coluna),
 sendo que:<BR>
 Colunas do formato "DECIMAL" ou "NÚMERO" ou "MOEDA" são inseridas no
 objeto Agregador de modo a permitir a utilização dos métodos
 getSomaTotal, getDesvioPadrao, getMaximo, etc.<BR>
 Colunas dos demais formatos são ignoradas (isto é, texto, data, mês,
 genérico, etc.).<BR>
 Por exemplo, se a tabela possui uma coluna com nome "UF" contendo valores
 "SP", "PR" e "PE", e outra coluna contendo valores cujo nome é "VALOR", e
 supondo que fizemos a agregação pela coluna "UF", então pode-se obter do
 resultado a "soma" de valores com "UF" igual a "PE" da seguinte forma:<BR>
 resultado.getSomaTotal("PE") ou resultado.getSoma("PE","RESULTADO")<BR>
 No exemplo acima, caso exista outra coluna de valores na mesma tabela
 (digamos que a outra coluna se chama "QUANTIDADE"), pode-se discriminar
 um total de outro através do "rótulo", que neste caso corresponde ao nome
 da coluna de valores. Por exemplo, para obter somente a soma da coluna
 "QUANTIDADE" que atende o critério "UF" igual a "PE", basta fazer:<BR>
 resultado.getSoma("PE","QUANTIDADE")<BR>
 OBS: Caso o nome da coluna passado como parâmetro não corresponda a um
 nome de coluna existente na tabela, é retornado um objeto Agregador
 vazio."""

    pass


  def alteraTitulos(self, formula, colunaInicial, colunaFinal) -> None:
    """Altera os títulos de algumas colunas da tabela, aplicando uma fórmula sobre cada um deles. Nesta fórmula
 você pode fazer referência ao título original através da variável 'X'"""

    pass


  def alteraTitulos(self, formula) -> None:
    """Altera todos os títulos da tabela, aplicando uma fórmula sobre cada um deles. Nesta fórmula
 você pode fazer referência ao título original através da variável 'X'"""

    pass


  def apagaDados(self) -> None:
    """Apaga todas as linhas da tabela, mantendo a mesma estrutura (nomes,
 colunas, formatos, etc.)"""

    pass


  def apagaFormatacaoCondicional(self) -> None:
    """Apaga qualquer configuração realizada anteriormente de 'formatação condicional' sobre esta tabela."""

    pass


  def apagaFormatacaoCondicional(self, nomeColuna) -> None:
    """Apaga configurações de 'formatação condicional' realizadas anteriormente sobre uma determinada coluna
 desta tabela."""

    pass


  def apagaLinha(self, linha) -> None:
    """Faz exatamente a mesma ação que {@link Tabela#removeLinha(int) removeLinha}.<BR>
 Este método existe apenas para manter compatibilidade com códigos antigos."""

    pass


  def aplicaPrincipalComponentAnalysis(self, dimensao, normaliza) -> PrincipalComponentAnalysis:
    """Aplica a técnica conhecida como "Principal Component Analysis" (PCA) destinada a reduzir
 a dimensão de um conjunto de dados de tal modo a reduzir as "redundâncias".<BR>
 Esta técnica atua somente sobre as colunas com dados de tipo "numérico". Caso existam na
 tabela colunas do tipo "não numérico" (ex: texto), tais colunas são preservadas na tabela
 de resultado, mas não participam da análise (não interferem na análise).<BR>
 As colunas e os valores da tabela original não são afetados por este método.<BR>
 Antes de calcular o PCA, este método faz uma "normalização" dos dados (isto é, transforma
 os valores de cada coluna de tipo "numérico" de tal modo que a "média" seja zero e o "desvio padrão"
 seja unitário).<BR>
 Este método é aplicado somente sobre tabelas que incluam duas ou mais colunas de dados
 numéricos. O propósito é elaborar uma nova tabela que contenha "menos" de tais colunas, mas
 de tal forma que os números dessas colunas sejam relações lineares sobre uma nova "base
 ortogonal" construída de tal modo a deixar a maior "variância" possível sobre cada "projeção"
 das colunas originais.<BR>"""

    pass


  def calculaFormula(self, formula, nomeColuna, primeiraLinha, quantidadeLinhas) -> None:
    """Método alternativo onde é possível indicar a primeira linha da tabela onde a fórmula deve ser calculada e também a quantidade total de linhas
 que devem ser calculadas. Se a tabela possui menos linhas do que é indicado, a tabela aumenta de tamanho de modo a acomodar as novas
 linhas.<BR>
 Veja mais comentários na documentação do método alternativo."""

    pass


  def calculaFormula(self, formula, colunaResultado, primeiraLinha, quantidadeLinhas) -> None:
    """Método alternativo onde é possível indicar a primeira linha da tabela onde a fórmula deve ser calculada e também a quantidade total de linhas
 que devem ser calculadas. Se a tabela possui menos linhas do que é indicado, a tabela aumenta de tamanho de modo a acomodar as novas
 linhas.<BR>
 Veja mais comentários na documentação do método alternativo."""

    pass


  def calculaFormula(self, formula, nomeColuna) -> None:
    """Percorre todas as linhas da tabela calculando uma fórmula e preenchendo as células
 de uma coluna com os resultados.<BR>
 DIFERENÇA ENTRE O MÉTODO 'CALCULAR FORMULA' E O MÉTODO 'TRANSFORMAR LINHAS/COLUNAS':<BR>
 Este método e os demais métodos alternativos 'CALCULAR FORMULA' calculam uma fórmula sobre os valores da tabela, mas escreve
 o resultado em uma determinada coluna da tabela (uma mesma coluna para todos os resultados). Além disso, este método
 não admite na fórmula o uso do nome 'X' para se referir ao valor da fórmula, a menos que exista uma coluna com este nome 'X'.<BR>
 O método 'TRANSFORMAR LINHAS/COLUNAS', por sua vez, aplica a fórmula sobre cada célula individual da tabela e escreve seu
 resultado na própria célula. Neste caso, a fórmula pode fazer referência a uma variável de nome 'X', que corresponde ao valor
 da própria célula que está sendo transformada."""

    pass


  def calculaFormula(self, formula, colunaResultado) -> None:
    """Percorre todas as linhas da tabela calculando uma fórmula e preenchendo as células
 de uma coluna com os resultados.<BR>
 DIFERENÇA ENTRE O MÉTODO 'CALCULAR FORMULA' E O MÉTODO 'TRANSFORMAR LINHAS/COLUNAS':<BR>
 Este método e os demais métodos alternativos 'CALCULAR FORMULA' calculam uma fórmula sobre os valores da tabela, mas escreve
 o resultado em uma determinada coluna da tabela (uma mesma coluna para todos os resultados). Além disso, este método
 não admite na fórmula o uso do nome 'X' para se referir ao valor da fórmula, a menos que exista uma coluna com este nome 'X'.<BR>
 O método 'TRANSFORMAR LINHAS/COLUNAS', por sua vez, aplica a fórmula sobre cada célula individual da tabela e escreve seu
 resultado na própria célula. Neste caso, a fórmula pode fazer referência a uma variável de nome 'X', que corresponde ao valor
 da própria célula que está sendo transformada."""

    pass


  def calculaFormulaRetornaLista(self, formula) -> Lista:
    """Percorre todas as linhas da tabela calculando uma fórmula. O resultado da aplicação da fórmula é inserido em uma lista que é retornada por
 esta função (ou seja, a tabela original não é alterada)."""

    pass


  def calculaFormulaRetornaLista(self, formula, primeiraLinha, quantidadeLinhas) -> Lista:
    """Percorre todas as linhas da tabela calculando uma fórmula. O resultado da aplicação da fórmula é inserido em uma lista que é retornada por
 esta função (ou seja, a tabela original não é alterada)."""

    pass


  def executaSubRotina(self, nomeSubRotina, colunaEntrada1, colunaEntrada2, colunaEntrada3, colunaSaida) -> None:
    """Dada uma sub-rotina do script atual que recebe três parâmetros de entrada e retorna algum resultado como saída, este método
 permite aplicar a mesma sub-rotina sobre todas as linhas da tabela. Em cada linha da tabela consideram-se valores obtidos de três
 colunas da tabela e executa a rotina com estes valores. O resultado da execução da rotina é então armazenado em outra coluna
 da tabela ou na mesma coluna se for desejável.<BR>
 Por exemplo, se a tabela possui 100 linhas, a rotina é executada 100 vezes, uma vez para cada linha, em cada vez considerando-se
 valores de três colunas específicas da tabela e armazenando o resultado em outra coluna da tabela."""

    pass


  def executaSubRotina(self, nomeSubRotina, colunaEntrada, colunaSaida) -> None:
    """Dada uma sub-rotina do script atual que recebe um único parâmetro de entrada e retorna algum resultado como saída, este método
 permite aplicar a mesma sub-rotina sobre todas as linhas da tabela. Em cada linha da tabela considera-se um valor obtido de uma
 mesma coluna da tabela e executa a rotina com este valor. O resultado da execução da rotina é então armazenado em outra coluna
 da tabela ou na mesma coluna se for desejável.<BR>
 Por exemplo, se a tabela possui 100 linhas, a rotina é executada 100 vezes, uma vez para cada linha, em cada vez considerando-se
 o valor de uma coluna específica da tabela e armazenando o resultado em outra coluna da tabela."""

    pass


  def executaSubRotina(self, nomeSubRotina, colunaEntrada1, colunaEntrada2, colunaSaida) -> None:
    """Dada uma sub-rotina do script atual que recebe dois parâmetros de entrada e retorna algum resultado como saída, este método
 permite aplicar a mesma sub-rotina sobre todas as linhas da tabela. Em cada linha da tabela consideram-se valores obtidos de duas
 colunas da tabela e executa a rotina com estes valores. O resultado da execução da rotina é então armazenado em outra coluna
 da tabela ou na mesma coluna se for desejável.<BR>
 Por exemplo, se a tabela possui 100 linhas, a rotina é executada 100 vezes, uma vez para cada linha, em cada vez considerando-se
 valores de duas colunas específicas da tabela e armazenando o resultado em outra coluna da tabela."""

    pass


  def exportaCSV(self, nomeArquivo, separador) -> None:
    """Exporta o conteúdo desta tabela para um novo arquivo do tipo CSV,
 sobrescrevendo o arquivo que porventura já exista.<BR>"""

    pass


  def exportaCSV(self, arquivo) -> None:
    """Exporta o conteúdo desta tabela para um arquivo do tipo CSV já
 previamente aberto ou criado.<BR>
 Esta função é análoga à função
 {@link ArquivoCSV#escreveTabela(Tabela) escreveTabela}."""

    pass


  def exportaCSV(self, nomeArquivo) -> None:
    """Exporta o conteúdo desta tabela para um novo arquivo do tipo CSV,
 sobrescrevendo o arquivo que porventura já exista.<BR>"""

    pass


  def exportaExcel(self, nomeArquivo) -> None:
    """Exporta o conteúdo desta tabela para um novo arquivo do tipo EXCEL,
 sobrescrevendo o arquivo que porventura já exista.<BR>"""

    pass


  def exportaExcel(self, arquivo) -> None:
    """Exporta o conteúdo desta tabela para um arquivo do tipo EXCEL já
 previamente aberto ou criado.<BR>
 Esta função é análoga à função
 {@link ArquivoExcel#escreveTabela(Tabela) escreveTabela}."""

    pass


  def exportaPDF(self, nomeArquivo) -> Arquivo:
    """Exporta o conteúdo desta tabela para um novo arquivo do tipo PDF,
 sobrescrevendo o arquivo que porventura já exista.<BR>"""

    pass


  def exportaPDF(self, nomeArquivo, ni, razaoSocial, pf) -> Arquivo:
    """Exporta o conteúdo desta tabela para um novo arquivo do tipo PDF,
 sobrescrevendo o arquivo que porventura já exista.<BR>"""

    pass


  def exportaTabelaUsuario(self, nome, acrescenta, tipoArquivo) -> TabelaUsuario:
    """Método de uso interno destinado à exportação dos dados para "tabela do
 usuário". Não deve ser utilizado em linguagem de script pois seu
 comportamento pode ser alterado em qualquer momento."""

    pass


  def exportaTabelaUsuario(self, nome) -> TabelaUsuario:
    """Idem à função
 {@link Tabela#exportaTabelaUsuario(String, boolean) exportaTabelaUsuario},
 sendo que está implícito o parâmetro "acrescenta" = FALSE (isto é, nunca
 aproveita os dados existentes)."""

    pass


  def exportaTabelaUsuario(self, nome, acrescenta) -> TabelaUsuario:
    """Exporta o conteúdo desta tabela para uma
 {@link TabelaUsuario TabelaUsuario}. Ou seja, os dados ficam armazenados
 em disco de uma forma que pode ser consultada posteriormente pelo usuário
 por um MODELO ANALÍTICO DINÂMICO ou até mesmo por script através do
 método {@link ContAgilEngine#getTabelaUsuario(String) getTabelaUsuario}.<BR>
 Se já existir uma tabela do usuário com o nome especificado, ela é
 sobrescrita com os novos dados."""

    pass


  def exportaTabelaUsuario(self, nome, acrescenta, nome_bd, engine) -> TabelaUsuario:
    """Exporta o conteúdo desta tabela para um
 {@link TabelaUsuario TabelaUsuario}, sendo de uso restrito a banco de
 dados.<BR>
 Esta é uma alternativa ao método de dois parâmetros
 {@link Tabela#exportaTabelaUsuario(String, boolean) exportaTabelaUsuario},
 com o acréscimo de um terceiro parâmetro onde é possível indicar o nome
 do "banco de dados" (conforme previamente configurado nas configurações
 de conexões a banco de dados pelo ContÁgil) e também o nome da "engine"
 implementada pelo banco de dados, que deve ser um do tipos previstos pelo
 banco de dados (podendo deixar vazio caso não se conheça esta
 informação).<BR>
 OBS: o método alternativo de exportação para tabela do usuário (método de
 2 parâmetros) pode também ser utilizado com banco de dados. No entanto,
 ele requer que o banco de dados tenha sido configurado como "padrão"
 (conforme indicado no manual do ContÁgil). Este método, por sua vez,
 permite que se escolha o banco de dados de forma explícita."""

    pass


  def exportaTabelaUsuarioDepoisDescarta(self, nome, minimoLinhas) -> TabelaUsuario:
    """Este método realiza as seguintes funções:<BR>
 - Exporta o resultado desta tabela para uma tabela do usuário. Se a tabela do usuário existe, acrescenta a ela os novos dados
 sem apagar os dados anteriores. É exatamente o mesmo que executar a função {@link #exportaTabelaUsuario(String, boolean) exportaTabelaUsuario}
 com parâmetro 'acrescenta' = 'true'.<BR>
 - Apaga o conteúdo desta tabela (todas as suas linhas, mas não as definições de suas colunas). É exatamente o mesmo que executar
 a função {@link #apagaDados() apagaDados}<BR>
 A vantagem de utilizar este método em substituição aos outros dois é que este método é 'thread safe', o que significa que outras threads
 podem estar executando ao mesmo tempo, inserindo dados na mesma tabela, enquanto outra thread faz a 'descarga' desses dados em memória
 para o disco.<BR>
 Além disso, o parâmetro adicional 'minimoLinhas' para indicar que esta função apenas deve ser realizada caso a quantidade total
 de linhas na tabela seja no mínimo igual a quantidade informada. Por exemplo, se for indicado o número 100, este método será apenas efetivo
 apenas se houver 100 ou mais linhas preenchidas na tabela em memória.<BR>
 Com isso, pode-se programar alguma lógica que permite descarregar o conteúdo em memória para o disco a cada lote de quantidade de linhas.<BR>
 ATENÇÃO: o que se 'descarta' são os dados mantidos em memória neste objeto {@link Tabela Tabela}. Os dados são preservados na tabela do usuário."""

    pass


  def exportaTabelaUsuarioServidor(self, nome, acrescenta) -> TabelaUsuario:
    """Exporta o conteúdo desta tabela para uma {@link TabelaUsuario TabelaUsuario} nova ou existente 
 que fica armazenada em um servidor definido pela aplicação. Não se trata apenas
 de um banco de dados, mas de um ambiente que pode reunir um ou mais bancos de dados.<BR>
 Caso queira atualizar o conteúdo de uma tabela que resida em um 'banco de dados externo',
 não utilize esta função, mas sim a função {@link #exportaTabelaUsuario(String, boolean, String, String) exportaTabelaUsuario},
 onde é possível indicar o nome da conexão ao banco de dados conforme configurado no ContÁgil.<BR>
 OBS: dependendo da versão da aplicação e dos perfis do usuário, este recurso pode
 não estar disponível.<BR>
 Além disso, dependendo das configurações do servidor, é possível que nem todos os
 dados da tabela gerada fiquem diretamente disponíveis para consulta por meio deste objeto 
 {@link TabelaUsuario TabelaUsuario}, em razão de diminuir tráfego na rede, sendo muitas 
 vezes necessário utilizar um MAD para ter acesso ao conteúdo completo.<BR>
 O nome da tabela efetivamente criada no servidor pode também não coincidir exatamente com o nome
 indicado nesta função. Por exemplo, o servidor pode exigir a inclusão do CPF do usuário no nome
 da tabela que está sendo criada, e isso será feito mesmo que este método seja executado sem esta
 indicação.<BR>
 Se estiver tentando 'acrescentar' dados a tabela que foi 'incorporada' pelo usuário, estando presente em esquema particular, este
 método poderá falhar por falta de acesso de escrita.<BR>
 ATENÇÃO: caso este script inteiro esteja sendo executado no servidor, não utilize este método. Este método
 apenas deve ser utilizado caso o script esteja sendo executado localmente, mas a tabela esteja sendo armazenada
 no servidor.<BR>"""

    pass


  def exportaTabelaUsuarioServidor(self, nome_mad, acrescenta, nome_bd, nome_tabela) -> TabelaUsuario:
    """Alternativa aos demais métodos 'exportaTabelaUsuarioServidor' onde é possível indicar também
 o nome da conexão que representa o 'schema' onde se deseja armazenar os dados. Notar que o nome
 indicado aqui pode ser diferente do nome do schema conforme comandos SQL. Deve-se utilizar o nome
 que foi configurado no servidor para representar o 'schema' desejado.<BR>
 OBS: dependendo do perfil do usuário, esta função pode estar limitada ao schema do próprio usuário 
 (isto é, pode não alcançar outros schemas, mesmo que o usuário tenha acesso a eles por outras ferramentas).<BR>
 IMPORTANTE: certifique-se de que o schema no servidor onde deseja executar esta função atribuiu os privilégios
 de 'escrita' à conta de serviço que representa a aplicação. Caso contrário, esta operação irá falhar por falta
 de permissão. Lembre-se de conceder ao DATABASE (isto é, ao schema completo) os acessos de CREATE, INSERT 
 para a conta de serviço que é utilizada pelo sistema. Além disso, para que seja possível fazer qualquer consulta
 a esta tabela pore sta aplicação, é necessário que seja também concedido o acesso de SELECT sobre a tabela recém
 criada, ou ao database inteiro."""

    pass


  def exportaTabelaUsuarioServidor(self, nome) -> TabelaUsuario:
    """Exporta o conteúdo desta tabela para uma nova {@link TabelaUsuario TabelaUsuario}
 que fica armazenada em um servidor definido pela aplicação. Não se trata apenas
 de um banco de dados, mas de um ambiente que pode reunir um ou mais bancos de dados.<BR>
 Caso queira atualizar o conteúdo de uma tabela que resida em um 'banco de dados externo',
 não utilize esta função, mas sim a função {@link #exportaTabelaUsuario(String, boolean, String, String) exportaTabelaUsuario},
 onde é possível indicar o nome da conexão ao banco de dados conforme configurado no ContÁgil.<BR>
 OBS: dependendo da versão da aplicação e dos perfis do usuário, este recurso pode
 não estar disponível.<BR>
 Além disso, dependendo das configurações do servidor, é possível que nem todos os
 dados da tabela gerada fiquem diretamente disponíveis para consulta por meio deste objeto 
 {@link TabelaUsuario TabelaUsuario}, em razão de diminuir tráfego na rede, sendo muitas 
 vezes necessário utilizar um MAD para ter acesso ao conteúdo completo.<BR>
 O nome da tabela efetivamente criada no servidor pode também não coincidir exatamente com o nome
 indicado nesta função. Por exemplo, o servidor pode exigir a inclusão do CPF do usuário no nome
 da tabela que está sendo criada, e isso será feito mesmo que este método seja executado sem esta
 indicação.<BR>
 ATENÇÃO: caso este script inteiro esteja sendo executado no servidor, não utilize este método. Este método
 apenas deve ser utilizado caso o script esteja sendo executado localmente, mas a tabela esteja sendo armazenada
 no servidor.<BR>"""

    pass


  def exportaTabelaUsuarioServidorDepoisDescarta(self, nome, minimoLinhas) -> TabelaUsuario:
    """Este método realiza as seguintes funções:<BR>
 - Exporta o resultado desta tabela para uma tabela do servidor. Se a tabela do servidor existe, acrescenta a ela os novos dados
 sem apagar os dados anteriores. É exatamente o mesmo que executar a função {@link #exportaTabelaUsuarioServidor(String, boolean) exportaTabelaUsuarioServidor}
 com parâmetro 'acrescenta' = 'true'.<BR>
 - Apaga o conteúdo desta tabela (todas as suas linhas, mas não as definições de suas colunas). É exatamente o mesmo que executar
 a função {@link #apagaDados() apagaDados}<BR>
 A vantagem de utilizar este método em substituição aos outros dois é que este método é 'thread safe', o que significa que outras threads
 podem estar executando ao mesmo tempo, inserindo dados na mesma tabela, enquanto outra thread faz a 'descarga' desses dados em memória
 para o disco.<BR>
 Além disso, o parâmetro adicional 'minimoLinhas' para indicar que esta função apenas deve ser realizada caso a quantidade total
 de linhas na tabela seja no mínimo igual a quantidade informada. Por exemplo, se for indicado o número 100, este método será apenas efetivo
 apenas se houver 100 ou mais linhas preenchidas na tabela em memória.<BR>
 Com isso, pode-se programar alguma lógica que permite descarregar o conteúdo em memória para o servidor a cada lote de quantidade de linhas.<BR>
 ATENÇÃO: o que se 'descarta' são os dados mantidos em memória neste objeto {@link Tabela Tabela}. Os dados são preservados na tabela do usuário."""

    pass


  def getANOVA(self, colunaCategoria, colunaValores) -> ANOVA:
    """Executa o processamento estatístico conhecido como ANOVA (Análise da Variância) que
 tem o propósito de testar (para aceitar ou rejeitar) a hipótese de que os dados coletados e condicionados sob duas ou mais
 "categorias" possuem variação explicada pelo "acaso" (chamada de hipótese "nula" neste tipo de teste).<BR>
 Caso a hipótese seja "rejeitada", então pode-se concluir que existe pelo menos uma das sub-populações
 cuja média difere das médias das demais sub-populações com um determinado nível de certeza (embora não seja
 possível identificar qual delas, caso existam mais de duas categorias diferentes).<BR>
 Esta implementação é a chamada "One-Factor ANOVA" ou "One-Way ANOVA" pelo fato de haver
 apenas um único "fator" de divisão dos dados (isto é, uma única propriedade na tabela
 que separa os dados em diferentes "categorias" ou "níveis").<BR>
 Existem algums PRESSUPOSTOS para utilização desta técnica:<BR>
 1 - As sub-populações possuem a mesma variância.<BR>
 2 - As observações são independentes<BR>
 3 - A distribuição é aproximadamente NORMAL<BR>
 OBS: é feita distinção de maiúsculas/minúsculas para efeitos de separação da população em sub-populações."""

    pass


  def getAlturaLinhas(self) -> int:
    """Retorna a altura mínima, em pixels, que foi configurada para exibição das linhas desta tabela. Retorna 0 se não foi configurada nenhuma altura mínima."""

    pass


  def getAmostragemAleatoria(self, tamanhoAmostra) -> Tabela:
    """A partir da tabela atual (população) extrai uma tabela menor utilizando
 AMOSTRAGEM PROBABILÍSTICA onde a quantidade de linhas da tabela
 resultante é determinada pelo tamanho da amostra (parâmetro da função).<BR>
 Nesta função utiliza-se um gerador de números pseudo-aleatórios de
 distribuição uniforme (isto é, todas as linhas da tabela original possuem
 a mesma probabilidade de serem escolhidos).<BR>
 O gerador de números pseudo-aleatórios utilizado neste método é o mesmo
 utilizado em criptografia, estando de acordo com o que é especificado em
 FIPS 140-2, Security Requirements for Cryptographic Modules, seção 4.9.1.<BR>
 As execuções sucessivas deste método retornam resultados variados em
 razão da escolha aleatória (deve-se notar que ao executar sucessivamente
 o mesmo método sobre o mesmo conjunto de dados, alguns elementos podem
 ser escolhidos repetidas vezes).<BR>
 Caso o parâmetro que indica o tamanho da amostra seja maior ou igual que
 o tamanho da popupação, retorna-se a tabela inteira, mas as linhas ficam
 ordenadas de forma aleatória.<BR>
 OBS: se a tabela original possui linhas VAZIAS, essas linhas também podem
 ser escolhidas na amostragem probabilística."""

    pass


  def getAmostragemEstratificada(self, colunaEstratificacao, tamanhoAmostra) -> Tabela:
    """A partir da tabela atual (população) extrai uma tabela menor utilizando
 AMOSTRAGEM PROBABILÍSTICA ESTRATIFICADA onde a quantidade de linhas da
 tabela resultante é determinado pelo tamanho da amostra (parâmetro da
 função) e os "estratos" são obtidos conforme os valores encontrados em
 uma coluna de "critério de estratificação".<BR>
 Por exemplo, se a tabela possui uma coluna chamada "UF" onde os valores
 da coluna são as siglas das unidades federativas, pode-se montar uma
 amostragem estratificada respeitando as proporções de dados em cada
 estado especificando como nome de coluna o nome "UF".<BR>
 Nesta função utiliza-se um gerador de números pseudo-aleatórios de
 distribuição uniforme (isto é, todas as linhas da tabela original possuem
 a mesma probabilidade de serem escolhidos).<BR>
 O gerador de números pseudo-aleatórios utilizado neste método é o mesmo
 utilizado em criptografia, estando de acordo com o que é especificado em
 FIPS 140-2, Security Requirements for Cryptographic Modules, seção 4.9.1.<BR>
 As execuções sucessivas deste método retornam resultados variados em
 razão da escolha aleatória (deve-se notar que ao executar sucessivamente
 o mesmo método sobre o mesmo conjunto de dados, alguns elementos podem
 ser escolhidos repetidas vezes).<BR>
 Caso o parâmetro que indica o tamanho da amostra seja maior ou igual que
 o tamanho da popupação, retorna-se a tabela inteira, mas as linhas ficam
 ordenadas de forma aleatória.<BR>
 OBS: se a tabela original possui linhas VAZIAS, essas linhas NÃO são
 consideradas na tabela de resultado (é um comportamento diferente da
 amostragem puramente probabilística sem estratos, pois na análise
 estratificada precisamos ter alguma coisa preenchida na linha para
 associa-la a um determinado estrato).<BR>
 OBS-2: se a coluna que contém o critério de estratificação não é
 encontrada na tabela (isto é, o nome indicado como parâmetro não
 corresponde a um nome de coluna existente na tabela), a tabela retornada
 é vazia.<BR>"""

    pass


  def getAmostragemUnidadeMonetaria(self, tamanhoAmostra, colunaValor) -> Tabela:
    """A partir da tabela atual (população) extrai uma tabela menor utilizando
 AMOSTRAGEM PROBABILÍSTICA POR UNIDADE MONETÁRIA (MUS).<BR>
 A quantidade de linhas da tabela resultante é determinada pelo tamanho da
 amostra (parâmetro da função).<BR>
 Ao contrário da amostragem simples (função
 {@link Tabela#getAmostragemAleatoria(int) getAmostragemAleatoria}), onde
 todas as linhas da tabela possuem igual probabilidade de escolha, esta
 técnica de amostragem (MUS) atribui pesos distintos para cada linha da
 tabela, onde os pesos são determinados por valores existentes em uma das
 colunas da tabela (segundo parâmetro da função).<BR>
 Por exemplo, dada uma tabela contendo mil linhas, onde uma das colunas
 indica valores de notas fiscais, pode-se utilizar esta técnica de
 amostragem para que os valores mais elevados sejam priorizados em relação
 aos valores menores (a amostragem ainda é aleatória no sentido de que
 existe uma certa probabilidade dos valores menores serem escolhidos no
 lugar de valores maiores, mas esta probabilidade é baixa).<BR>"""

    pass


  def getAssimetria(self, nomeColuna) -> float:
    """Retorna o coeficiente de assimetria (calculado a partir dos momentos de
 ordem 3, não se tratando do coeficiente de Pearson) com base nos valores
 de uma determinada coluna."""

    pass


  def getAssimetria(self, coluna) -> float:
    """Retorna o coeficiente de assimetria (calculado a partir dos momentos de
 ordem 3, não se tratando do coeficiente de Pearson) com base nos valores
 de uma determinada coluna."""

    pass


  def getAtributo(self, linha, nome) -> Object:
    """Retorna o atributo que foi atribuído pela função
 {@link Tabela#setAtributo(int, String, Object) setAtributo}.<BR>
 Esta função difere da função
 {@link Tabela#getAtributo(int, int, String) getAtributo} pois esta função
 retorna um atributo definido para a linha (e não para uma célula da
 linha).<BR>"""

    pass


  def getAtributo(self, linha, coluna, nome) -> Object:
    """Retorna o atributo que foi atribuído pela função
 {@link Tabela#setAtributo(int, int, String, Object) setAtributo}."""

    pass


  def getAtributoColuna(self, coluna, nome) -> Object:
    """Retorna o atributo que foi atribuído pela função
 {@link Tabela#setAtributoColuna(int, String, Object) setAtributoColuna}.<BR>
 Esta função difere da função
 {@link Tabela#getAtributo(int, int, String) getAtributo} pois esta função
 retorna um atributo definido para a coluna (e não para uma célula da
 coluna).<BR>"""

    pass


  def getAtributoColuna(self, nomeColuna, nome) -> Object:
    """Retorna o atributo que foi atribuído pela função
 {@link Tabela#setAtributoColuna(int, String, Object) setAtributoColuna}.<BR>
 Esta função difere da função
 {@link Tabela#getAtributo(int, int, String) getAtributo} pois esta função
 retorna um atributo definido para a coluna (e não para uma célula da
 coluna).<BR>"""

    pass


  def getAtributoTabela(self, nome) -> Object:
    """Retorna o atributo que foi atribuído pela função
 {@link Tabela#setAtributoTabela(String, Object) setAtributoTabela}.<BR>
 Esta função difere da função
 {@link Tabela#getAtributo(int, int, String) getAtributo} pois esta função
 retorna um atributo definido para a tabela (e não para uma célula da
 coluna ou para uma coluna específica).<BR>"""

    pass


  def getAutoCorrelacao(self, nomeColuna, lag) -> float:
    """Retorna o coeficiente de auto-correlação com base nos valores de uma determinada coluna.<BR>
 Este parâmetro é calculado sobre uma série numérica.<BR>
 <BR>
 OBS: podem haver diferenças na forma de calcular o coeficiente de "auto-correlação". Alguns
 lugares utilizam no cálculo da correlação o denominador (N-k), onde N é o número de valores e
 k é o "lag", tendo em vista que no numerador deste cálculo temos também (N-k) elementos somados.
 Por outro lado, em outros lugares utiliza-se o denominador N (como em Chatfield e muitos outros).
 A utilização de (N-k) na fórmula pode reduzir o "bias" (tendência), mas aumenta o erro quadrático médio. 
 Esta função implementada aqui utiliza o denominador (N), não (N-k).<BR>
 Para converter este resultado para o outro padrão, basta multiplicar este valor por N/(N-k)."""

    pass


  def getAutoCorrelacao(self, coluna, lag) -> float:
    """Retorna o coeficiente de auto-correlação com base nos valores de uma determinada coluna.<BR>
 Este parâmetro é calculado sobre uma série numérica.<BR>
 <BR>
 OBS: podem haver diferenças na forma de calcular o coeficiente de "auto-correlação". Alguns
 lugares utilizam no cálculo da correlação o denominador (N-k), onde N é o número de valores e
 k é o "lag", tendo em vista que no numerador deste cálculo temos também (N-k) elementos somados.
 Por outro lado, em outros lugares utiliza-se o denominador N (como em Chatfield e muitos outros).
 A utilização de (N-k) na fórmula pode reduzir o "bias" (tendência), mas aumenta o erro quadrático médio. 
 Esta função implementada aqui utiliza o denominador (N), não (N-k).<BR>
 Para converter este resultado para o outro padrão, basta multiplicar este valor por N/(N-k)."""

    pass


  def getAutoCorrelacaoParcial(self, nomeColuna, lag) -> float:
    """Retorna o coeficiente de auto-correlação parcial com base nos valores de uma determinada coluna.<BR>
 Este parâmetro é calculado sobre uma série numérica.<BR>
 Esta medida está intimamente relacionada com o modelo AR(p) (auto-regressivo com parâmetro "p") no
 sentido que em um modelo AR(p) os coeficientes de auto-correlação parcial assumem apenas valores iguais a 0 
 no "lag" (p+1) em diante. Deste modo, observando os valores de autocorrelação parcial de uma série, é
 possível estimar um parâmetro apropriado para "p" do modelo AR(p) correspondente (utilizado, por exemplo,
 no modelo ARIMA(p,d,q)).<BR>"""

    pass


  def getAutoCorrelacaoParcial(self, coluna, lag) -> float:
    """Retorna o coeficiente de auto-correlação parcial com base nos valores de uma determinada coluna.<BR>
 Este parâmetro é calculado sobre uma série numérica.<BR>
 Esta medida está intimamente relacionada com o modelo AR(p) (auto-regressivo com parâmetro "p") no
 sentido que em um modelo AR(p) os coeficientes de auto-correlação parcial assumem apenas valores iguais a 0 
 no "lag" (p+1) em diante. Deste modo, observando os valores de autocorrelação parcial de uma série, é
 possível estimar um parâmetro apropriado para "p" do modelo AR(p) correspondente (utilizado, por exemplo,
 no modelo ARIMA(p,d,q)).<BR>"""

    pass


  def getCelula(self, linha, nomeColuna) -> Object:
    """Retorna o conteúdo de uma célula da tabela (isto é, algo armazenado em
 uma determinada linha e em uma determinada coluna). A coluna é
 identificada por seu título."""

    pass


  def getCelula(self, linha, coluna) -> Object:
    """Retorna o conteúdo de uma célula da tabela (isto é, algo armazenado em
 uma determinada linha e em uma determinada coluna). A coluna é
 identificada por sua posição na linha."""

    pass


  def getCelulaFormatada(self, linha, nomeColuna) -> str:
    """Retorna o conteúdo da célula conforme a formatação que foi especificada
 pela função {@link Tabela#setFormato(int, String) setFormato}."""

    pass


  def getCelulaFormatada(self, linha, coluna) -> str:
    """Retorna o conteúdo da célula conforme a formatação que foi especificada
 pela função {@link Tabela#setFormato(int, String) setFormato}."""

    pass


  def getColunaComTitulo(self, titulo) -> int:
    """Retorna o número da coluna (isto é, sua posição) a partir do título. Isto
 é, supõe que os títulos já foram atribuídos às colunas desta tabela."""

    pass


  def getColunaComTituloExpressaoRegular(self, expressaoRegular, primeiraColunaPesquisar) -> int:
    """Retorna o número da coluna (isto é, sua posição) a partir de uma expressão regular que é aplicada sobre os títulos da tabela. Isto
 é, supõe que os títulos já foram atribuídos às colunas desta tabela. Se há mais de um título que atende à expressão regular, retorna
 o primeiro deles."""

    pass


  def getColunaComTituloExpressaoRegular(self, expressaoRegular) -> int:
    """Retorna o número da coluna (isto é, sua posição) a partir de uma expressão regular que é aplicada sobre os títulos da tabela. Isto
 é, supõe que os títulos já foram atribuídos às colunas desta tabela. Se há mais de um título que atende à expressão regular, retorna
 o primeiro deles."""

    pass


  def getColunaComoLista(self, coluna) -> Lista:
    """Dada uma coluna da tabela, cria um novo objeto do tipo Lista contendo
 todos os elementos da coluna.<BR>
 Esta "lista" é uma estrutura independente da coluna da tabela de onde ela
 se originou.<BR>
 Isto é, qualquer modificação posterior na tabela original não tem impacto
 nesta lista, ou vice-versa.<BR>
 As células vazias NÃO são inseridas na lista (uma célula cujo conteúdo é
 o número zero não é considerada vazia).<BR>
 <BR>
 Atenção: as células 'vazias' que existirem na coluna indicada não são incluídas
 na lista que está sendo retornada. Caso seja desejável retornar as células vazias,
 utilize o método alternativo que recebe o parâmetro adicional com esta indicação."""

    pass


  def getColunaComoLista(self, titulo, incluiCelulasVazias) -> Lista:
    """Método alternativo a {@link Tabela#getColunaComoLista(String) getColunaComoLista} onde é possível
 indicar se deve ou não incluir na lista de resultado os valores vazios."""

    pass


  def getColunaComoLista(self, coluna, incluiCelulasVazias) -> Lista:
    """Método alternativo a {@link Tabela#getColunaComoLista(int) getColunaComoLista} onde é possível
 indicar se deve ou não incluir na lista de resultado os valores vazios."""

    pass


  def getColunaComoLista(self, titulo) -> Lista:
    """Dada uma coluna da tabela, cria um novo objeto do tipo Lista contendo
 todos os elementos da coluna.<BR>
 Esta "lista" é uma estrutura independente da coluna da tabela de onde ela
 se originou.<BR>
 Isto é, qualquer modificação posterior na tabela original não tem impacto
 nesta lista, ou vice-versa.<BR>
 <BR>
 Atenção: as células 'vazias' que existirem na coluna indicada não são incluídas
 na lista que está sendo retornada. Caso seja desejável retornar as células vazias,
 utilize o método alternativo que recebe o parâmetro adicional com esta indicação."""

    pass


  def getColunas(self, colunas) -> Tabela:
    """Retorna uma nova tabela contendo parte das colunas da tabela atual."""

    pass


  def getColunas(self, primeiraColuna, ultimaColuna) -> Tabela:
    """Retorna uma nova tabela contendo parte das colunas da tabela atual."""

    pass


  def getCopia(self) -> Tabela:
    """Obtém uma cópia da tabela original, incluindo todas as suas linhas,
 colunas e atributos (nomes, formatos, etc)."""

    pass


  def getCopiaSemDados(self) -> Tabela:
    """Obtém uma cópia da tabela sem incluir seus dados (isto é, copia apenas os
 nomes, formatos, etc.).<BR>"""

    pass


  def getCorrelacao(self) -> Tabela:
    """Dada a tabela atual, calcula a matriz 'correlação' sobre todas as colunas do tipo 'numérico' (isto é, colunas
 que contenham valores numéricos inteiros ou decimais).<BR>
 Não considera outros tipos de colunas (isto é, colunas com textos, datas, meses, códigos CPF, códigos CNPJ, etc.).<BR>
 A tabela precisa ter no mínimo 1 coluna do tipo 'numérico'.<BR>
 A tabela resultado contém uma linha para cada coluna do tipo 'numérico' da tabela original. A quantidade de colunas é
 igual à quantidade de linhas 'mais um' para incluir a coluna com os nomes.<BR>
 Os valores são as correlações entre as colunas do tipo 'numérico' da tabela original. Por se tratar de uma 'normalização',
 os valores na 'diagonal' são todos iguais a 1.<BR>
 Este método é análogo ao método de mesmo nome definido no objeto {@link Matriz Matriz}, com a diferença que aqui os títulos
 das colunas são preservados."""

    pass


  def getCovariancia(self) -> Tabela:
    """Dada a tabela atual, calcula a matriz 'covariância' sobre todas as colunas do tipo 'numérico' (isto é, colunas
 que contenham valores numéricos inteiros ou decimais).<BR>
 Não considera outros tipos de colunas (isto é, colunas com textos, datas, meses, códigos CPF, códigos CNPJ, etc.).<BR>
 A tabela precisa ter no mínimo 1 coluna do tipo 'numérico'.<BR>
 A tabela resultado contém uma linha para cada coluna do tipo 'numérico' da tabela original. A quantidade de colunas é
 igual à quantidade de linhas 'mais um' para incluir a coluna com os nomes.<BR>
 Os valores são as covariâncias entre as colunas do tipo 'numérico' da tabela original.<BR> 
 Este método é análogo ao método de mesmo nome definido no objeto {@link Matriz Matriz}, com a diferença que aqui os títulos
 das colunas são preservados."""

    pass


  def getCurtose(self, nomeColuna) -> float:
    """Retorna o coeficiente de curtose (calculado a partir do momento de ordem
 4, subtraindo o resultado por 3 para fins de comparação com a curva
 normal) com base nos valores de uma determinada coluna."""

    pass


  def getCurtose(self, coluna) -> float:
    """Retorna o coeficiente de curtose (calculado a partir do momento de ordem
 4, subtraindo o resultado por 3 para fins de comparação com a curva
 normal) com base nos valores de uma determinada coluna."""

    pass


  def getDados(self) -> Iterator:
    """Retorna o conteúdo da tabela na forma de um objeto que pode ser
 percorrido em um LOOP, percorrendo uma linha de cada vez."""

    pass


  def getDadosComAtributoLinha(self, nomeAtributo, valorAtributo) -> Iterator:
    """Retorna o conteúdo da tabela na forma de um objeto que pode ser
 percorrido em um LOOP, percorrendo uma linha de cada vez, mas somente aquelas
 linhas que possuam um determinado atributo com um determinado valor.<BR>
 Ou seja, previamente a este método é necessário que esta tabela tenha atribuído
 algum atributo sobre 'linhas', utilizando o método {@link Tabela#setAtributo(int, String, Object) setAtributo}.
 Feito isso, este método pode então ser utilizado para 'percorrer' aquelas linhas que
 possuem este atributo com o valor indicado.<BR>
 Note que estamos falando de atributos de 'linha'. Não se aplica a atributos de 'coluna' ou
 a atributos de 'célula' ou a atributos gerais de 'tabela' (todas essas outras modalidades de
 atributos são definidas através de outros métodos)."""

    pass


  def getDecimais(self, coluna) -> int:
    """Retorna a quantidade de decimais que foi atribuída a determinada coluna"""

    pass


  def getDecimais(self, coluna) -> int:
    """Retorna a quantidade de decimais que foi atribuída a determinada coluna"""

    pass


  def getDesvioPadrao(self, nomeColuna) -> float:
    """Calcula o desvio padrão com base nos valores de uma determinada coluna.<BR>
 Utiliza-se a convenção onde o denominador é N-1 (isto é, considera fator de correção da amostra para a população)."""

    pass


  def getDesvioPadrao(self, coluna) -> float:
    """Calcula o desvio padrão com base nos valores de uma determinada coluna.<BR>
 Utiliza-se a convenção onde o denominador é N-1 (isto é, considera fator de correção da amostra para a população)."""

    pass


  def getDistribuicaoAjustada(self, coluna) -> DistribuicaoAjustada:
    """Retorna a distribuição de números aleatórios que melhor descreve o
 conjunto de valores de uma coluna da tabela.<BR>
 Para mais informações sobre esta técnica, consulte comentários
 relacionados à classe {@link DistribuicaoAjustada DistribuicaoAjustada}."""

    pass


  def getEntropia(self, nomeColuna, base) -> float:
    """Retorna a "entropia da informação" calculada sobre os dados (numéricos ou
 não) de uma coluna da tabela.<BR>
 Trata-se de uma forma de medir a "quantidade de informação", sendo tanto
 maior quanto maior for o seu grau de incerteza (este conceito foi
 introduzido por Claude Shannon em seu trabalho "Uma Teoria Matemática da
 Comunicação").<BR>
 Algumas de suas propriedades:<BR> - É sempre positiva (pode ser igual a
 zero quando o evento é plenamente "conhecido", isto é, quando se tem
 certeza sobre sua realização, que é o que ocorre com um valor
 "constante", por exemplo).<BR> - É máxima quando todos os possíveis
 números são igualmente "prováveis" (por exemplo, em um lance de moeda
 onde há 50% de chance de sair cara e 50% de chance de sair coroa, a
 entropia atinge seu valor máximo).<BR>
 OBS: o comportamento desta função no ContÁgil é diferente quando a coluna
 é numérica ou não. Se a coluna é numérica (isto é, possui números),
 considera-se cada número em razão da soma total. Por exemplo, se os
 números são 2 e 3, considera-se 2/5 e 3/5 como valores para o calculo da
 entropia. Os números negativos ou iguais a zero são ignorados, como se
 não existissem.<BR>
 Por outro lado, se a coluna possui algo que não é número (como textos,
 códigos ou datas), são calculadas as frequencias com que cada um desses
 conteúdos aparecem na coluna, depois calcula-se a entropia sobre essas
 frequencias."""

    pass


  def getEntropia(self, coluna, base) -> float:
    """Retorna a "entropia da informação" calculada sobre os dados (numéricos ou
 não) de uma coluna da tabela.<BR>
 Trata-se de uma forma de medir a "quantidade de informação", sendo tanto
 maior quanto maior for o seu grau de incerteza (este conceito foi
 introduzido por Claude Shannon em seu trabalho "Uma Teoria Matemática da
 Comunicação").<BR>
 Algumas de suas propriedades:<BR> - É sempre positiva (pode ser igual a
 zero quando o evento é plenamente "conhecido", isto é, quando se tem
 certeza sobre sua realização, que é o que ocorre com um valor
 "constante", por exemplo).<BR> - É máxima quando todos os possíveis
 números são igualmente "prováveis" (por exemplo, em um lance de moeda
 onde há 50% de chance de sair cara e 50% de chance de sair coroa, a
 entropia atinge seu valor máximo).<BR>
 OBS: o comportamento desta função no ContÁgil é diferente quando a coluna
 é numérica ou não. Se a coluna é numérica (isto é, possui números),
 considera-se cada número em razão da soma total. Por exemplo, se os
 números são 2 e 3, considera-se 2/5 e 3/5 como valores para o calculo da
 entropia. Os números negativos ou iguais a zero são ignorados, como se
 não existissem.<BR>
 Por outro lado, se a coluna possui algo que não é número (como textos,
 códigos ou datas), são calculadas as frequencias com que cada um desses
 conteúdos aparecem na coluna, depois calcula-se a entropia sobre essas
 frequencias."""

    pass


  def getFormato(self, coluna) -> str:
    """Retorna o formato que foi atribuído a uma determinada coluna."""

    pass


  def getFormatoBasico(self, coluna) -> int:
    """Retorna o formato básico que foi atribuído a uma determinada coluna.<BR>
 Por formato "básico" entende-se: TEXTO ou DECIMAL ou DATA ou MOEDA ou
 INTEIRO. Caso o formato seja um tipo texto específico (tal como CPF,
 CNPJ, etc), retorna nesses casos sempre o mesmo número: 4 (que
 corresponde a "texto").<BR>
 Se for necessário obter o número indicativo do tipo específico, deve-se
 utilizar o método getFormatoNumerico()."""

    pass


  def getFormatoNumerico(self, coluna) -> int:
    """Retorna o formato que foi atribuído a uma determinada coluna."""

    pass


  def getInformacaoMutua(self) -> Tabela:
    """Dada a tabela atual, retorna uma tabela com o cálculo da INFORMAÇÃO MÚTUA entre cada par de colunas.<BR>
 Trata-se de um método que procura correlacionar duas colunas quaisquer. Ao contrário de uma CORRELAÇÃO,
 este método se aplica também a dados não métricos (ex: dados categóricos, datas, códigos, etc.).<BR>
 Se há total independência entre duas colunas, o coeficiente de 'INFORMAÇÃO MÚTUA' entre elas é igual a zero.<BR>
 Porém, quanto maior a dependência entre duas colunas (isto é, se conhecendo o valor de uma coluna contribui
 para conhecer o valor da segunda coluna), o coeficiente de 'INFORMAÇÃO MÚTUA' assume valores positivos maiores
 até alcançar o limite no valor conhecido como 'ENTROPIA' dos valores da referida coluna.<BR>
 Caso a coluna apresente dados não métricos (ex: textos, datas, códigos, etc.), internamente esses conteúdos
 são mapeados temporariamente para 'números' (por exemplo, um mesmo texto é sempre mapeado para um mesmo número, mas
 textos diferentes são mapeados para números diferentes). Neste 'mapeamento' interno, temporário (que não modifica
 a tabela original), não se consideram diferenças de letras maiúsculas/minúsculas e nem de acentuação.<BR>
 A tabela é 'simétrica' (isto é, o coeficiente de informação mútua entre as colunas A e B é igual ao coeficiente
 de informação mútua entre as colunas B e A).<BR>
 A 'diagonal' (coeficiente da coluna original com ela mesma) corresponde à 'entropia' da coluna considerada.<BR> 
 A tabela resultado contém uma linha para cada coluna da tabela original. A quantidade de colunas é
 igual à quantidade de linhas 'mais um' para incluir a coluna com os nomes.<BR>
 A medida do coeficiente de 'Informação Mútua' é dada em 'bits' (utiliza-se logaritmo na base 2). Isto é, utilizamos o conceito de 'bit'
 da teoria da informação, não o conceito convencional utilizado em armazenamento de dados.<BR>
 Atenção: caso a coluna apresente valores numéricos, eles são discretizados para o número inteiro mais próximo. Caso todos os valores
 numéricos da coluna estejam situados no intervalo aberto entre -1 e +1, eles será todos considerados iguais a 0, consequentemente terá
 entropia 0."""

    pass


  def getInformacaoMutuaNormalizada(self) -> Tabela:
    """Alternativa ao método {@link Tabela#getInformacaoMutua() getInformacaoMutua} onde, no lugar da 'informação mútua' convencional,
 calcula-se um outro número 'normalizado', variando de 0 a 1, conforme a expressão:<BR>
 D(X,Y) = I(X,Y)/min(H(X),H(Y)), onde I(X,Y) é a informação mútua entre X e Y e H(X) é a entropia de X.<BR>
 Será igual a 0 para situações onde não há similaridade alguma. Será igual a 1 para situações onde há total similaridade.<BR>
 OBS: esta medida é o 'complemento' da distância Jaccard (isto é, se tomarmos 1 - D(X,Y), o que temos é a 'distância de Jaccard', que mede a 'dissimilaridade' entre dois conjuntos).<BR>
 Atenção: caso a coluna apresente valores numéricos, eles são discretizados para o número inteiro mais próximo. Caso todos os valores
 numéricos da coluna estejam situados no intervalo aberto entre -1 e +1, eles será todos considerados iguais a 0, consequentemente terá
 entropia 0, resultando em um coeficiente de informação mútua indefinido (divisão por zero)."""

    pass


  def getKolmogorovSmirnovEstatistica(self, coluna1, coluna2) -> float:
    """Aplica o teste 'Kolmogorov-Smirnov' para testar a hipótese de que uma relação de valores se
 distribui conforme a mesma distribuição que outra relação de valores.<BR>
 O valor retornado por esta função é a 'estatística' que pode ser depois comparada com uma
 tabela de distribuição D(n) conforme explicado em: http://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test.<BR>"""

    pass


  def getKolmogorovSmirnovEstatistica(self, formula, coluna) -> float:
    """Aplica o teste 'Kolmogorov-Smirnov' para testar a hipótese de que uma relação de valores se
 distribui conforme uma determinada distribuição.<BR>
 O valor retornado por esta função é a 'estatística' que pode ser depois comparada com uma
 tabela de distribuição D(n) conforme explicado em: http://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test.<BR>
 ATENÇÃO: a fórmula indicada deve ser uma fórmula no padrão do ContÁgil sobre uma variável independente X que retorne algo
 compatível com uma 'função distribuição acumulada'. Por exemplo, "NORMAL.ACUM(X;0;1)" pode ser utilizado para comparar com
 a distribuição NORMAL de média 0 e desvio padrão 1."""

    pass


  def getKolmogorovSmirnovValorP(self, formula, coluna) -> float:
    """Aplica o teste 'Kolmogorov-Smirnov' para testar a hipótese de que uma relação de valores se
 distribui conforme uma determinada distribuição.<BR>
 O valor retornado por esta função é o valor 'P' obtido após comparação da estatística com a tabela de distribuição D(n) conforme explicado em: http://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test.<BR>
 Geralmente um valor inferior a 0,05 indica que 'rejeitamos' a hipótese de que os valores seguem a distribuição informada no primeiro parâmetro com 95% de confiança, e um valor superior a 0,05
 indica que não rejeitamos (isto é, que mantemos a hipótese de que os valores seguem esta distribuição).<BR>
 ATENÇÃO: a fórmula indicada deve ser uma fórmula no padrão do ContÁgil sobre uma variável independente X que retorne algo
 compatível com uma 'função distribuição acumulada'. Por exemplo, "NORMAL.ACUM(X;0;1)" pode ser utilizado para comparar com
 a distribuição NORMAL de média 0 e desvio padrão 1."""

    pass


  def getKolmogorovSmirnovValorP(self, coluna1, coluna2) -> float:
    """Aplica o teste 'Kolmogorov-Smirnov' para testar a hipótese de que uma relação de valores se
 distribui conforme a mesma distribuição que outra relação de valores.<BR>
 O valor retornado por esta função é o valor 'P' obtido após comparação da estatística com a tabela de distribuição D(n) conforme explicado em: http://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test.<BR>
 Geralmente um valor inferior a 0,05 indica que 'rejeitamos' a hipótese de que os valores seguem a distribuição informada no primeiro parâmetro com 95% de confiança, e um valor superior a 0,05
 indica que não rejeitamos (isto é, que mantemos a hipótese de que os valores seguem esta distribuição).<BR>"""

    pass


  def getLinha(self, idx) -> TabelaDetalhe:
    """Dado um índice para a tabela, retorna a linha correspondente"""

    pass


  def getLinhas(self, primeiraLinha, ultimaLinha) -> Tabela:
    """Retorna uma nova tabela contendo parte das linhas da tabela atual."""

    pass


  def getMaximo(self, nomeColuna) -> float:
    """Calcula o máximo com base nos valores de uma determinada coluna."""

    pass


  def getMaximo(self, coluna) -> float:
    """Calcula o máximo com base nos valores de uma determinada coluna."""

    pass


  def getMedia(self, coluna) -> float:
    """Calcula a média com base nos valores de uma determinada coluna."""

    pass


  def getMedia(self, nomeColuna) -> float:
    """Calcula a média com base nos valores de uma determinada coluna."""

    pass


  def getMediana(self, nomeColuna) -> float:
    """Retorna a "mediana" sobre os dados numéricos de uma coluna da tabela.<BR>
 Trata-se do mesmo efeito de executar a função: getPercentil(coluna, 50).<BR>
 A "mediana" é o valor que "divide" os dados pela "metade" (isto é, a
 quantidade de valores à esquerda da mediana equivale à quantidade de
 valores à direita).<BR>
 Somente em alguns casos a mediana é igual à média.<BR>
 A "mediana" é utilizada no cálculo de assimetria (segundo coeficiente de
 Pearson).<BR>
 A "mediana" é também a constante "c" que minimiza a relação E|x-c| (o
 valor esperado das diferenças absolutas entre os valores e uma
 constante)."""

    pass


  def getMediana(self, coluna) -> float:
    """Retorna a "mediana" sobre os dados numéricos de uma coluna da tabela.<BR>
 Trata-se do mesmo efeito de executar a função: getPercentil(coluna, 50).<BR>
 A "mediana" é o valor que "divide" os dados pela "metade" (isto é, a
 quantidade de valores à esquerda da mediana equivale à quantidade de
 valores à direita).<BR>
 Somente em alguns casos a mediana é igual à média.<BR>
 A "mediana" é utilizada no cálculo de assimetria (segundo coeficiente de
 Pearson).<BR>
 A "mediana" é também a constante "c" que minimiza a relação E|x-c| (o
 valor esperado das diferenças absolutas entre os valores e uma
 constante)."""

    pass


  def getMinimo(self, nomeColuna) -> float:
    """Calcula o mínimo com base nos valores de uma determinada coluna."""

    pass


  def getMinimo(self, coluna) -> float:
    """Calcula o mínimo com base nos valores de uma determinada coluna."""

    pass


  def getModa(self, nomeColuna) -> long:
    """Calcula a "moda" de uma relação de números existentes em uma coluna.<BR>
 Este é o número que se repete com maior frequencia.<BR>
 Uma lista de valores pode conter mais de uma "moda" (por exemplo, em
 1,2,2,3,3 temos duas modas: 2 e 3). Nesta hipótese, esta função retorna
 apenas aquela de "maior" número (neste exemplo seria a moda de número 3).<BR>
 Esta função considera que a coluna possui apenas números INTEIROS. Caso
 existam números fracionários, eles são arredondados para o INTEIRO mais
 próximo.<BR>
 Note que para valores fracionários geralmente é melhor agrupa-los
 primeiro conforme intervalos de tamanhos definidos para somente depois
 calcular a "moda" conforme as repetições de cada intervalo (ao invés de
 analisar as repetições de valores individuais). Isso não é feito nesta
 função, pois aqui são comparados sempre os valores individuais.<BR>"""

    pass


  def getModa(self, coluna) -> long:
    """Calcula a "moda" de uma relação de números existentes em uma coluna.<BR>
 Este é o número que se repete com maior frequencia.<BR>
 Uma lista de valores pode conter mais de uma "moda" (por exemplo, em
 1,2,2,3,3 temos duas modas: 2 e 3). Nesta hipótese, esta função retorna
 apenas aquela de "maior" número (neste exemplo seria a moda de número 3).<BR>
 Esta função considera que a coluna possui apenas números INTEIROS. Caso
 existam números fracionários, eles são arredondados para o INTEIRO mais
 próximo.<BR>
 Note que para valores fracionários geralmente é melhor agrupa-los
 primeiro conforme intervalos de tamanhos definidos para somente depois
 calcular a "moda" conforme as repetições de cada intervalo (ao invés de
 analisar as repetições de valores individuais). Isso não é feito nesta
 função, pois aqui são comparados sempre os valores individuais.<BR>"""

    pass


  def getNome(self) -> str:
    """Retorna o nome desta tabela (caso tenha sido atribuído algum)."""

    pass


  def getNomesAtributosColuna(self, coluna) -> list:
    """Retorna os nomes dos atributos definidos para uma determinada coluna da tabela.<BR>
 Os atributos de colunas são definidos através da função {@link Tabela#setAtributoColuna(int, String, Object) setAtributoColuna}.<BR>"""

    pass


  def getNomesAtributosColuna(self, nomeColuna) -> list:
    """Retorna os nomes dos atributos definidos para uma determinada coluna da tabela.<BR>
 Os atributos de colunas são definidos através da função {@link Tabela#setAtributoColuna(int, String, Object) setAtributoColuna}.<BR>"""

    pass


  def getNomesAtributosLinha(self, linha) -> list:
    """Retorna os nomes dos atributos definidos para uma determinada linha da tabela.<BR>
 Os atributos de colunas são definidos através da função {@link Tabela#setAtributo(int, String, Object) setAtributo}.<BR>"""

    pass


  def getNomesAtributosTabela(self) -> list:
    """Retorna os nomes dos atributos definidos para a tabela sem distinção de coluna ou de linha.<BR>
 Os atributos de tabela são definidos através da função {@link Tabela#setAtributoTabela(String, Object) setAtributoTabela}.<BR>"""

    pass


  def getNumColunas(self) -> int:
    """Retorna a quantidade de colunas na tabela"""

    pass


  def getNumLinhas(self) -> int:
    """Retorna a quantidade de linhas na tabela"""

    pass


  def getPercentil(self, coluna, proporcao) -> float:
    """Retorna um determinado "percentil" sobre os dados numéricos de uma coluna
 da tabela.<BR>
 Os "percentis" são utilizados no cálculo de coeficiente de assimetria e
 de curtose (achatamento).<BR>
 O percentil 25 corresponde ao primeiro quartil<BR>
 O percentil 50 corresponde à mediana (ou segundo quartil).<BR>
 O percentil 75 corresponde ao terceiro quartil<BR>"""

    pass


  def getPercentil(self, nomeColuna, proporcao) -> float:
    """Retorna um determinado "percentil" sobre os dados numéricos de uma coluna
 da tabela.<BR>
 Os "percentis" são utilizados no cálculo de coeficiente de assimetria e
 de curtose (achatamento).<BR>
 O percentil 25 corresponde ao primeiro quartil<BR>
 O percentil 50 corresponde à mediana (ou segundo quartil).<BR>
 O percentil 75 corresponde ao terceiro quartil<BR>"""

    pass


  def getQtdColunas(self) -> int:
    """Idem ao método {@link Tabela#getNumColunas() getNumColunas}"""

    pass


  def getQtdLinhas(self) -> int:
    """Idem ao método {@link Tabela#getNumLinhas getNumLinhas}"""

    pass


  def getRegressaoLinearMultipla(self, colunasX, colunaY) -> RegressaoMultipla:
    """Dadas mais de duas colunas da tabela contendo valores numéricos, onde uma
 das colunas depende das demais, aplica o método estatístico da regressão
 linear múltipla (a relação entre a variável e as dependentes pode ser
 aproximada por um "hiperplano").<BR>
 As variáveis são as "colunas" da tabela indicadas nos parâmetros. As
 variáveis "independentes" são as colunas "X" e a variável dependente é a
 coluna "Y".<BR>
 Se alguma célula nas colunas informadas não contiver um valor numérico
 válido (isto é, se for um valor "omisso"), considera que seu valor é 0.<BR>
 OBS: este método procura um modelo de regressão onde não há o termo 'intersecção' (isto é,
 o hiperplano encontrado passa pela origem). Caso queira considerar o termpo 'intersecção'
 no modelo de regressão, utilize a outra alternativa deste método."""

    pass


  def getRegressaoLinearMultipla(self, colunasX, colunaY, calculaInterseccao) -> RegressaoMultipla:
    """Dadas mais de duas colunas da tabela contendo valores numéricos, onde uma
 das colunas depende das demais, aplica o método estatístico da regressão
 linear múltipla (a relação entre a variável e as dependentes pode ser
 aproximada por um "hiperplano").<BR>
 As variáveis são as "colunas" da tabela indicadas nos parâmetros. As
 variáveis "independentes" são as colunas "X" e a variável dependente é a
 coluna "Y".<BR>
 Se alguma célula nas colunas informadas não contiver um valor numérico
 válido (isto é, se for um valor "omisso"), considera que seu valor é 0.<BR>"""

    pass


  def getRegressaoLinearSimples(self, colunaX, colunaY) -> RegressaoSimples:
    """Dadas duas colunas da tabela contendo valores numéricos, aplica o método
 estatístico da regressão linear simples (melhor reta que passa por todos
 os pontos). Cada "ponto" é definido utilizando um valor da coluna
 identificada pelo parâmetro "colunaX" e um valor correspondente da coluna
 identificada pelo parâmetro "colunaY"."""

    pass


  def getSoma(self, coluna) -> float:
    """Calcula a soma com base nos valores de uma determinada coluna."""

    pass


  def getSoma(self, nomeColuna) -> float:
    """Calcula a soma com base nos valores de uma determinada coluna."""

    pass


  def getSubTabelaComFormula(self, formula, primeira_linha_procurar, ultima_linha_procurar) -> Tabela:
    """Função alternativa onde é possível indicar um parâmetro adicional informando o número da linha a partir da qual deseja
 realizar a pesquisa e o número da linha até onde deseja realizar a pesquisa. Isto é, as linhas anteriores ou posteriores 
 presentes na tabela são ignoradas."""

    pass


  def getSubTabelaComFormula(self, formula) -> Tabela:
    """Procura todas as linhas da tabela atual que atendem ao critério definido na fórmula.<BR>
 Retorna na forma de uma nova tabela as linhas que satisfazem o critério.<BR>
 A tabela original não é alterada por este método.
 A fórmula deve seguir o padrão do ContÁgil (isto é, a mesma sintaxe utilizada em MAD e em outros lugares) e deve fazer referência
 a qualquer uma das colunas da tabela. Pode-se também considerar na mesma fórmula mais de uma coluna da tabela."""

    pass


  def getSubTabelaComFormula(self, formula, primeira_linha_procurar) -> Tabela:
    """Função alternativa onde é possível indicar um parâmetro adicional informando o número da linha a partir da qual deseja
 realizar a pesquisa. Isto é, as linhas anteriores presentes na tabela são ignoradas."""

    pass


  def getSubTabelaSemLinhasOutraTabela(self, outraTabela, colunasComparadas) -> Tabela:
    """Cria em memória um novo objeto 'Tabela' com a mesma estrutura de colunas que a tabela atual, porém copia para esta nova tabela apenas
 as linhas da tabela atual que não aparecem na tabela indicada no parâmetro.<BR>
 Trata-se de uma função alternativa à outra função de mesmo nome que tem um só parâmetro.<BR>
 A diferença é que aqui se pode indicar os índices das colunas (onde 0 = primeira coluna) que devem ser consideradas na comparação entre
 as diferentes tabelas.<BR>
 OBS: todas as colunas desta tabela são copiadas para a nova tabela, independentemente da relação de colunas informadas no segundo parâmetro. Esta
 relação de colunas apenas é considerada para efeitos de comparar uma tabela com outra.<BR>
 ATENÇÃO: não utilize esta função com tabelas muito grandes porque isso pode ocasionar erro de falta de memória!"""

    pass


  def getSubTabelaSemLinhasOutraTabela(self, outraTabela) -> Tabela:
    """Cria em memória um novo objeto 'Tabela' com a mesma estrutura de colunas que a tabela atual, porém copia para esta nova tabela apenas
 as linhas da tabela atual que não aparecem na tabela indicada no parâmetro.<BR>
 Nesta comparação, considera todas as colunas de ambas tabelas, na mesma ordem com que aparecem nas tabelas. Isto é, compara o valor da primeira
 coluna desta tabela com o valor da primeira coluna na tabela parâmetro, e assim sucessivamente, independentemente dos nomes dessas colunas serem
 os mesmos ou não.\n
 Caso exista diferença em qualquer uma das colunas, a linha desta tabela é copiada para a nova tabela.<BR>
 ATENÇÃO: não utilize esta função com tabelas muito grandes porque isso pode ocasionar erro de falta de memória!"""

    pass


  def getTitulo(self, coluna) -> str:
    """Retorna o título que foi atribuído a uma determinada coluna."""

    pass


  def getTitulos(self) -> list:
    """Retorna os títulos de todas as colunas."""

    pass


  def getValor(self, linha, coluna) -> Object:
    """Faz exatamente a mesma coisa que a função
 {@link Tabela#getCelula(int, int) getCelula}. Trata-se apenas de uma
 conveniência para se utilizar outro nome de função para o mesmo
 procedimento."""

    pass


  def getValorNumerico(self, linha, nomeColuna) -> float:
    """Retorna o conteúdo da célula, porém já faz o tratamento do 'valor' de
 modo a sempre considerá-lo como um 'número'.<BR>
 Caso o conteúdo da célula esteja vazio ou caso contenha algo diferente
 de número, tentará fazer alguma 'conversão'. Por exemplo, se o conteúdo
 for um 'texto' que representa um 'número', este texto é convertido para
 número. Porém, se o texto começa com letras ou outros caracteres não numéricos,
 retorna 0.<BR>
 Também retornará 0 se o conteúdo for algo que não possa ser convertido
 em um número (tal como um 'mês', uma 'data', etc.)."""

    pass


  def getValorNumerico(self, linha, coluna) -> float:
    """Retorna o conteúdo da célula, porém já faz o tratamento do 'valor' de
 modo a sempre considerá-lo como um 'número'.<BR>
 Caso o conteúdo da célula esteja vazio ou caso contenha algo diferente
 de número, tentará fazer alguma 'conversão'. Por exemplo, se o conteúdo
 for um 'texto' que representa um 'número', este texto é convertido para
 número. Porém, se o texto começa com letras ou outros caracteres não numéricos,
 retorna 0.<BR>
 Também retornará 0 se o conteúdo for algo que não possa ser convertido
 em um número (tal como um 'mês', uma 'data', etc.)."""

    pass


  def getValoresAtributo(self, nome) -> Lista:
    """Retorna em uma lista os valores de um atributo que foi definido em linhas da tabela
 através da função {@link Tabela#setAtributo(int, String, Object) setAtributo}.<BR>
 IMPORTANTE: considera apenas atributos definidos em 'linhas' da tabela. Ignora atributos
 definidos em 'colunas' ou 'células'.<BR>
 O tamanho da lista retornada pode diferir do tamanho da tabela caso nem todas as linhas
 possuam o atributo solicitado (a lista retornada não inclui valores nulos).<BR>
 Além disso, se diferentes linhas da tabela apresentam o mesmo conteúdo para este atributo,
 a lista retorna apenas uma ocorrência do mesmo valor."""

    pass


  def hasColunaComTitulo(self, titulo) -> bool:
    """Verifica se existe uma coluna na tabela com o título indicado no parâmetro."""

    pass


  def hasFormatacaoCondicional(self) -> bool:
    """Retorna a indicação de que há alguma configuração de 'formatação condicional' aplicada a esta tabela."""

    pass


  def isEmpty(self) -> bool:
    """Retorna a indicação de que a tabela está vazia (isto é, nenhuma célula
 foi informada)."""

    pass


  def isFormatoValido(self, linha, nomeColuna) -> bool:
    """Verifica se uma determinada célula da tabela está com o formato válido.<BR>
 Esta verificação é feita tomando como base o formato definido para a
 coluna da tabela com o uso do método
 {@link Tabela#setFormato(int, String) setFormato} ou outra função
 similar."""

    pass


  def isFormatoValido(self, linha, coluna) -> bool:
    """Verifica se uma determinada célula da tabela está com o formato válido.<BR>
 Esta verificação é feita tomando como base o formato definido para a
 coluna da tabela com o uso do método
 {@link Tabela#setFormato(int, String) setFormato} ou outra função
 similar."""

    pass


  def juntaTabela(self, colunaChaveDestaTabela, outraTabela, colunaChaveOutraTabela) -> None:
    """Junta os dados de outra tabela com esta tabela.<BR>
 As colunas da outra tabela se tornarão novas colunas da tabela atual.<BR>
 Para juntar as duas tabelas entre si, considera-se o valor de uma coluna desta tabela e procura-se pelo mesmo valor em uma coluna da outra tabela.<BR>
 Se encontrar mais de uma ocorrência do mesmo valor na outra tabela, fica com a primeira ocorrência e despreza as demais.<BR>
 OBS: esta rotina requer que todos os dados estejam presentes em memória. Se a outra tabela for muito grande, é possível que cause problema de falta de memória.<BR>
 Esta rotina irá copiar todas as colunas da outra tabela para esta tabela, exceto apenas pela coluna que foi utilizada como chave de pesquisa na outra tabela.<BR>"""

    pass


  def juntaTabela(self, colunaChaveDestaTabela, colunaOndeIncluir, criaColunas, outraTabela, colunaChaveOutraTabela, colunasIncluirOutraTabela) -> None:
    """Junta os dados de outra tabela com esta tabela.<BR>
 As colunas da outra tabela podem se tornar novas colunas da tabela atual ou podem sobrescrever conteúdo de colunas existentes da tabela atual.<BR>
 Há diversos parâmetros para você indicar como esta junção será feita.<BR>
 Para juntar as duas tabelas entre si, considera-se o valor de uma coluna desta tabela e procura-se pelo mesmo valor em uma coluna da outra tabela.<BR>
 Se encontrar mais de uma ocorrência do mesmo valor na outra tabela, fica com a primeira ocorrência e despreza as demais.<BR>
 OBS: esta rotina requer que todos os dados estejam presentes em memória. Se a outra tabela for muito grande, é possível que cause problema de falta de memória."""

    pass


  def juntaTabela(self, colunaChaveDestaTabela, outraTabela, colunaChaveOutraTabela) -> None:
    """Junta os dados de outra tabela com esta tabela.<BR>
 As colunas da outra tabela se tornarão novas colunas da tabela atual.<BR>
 Para juntar as duas tabelas entre si, considera-se o valor de uma coluna desta tabela e procura-se pelo mesmo valor em uma coluna da outra tabela.<BR>
 Se encontrar mais de uma ocorrência do mesmo valor na outra tabela, fica com a primeira ocorrência e despreza as demais.<BR>
 OBS: esta rotina requer que todos os dados estejam presentes em memória. Se a outra tabela for muito grande, é possível que cause problema de falta de memória.<BR>
 Esta rotina irá copiar todas as colunas da outra tabela para esta tabela, exceto apenas pela coluna que foi utilizada como chave de pesquisa na outra tabela.<BR>"""

    pass


  def moveLinhas(self, primeiraLinha, ultimaLinha, posicoes) -> None:
    """Move um conjunto de linhas da tabela algumas posições para frente ou para trás. Os 'espaços deixados para trás' são ocupados
 pelas linhas posteriores ou anteriores.<BR>
 Por exemplo, se a tabela possui em linhas diferentes os números "1", "2", "3" e "4" e se a segunda e terceira linhas são 'movidas'
 uma posição para frente (isto é, para 'baixo' na tabela), então a tabela passa a listar linhas com conteúdos "1", "4", "2" e "3".<BR>
 Se as linhas forem movidas para uma posição anterior à primeira, mantém na primeira linha. Se forem movidas para uma posição posterior
 à última, mantém na última linha. Para mover uma única linha, informe o mesmo número nos parâmetros 'primeiraLinha' e 'ultimaLinha'"""

    pass


  def normalizaColuna(self, coluna) -> None:
    """Normaliza uma coluna da tabela. Isto é, deixa-a com média 0 e variância unitária. Apenas aplicável a coluna com formato numérico ou decimal."""

    pass


  def normalizaColunas(self, colunaInicial, colunaFinal) -> None:
    """Normaliza colunas da tabela. Isto é, deixa-as com média 0 e variância unitária. Apenas aplicável a colunas com formato numérico ou decimal."""

    pass


  def ofuscaColuna(self, coluna, metodo) -> None:
    """Aplica um método de 'ofuscamento' sobre o conteúdo de uma coluna da tabela. O método de 'ofuscamento' tem o objetivo de substituir
 o conteúdo existente por outro que seja diferente, de tal modo a esconder o conteúdo original.<BR>
 Não se trata de um processo completamente aleatório. Se o conteúdo original é o mesmo entre células diferentes, o conteúdo gerado também
 é o mesmo para essas células. Porém, se há alguma diferença no conteúdo, ainda que seja uma pequena diferença, o resultado pode ficar bastante diferente.<BR>
 Não há como fazer o processo 'inverso' (isto é, dado o resultado 'ofuscado', obter o conteúdo original).<BR>
 Há uma certa 'consistência' entre os diferentes métodos. Por exemplo, se uma coluna indica CNPJ de 8 digitos igual a 11111111 e outra coluna indica CNPJ
 de 14 dígitos igual a 11111111000191 (isto é, os 8 primeiros dígitos em cada caso são os mesmos), ao aplicar 'ofuscamento' pelo método 'CNPJ8' na primeira coluna
 e 'ofuscamento' pelo método 'CNPJ14' na segunda coluna, os resultados serão gerados de forma arbitrária, porém os 8 primeiros dígitos dos novos códigos gerados
 serão os mesmos quando comparados um com outro (isto é, como se referissem à mesma 'empresa', embora com números diferentes dos originais).<BR>
 O método de ofuscamento informado no segundo parâmetro deve ser um dos seguintes:<BR>
 CNPJ8 -> gera novos códigos CNPJ de 8 dígitos<BR>
 CNPJ14 -> gera novos códigos CNPJ de 14 dígitos, onde os dígitos verificadores são válidos<BR>
 CPF -> gera novos códigos CPF de 11 dígitos, onde os dígitos verificadores são válidos<BR>
 CEI -> gera novos códigos CEI, onde os dígitos verificadores são válidos<BR>
 DATA -> gera novas datas<BR>
 MES -> gera novos meses+anos<BR>
 CODIGO -> gera novos códigos contendo apenas dígitos, com o mesmo tamanho que o código original<BR>
 TEXTO -> gera novos textos, preservando palavras comuns e substituindo palavras incomuns com XXXXX<BR>
 NOME_PESSOA -> gera novos nomes de pessoas<BR>
 RAZAO_SOCIAL -> gera novos nomes de empresas<BR>
 Para mais informações sobre o método de ofuscamento, consulte documentação em {@link Ofuscador Ofuscador}.<BR>"""

    pass


  def ordenaTabela(self, coluna, crescente) -> None:
    """Altera a ordem das linhas da tabela com base no conteúdo de uma
 determinada coluna.<BR>
 Caso os valores da coluna sejam numéricos, utiliza a comparação numérica
 (crescente ou decrescente).<BR>
 Caso os valores da coluna sejam textos, utiliza a comparação alfanumérica
 (crescente ou decrescente).<BR>
 Caso os valores da coluna sejam datas ou meses, utiliza a comparação
 cronológica (crescente ou decrescente).<BR>
 Os valores nulos são sempre colocados no final da relação (crescente ou
 decrescente).<BR>
 Caso seja desejável utilizar mais de um critério de ordenação (mais de
 uma coluna), execute esta função sucessivas vezes, uma vez para cada
 coluna. Em caso de "empate" em uma ordenação, persiste a ordem anterior."""

    pass


  def ordenaTabela(self, cols) -> None:
    """Ordena uma tabela segundo uma chave de ordenação. A classificação
 considera a ordem em que cada coluna aparece na chave de ordenação.<br>"""

    pass


  def ordenaTabela(self, nomeColuna, crescente) -> None:
    """Altera a ordem das linhas da tabela com base no conteúdo de uma
 determinada coluna.<BR>
 Caso os valores da coluna sejam numéricos, utiliza a comparação numérica
 (crescente ou decrescente).<BR>
 Caso os valores da coluna sejam textos, utiliza a comparação alfanumérica
 (crescente ou decrescente).<BR>
 Caso os valores da coluna sejam datas ou meses, utiliza a comparação
 cronológica (crescente ou decrescente).<BR>
 Os valores nulos são sempre colocados no final da relação (crescente ou
 decrescente).<BR>
 Caso seja desejável utilizar mais de um critério de ordenação (mais de
 uma coluna), execute esta função sucessivas vezes, uma vez para cada
 coluna. Em caso de "empate" em uma ordenação, persiste a ordem anterior."""

    pass


  def ordenaTabelaNoIntervalo(self, coluna, crescente, primeiraLinha, ultimaLinha) -> None:
    """Muda a ordem das linhas considerando apenas uma parte da tabela. As demais linhas da tabela não compreendidas no intervalo
 são mantidas inalteradas."""

    pass


  def paraMatriz(self, colunasValores, colunaRotulosLinhas) -> Matriz:
    """Converte a tabela atual em um objeto do tipo {@link Matriz Matriz}. As linhas da matriz
 criada são as linhas da tabela atual.<BR>
 O parâmetro 'colunasValores' deve indicar os índices de colunas desta tabela que devem ser escritas na matriz. As demais
 colunas são ignoradas (exceto a coluna indicada no parâmetro 'colunaRotulosLinhas', que é utilizada para rotular as diferentes
 linhas).<BR>
 O parâmetro 'colunaRotulosLinhas', quando maior ou igual a zero, pode ser utilizado para indicar o índice
 da coluna (começando em 0) que deve conter textos para serem utilizados como 'rótulos de linhas' na matriz resultante."""

    pass


  def paraMatriz(self) -> Matriz:
    """Converte a tabela atual em um objeto do tipo {@link Matriz Matriz}. As linhas da matriz
 criada são as linhas da tabela atual. A matriz é criada com a mesma quantidade de colunas
 que a tabela atual, no entanto são aproveitados somente os valores do tipo numérico. Valores
 que não são numéricos (ex: textos, datas, códigos CNPJ, etc.) são convertidos para zero na
 matriz resultante."""

    pass


  def paraMatriz(self, ignoraColunasNaoNumericas, colunaRotulosLinhas) -> Matriz:
    """Converte a tabela atual em um objeto do tipo {@link Matriz Matriz}. As linhas da matriz
 criada são as linhas da tabela atual.<BR>
 Se o parâmetro 'ignoraColunasNaoNumericas' é 'falso', a matriz é criada com a mesma quantidade de colunas
 que a tabela atual, no entanto são aproveitados somente os valores do tipo numérico. Valores
 que não são numéricos (ex: textos, datas, códigos CNPJ, etc.) são convertidos para zero na
 matriz resultante.<BR>
 Se o parâmetro 'ignoraColunasNaoNumericas' é 'verdadeiro', a matriz criada pode conter menos colunas, pois
 as colunas contendo valores que não são numéricos (ex: textos, datas, CNPJ, etc.) simplesmente são omitidas (isto é,
 não são incluídas com valores zeros).<BR>
 O parâmetro 'colunaRotulosLinhas', quando maior ou igual a zero, pode ser utilizado para indicar o índice
 da coluna (começando em 0) que deve conter textos para serem utilizados como 'rótulos de linhas' na matriz resultante."""

    pass


  def paraMatriz(self, ignoraColunasNaoNumericas) -> Matriz:
    """Converte a tabela atual em um objeto do tipo {@link Matriz Matriz}. As linhas da matriz
 criada são as linhas da tabela atual.<BR>
 Se o parâmetro 'ignoraColunasNaoNumericas' é 'falso', a matriz é criada com a mesma quantidade de colunas
 que a tabela atual, no entanto são aproveitados somente os valores do tipo numérico. Valores
 que não são numéricos (ex: textos, datas, códigos CNPJ, etc.) são convertidos para zero na
 matriz resultante.<BR>
 Se o parâmetro 'ignoraColunasNaoNumericas' é 'verdadeiro', a matriz criada pode conter menos colunas, pois
 as colunas contendo valores que não são numéricos (ex: textos, datas, CNPJ, etc.) simplesmente são omitidas (isto é,
 não são incluídas com valores zeros).<BR>"""

    pass


  def preencheColuna(self, nomeColuna, lista) -> None:
    """Preenche uma coluna da tabela com valores de uma lista. Este método é diferente de {@link Tabela#addColuna(int, List) addColuna} porque,
 caso exista a coluna indicada, ela é sobrescrita com os novos valores (isto é, ela não é 'arrastada' para a direita).<BR>
 Caso a coluna existente na tabela possua mais linhas do que elementos existentes na lista, os elementos excedentes existentes na tabela
 são preservados.<BR>"""

    pass


  def preencheColuna(self, coluna, lista) -> None:
    """Preenche uma coluna da tabela com valores de uma lista. Este método é diferente de {@link Tabela#addColuna(int, List) addColuna} porque,
 caso exista a coluna indicada, ela é sobrescrita com os novos valores (isto é, ela não é 'arrastada' para a direita).<BR>
 Caso a coluna existente na tabela possua mais linhas do que elementos existentes na lista, os elementos excedentes existentes na tabela
 são preservados.<BR>"""

    pass


  def println(self) -> None:
    """Escreve o conteúdo da tabela no LOG.<BR>
 Útil para fazer depuração."""

    pass


  def procuraCelula(self, expressao) -> str:
    """Utiliza expressão regular para procurar uma determinada célula da tabela, percorrendo
 todas as suas linhas e colunas. Retorna a primeira ocorrência que encontrar.<BR>
 A tabela é percorrida linha após linha, começando da primeira e terminando da última. Em cada
 linha percorrem-se todas as colunas, começando da primeira e terminando na última coluna.<BR>"""

    pass


  def procuraCelulas(self, expressao) -> Lista:
    """Utiliza expressão regular para procurar uma ou mais células da tabela, percorrendo
 todas as suas linhas e colunas. Retorna todas as ocorrências que encontrar.<BR>
 A tabela é percorrida linha após linha, começando da primeira e terminando da última. Em cada
 linha percorrem-se todas as colunas, começando da primeira e terminando na última coluna.<BR>"""

    pass


  def procuraColuna(self, linha, valor) -> int:
    """Procura uma coluna em uma determinada linha que tenha um determinado
 valor.<BR>
 OBS: não diferencia maiúsculas de minúsculas e nem caracteres de
 acentuação."""

    pass


  def procuraLinha(self, coluna1, valor1, coluna2, valor2) -> int:
    """Procura uma linha passando dois critérios que serão pesquisados em duas colunas distintas. Ambos
 critérios precisam ser satisfeitos.<BR>
 OBS: não diferencia maiúsculas de minúsculas e nem caracteres de
 acentuação."""

    pass


  def procuraLinha(self, nomeColuna1, valor1, nomeColuna2, valor2) -> int:
    """Procura uma linha passando dois critérios que serão pesquisados em duas colunas distintas. Ambos
 critérios precisam ser satisfeitos.<BR>
 OBS: não diferencia maiúsculas de minúsculas e nem caracteres de
 acentuação."""

    pass


  def procuraLinha(self, coluna, valor) -> int:
    """Procura uma linha em uma determinada coluna que tenha um determinado
 valor.<BR>
 OBS: não diferencia maiúsculas de minúsculas e nem caracteres de
 acentuação."""

    pass


  def procuraLinha(self, nomeColuna, valor) -> int:
    """Procura uma linha em uma determinada coluna que tenha um determinado
 valor.<BR>
 OBS: não diferencia maiúsculas de minúsculas e nem caracteres de
 acentuação."""

    pass


  def procuraLinhaComFormula(self, formula, primeira_linha_procurar, ultima_linha_procurar) -> int:
    """Função alternativa onde é possível indicar um parâmetro adicional informando o número da linha a partir da qual deseja
 realizar a pesquisa e o número da linha até onde deseja realizar a pesquisa. Isto é, as linhas anteriores ou posteriores 
 presentes na tabela são ignoradas."""

    pass


  def procuraLinhaComFormula(self, formula) -> int:
    """Procura uma linha da tabela passando como critério uma fórmula cujo resultado deve ser VERDADEIRO para a linha desejada, e FALSO
 para as demais.<BR>
 A fórmula deve seguir o padrão do ContÁgil (isto é, a mesma sintaxe utilizada em MAD e em outros lugares) e deve fazer referência
 a qualquer uma das colunas da tabela. Pode-se também considerar na mesma fórmula mais de uma coluna da tabela."""

    pass


  def procuraLinhaComFormula(self, formula, primeira_linha_procurar) -> int:
    """Função alternativa onde é possível indicar um parâmetro adicional informando o número da linha a partir da qual deseja
 realizar a pesquisa. Isto é, as linhas anteriores presentes na tabela são ignoradas."""

    pass


  def procuraLinhaTabelaPreOrdenada(self, coluna, valor, criterio) -> int:
    """Supondo que a tabela foi previamente ordenada conforme uma coluna de interesse,
 procura uma linha cujo valor nesta mesma coluna tenha valor igual
 ao valor informado, ou o mais próximo a ele, dependendo do critério informado
 no terceiro parâmetro. Esta função tem desempenho melhor do que as funções alternativas
 que não presumem pre-ordenação da tabela.<BR>
 Se aplica a valores numéricos ou textos ou datas ou meses.<BR>
 OBS: não diferencia maiúsculas de minúsculas e nem caracteres de
 acentuação.<BR>
 ATENÇÃO: caso a tabela não tenha sido previamente ordenada conforme a coluna
 de interesse, o resultado será arbitrário.<BR>"""

    pass


  def procuraLinhaTabelaPreOrdenada(self, coluna, valor) -> int:
    """Supondo que a tabela foi previamente ordenada conforme uma coluna de interesse,
 procura uma linha cujo valor nesta mesma coluna tenha valor igual
 ao valor informado. Esta função tem desempenho melhor do que as funções alternativas
 que não presumem pre-ordenação da tabela.<BR>
 Se aplica a valores numéricos ou textos ou datas ou meses.<BR>
 OBS: não diferencia maiúsculas de minúsculas e nem caracteres de
 acentuação.<BR>
 ATENÇÃO: caso a tabela não tenha sido previamente ordenada conforme a coluna
 de interesse, o resultado será arbitrário.<BR>"""

    pass


  def procuraLinhaTabelaPreOrdenada(self, nomeColuna, valor, criterio) -> int:
    """Supondo que a tabela foi previamente ordenada conforme uma coluna de interesse,
 procura uma linha cujo valor nesta mesma coluna tenha valor igual
 ao valor informado, ou o mais próximo a ele, dependendo do critério informado
 no terceiro parâmetro. Esta função tem desempenho melhor do que as funções alternativas
 que não presumem pre-ordenação da tabela.<BR>
 Se aplica a valores numéricos ou textos ou datas ou meses.<BR>
 OBS: não diferencia maiúsculas de minúsculas e nem caracteres de
 acentuação.<BR>
 ATENÇÃO: caso a tabela não tenha sido previamente ordenada conforme a coluna
 de interesse, o resultado será arbitrário.<BR>"""

    pass


  def procuraLinhaTabelaPreOrdenada(self, nomeColuna, valor) -> int:
    """Supondo que a tabela foi previamente ordenada conforme uma coluna de interesse,
 procura uma linha cujo valor nesta mesma coluna tenha valor igual
 ao valor informado. Esta função tem desempenho melhor do que as funções alternativas
 que não presumem pre-ordenação da tabela.<BR>
 Se aplica a valores numéricos ou textos ou datas ou meses.<BR>
 OBS: não diferencia maiúsculas de minúsculas e nem caracteres de
 acentuação.<BR>
 ATENÇÃO: caso a tabela não tenha sido previamente ordenada conforme a coluna
 de interesse, o resultado será arbitrário.<BR>"""

    pass


  def removeColuna(self, coluna) -> bool:
    """Remove uma determinada coluna da tabela"""

    pass


  def removeColuna(self, nomeColuna) -> bool:
    """Remove uma determinada coluna da tabela"""

    pass


  def removeColunas(self, colunaInicial, colunaFinal) -> bool:
    """Remove uma ou mais colunas dentro de um intervalo de colunas."""

    pass


  def removeColunas(self, colunas) -> bool:
    """Remove uma ou mais colunas especificadas pelo vetor de números de colunas."""

    pass


  def removeColunasVazias(self) -> int:
    """Remove todas as colunas 'vazias' que existirem na tabela.<BR>
 Uma coluna é considerada 'vazia' se ela não possuir valor algum.<BR>
 Também é considerada 'vazia' se suas células contém apenas 'espaços em branco'.<BR>
 Atenção: o conteúdo '0' (zero), quando presente em uma coluna, não qualifica a coluna como sendo uma 'coluna vazia'."""

    pass


  def removeLinha(self, linha) -> bool:
    """Remove uma linha da tabela, remanejando as linhas posteriores a esta uma
 posição para cima."""

    pass


  def removeLinhas(self, linhas) -> bool:
    """Remove uma ou mais linhas especificadas pelo vetor de números de linhas."""

    pass


  def removeLinhas(self, linhaInicial, linhaFinal) -> bool:
    """Remove uma ou mais linhas dentro de um intervalo de linhas."""

    pass


  def removeLinhasComFormula(self, formula) -> bool:
    """Percorre todas as linhas da tabela calculando uma fórmula que deve indicar VERDADEIRO ou FALSO e removendo todas aquelas
 linhas para as quais a fórmula indica o resultado VERDADEIRO."""

    pass


  def removeLinhasDuplicadas(self) -> int:
    """Remove todas as linhas com conteúdos 'duplicados' na tabela.<BR>
 Uma linha é considerada 'duplicada' caso todas as suas colunas possuam exatamente
 o mesmo conteúdo que outra linha da tabela.<BR>
 Nesta comparação, os conteúdos do tipo 'texto' desprezam diferenças de maiúsculas/minúsculas ou acentuação.<BR>"""

    pass


  def removeLinhasDuplicadas(self, nomesColunas) -> int:
    """Remove todas as linhas com conteúdos 'duplicados' na tabela.<BR>
 Uma linha é considerada 'duplicada' caso as colunas indicadas no parâmetro possuam exatamente
 o mesmo conteúdo que outra linha da tabela.<BR>
 Nesta comparação, os conteúdos do tipo 'texto' desprezam diferenças de maiúsculas/minúsculas ou acentuação.<BR>"""

    pass


  def removeLinhasDuplicadas(self, colunas) -> int:
    """Remove todas as linhas com conteúdos 'duplicados' na tabela.<BR>
 Uma linha é considerada 'duplicada' caso as colunas indicadas no parâmetro possuam exatamente
 o mesmo conteúdo que outra linha da tabela.<BR>
 Nesta comparação, os conteúdos do tipo 'texto' desprezam diferenças de maiúsculas/minúsculas ou acentuação.<BR>"""

    pass


  def removeLinhasVazias(self) -> int:
    """Remove todas as linhas 'vazias' que existirem na tabela.<BR>
 Uma linha é considerada 'vazia' se ela não possuir valor algum.<BR>
 Também é considerada 'vazia' se suas células contém apenas 'espaços em branco'.<BR>
 Atenção: o conteúdo '0' (zero), quando presente em uma linha, não qualifica a linha como sendo uma 'linha vazia'."""

    pass


  def removeRetornaLinhasDuplicadas(self, colunas) -> Tabela:
    """Remove desta tabela todas as linhas com conteúdos 'duplicados' e retorna essas linhas removidas como uma nova tabela.<BR>
 Uma linha é considerada 'duplicada' caso as colunas indicadas no parâmetro possuam exatamente
 o mesmo conteúdo que outra linha da tabela.<BR>
 Nesta comparação, os conteúdos do tipo 'texto' desprezam diferenças de maiúsculas/minúsculas ou acentuação.<BR>"""

    pass


  def removeRetornaLinhasDuplicadas(self) -> Tabela:
    """Remove desta tabela todas as linhas com conteúdos 'duplicados' e retorna essas linhas removidas como uma nova tabela.<BR>
 Uma linha é considerada 'duplicada' caso todas as suas colunas possuam exatamente
 o mesmo conteúdo que outra linha da tabela.<BR>
 Nesta comparação, os conteúdos do tipo 'texto' desprezam diferenças de maiúsculas/minúsculas ou acentuação.<BR>"""

    pass


  def removeRetornaLinhasDuplicadas(self, nomesColunas) -> Tabela:
    """Remove desta tabela todas as linhas com conteúdos 'duplicados' e retorna essas linhas removidas como uma nova tabela.<BR>
 Uma linha é considerada 'duplicada' caso as colunas indicadas no parâmetro possuam exatamente
 o mesmo conteúdo que outra linha da tabela.<BR>
 Nesta comparação, os conteúdos do tipo 'texto' desprezam diferenças de maiúsculas/minúsculas ou acentuação.<BR>"""

    pass


  def removeValoresInfinitos(self) -> bool:
    """Se a tabela possui alguma célula contendo um valor numérico que represente 'infinito' (geralmente
 resultado de alguma divisão por zero), esta função pode ser utilizada para remover esses valores (isto é,
 deixar as células correspondentes em branco)."""

    pass


  def separaDadosPorClasse(self, coluna) -> Tabela:
    """Dada uma coluna da tabela contendo valores numéricos, cria uma nova
 tabela onde esses valores estão separados por "classes".<BR>
 A quantidade de classes (número de linhas da tabela resultante) é obtida
 com uma fórmula empírica sobre a quantidade de valores da tabela ("n"):
 raiz quadrada de n, se n está entre 0 e 100, ou a fórmula de Sturges (1 +
 3,3 * log(n)), se n é superior a 100.<BR>
 A tabela resultante apresenta quatro colunas assim dispostas:<BR>
 1ª coluna: nome de identificação da classe (ex: "100 - 300")<BR>
 2ª coluna: quantidade de elementos dentro da classe<BR>
 3ª coluna: número percentual de freqüência relativa da classe<BR>
 4ª coluna: número percentual de freqüência acumulada<BR>
 <BR>
 As amplitudes de cada classe são fixas e iguais."""

    pass


  def separaDadosPorClasse(self, coluna, k) -> Tabela:
    """Dada uma coluna da tabela contendo valores numéricos, cria uma nova
 tabela onde esses valores estão separados por "classes".<BR>
 A quantidade de classes (número de linhas da tabela resultante) é
 informada no parâmetro adicional.<BR>
 A tabela resultante apresenta quatro colunas assim dispostas:<BR>
 1ª coluna: nome de identificação da classe (ex: "100 - 300")<BR>
 2ª coluna: quantidade de elementos dentro da classe<BR>
 3ª coluna: número percentual de freqüência relativa da classe<BR>
 4ª coluna: número percentual de freqüência acumulada<BR>
 <BR>
 As amplitudes de cada classe são fixas e iguais."""

    pass


  def separaDadosSubTabelas(self, coluna) -> Tabela:
    """Obtém uma ou mais tabelas (sub-tabelas) a partir da tabela atual.<BR>
 O critério de divisão em sub-tabelas é definido pelo conteúdo da coluna
 indicada no parâmetro.<BR>
 São conservadas na mesma tabela os dados que apresentam o mesmo valor
 na coluna indicada como parâmetro.<BR>
 Por exemplo, digamos que uma tabela contém duas colunas: MUNICIPIO e VALOR.<BR>
 Digamos que nesta tabela temos 30 linhas, sendo 10 linhas com o conteúdo "CURITIBA"
 na coluna MUNICIPIO, 10 linhas com o conteúdo "RECIFE" e 10 linhas com o conteúdo
 "RIO DE JANEIRO". Ao utilizar este método, passando como parâmetro o número da coluna
 referente a MUNICIPIO, resulta em três tabelas: uma contendo as 10 linhas de CURITIBA,
 10 linhas de RECIFE e 10 linhas de RIO DE JANEIRO.<BR>
 OBS: caso algumas linhas apresentem conteúdo NULO na coluna indicada como parâmetro,
 elas são inseridas em uma tabela contendo apenas linhas nesta condição.<BR>
 Esta operação não afeta a tabela atual. As novas tabelas são criadas sem alterar a
 tabela atual.<BR>
 OBS: é feita distinção de maiúsculas/minúsculas."""

    pass


  def setAlinhamentoColuna(self, nomeColuna, alinhamento) -> None:
    """Define o alinhamento horizontal que o conteúdo da coluna deve ter ao ser apresentada em uma janela. Este método tem o mesmo
 efeito que executar o método {@link Tabela#setAtributoColuna(int, String, Object) setAtributoColuna} indicando
 o nome de atributo "ALINHAMENTO".<BR>
 Note que esta mudança apenas afeta a tabela atual. Nâo é propagada para a 'tabela do usuário' caso seja 'exportada'."""

    pass


  def setAlinhamentoColuna(self, coluna, alinhamento) -> None:
    """Define o alinhamento horizontal que o conteúdo da coluna deve ter ao ser apresentada em uma janela. Este método tem o mesmo
 efeito que executar o método {@link Tabela#setAtributoColuna(int, String, Object) setAtributoColuna} indicando
 o nome de atributo "ALINHAMENTO".<BR>
 Note que esta mudança apenas afeta a tabela atual. Nâo é propagada para a 'tabela do usuário' caso seja 'exportada'."""

    pass


  def setAlinhamentoVerticalColuna(self, nomeColuna, alinhamento) -> None:
    """Define o alinhamento vertical que o conteúdo da coluna deve ter ao ser apresentada em uma janela. Este método tem o mesmo
 efeito que executar o método {@link Tabela#setAtributoColuna(int, String, Object) setAtributoColuna} indicando
 o nome de atributo "ALINHAMENTO VERTICAL".<BR>
 Note que esta mudança apenas afeta a tabela atual. Nâo é propagada para a 'tabela do usuário' caso seja 'exportada'."""

    pass


  def setAlinhamentoVerticalColuna(self, coluna, alinhamento) -> None:
    """Define o alinhamento vertical que o conteúdo da coluna deve ter ao ser apresentada em uma janela. Este método tem o mesmo
 efeito que executar o método {@link Tabela#setAtributoColuna(int, String, Object) setAtributoColuna} indicando
 o nome de atributo "ALINHAMENTO VERTICAL".<BR>
 Note que esta mudança apenas afeta a tabela atual. Nâo é propagada para a 'tabela do usuário' caso seja 'exportada'."""

    pass


  def setAlturaLinhas(self, altura) -> None:
    """Define a altura mínima para exibição das linhas desta tabela."""

    pass


  def setAtributo(self, linha, coluna, nome, valor) -> None:
    """Informa um determinado "atributo" associado a uma célula individual da
 tabela.<BR>
 Um "atributo" pode ser qualquer coisa definida pelo "script". Ele não tem
 significado especial para o ContÁgil, a não ser em situações específicas
 (ex: uma {@link WebTabela WebTabela} define um atributo "LINK" para
 células contendo hyperlinks).<BR>
 Trata-se de um recurso conveniente para armazenar temporariamente em cada
 célula algum conteúdo que possa ter um significado especial para outras
 partes do script.<BR>
 OBS: os "atributos" assim definidos possuem um caráter temporário. Quando
 os dados da tabela são colocados em outro lugar através de alguma função
 de exportação, os atributos não são copiados (isto é, eles são
 ignorados)."""

    pass


  def setAtributo(self, linha, nome, valor) -> None:
    """Informa um determinado "atributo" associado a uma linha da tabela.<BR>
 Esta função difere da função
 {@link Tabela#setAtributo(int, int, String, Object) setAtributo}, pois
 nesta função define-se um atributo para a linha inteira, e não para uma
 célula da linha.<BR>
 Um "atributo" pode ser qualquer coisa definida pelo "script". Ele não tem
 significado especial para o ContÁgil, a não ser em situações específicas.<BR>
 Trata-se de um recurso conveniente para armazenar temporariamente em cada
 linha algum conteúdo que possa ter um significado especial para outras
 partes do script.<BR>
 OBS: os "atributos" assim definidos possuem um caráter temporário. Quando
 os dados da tabela são colocados em outro lugar através de alguma função
 de exportação, os atributos não são copiados (isto é, eles são
 ignorados)."""

    pass


  def setAtributoColuna(self, nomeColuna, nome, valor) -> None:
    """Informa um determinado "atributo" associado a uma coluna da tabela.<BR>
 Esta função difere da função
 {@link Tabela#setAtributo(int, int, String, Object) setAtributo}, pois
 nesta função define-se um atributo para a coluna inteira, e não para uma
 célula da coluna.<BR>
 Um "atributo" pode ser qualquer coisa definida pelo "script". Ele não tem
 significado especial para o ContÁgil, a não ser em situações específicas.<BR>
 Trata-se de um recurso conveniente para armazenar temporariamente em cada
 coluna algum conteúdo que possa ter um significado especial para outras
 partes do script.<BR>
 OBS: os "atributos" assim definidos possuem um caráter temporário. Quando
 os dados da tabela são colocados em outro lugar através de alguma função
 de exportação, os atributos não são copiados (isto é, eles são
 ignorados)."""

    pass


  def setAtributoColuna(self, coluna, nome, valor) -> None:
    """Informa um determinado "atributo" associado a uma coluna da tabela.<BR>
 Esta função difere da função
 {@link Tabela#setAtributo(int, int, String, Object) setAtributo}, pois
 nesta função define-se um atributo para a coluna inteira, e não para uma
 célula da coluna.<BR>
 Um "atributo" pode ser qualquer coisa definida pelo "script". Ele não tem
 significado especial para o ContÁgil, a não ser em situações específicas.<BR>
 Trata-se de um recurso conveniente para armazenar temporariamente em cada
 coluna algum conteúdo que possa ter um significado especial para outras
 partes do script.<BR>
 OBS: os "atributos" assim definidos possuem um caráter temporário. Quando
 os dados da tabela são colocados em outro lugar através de alguma função
 de exportação, os atributos não são copiados (isto é, eles são
 ignorados)."""

    pass


  def setAtributoTabela(self, nome, valor) -> None:
    """Informa um determinado "atributo" associado à tabela de forma geral.<BR>
 Esta função difere da função
 {@link Tabela#setAtributo(int, int, String, Object) setAtributo}, pois
 nesta função define-se um atributo para a tabela inteira, e não para uma
 célula da coluna ou para uma coluna específica.<BR>
 Um "atributo" pode ser qualquer coisa definida pelo "script". Ele não tem
 significado especial para o ContÁgil, a não ser em situações específicas.<BR>
 Trata-se de um recurso conveniente para armazenar temporariamente em uma
 tabela algum conteúdo que possa ter um significado especial para outras
 partes do script.<BR>
 OBS: os "atributos" assim definidos possuem um caráter temporário. Quando
 os dados da tabela são colocados em outro lugar através de alguma função
 de exportação, os atributos não são copiados (isto é, eles são
 ignorados)."""

    pass


  def setBotoes(self, coluna, nomeBotao, subrotina) -> None:
    """Define se esta coluna deve ser exibida na forma de 'botões'. Cada célula desta coluna passa a apresentar um botão cujo nome é o mesmo em todas as células. Ao clicar
 sobre o botão, a subrotina indicada neste método é executada, passando como parâmetro o conteúdo da célula onde havia o botão que foi clicado. Se a célula estiver vazia,
 é passado como parâmetro para a subrotina um objeto do tipo 'TabelaDetalhe' com informações sobre a linha da tabela que foi clicada.<BR>
 Se a célula possuir o conteúdo literal '&lt;N/D&gt;', o botão estará indisponível.
 Este método tem o mesmo efeito que executar o método {@link Tabela#setAtributoColuna(int, String, Object) setAtributoColuna} 
 indicando o nome de atributo "BOTAO".<BR>"""

    pass


  def setBotoes(self, nomeColuna, nomeBotao, subrotina) -> None:
    """Define se esta coluna deve ser exibida na forma de 'botões'. Cada célula desta coluna passa a apresentar um botão cujo nome é o mesmo em todas as células. Ao clicar
 sobre o botão, a subrotina indicada neste método é executada, passando como parâmetro o conteúdo da célula onde havia o botão que foi clicado. Se a célula estiver vazia,
 é passado como parâmetro para a subrotina um objeto do tipo 'TabelaDetalhe' com informações sobre a linha da tabela que foi clicada.<BR>
 Se a célula possuir o conteúdo literal '&lt;N/D&gt;', o botão estará indisponível.
 Este método tem o mesmo efeito que executar o método {@link Tabela#setAtributoColuna(int, String, Object) setAtributoColuna} 
 indicando o nome de atributo "BOTAO".<BR>"""

    pass


  def setCaminhoMADColuna(self, nomeColuna, alinhamento) -> None:
    """Caso esta tabela seja posteriormente exportada para uma 'tabela do usuário' (via {@link #exportaTabelaUsuario(String) exportaTabelaUsuario} ou suas alternativas)
 e caso a tabela do usuário exportada seja apresentada em um Modelo Analítico Dinâmico, este método permite indicar qual 'caminho' deve ser apresentado no
 'Catálogo de Atributos e Métricas' do MAD para disponibilização do atributo ou métrica representado por esta coluna. Este método tem o mesmo
 efeito que executar o método {@link Tabela#setAtributoColuna(int, String, Object) setAtributoColuna} indicando
 o nome de atributo "CAMINHO".<BR>
 O nome indicado no 'caminho' pode conter diferentes 'partes', devendo cada parte ser separada das demais pelo uso do caractere '|'."""

    pass


  def setCaminhoMADColuna(self, coluna, caminho) -> None:
    """Caso esta tabela seja posteriormente exportada para uma 'tabela do usuário' (via {@link #exportaTabelaUsuario(String) exportaTabelaUsuario} ou suas alternativas)
 e caso a tabela do usuário exportada seja apresentada em um Modelo Analítico Dinâmico, este método permite indicar qual 'caminho' deve ser apresentado no
 'Catálogo de Atributos e Métricas' do MAD para disponibilização do atributo ou métrica representado por esta coluna. Este método tem o mesmo
 efeito que executar o método {@link Tabela#setAtributoColuna(int, String, Object) setAtributoColuna} indicando
 o nome de atributo "CAMINHO".<BR>
 O nome indicado no 'caminho' pode conter diferentes 'partes', devendo cada parte ser separada das demais pelo uso do caractere '|'."""

    pass


  def setCelula(self, linha, coluna, valor) -> None:
    """Insere um valor na tabela, em uma determinada linha e uma determinada
 coluna."""

    pass


  def setCelula(self, linha, nomeColuna, valor) -> None:
    """Insere um valor na tabela, em uma determinada linha e uma determinada
 coluna."""

    pass


  def setCheckboxes(self, coluna, checkboxes) -> None:
    """Define se esta coluna deve ser exibida na forma de 'checkboxes'. É necessário também que o 'formato' da coluna tenha sido definido como 'BOOLEANO' para funcionar corretamente.<BR>
 Este método tem o mesmo efeito que executar o método {@link Tabela#setAtributoColuna(int, String, Object) setAtributoColuna} 
 indicando o nome de atributo "CHECKBOX".<BR>
 OBS: este atributo apenas se aplica a conteúdos do tipo BOOLEANO. Não se aplica a outros formatos de colunas."""

    pass


  def setCheckboxes(self, nomeColuna, checkboxes) -> None:
    """Define se esta coluna deve ser exibida na forma de 'checkboxes'. É necessário também que o 'formato' da coluna tenha sido definido como 'BOOLEANO' para funcionar corretamente.<BR>
 Este método tem o mesmo efeito que executar o método {@link Tabela#setAtributoColuna(int, String, Object) setAtributoColuna} 
 indicando o nome de atributo "CHECKBOX".<BR>
 OBS: este atributo apenas se aplica a conteúdos do tipo BOOLEANO. Não se aplica a outros formatos de colunas."""

    pass


  def setDecimais(self, coluna, qtdeDecimais) -> None:
    """Define o número de decimais que devem ser consideradas na coluna informada no momento da exportação dos dados,
 especialmente para PDF. <br>"""

    pass


  def setEscopoFormatacaoCondicional(self, nomeColuna, opcao) -> None:
    """Caso alguma coluna da tabela já tenha sido configurada anteriormente com alguma opção de 'formatação condicional' (ex: através
 do método {@link Tabela#addFormatacaoCondicionalDesvioPadrao(String, double, double, boolean, String...) addFormatacaoCondicionalDesvioPadrao}),
 este método permite definir o 'escopo' sobre o qual são calculadas as estatísticas para a formatação condicional.<BR>
 O padrão é considerar todos os dados da tabela, inclusive aqueles que podem não estar 'visíveis' na janela em decorrência de algum filtro do usuário. Porém,
 é possível alterar para outra opção de sua escolha.<BR>
 <BR>
 OBS: esta configuração afeta somente a formatação condicional que requer algum 'cálculo estatístico' sobre os dados (ex: 'desvio padrão', 'média', 'quartil', etc.).<BR>
 Não se aplica a outros tipos de formatação condicional que independem dos demais dados da tabela.<BR>
 <BR>
 Esta ação é ignorada (fica sem efeito) caso nenhuma outra ação prévia tenha definido algum critério de formatação condicional sobre a mesma coluna indicada no primeiro parâmetro."""

    pass


  def setFormato(self, coluna, tipo) -> None:
    """Define o formato de apresentação de dados de uma determinada coluna (isto é, se é texto, número, etc.).<BR>
 Na ausência desta identificação, o ContÁgil tenta descobrir automaticamente, com base nos próprios dados, 
 qual é o formato mais aplicável.<BR>
 OBS: se este método for utilizado para definir o formato de uma coluna
 como sendo DECIMAL, todos os valores existentes nesta coluna e todos os
 valores futuramente inserido nesta coluna são automaticamente convertidos
 para decimais (isto é, os textos que representam números são convertidos
 para números).<BR>"""

    pass


  def setFormato(self, coluna, formato) -> None:
    """Define o formato de apresentação de dados de uma determinada coluna (isto
 é, se é texto, número, etc.).<BR>
 Na ausência desta identificação, o ContÁgil tenta descobrir
 automaticamente, com base nos próprios dados, qual é o formato mais
 aplicável.<BR>
 OBS: se este método for utilizado para definir o formato de uma coluna
 como sendo DECIMAL, todos os valores existentes nesta coluna e todos os
 valores futuramente inserido nesta coluna são automaticamente convertidos
 para decimais (isto é, os textos que representam números são convertidos
 para números).<BR>"""

    pass


  def setFormato(self, colunaInicial, colunaFinal, formato) -> None:
    """Define o mesmo formato para um conjunto de colunas."""

    pass


  def setLarguraColuna(self, nomeColuna, largura) -> None:
    """Define a lagura que a coluna deve ter ao ser apresentada em uma janela. Este método tem o mesmo
 efeito que executar o método {@link Tabela#setAtributoColuna(int, String, Object) setAtributoColuna} indicando
 o nome de atributo "LARGURA".<BR>
 Note que esta mudança apenas afeta a tabela atual. Nâo é propagada para a 'tabela do usuário' caso seja 'exportada'."""

    pass


  def setLarguraColuna(self, coluna, largura) -> None:
    """Define a lagura que a coluna deve ter ao ser apresentada em uma janela. Este método tem o mesmo
 efeito que executar o método {@link Tabela#setAtributoColuna(int, String, Object) setAtributoColuna} indicando
 o nome de atributo "LARGURA".<BR>
 Note que esta mudança apenas afeta a tabela atual. Nâo é propagada para a 'tabela do usuário' caso seja 'exportada'."""

    pass


  def setLinhaCabecalho(self, linha) -> None:
    """Altera a tabela de tal modo a considerar uma determinada linha como sendo uma linha
 de definição de títulos de colunas (uma linha de "cabeçalho").<BR>
 Isto é, supondo que a linha que contém os títulos das colunas está dentro da própria
 tabela, esta função tem o objetivo de retirar esta linha da tabela e também alterar
 os títulos de cada coluna de acordo com as informações apresentadas nela.<BR>
 As linhas localizadas dentro da tabela antes da linha de "cabeçalho" são mantidas na
 tabela como estão.<BR>
 Ao executar este método, a quantidade de linhas da tabela é reduzido em um (a linha
 que foi indicada como parâmetro é removida da tabela). Os títulos da tabela são afetados
 também."""

    pass


  def setNome(self, nome) -> None:
    """Define um nome para esta tabela (uso opcional)."""

    pass


  def setOpcoesColuna(self, coluna, opcoes) -> None:
    """Define as opções para apresentação em um campo do tipo selecionável caso esta tabela possa ser editada pelo usuário. 
 Indique um vetor com os nomes das opções passíveis de escolha.<BR>
 Note que esta mudança apenas afeta a tabela atual. Nâo é propagada para a 'tabela do usuário' caso seja 'exportada'."""

    pass


  def setOpcoesColuna(self, nomeColuna, opcoes) -> None:
    """Define as opções para apresentação em um campo do tipo selecionável caso esta tabela possa ser editada pelo usuário. 
 Indique um vetor com os nomes das opções passíveis de escolha.<BR>
 Note que esta mudança apenas afeta a tabela atual. Nâo é propagada para a 'tabela do usuário' caso seja 'exportada'."""

    pass


  def setQuebraAutomaticaLinhas(self, coluna, quebra) -> None:
    """Define se deve haver quebra automática de linhas caso o conteúdo texto de uma célula da coluna indicada na tabela ultrapasse o limite
 da largura da coluna. Este método tem o mesmo efeito que executar o método {@link Tabela#setAtributoColuna(int, String, Object) setAtributoColuna} 
 indicando o nome de atributo "QUEBRA LINHAS".<BR>
 OBS: este atributo apenas se aplica a conteúdos do tipo TEXTO. Não se aplica a outros formatos de colunas."""

    pass


  def setQuebraAutomaticaLinhas(self, nomeColuna, quebra) -> None:
    """Define se deve haver quebra automática de linhas caso o conteúdo texto de uma célula da coluna indicada na tabela ultrapasse o limite
 da largura da coluna. Este método tem o mesmo efeito que executar o método {@link Tabela#setAtributoColuna(int, String, Object) setAtributoColuna} 
 indicando o nome de atributo "QUEBRA LINHAS".<BR>
 OBS: este atributo apenas se aplica a conteúdos do tipo TEXTO. Não se aplica a outros formatos de colunas."""

    pass


  def setTamanhoMaximoColuna(self, coluna, tamanhoMaximo) -> None:
    """Caso esta tabela venha a ser posteriormente armazenada em um banco de dados, indica o tamanho máximo que a coluna deve ter.<BR>
 Esta informação é desprezada caso a tabela não venha a ser armazenada em um banco de dados ou não corresponda ao tipo texto."""

    pass


  def setTamanhoMaximoColuna(self, nomeColuna, tamanhoMaximo) -> None:
    """Caso esta tabela venha a ser posteriormente armazenada em um banco de dados, indica o tamanho máximo que a coluna deve ter.<BR>
 Esta informação é desprezada caso a tabela não venha a ser armazenada em um banco de dados ou não corresponda ao tipo texto."""

    pass


  def setTitulo(self, coluna, titulo) -> None:
    """Ajusta o título de uma determinada coluna.<BR>
 Esta informação é importante para situações em que é desejável exportar o
 conteúdo da tabela para uma outra estrutura que comporte títulos.<BR>"""

    pass


  def setTitulo(self, coluna, titulo, formato) -> None:
    """Equivalente a chamar duas funções:
 {@link Tabela#setTitulo(int, String) setTitulo} e
 {@link Tabela#setFormato(int, String) setFormato}."""

    pass


  def setTitulos(self, titulos) -> None:
    """Ajusta o título de todas as colunas da tabela.<BR>
 Esta informação é importante para situações em que é desejável exportar o
 conteúdo da tabela para uma outra estrutura que comporte títulos.<BR>
 A posição do título dentro do vetor deve ser a mesma da coluna dentro da tabela.<br>"""

    pass


  def setValor(self, linha, coluna, valor) -> None:
    """Faz exatamente a mesma coisa que a função
 {@link Tabela#setCelula(int, int, Object) setCelula}. Trata-se apenas de
 uma conveniência para se utilizar outro nome de função para o mesmo
 procedimento."""

    pass


  def somaFormula(self, formula) -> float:
    """Percorre todas as linhas da tabela calculando uma fórmula. Retorna a somatória de todos os valores calculados."""

    pass


  def somaFormula(self, formula, primeiraLinha, quantidadeLinhas) -> float:
    """Método alternativo onde é possível indicar a primeira linha da tabela onde a fórmula deve ser calculada e também a quantidade total de linhas
 que devem ser calculadas.<BR>
 Veja mais comentários na documentação do método alternativo."""

    pass


  def transformaColunas(self, formula, primeiraColuna, quantidadeColunas) -> None:
    """Transforma as colunas de uma tabela alterando o valor de cada célula pelo resultado da fórmula.<BR>
 Nesta fórmula você deve indicar com o nome 'X' o valor correspondente à célula da tabela, onde quer que ela esteja.<BR>
 Por exemplo, se quiser transformar todos os valores em logaritmos, indique a fórmula LOG(X).<BR>
 Se quiser indicar na fórmula o valor correspondente a uma coluna específica, indique o nome correspondente da coluna.<BR>
 Por exemplo, se quiser transformar todos os valores em logaritmos apenas se o valor da coluna 'TIPO' for igual a 'A', indique
 a fórmula:  SE(TIPO="A"; LOG(X) ; X)<BR>
 DIFERENÇA ENTRE O MÉTODO 'CALCULAR FORMULA' E O MÉTODO 'TRANSFORMAR COLUNAS':<BR>
 O método 'CALCULAR FORMULA' calcula uma fórmula sobre os valores da tabela, mas escreve
 o resultado em uma determinada coluna da tabela (uma mesma coluna para todos os resultados). Além disso, este método
 não admite na fórmula o uso do nome 'X' para se referir ao valor da fórmula, a menos que exista uma coluna com este nome 'X'.<BR>
 O método 'TRANSFORMAR COLUNAS', por sua vez, aplica a fórmula sobre cada célula individual da tabela e escreve seu
 resultado na própria célula. Neste caso, a fórmula pode fazer referência a uma variável de nome 'X', que corresponde ao valor
 da própria célula que está sendo transformada."""

    pass


  def transformaLinhas(self, formula, primeiraLinha, quantidadeLinhas) -> None:
    """Transforma as linhas de uma tabela alterando o valor de cada célula pelo resultado da fórmula.<BR>
 Nesta fórmula você deve indicar com o nome 'X' o valor correspondente à célula da tabela, onde quer que ela esteja.<BR>
 Por exemplo, se quiser transformar todos os valores em logaritmos, indique a fórmula LOG(X).<BR>
 Se quiser indicar na fórmula o valor correspondente a uma coluna específica, indique o nome correspondente da coluna.<BR>
 Por exemplo, se quiser transformar todos os valores em logaritmos apenas se o valor da coluna 'TIPO' for igual a 'A', indique
 a fórmula:  SE(TIPO="A"; LOG(X) ; X)<BR>
 DIFERENÇA ENTRE O MÉTODO 'CALCULAR FORMULA' E O MÉTODO 'TRANSFORMAR LINHAS':<BR>
 O método 'CALCULAR FORMULA' calcula uma fórmula sobre os valores da tabela, mas escreve
 o resultado em uma determinada coluna da tabela (uma mesma coluna para todos os resultados). Além disso, este método
 não admite na fórmula o uso do nome 'X' para se referir ao valor da fórmula, a menos que exista uma coluna com este nome 'X'.<BR>
 O método 'TRANSFORMAR LINHAS', por sua vez, aplica a fórmula sobre cada célula individual da tabela e escreve seu
 resultado na própria célula. Neste caso, a fórmula pode fazer referência a uma variável de nome 'X', que corresponde ao valor
 da própria célula que está sendo transformada."""

    pass


  def transporColuna(self, colunaTranspor) -> None:
    """Faz a "transposição" de coluna. Isto é, os conteúdos distintos que são apresentados nesta coluna 
 (geralmente são textos ou códigos ou anos) passam a ser apresentados como diferentes "colunas" da
 tabela. As demais colunas da tabela que representam "valores numéricos" são repetidas para cada conteúdo
 distinto da coluna transposta. As demais colunas que não representam "valores numéricos" são mantidas como critério de "agregação".<BR>
 Por exemplo, digamos que uma tabela contém 10 linhas e 3 colunas assim dispostas:<BR>
 MÊS   		PF/PJ   VALOR<BR>
 01/2010		PF		1000,00<BR>
 01/2010		PJ		 200,00<BR>
 02/2010		PF		 800,00<BR>
 02/2010		PJ		 300,00<BR>
 03/2010		PF		 900,00<BR>
 04/2010		PJ		 100,00<BR>
 05/2010		PF		 800,00<BR>
 05/2010		PJ		 200,00<BR>
 06/2010		PF		 500,00<BR>
 06/2010		PJ		 500,00<BR>
 <BR>
 Neste exemplo, suponha que terceira coluna foi formatada como "MOEDA".<BR>
 Digamos que decidimos "transpor" a coluna "PF/PJ" (segunda coluna da tabela, ou seja, a de índice "1").<BR>
 Ao indicar a coluna de índice "1" na execução do método "transporColuna", seus conteúdos "distintos" ("PF" e "PJ") são
 utilizados para efeitos de divisão da coluna "VALOR" em dois grupos: "VALOR: PF" e "VALOR: PJ".<BR>
 MÊS		VALOR: PF		VALOR: PJ<BR>
 01/2010	1000,00			200,00<BR>
 02/2010   800,00			300,00<BR>
 03/2010	 900,00			  0,00<BR>
 04/2010	   0,00			100,00<BR>
 05/2010	 800,00			200,00<BR>
 06/2010	 500,00			500,00<BR>
 <BR> 
 Note que se houvesse um terceiro conteúdo na coluna "PF/PJ" que fosse diferente de "PF" e de "PJ", teríamos uma terceira
 coluna de valor para representar esses valores.<BR>
 Se tivéssemos mais uma coluna com formato "MOEDA" ou "DECIMAL" ou "NUMERO", teríamos mais duas colunas na tabela: uma para representar
 esses valores para "PF" e outra para representar esses valores para "PJ".<BR> 
 OBS: se a tabela não apresentar nenhuma coluna com o formato "MOEDA" ou "DECIMAL" ou "NUMERO", computam-se então as quantidades de linhas da
 tabela para cada critério.<BR>
 Para que esta função funcione adequadamente, recomenda-se que os "títulos" e os "formatos" das colunas tenham sido previamente
 ajustados de acordo.<BR>"""

    pass


  def transporColuna(self, colunaTranspor, funcao, consideraDemaisColunasNaoNumericas) -> None:
    """Faz o mesmo que a função de um parâmetro {@link #transporColuna(int) transporColuna}, mas permite indicar no segundo parâmetro
 qual é a função que deve ser utilizada na agregação dos dados, podendo ser qualquer uma dessas funções:<BR>
 ASSIMETRIA (calculado a partir dos momentos de ordem 3, não se tratando do coeficiente de Pearson)<BR>
 CURTOSE (calculado a partir do momento de ordem 4, subtraindo o resultado por 3 para fins de comparação com a curva normal)<BR>
 DESVIO PADRÃO<BR>
 MÁXIMO<BR>
 MÉDIA<BR>
 MEDIANA<BR>
 MÍNIMO<BR>
 SOMA<BR>
 <BR>
 O terceiro parâmetro indica se as demais colunas não numéricas devem ser consideradas (ex: outras colunas do tipo TEXTO). Se for SIM, elas
 são consideradas (isto é, são incluídas como colunas na tabela resultante). Se for NÃO, elas são ignoradas (isto é, considera apenas as colunas
 numéricas e a coluna indicada no parâmetro 'colunaTranspor')."""

    pass


  def transporColuna(self, colunaTranspor, funcao) -> None:
    """Faz o mesmo que a função de um parâmetro {@link #transporColuna(int) transporColuna}, mas permite indicar no segundo parâmetro
 qual é a função que deve ser utilizada na agregação dos dados, podendo ser qualquer uma dessas funções:<BR>
 ASSIMETRIA (calculado a partir dos momentos de ordem 3, não se tratando do coeficiente de Pearson)<BR>
 CURTOSE (calculado a partir do momento de ordem 4, subtraindo o resultado por 3 para fins de comparação com a curva normal)<BR>
 DESVIO PADRÃO<BR>
 MÁXIMO<BR>
 MÉDIA<BR>
 MEDIANA<BR>
 MÍNIMO<BR>
 SOMA<BR>"""

    pass


  def trocaCelulasVazias(self, substituicao) -> None:
    """Percorre todas as linhas e todas as colunas da tabela, trocando todas as ocorrências de
 células com conteúdo 'nulo' (deixados em branco) pelo texto indicado no parâmetro."""

    pass


  def trocaCelulasVazias(self, substituicao, colunaInicial, colunaFinal) -> None:
    """Percorre todas as linhas e todas as colunas da tabela, trocando todas as ocorrências de
 células com conteúdo 'nulo' (deixados em branco) pelo texto indicado no parâmetro. Analisa somente as colunas no intervalo especificado."""

    pass


  def trocaValores(self, valorProcurar, valorSubstituir, colunaInicial, colunaFinal) -> None:
    """Percorre todas as linhas e todas as colunas da tabela, procurando todas as ocorrências
 de um determinado valor, considerando sua representação textual (por exemplo, códigos CNPJ são pesquisados como se fossem textos) e substituindo por outro conteúdo textual.  Analisa somente as colunas no intervalo especificado."""

    pass


  def trocaValores(self, valorProcurar, tolerancia, valorSubstituir, colunaInicial, colunaFinal) -> None:
    """Percorre todas as linhas e todas as colunas da tabela, procurando todas as ocorrências
 de um determinado valor numérico e substituindo por outro valor numérico. Analisa somente as colunas no intervalo especificado."""

    pass


  def trocaValores(self, valorProcurar, tolerancia, valorSubstituir) -> None:
    """Percorre todas as linhas e todas as colunas da tabela, procurando todas as ocorrências
 de um determinado valor numérico e substituindo por outro valor numérico."""

    pass


  def trocaValores(self, valorProcurar, valorSubstituir) -> None:
    """Percorre todas as linhas e todas as colunas da tabela, procurando todas as ocorrências
 de um determinado valor, considerando sua representação textual (por exemplo, códigos CNPJ são pesquisados como se fossem textos) e substituindo por outro conteúdo textual."""

    pass


  def trocaValoresInfinitos(self, substituicao, colunaInicial, colunaFinal) -> None:
    """Percorre todas as linhas e todas as colunas da tabela, trocando todas as ocorrências de
 valores 'infinitos' pelo valor indicado no parâmetro. Analisa somente as colunas no intervalo especificado.
 ATENÇÃO: Esta ação deve ser utilizada apenas em colunas cujo conteúdo seja númerico."""

    pass


  def trocaValoresInfinitos(self, substituicao) -> None:
    """Percorre todas as linhas e todas as colunas da tabela, trocando todas as ocorrências de
 valores 'infinitos' pelo valor indicado no parâmetro.
 ATENÇÃO: Esta ação deve ser utilizada apenas em colunas cujo conteúdo seja númerico."""

    pass


  def trocaValoresNulos(self, substituicao) -> None:
    """Percorre todas as linhas e todas as colunas da tabela, trocando todas as ocorrências de
 valores 'nulos' (deixados em branco) pelo valor numérico indicado no parâmetro.
 ATENÇÃO: Esta ação deve ser utilizada apenas em colunas cujo conteúdo seja númerico."""

    pass


  def trocaValoresNulos(self, substituicao, colunaInicial, colunaFinal) -> None:
    """Percorre todas as linhas e todas as colunas da tabela, trocando todas as ocorrências de
 valores 'nulos' (deixados em branco) pelo valor numérico indicado no parâmetro. 
 Analisa somente as colunas no intervalo especificado.
 ATENÇÃO: Esta ação deve ser utilizada apenas em colunas cujo conteúdo seja númerico."""

    pass


  def trocarLinhasColunas(self, colunaTitulos) -> Tabela:
    """Faz com que os dados ao dispostos ao longo das linhas estejam dispostos ao longo de colunas.<BR>
 A tabela atual não é afetada. O resultado é apresentado em uma nova tabela.<BR>
 A nova tabela não preserva formatações condicionais de colunas e nem os formatos das colunas<BR>"""

    pass

class TabelaCFOP ():
  """Tabela que para um determinado código retorna um ou mais objetos, que são armazenados em uma
 planilha, um para cada linha.
 <P>
 Assim, o acesso padrão é que para cada chave retorne uma lista de objetos chamados regra_NCM que
 atendem a esta chave. Trata-se de um objeto para uso em análise de crédito de PIS e COFINS
 através da caracterização da mercadoria por seu NCM.
 <P>
 Exemplo de utilização desta tabela pela linguagem de script:<BR>
 <CODE> // Adquire acesso à tabela de regras de PIS e Cofins<BR>
 tab = tabelas.getTabelaNCMPisCofins();<BR>
 <BR> // Obtém a lista de regras para uma determinada rubrica <BR>
 listaRegras = tab.para("02012020");<BR>
 
 for each (regra_NCM in listaRegras.toArray()) { println ("Método getNCM():
 "+regra_NCM.getNCM()); } </CODE>"""

  def getTabela(self) -> Tabela:
    """Retorna o conteúdo completo desta tabela na forma de um objeto do tipo {@link Tabela Tabela}.
 <BR>
 Isto é, todas as informações são apresentadas em linhas e colunas.<BR>
 OBS: para realizar pesquisas de descrições com base em códigos, é preferível não converter em
 tabela, mas sim utilizar o objeto atual, pois assim as consultas são mais rápidas."""

    pass


  def para(self, codigo) -> TipoCFOP:
    """Converte um código para um objeto TipoCFOP."""

    pass


  def toString(self) -> str:
    pass

class TabelaContribPrevi ():
  """Tabela de apuração das contribuições previdenciárias devidas pelos segurados
 (empregados e contribuintes individuais).<BR>
 
 Exemplo de utilização desta tabela pela linguagem de script:<BR>
 <CODE> // Adquire acesso à tabela de apuração das contribuições<BR>
 tab = tabelas.getTabelaContribPrevi();<BR>
 <BR> // Suponhamos que a variável "folha" refere-se a um "mestre" da folha de
 pagamento.<BR> // Obtém a competência, o valor da base de cálculo no mês e o
 tipo de segurado.<BR>
 var comp = folha.getCompetencia();<BR>
 var base = folha.getPsBaseCalculo();<BR>
 var seg = folha.getTrabalhador().isSeguradoEmpregado();<BR>
 <BR> // Agora utiliza a tabela de apuração para calcular a contribuição
 devida.<BR>
 if (seg) // É segurado empregado<BR>
 &nbsp;&nbsp;&nbsp;println("Contribuição devida pelo segurado empregado:
 "+tab.para(comp).getValorContribuicaoSE(base));<BR>
 else // É contribuinte individual<BR>
 &nbsp;&nbsp;&nbsp;println("Contribuição devida pelo contribuinte individual:
 "+tab.para(comp).getValorContribuicaoCI(base));<BR>
 </CODE>"""

  def getLimiteCI(self) -> float:
    """Retorna o limite de base de cálculo para contribuintes individuais"""

    pass


  def getLimiteSE(self) -> float:
    """Retorna o limite de base de cálculo para segurados empregados"""

    pass


  def getValorContribuicaoCI(self, remuneracao) -> float:
    """Retorna o valor da contribuição devida para contribuinte individual com
 uma determinada remuneração. Sobre este valor é aplicado o limite da
 tabela previdenciária e então, dependendo da faixa, aplica-se a aliquota
 correspondente."""

    pass


  def getValorContribuicaoSE(self, remuneracao) -> float:
    """Retorna o valor da contribuição devida para segurado empregado com uma
 determinada remuneração.<BR>
 Sobre este valor é aplicado o limite da tabela previdenciária e então,
 dependendo da faixa, aplica-se a aliquota correspondente."""

    pass


  def para(self, competencia) -> TabelaContribPrevi:
    """Obtém informações para um determinado mês de competência"""

    pass

class TabelaConvertida ():
  """Estrutura utilizada para extrair conteúdo de um arquivo qualquer (podendo ser
 um arquivo texto ou uma planilha) com alguma flexibilidade e com conversão de
 formatos.<BR>
 
 A flexibilidade consiste em reconhecer colunas do arquivo mesmo que as
 posições dessas colunas estejam trocadas. Isso é feito com uso de expressões
 que são programadas para identificar essas colunas em uma dada linha do
 arquivo.<BR>
 
 A conversão é feita com base em alguns padrões que já existem internamente,
 bastando para isso informar qual é o tipo de conversão que é desejado.<BR>
 
 Este objeto tem os mesmos métodos de um objeto Tabela (para todos os efeitos
 é como se fosse uma tabela), mas inclui também alguns métodos adicionais para
 informar algo sobre o processo de conversão (por exemplo, informar se um
 determinado campo foi encontrado ou não no arquivo).<BR>"""

  def contemAlgumaColuna(self) -> bool:
    """Retorna a indicação de que pelo menos uma coluna desta tabela foi
 encontrada no arquivo."""

    pass


  def contemColuna(self, coluna) -> bool:
    """Informa se determinada coluna da tabela foi mapeada para alguma coluna do
 arquivo.<BR>
 Note que esta coluna aparece na tabela com todos seus campos vazios mesmo
 que não tenha sido encontrado no arquivo.<BR>
 Este método oferece o meio de se saber se a coluna foi ou não foi
 encontrada no arquivo com base na expressão regular indicada no
 procedimento que gerou esta tabela."""

    pass


  def contemTodasColunas(self) -> bool:
    """Retorna a indicação de que todas as colunas desta tabela foram
 encontradas no arquivo."""

    pass


  def getColunaCorrespondenteArquivo(self, coluna) -> int:
    """Dado o número de uma coluna nesta tabela (começando pelo número 0),
 retorna o correspondente número de coluna no arquivo que foi mapeado a
 ela (começando pelo número 1), ou retorna 0 se não encontrou mapeamento
 algum para esta coluna desta tabela."""

    pass

class TabelaDescricoes ():
  """Tabela que para um determinado código retorna a correspondente descrição.
 <P>
 
 Trata-se de um objeto para uso em diversas situações, por exemplo:<BR> -
 códigos e descrições de CFOP (para notas fiscais).<BR> - códigos e
 descrições de NCM.<BR> - códigos e descrições de GPS (para previdência).<BR> -
 etc.
 <P>
 
 Existem várias formas de se obter objetos deste tipo em
 {@link Tabelas Tabelas}.
 <P>
 
 Exemplo de utilização desta tabela pela linguagem de script:<BR>
 <CODE> // Adquire acesso à tabela de CFOP<BR>
 tab = tabelas.getTabelaCFOP();<BR>
 <BR> // Obtém a descrição para um determinado CFOP<BR>
 println("CFOP de 1100 é " + tab.para(1100).getDescricao() );<BR>
 </CODE>"""

  def getDescricao(self, codigo) -> str:
    """Retorna a descrição associado ao código informado como parâmetro.<BR>
 Este método é equivalente a executar o método "para" seguido da
 alternativa sem parâmetro do método "getDescricao".<BR>
 Isto é, este método é equivalente a executar:
 para(codigo).getDescricao();<BR>
 Trata-se de uma alternativa conveniente para uso em scripts visuais."""

    pass


  def getDescricao(self) -> str:
    """Retorna a descrição associada ao código informado na função
 {@link TabelaDescricoes#para(Object) para}."""

    pass


  def getTabela(self) -> Tabela:
    """Retorna o conteúdo completo desta tabela na forma de um objeto do tipo
 {@link Tabela Tabela}.<BR>
 Isto é, todas as informações são apresentadas em linhas e colunas.<BR>
 OBS: para realizar pesquisas de descrições com base em códigos, é
 preferível não converter em tabela, mas sim utilizar o objeto atual, pois
 assim as consultas são mais rápidas."""

    pass


  def para(self, codigo) -> TabelaDescricoes:
    """Considera um determinado código para conversão."""

    pass


  def toString(self) -> str:
    pass

class TabelaIndice ():
  """Tabela que para um determinada data retorna um correspondente valor.
 <P>
 
 Trata-se de um objeto para uso em diversas situações, por exemplo:<BR> -
 datas e valores de taxas de câmbio.<BR> - datas e valores de taxas de juros.<BR> -
 etc.
 <P>
 
 
 Exemplo de utilização desta tabela pela linguagem de script:<BR>
 <CODE> // Adquire acesso à tabela de taxas de câmbio de dólar<BR>
 tab = tabelas.getTabelaDolar();<BR>
 <BR> // Obtém a taxa para um determinado dia<BR>
 println("A taxa de compra do dolar em 23/05/2008 é " +
 tab.valorEm(23/05/2008) );<BR>
 </CODE>
 
 A taxa de variação entre duas datas é obtida através da função
 variacaoEntre(data1, data2), da seguinte forma:
 
 <CODE> // variação tjlp<BR>
 tab = tabelas.getTabelaTjlp();<BR>
 <BR> // teste entreo inicio e o fim de um ano<BR>
 println("A variação da tjlp entre 01/01/2003 e 31/12/2003 é " +
 tab.variacaoEntre( "01/01/2003" , "31/12/2003") );<BR>
 <BR> // teste entre datas de meses subsequentes de um mesmo ano<BR>
 println("A variação da tjlp entre 08/03/2010 e 15/04/2010 é " +
 tab.variacaoEntre( "08/03/2010" , "15/04/2010") );<BR>
 </CODE>"""

  def getTabela(self) -> Tabela:
    """Retorna o conteúdo completo desta tabela na forma de um objeto do tipo
 {@link Tabela Tabela}.<BR>
 Isto é, todas as informações são apresentadas em linhas e colunas.<BR>
 OBS: para realizar pesquisas de valores por datas, é preferível não
 converter em tabela, mas sim utilizar o objeto atual, pois assim as
 consultas são mais rápidas."""

    pass


  def toString(self) -> str:
    pass


  def valorEm(self, data) -> Double:
    """Considera uma determinada data para consulta do índice que está aberto."""

    pass


  def variacaoEntre(self, dataInicio, dataFim) -> Double:
    pass

class TabelaRegras ():
  """Tabela que para um determinado código retorna um ou mais objetos, que são
 armazenados em uma planilha, um para cada linha.
 <P>
 Assim, o acesso padrão é que para cada chave retorne uma lista de objetos
 chamados regra_NCM que atendem a esta chave.
 
 Trata-se de um objeto para uso em análise de crédito de PIS e COFINS através
 da caracterização da mercadoria por seu NCM.
 <P>
 
 
 
 Exemplo de utilização desta tabela pela linguagem de script:<BR>
 <CODE> // Adquire acesso à tabela de regras de PIS e Cofins<BR>
 tab = tabelas.getTabelaNCMPisCofins();<BR>
 <BR> // Obtém a lista de regras para uma determinada rubrica <BR>
 listaRegras = tab.para("02012020");<BR>
 
 for each (regra_NCM in listaRegras.toArray()) { println ("Método getNCM():
 "+regra_NCM.getNCM()); } </CODE>"""

  def getTabela(self) -> Tabela:
    """Retorna o conteúdo completo desta tabela na forma de um objeto do tipo
 {@link Tabela Tabela}.<BR>
 Isto é, todas as informações são apresentadas em linhas e colunas.<BR>
 OBS: para realizar pesquisas de descrições com base em códigos, é
 preferível não converter em tabela, mas sim utilizar o objeto atual, pois
 assim as consultas são mais rápidas."""

    pass


  def para(self, codigo) -> list:
    """Considera um determinado código para conversão."""

    pass


  def toString(self) -> str:
    pass

class Tabelas ():
  """Classe utilizada por uma linguagem de scripting para se gerar
 {@link Tabela Tabela}.<BR>
 
 Pode também ser utilizada para disponibilizar acesso a outras tabelas
 internas do ContÁgil mantidas para propósitos específicos.<BR>
 
 Este objeto está acessível para a linguagem de script através do nome
 "tabelas".<BR>"""

  def atualizaTabelaIndicadores(self) -> None:
    """Atualiza os indicadores: SELIC, TJLP, DÓLAR e EURO
 Fonte: Banco Central do Brasil."""

    pass


  def atualizaTabelaSelicContagil(self) -> None:
    """Método mantido para manter a compatibilidade com códigos anteriores.
 Novo nome: TABELA INDICADORES -> ATUALIZAR TABELA INDICADORES.
 Atualiza os indicadores: SELIC, TJLP, DÓLAR e EURO.
 Fonte: Banco Central do Brasil."""

    pass


  def calculaDeducoesIRRF(self, dia, qtd_dep, idoso) -> float:
    """Calcula as deduções do Imposto de Renda Retido na Fonte (IRRF) a partir
 da tabela de incidência armazenada no ContÁgil. <BR>"""

    pass


  def calculaDeducoesIRRF(self, dia, qtd_dep, idoso) -> float:
    """Calcula as deduções do Imposto de Renda Retido na Fonte (IRRF) a partir
 da tabela de incidência armazenada no ContÁgil. <BR>"""

    pass


  def calculaIRRF(self, dia, base, qtd_dep, idoso) -> float:
    """Calcula o Imposto de Renda Retido na Fonte (IRRF) a partir da tabela de
 incidência armazenada no ContÁgil. <BR>"""

    pass


  def calculaIRRF(self, dia, base, qtd_dep, idoso) -> float:
    """Calcula o Imposto de Renda Retido na Fonte (IRRF) a partir da tabela de
 incidência armazenada no ContÁgil. <BR>"""

    pass


  def getMetaDadosAtributos(self, excel, planilha) -> Tabela:
    """Importa de um arquivo Excel as informações de 'metadados' no padrão do ContÁgil. Espera encontrar neste arquivo
 informações sobre 'ATRIBUTOS' em alguma planilha, sendo obrigatória a presença de uma linha nesta planilha com
 indicação dos nomes das colunas exatamente da forma como estão descritas na documentação do método {@link #getMetaDadosAtributos(String) getMetaDadosAtributos}.<BR>
 Durante este procedimento, alguns tratamentos preliminares podem ser realizados com o objetivo de compatibilizar algumas pequenas
 diferenças na sintaxe utilizada no arquivo."""

    pass


  def getMetaDadosAtributos(self, nome) -> Tabela:
    """Dado o nome de uma tabela do usuário, retorna a tabela com os correspondente metadados, especificamente com relação aos ATRIBUTOS.<BR>
 A tabela retornada apresenta as seguintes informações:<BR>
 NR_ORDEM: número de ordem da coluna, começando pelo número 0 para a primeira coluna da tabela de dados<BR>
 TX_NOME: nome do atributo que deve ser apresentado no MAD associado a esta coluna da tabela de dados<BR>
 NR_TIPO: número que indica o tipo de dado, podendo ser: 1 = MOEDA, 2 = PONTO FLUTUANTE, 3 = INTEIRO, 4 = TEXTO, 5 = DATA, 6 = PORCENTAGEM, 7 = CODIGO, 8 = BOOLEANO.<BR>
 TX_SUBTIPO: subtipo que indica se é CNPJ (gov.rfb.contagil.commons.tipos.CNPJ) ou CPF (gov.rfb.contagil.commons.tipos.CPF), ou outro tipo específico definido internamente no ContÁgil.<BR>
 TX_COLUNA: nome da coluna no banco de dados, se for criado no banco de dados<BR>
 TX_CAMINHO: caminho para localização do atributo no catálogo de atributos do MAD<BR>
 TX_JUNCOES: permite incluir nos metadados informações de colunas que residem em outras tabelas. Nesta hipótese, esta coluna deve indicar os critérios
 de junção necessários para juntar a tabela fato (que está sendo criada) com a tabela juntada. A sintaxe para informação dos critérios de junção está indicada na documentação
 do método {@link #novaTabelaComMetaDados(String, Tabela, Tabela) novaTabelaComMetaDados}.<BR>
 TX_COLUNA_FUNCAO: permite indicar uma função de transformação em SQL que deve ser aplicada automaticamente durante um MAD sempre que a correspondente coluna for utilizada. Nesta
 hipótese, o nome da coluna deve ser indicada em 'TX_COLUNA' sem indicação de função de transformação e, em TX_COLUNA_FUNCAO, o mesmo nome de coluna deve ser indicado com a presença
 das funções de transformação necessárias."""

    pass


  def getMetaDadosAtributos(self, excel, planilha, filtrarColuna, expressaoRegular) -> Tabela:
    """Importa de um arquivo Excel as informações de 'metadados' no padrão do ContÁgil. Espera encontrar neste arquivo
 informações sobre 'ATRIBUTOS' em alguma planilha, sendo obrigatória a presença de uma linha nesta planilha com
 indicação dos nomes das colunas exatamente da forma como estão descritas na documentação do método {@link #getMetaDadosAtributos(String) getMetaDadosAtributos}.<BR>
 Durante este procedimento, alguns tratamentos preliminares podem ser realizados com o objetivo de compatibilizar algumas pequenas
 diferenças na sintaxe utilizada no arquivo."""

    pass


  def getMetaDadosAtributosFiltrarComFormula(self, excel, planilha, formula, removeNoResultado) -> Tabela:
    """Importa de um arquivo Excel as informações de 'metadados' no padrão do ContÁgil. Espera encontrar neste arquivo
 informações sobre 'ATRIBUTOS' em alguma planilha, sendo obrigatória a presença de uma linha nesta planilha com
 indicação dos nomes das colunas exatamente da forma como estão descritas na documentação do método {@link #getMetaDadosAtributos(String) getMetaDadosAtributos}.<BR>
 Durante este procedimento, alguns tratamentos preliminares podem ser realizados com o objetivo de compatibilizar algumas pequenas
 diferenças na sintaxe utilizada no arquivo.<BR>
 Deve ser indicada uma fórmula com a qual deseja filtrar as linhas de interesse da planilha. Admite-se que a fórmula faça referência a colunas do Excel utilizando
 a sintaxe ["COLUNA-XX"] para expressar o valor da coluna XX do Excel, onde ["COLUNA-1"] representa a primeira coluna, ["COLUNA-2"] representa a segunda coluna, e assim em diante.<BR>
 A fórmula também pode fazer referência a colunas utilizando nomes que são encontrados nas células correspondentes, na linha identificada pelo método como sendo a 'linha de cabeçalho' (isto é,
 a mesma linha que contém os demais nomes de colunas, tais como TX_COLUNA, entre outros. Se a linha que contém esses nomes de colunas (ela pode estar em qualquer parte da planilha)
 também apresentar outros nomes em outras colunas, esses nomes podem também ser utilizados na fórmula. Por exemplo, se há na linha de nomes de colunas uma célula com o conteúdo 'NOME', a fórmula
 pode fazer referência a esta coluna utilizando a expressão ["NOME"] (lembrar sempre de incluir os colchetes e as pastas)."""

    pass


  def getMetaDadosMetricas(self, nome) -> Tabela:
    """Dado o nome de uma tabela do usuário, retorna a tabela com os correspondente metadados, especificamente com relação às MÉTRICAS.<BR>
 A tabela retornada apresenta as seguintes informações:<BR>
 NR_ORDEM: número de ordem da coluna, começando pelo número 0 para a primeira coluna da tabela de dados<BR>
 TX_NOME: nome da métrica que deve ser apresentado no MAD associado a esta coluna da tabela de dados<BR>
 NR_TIPO: número que indica o tipo de dado, podendo ser: 1 = MOEDA, 2 = PONTO FLUTUANTE, 3 = INTEIRO, 6 = PORCENTAGEM.<BR>
 TX_COLUNA: nome da coluna no banco de dados, se for criado no banco de dados<BR>
 NR_DECIMAIS: quantidade de casas decimais, ou -1 se esta quantidade for definida de forma automática pelo ContÁgil.<BR>
 TX_CAMINHO: caminho para localização da métrica no catálogo de métricas do MAD<BR>
 TX_JUNCOES: permite incluir nos metadados informações de colunas que residem em outras tabelas. Nesta hipótese, esta coluna deve indicar os critérios
 de junção necessários para juntar a tabela fato (que está sendo criada) com a tabela juntada. A sintaxe para informação dos critérios de junção está indicada na documentação
 do método {@link #novaTabelaComMetaDados(String, Tabela, Tabela) novaTabelaComMetaDados}.<BR>
 TX_COLUNA_FUNCAO: permite indicar uma função de transformação em SQL que deve ser aplicada automaticamente durante um MAD sempre que a correspondente coluna for utilizada. Nesta
 hipótese, o nome da coluna deve ser indicada em 'TX_COLUNA' sem indicação de função de transformação e, em TX_COLUNA_FUNCAO, o mesmo nome de coluna deve ser indicado com a presença
 das funções de transformação necessárias."""

    pass


  def getMetaDadosMetricas(self, excel, planilha, filtrarColuna, expressaoRegular) -> Tabela:
    """Importa de um arquivo Excel as informações de 'metadados' no padrão do ContÁgil. Espera encontrar neste arquivo
 informações sobre 'MÉTRICAS' em alguma planilha, sendo obrigatória a presença de uma linha nesta planilha com
 indicação dos nomes das colunas exatamente da forma como estão descritas na documentação do método {@link #getMetaDadosMetricas(String) getMetaDadosMetricas}.<BR>
 Durante este procedimento, alguns tratamentos preliminares podem ser realizados com o objetivo de compatibilizar algumas pequenas
 diferenças na sintaxe utilizada no arquivo."""

    pass


  def getMetaDadosMetricas(self, excel, planilha) -> Tabela:
    """Importa de um arquivo Excel as informações de 'metadados' no padrão do ContÁgil. Espera encontrar neste arquivo
 informações sobre 'MÉTRICAS' em alguma planilha, sendo obrigatória a presença de uma linha nesta planilha com
 indicação dos nomes das colunas exatamente da forma como estão descritas na documentação do método {@link #getMetaDadosMetricas(String) getMetaDadosMetricas}.<BR>
 Durante este procedimento, alguns tratamentos preliminares podem ser realizados com o objetivo de compatibilizar algumas pequenas
 diferenças na sintaxe utilizada no arquivo."""

    pass


  def getMetaDadosMetricasFiltrarComFormula(self, excel, planilha, formula, removeNoResultado) -> Tabela:
    """Importa de um arquivo Excel as informações de 'metadados' no padrão do ContÁgil. Espera encontrar neste arquivo
 informações sobre 'MÉTRICAS' em alguma planilha, sendo obrigatória a presença de uma linha nesta planilha com
 indicação dos nomes das colunas exatamente da forma como estão descritas na documentação do método {@link #getMetaDadosMetricas(String) getMetaDadosMetricas}.<BR>
 Durante este procedimento, alguns tratamentos preliminares podem ser realizados com o objetivo de compatibilizar algumas pequenas
 diferenças na sintaxe utilizada no arquivo.<BR>
 Deve ser indicada uma fórmula com a qual deseja filtrar as linhas de interesse da planilha. Admite-se que a fórmula faça referência a colunas do Excel utilizando
 a sintaxe ["COLUNA-XX"] para expressar o valor da coluna XX do Excel, onde ["COLUNA-1"] representa a primeira coluna, ["COLUNA-2"] representa a segunda coluna, e assim em diante.<BR>
 A fórmula também pode fazer referência a colunas utilizando nomes que são encontrados nas células correspondentes, na linha identificada pelo método como sendo a 'linha de cabeçalho' (isto é,
 a mesma linha que contém os demais nomes de colunas, tais como TX_COLUNA, entre outros. Se a linha que contém esses nomes de colunas (ela pode estar em qualquer parte da planilha)
 também apresentar outros nomes em outras colunas, esses nomes podem também ser utilizados na fórmula. Por exemplo, se há na linha de nomes de colunas uma célula com o conteúdo 'NOME', a fórmula
 pode fazer referência a esta coluna utilizando a expressão ["NOME"] (lembrar sempre de incluir os colchetes e as pastas)."""

    pass


  def getMetaDadosServidorAtributos(self, nome) -> Tabela:
    """Dado o nome de uma tabela do usuário mantida no servidor do ContÁgil, retorna a tabela com os correspondente metadados, especificamente com relação aos ATRIBUTOS.<BR>
 A tabela retornada apresenta as mesmas informações apresentadas na documentação do método {@link #getMetaDadosAtributos(String) getMetaDadosAtributos}"""

    pass


  def getMetaDadosServidorMetricas(self, nome) -> Tabela:
    """Dado o nome de uma tabela do usuário mantida no servidor do ContÁgil, retorna a tabela com os correspondente metadados, especificamente com relação às MÉTRICAS.<BR>
 A tabela retornada apresenta as mesmas informações apresentadas na documentação do método {@link #getMetaDadosMetricas(String) getMetaDadosAtributos}"""

    pass


  def getTabelaBancos(self) -> Tabela:
    """Retorna um tabela com a relação de bancos cadastrada no ContÁgil. Cada linha da tabela indica:<BR>
 1a coluna: Código de compensação de 3 dígitos<BR>
 2a coluna: Nome do banco que foi cadastrado no ContÁgil<BR>"""

    pass


  def getTabelaCFOP(self) -> TabelaDescricoes:
    """Retorna a tabela que relaciona para cada código CFOP a correspondente
 descrição."""

    pass


  def getTabelaCFOPComIndicadores(self) -> TabelaCFOP:
    """Retorna a tabela que relaciona para cada código CFOP a correspondente 
 descrição e suas características."""

    pass


  def getTabelaCNAE(self) -> Tabela:
    """Retorna a tabela que relaciona para cada código CNAE (7 dígitos) a
 correspondente descrição e alíquota."""

    pass


  def getTabelaCategoriasSegurados(self) -> TabelaDescricoes:
    """Retorna a tabela que relaciona para cada código de categoria de segurado
 a correspondente descrição."""

    pass


  def getTabelaContribPrevi(self) -> TabelaContribPrevi:
    """Retorna a tabela de apuração das contribuições previdenciárias devidas
 pelos segurados empregados e contribuintes individuais. OBS: A tabela
 retornada em nada se parece com o objeto {@link Tabela Tabela}, mas
 possui métodos específicos para auxiliar no cálculo das contribuições
 devidas."""

    pass


  def getTabelaCorretoras(self) -> Tabela:
    """Retorna um tabela com a relação de corretoras que operam em bolsa de valores conforme cadastro interno do ContÁgil. Cada linha da tabela indica:<BR>
 1a coluna: CNPJ de 14 dígitos da corretora<BR>
 2a coluna: Nome da corretora<BR>
 3a coluna: Site da corretora na Internet"""

    pass


  def getTabelaDolar(self) -> TabelaIndice:
    """Retorna uma tabela com os dados de dolar"""

    pass


  def getTabelaDolarCompra(self) -> TabelaIndice:
    """Retorna uma tabela com os dados de dolar - valores para compra"""

    pass


  def getTabelaDolarVenda(self) -> TabelaIndice:
    """Retorna uma tabela com os dados de dolar - valores para venda"""

    pass


  def getTabelaDominio(self, nomeTabela) -> TabelaDescricoes:
    """Retorna uma tabela de domínio qualquer definida internamente no ContÁgil. Caso seja encontrada, a tabela
 retornada faz a correspondência entre código e descrição.<BR>
 Caso não seja encontrada, retorna NULL."""

    pass


  def getTabelaEmissoresPapeisBolsa(self) -> Tabela:
    """Retorna um tabela com a relação de empresas emissoras de papéis em bolsa. Cada linha da tabela indica:<BR>
 1a coluna: CNPJ de 14 dígitos do emissor<BR>
 2a coluna: Nome do emissor<BR>
 3a coluna: Nomes dos papéis negociados em bolsa"""

    pass


  def getTabelaEuro(self) -> TabelaIndice:
    """Retorna uma tabela com os dados de euro"""

    pass


  def getTabelaEuroCompra(self) -> TabelaIndice:
    """Retorna uma tabela com os dados de euro - valores para compra"""

    pass


  def getTabelaEuroVenda(self) -> TabelaIndice:
    """Retorna uma tabela com os dados de euro - valores para venda"""

    pass


  def getTabelaGPS(self) -> TabelaDescricoes:
    """Retorna a tabela que relaciona para cada código GPS a correspondente
 descrição."""

    pass


  def getTabelaMoedas(self) -> Tabela:
    """Retorna um tabela com a relação de moedas estrangeiras e padrões monetários
 brasileiros"""

    pass


  def getTabelaNCM(self) -> TabelaDescricoes:
    """Retorna a tabela que relaciona para cada código NCM a correspondente
 descrição."""

    pass


  def getTabelaNCMPisCofins(self) -> TabelaRegras:
    """Retorna a tabela que relaciona para cada código NCM a lista de regras."""

    pass


  def getTabelaPlanoReferencial(self) -> Tabela:
    """Retorna uma tabela com os dados do Plano de Contas Referencial do
 ContÁgil"""

    pass


  def getTabelaPlanoSped(self) -> Tabela:
    """Retorna uma tabela com os dados do Plano de Contas Referencial do SPED."""

    pass


  def getTabelaSelic(self) -> TabelaIndice:
    """Retorna uma tabela com os dados da Selic"""

    pass


  def getTabelaTIPI(self) -> TIPI:
    pass


  def getTabelaTjlp(self) -> TabelaIndice:
    """Retorna um tabela com os dados de TJLP"""

    pass


  def getTabelaTributoGrupo(self) -> Tabela:
    """Retorna um tabela com códigos de grupos de receitas e sua descrição."""

    pass


  def getTabelaTributoReceita(self) -> Tabela:
    """Retorna um tabela com códigos de receitas, sua descrição e o grupo e
 subgrupo de tributo a que pertence."""

    pass


  def getTabelaTributoSubgrupo(self) -> Tabela:
    """Retorna um tabela com códigos de subgrupos de receitas, sua descrição e o
 grupo de tributo a que pertence."""

    pass


  def getTabelaUnidadesRFB(self, tipo) -> TabelaDescricoes:
    """Retorna a tabela que relaciona para cada código de 7 dígitos a
 correspondente unidade da RFB.<BR>
 O parâmetro adicional informa se os nomes devem ser aqueles
 que foram cadastrados na tabela interna do ContÁgil ou se devem
 ser os nomes que são apresentados no DW - DIRF.<BR>"""

    pass


  def getTabelaUnidadesRFB(self) -> TabelaDescricoes:
    """Retorna a tabela que relaciona para cada código de 7 dígitos a
 correspondente unidade da RFB.<BR>
 Os nomes obtidos nesta tabela são os nomes configurados na tabela
 interna do ContÁgil."""

    pass


  def getTabelaUnidadesRFB_INSS(self, tipo) -> TabelaDescricoes:
    """Retorna a tabela que relaciona para cada código de 5 dígitos do INSS a
 correspondente unidade da RFB (DRF).<BR>
 O parâmetro adicional informa se os nomes devem ser aqueles
 que foram cadastrados na tabela interna do ContÁgil ou se devem
 ser os nomes que são apresentados no DW - DIRF.<BR>"""

    pass


  def getTabelaUnidadesRFB_INSS(self) -> TabelaDescricoes:
    """Retorna a tabela que relaciona para cada código de 5 dígitos do INSS a
 correspondente unidade da RFB (DRF).<BR>
 Os nomes obtidos nesta tabela são os nomes configurados na tabela
 interna do ContÁgil."""

    pass


  def getTabelasDominioDirf(self) -> Tabela:
    """Retorna uma relação de tabelas de domínio pertinentes às informações de
 Dirf."""

    pass


  def nova(self) -> Tabela:
    """Cria uma nova tabela."""

    pass


  def novaTabela(self, nome, configuracaoColunas) -> Tabela:
    """Cria uma nova tabela já especificando a relação de colunas e seus
 respectivos formatos de dados.<BR>
 Os formatos de colunas previstos são aqueles enumerados na documentação
 do método {@link Tabela#setFormato(int, String) setFormato}.<BR>
 <BR>
 Exemplo de utilização (em JavaScript):<BR>
 <CODE> // Cria uma nova tabela com 3 colunas, sendo a primeira de nome
 "CNPJ" e do tipo "CNPJ de 14 dígitos",<BR> // a segunda de nome "Dia
 Emis" e tipo "DATA", e a terceira de nome "Nome" e tipo "TEXTO".<BR>
 tab = tabelas.novaTabela(["CNPJ","CNPJ14", "Dia Emis","DATA",
 "Nome","TEXTO"]);<BR>
 </CODE>"""

    pass


  def novaTabela(self) -> Tabela:
    """Cria uma nova tabela."""

    pass


  def novaTabelaComMetaDados(self, nome, atributos, metricas) -> TabelaUsuario:
    """Cria uma nova 'tabela do usuário' inicialmente vazia. Este método requer a indicação dos 'metadados' através dos parâmetros adicionais 'atributos' e 'métricas',
 os quais precisam obrigatoriamente seguir uma convenção de nomes de colunas e conteúdo que são específicos para o ContÁgil.<BR>
 ATENÇÃO: se você desejar criar uma 'tabela' para ser preenchida via script, utilize os método alternativos {@link #novaTabela() novaTabela} ou {@link #novaTabela(String, String...) novaTabela}.<BR><BR>
 Caso exista necessidade de informar colunas juntadas, oriundas de outras tabelas (isto é, critérios de junção informados em 'TX_JUNCOES'), a sintaxe utilizada na definição dos critérios
 de junção é a seguinte:<BR>
 schema1.tabela1.coluna1=schema2.tabela2.coluna2<BR>
 Onde:<BR>
 schema1 = nome do schema onde reside a tabela fato (que está sendo criada)<BR>
 tabela1 = nome da tabela fato, conforme armazenada no banco de dados (pode ser diferente do nome para uso no MAD)<BR>
 coluna1 = nome da coluna da tabela fato que se liga com a tabela juntada<BR>
 schema2 = nome do schema onde reside a tabela com a informação juntada<BR>
 tabela2 = nome da tabela juntada, conforme armazenada no banco de dados<BR>
 coluna2 = nome da coluna da tabela juntada que se liga com a 'coluna1' da tabela fato<BR>
 <BR>
 Isso possibilita que, durante um MAD, informações sejam obtidas de outras tabelas por meio de 'JOIN's.<BR>
 Se houver necessidade de representar mais de um elo de ligação nos critérios de junção (isto é, se a informação é obtida por junções sucessivas com outras tabelas), indique
 todos os critérios de junção no mesmo campo, separando-os com ponto e vírgula.<BR>
 Se houver necessidade de aplicação de alguma transformação em SQL para obtenção da junção, indique essas expressões em SQL no próprio critério de junção.<BR>
 Se houver necessidade de juntar duas tabelas entre si por mais de uma coluna, indique os diferentes critérios de junção, conforme especificado acima, indicando um após o outro,
 separando-os com ponto e vírgula.<BR>
 OBS: a ordem com que são indicados os critérios de junção para um mesmo atributo é relevante. Deve começar pela indicação da tabela fato (que está sendo criada), prosseguindo
 adiante, nas ligações com as demais tabelas do elo de ligação, até chegar na tabela final, que contém a informação apresentada nos metadados.<BR>"""

    pass


  def novaTabelaServidorComMetaDados(self, nome, atributos, metricas) -> TabelaUsuario:
    """Faz o mesmo que a função {@link #novaTabelaComMetaDados(String, Tabela, Tabela) novaTabelaComMetaDados}, porém a tabela é criada no servidor."""

    pass


  def novosMetaDados(self, nome, atributos, metricas) -> TabelaUsuario:
    """Cria as tabelas internas de 'metadados' utilizadas pelo MAD do ContÁgil para utilização de alguma tabela do
 banco de dados.<BR>
 Este método faz quase a mesma coisa que o método {@link #novaTabelaComMetaDados(String, Tabela, Tabela) novaTabelaComMetaDados}, com
 a diferença que aqui não se cria a tabela de dados. Apenas são criadas as tabelas de metadados (isto é, as tabelas com sufixos ATRIBUTOS e METRICAS).<BR>
 Útil quando se quer mapear para uso no ContÁgil alguma tabela existente no banco de dados.<BR>
 Para mais informações sobre todos os parâmetros, consulte a documentação de {@link #novaTabelaComMetaDados(String, Tabela, Tabela) novaTabelaComMetaDados}."""

    pass


  def novosMetaDadosServidor(self, nome, atributos, metricas, nomeInternoTabela, nomeInternoBase) -> TabelaUsuario:
    """Cria as tabelas internas de 'metadados' utilizadas pelo MAD do ContÁgil para utilização de alguma tabela do
 banco de dados do servidor.<BR>
 Este método faz quase a mesma coisa que o método {@link #novaTabelaServidorComMetaDados(String, Tabela, Tabela) novaTabelaServidorComMetaDados}, com
 a diferença que aqui não se cria a tabela de dados. Apenas são criadas as tabelas de metadados (isto é, as tabelas com sufixos ATRIBUTOS e METRICAS).<BR>
 Útil quando se quer mapear para uso no ContÁgil alguma tabela existente no banco de dados.<BR>
 Para mais informações sobre todos os parâmetros, consulte a documentação de {@link #novaTabelaComMetaDados(String, Tabela, Tabela) novaTabelaComMetaDados}."""

    pass


  def novosMetaDadosServidor(self, nome, atributos, metricas) -> TabelaUsuario:
    """Cria as tabelas internas de 'metadados' utilizadas pelo MAD do ContÁgil para utilização de alguma tabela do
 banco de dados do servidor.<BR>
 Este método faz quase a mesma coisa que o método {@link #novaTabelaServidorComMetaDados(String, Tabela, Tabela) novaTabelaServidorComMetaDados}, com
 a diferença que aqui não se cria a tabela de dados. Apenas são criadas as tabelas de metadados (isto é, as tabelas com sufixos ATRIBUTOS e METRICAS).<BR>
 Útil quando se quer mapear para uso no ContÁgil alguma tabela existente no banco de dados.<BR>
 Para mais informações sobre todos os parâmetros, consulte a documentação de {@link #novaTabelaComMetaDados(String, Tabela, Tabela) novaTabelaComMetaDados}."""

    pass

class Terminal ():
  """Objeto que pode ser utilizado por uma linguagem de script para interagir com
 um terminal remoto (Telnet TN3270).
 <P>"""

  def aguardaPosicaoCursor(self, linha, coluna, espera) -> bool:
    """Aguarda que a tela do terminal seja atualizada e espera a posição do
 cursor ficar na posição indicada até o tempo máximo de espera indicado
 como parâmetro."""

    pass


  def aguardaTela(self, padrao1) -> bool:
    """Aguarda um tempo até que a tela do terminal remoto apresente um
 determinado texto.<BR>
 Se o terminal remoto já estiver apresentando o texto especificado, o
 método retorna imediatamente.<BR>
 Se o terminal remoto não apresentar o texto especificado em até 6
 segundos (isto é, após duas tentativas de 3 segundos cada), o método
 retorna FALSE.<BR>"""

    pass


  def aguardaTela(self, padrao1, padrao2) -> bool:
    """Aguarda um tempo até que a tela do terminal remoto apresente dois textos
 simultaneamente.<BR>
 Se o terminal remoto já estiver apresentando o texto especificado, o
 método retorna imediatamente.<BR>
 Se o terminal remoto não apresentar o texto especificado em até 6
 segundos (isto é, após duas tentativas de 3 segundos cada), o método
 retorna FALSE.<BR>"""

    pass


  def aguardaTela(self, padrao1, padrao2, padrao3) -> bool:
    """Aguarda um tempo até que a tela do terminal remoto apresente três textos
 simultaneamente.<BR>
 Se o terminal remoto já estiver apresentando o texto especificado, o
 método retorna imediatamente.<BR>
 Se o terminal remoto não apresentar o texto especificado em até 6
 segundos (isto é, após duas tentativas de 3 segundos cada), o método
 retorna FALSE.<BR>"""

    pass


  def aguardaTelaTextosAlternativos(self, padrao1, padrao2) -> bool:
    """Aguarda um tempo até que a tela do terminal remoto apresente qualquer um
 de dois textos alternativos (um dos dois, ou ambos).<BR>
 Se o terminal remoto já estiver apresentando o texto especificado, o
 método retorna imediatamente.<BR>
 Se o terminal remoto não apresentar o texto especificado em até 6
 segundos (isto é, após duas tentativas de 3 segundos cada), o método
 retorna FALSE.<BR>"""

    pass


  def aguardaTelaTextosAlternativos(self, padrao1, padrao2, padrao3) -> bool:
    """Aguarda um tempo até que a tela do terminal remoto apresente qualquer um
 de três textos alternativos (um dos três, dois dos três, ou todos eles).<BR>
 Se o terminal remoto já estiver apresentando o texto especificado, o
 método retorna imediatamente.<BR>
 Se o terminal remoto não apresentar o texto especificado em até 6
 segundos (isto é, após duas tentativas de 3 segundos cada), o método
 retorna FALSE.<BR>"""

    pass


  def autentica(self, endereco, porta, chave, sistema) -> None:
    """Faz autenticação em um terminal remoto localizado em um determinado
 endereço de rede e com determinas credenciais de usuário."""

    pass


  def autentica(self, chave, sistema) -> None:
    """Faz autenticação em um terminal remoto localizado no endereço padrão
 10.3.254.1 e com determinas credenciais de usuário."""

    pass


  def conectaSemAutenticar(self, endereco, porta) -> None:
    """Conecta-se em um endereço e porta sem efetuar autenticação do usuário, a qual deverá ser feita
 pelos métodos seguintes.<BR>
 Esta função é útil quando utilizada através do 'espaço interativo do script visual', onde a emulação
 do terminal é feita em uma janela do ContÁgil, podendo o usuário se autenticar através da própria
 janela de emulação do terminal (por exemplo, para permitir troca de senha).<BR>"""

    pass


  def desconecta(self) -> None:
    """Caso esteja com uma conexão ativa no terminal remoto, desconecta. Caso
 contrário, não faz nada."""

    pass


  def entrarMenu(self, texto) -> bool:
    """Procura um determinado texto na tela e, caso seja encontrado, simula um
 clique com o botão esquerdo do mouse ao lado esquerdo deste texto,
 seguido da tecla ENTER (isto é, como se fosse um item de menu que está
 sendo visitado)."""

    pass


  def enviaBackTAB(self) -> None:
    """Envia a tecla BACK-TAB para o terminal, geralmente obtida pelo teclado
 através de SHIFT+TAB"""

    pass


  def enviaENTER(self) -> None:
    """Envia para o terminal a tecla ENTER (isto é, simula que esta tecla foi
 pressionada)."""

    pass


  def enviaF1(self) -> None:
    """Envia para o terminal a tecla F1 (isto é, simula que esta tecla foi
 pressionada)."""

    pass


  def enviaF10(self) -> None:
    """Envia para o terminal a tecla F10 (isto é, simula que esta tecla foi
 pressionada)."""

    pass


  def enviaF11(self) -> None:
    """Envia para o terminal a tecla F11 (isto é, simula que esta tecla foi
 pressionada)."""

    pass


  def enviaF12(self) -> None:
    """Envia para o terminal a tecla F12 (isto é, simula que esta tecla foi
 pressionada)."""

    pass


  def enviaF2(self) -> None:
    """Envia para o terminal a tecla F2 (isto é, simula que esta tecla foi
 pressionada)."""

    pass


  def enviaF3(self) -> None:
    """Envia para o terminal a tecla F3 (isto é, simula que esta tecla foi
 pressionada)."""

    pass


  def enviaF4(self) -> None:
    """Envia para o terminal a tecla F4 (isto é, simula que esta tecla foi
 pressionada)."""

    pass


  def enviaF5(self) -> None:
    """Envia para o terminal a tecla F5 (isto é, simula que esta tecla foi
 pressionada)."""

    pass


  def enviaF6(self) -> None:
    """Envia para o terminal a tecla F6 (isto é, simula que esta tecla foi
 pressionada)."""

    pass


  def enviaF7(self) -> None:
    """Envia para o terminal a tecla F7 (isto é, simula que esta tecla foi
 pressionada)."""

    pass


  def enviaF8(self) -> None:
    """Envia para o terminal a tecla F8 (isto é, simula que esta tecla foi
 pressionada)."""

    pass


  def enviaF9(self) -> None:
    """Envia para o terminal a tecla F9 (isto é, simula que esta tecla foi
 pressionada)."""

    pass


  def enviaSetaParaBaixo(self) -> None:
    pass


  def enviaSetaParaCima(self) -> None:
    pass


  def enviaSetaParaDireita(self) -> None:
    pass


  def enviaSetaParaEsquerda(self) -> None:
    pass


  def enviaTAB(self) -> None:
    """Envia a tecla TAB para o terminal"""

    pass


  def enviaTECLA_PA1(self) -> None:
    """Envia para o terminal a tecla PA1 (isto é, simula que esta
 tecla foi pressionada)."""

    pass


  def enviaTECLA_PAGINA_ACIMA(self) -> None:
    """Envia para o terminal a tecla PAGINA PARA CIMA (isto é, simula que esta
 tecla foi pressionada)."""

    pass


  def enviaTECLA_PAGINA_BAIXO(self) -> None:
    """Envia para o terminal a tecla PAGINA PARA BAIXO (isto é, simula que esta
 tecla foi pressionada)."""

    pass


  def enviaTeclaHOME(self) -> None:
    """Envia a tecla HOME para o terminal."""

    pass


  def enviaTeclas(self, texto) -> None:
    """Envia um ou mais caracteres para o terminal (isto é, simula que essas
 teclas foram pressionadas).<BR>
 OBS: para enviar teclas de função (ex: F1, F2, ENTER, etc), utilize o
 método específico correspondente (ex:
 {@link Terminal#enviaENTER() enviaENTER} para enviar a tecla ENTER)."""

    pass


  def getColunaCursor(self) -> int:
    """Retorna a coluna atual em que está posicionado o cursor no terminal.<BR>
 Para terminais do tipo VT100, a primeira coluna começa no número 1.<BR>
 Para terminais do tipo TN3270, a primeira coluna começa no número 0."""

    pass


  def getLinhaCursor(self) -> int:
    """Retorna a linha atual em que está posicionado o cursor no terminal.<BR>
 Para terminais do tipo VT100, a primeira linha começa no número 1.<BR>
 Para terminais do tipo TN3270, a primeira linha começa no número 0."""

    pass


  def getMensagemServidor(self) -> str:
    """Obtém o conteúdo da linha de "mensagem do servidor". Isto é, o conteúdo
 da linha 23."""

    pass


  def getNumColunas(self) -> int:
    """Retorna a quantidade de colunas exibidas neste terminal."""

    pass


  def getNumLinhas(self) -> int:
    """Retorna a quantidade de linhas exibidas neste terminal."""

    pass


  def getSistema(self) -> str:
    """Retorna o nome do sistema onde tentou se conectar na última vez."""

    pass


  def getTela(self) -> TerminalPagina:
    """Obtém a tela atualmente apresentada no terminal."""

    pass


  def getTipoTerminal(self) -> str:
    """Retorna o tipo de emulação de terminal que este objeto foi configurado utilizar. Pode ser um de dois:<BR>
 TN3270 - para acessar sistemas no grande porte do Serpro (HOD)<BR>
 VT100 - para acessar sistemas no grande porte da Dataprev (Plenus)"""

    pass


  def isConectado(self) -> bool:
    """Retorna a indicação de que está conectado no terminal remoto"""

    pass


  def isSolicitaConfirmacao(self) -> bool:
    """Verifica se o terminal remoto está atualmente solicitando a confirmação
 de senha por algum motivo."""

    pass


  def isSolicitaDesbloqueio(self) -> bool:
    """Verifica se o terminal remoto está atualmente solicitando a liberação de
 um terminal que foi bloqueado"""

    pass


  def isSolicitaImpressora(self) -> bool:
    """Verifica se o terminal remoto está atualmente solicitando a indicação de
 uma impressora local"""

    pass


  def marcarX(self, texto) -> bool:
    """Procura um determinado texto na tela e, caso seja encontrado, simula um
 clique com o botão esquerdo do mouse ao lado direito do item, seguido da
 tecla X (isto é, como se estivesse marcando X em um item exibido na
 tela)."""

    pass


  def sairMenu(self, texto) -> None:
    """Caso o terminal remoto esteja apresentando um determinado texto, clica F3
 para sair da tela em que o texto é apresentado. Se a tela anterior também
 contém o texto, continua a clicar F3 até apresentar uma tela em que o
 texto não aparece."""

    pass


  def setTipoTerminal(self, tipoTerminal) -> None:
    """Configura o tipo de emulação de terminal a utilizar:<BR>
 TN3270 - para acessar sistemas no grande porte do Serpro (HOD)<BR>
 VT100 - para acessar sistemas no grande porte da Dataprev (Plenus)"""

    pass


  def toString(self) -> str:
    pass


  def vaiParaCampo(self, linha, coluna) -> None:
    """Move o cursor para campo em determinada posição (linha e coluna).<BR>
 Para terminais do tipo VT100, a primeira coluna e a primeira linha
 começam no número 1.<BR>
 Para terminais do tipo TN3270, a primeira coluna e a primeira linha
 começam no número 0."""

    pass


  def vaiParaPosicao(self, linha, coluna) -> None:
    """Move o cursor para uma determinada posição (linha e coluna).<BR>
 Para terminais do tipo VT100, a primeira coluna e a primeira linha
 começam no número 1.<BR>
 Para terminais do tipo TN3270, a primeira coluna e a primeira linha
 começam no número 0."""

    pass


  def vaiParaPosicaoAbaixo(self) -> None:
    """Move o cursor para a posição que corresponde a uma linha abaixo da linha
 atual. Diferentemente da função {@link Terminal#enviaSetaParaBaixo() enviaSetaParaBaixo}, 
 esta função altera diretamente a posição do cursor sem simular o envio da tecla 'seta
 para baixo', embora o efeito seja praticamente o mesmo, com a diferença de ser mais rápido
 desta forma."""

    pass


  def vaiParaPosicaoAcima(self) -> None:
    """Move o cursor para a posição que corresponde a uma linha acima da linha
 atual. Diferentemente da função {@link Terminal#enviaSetaParaCima() enviaSetaParaCima}, 
 esta função altera diretamente a posição do cursor sem simular o envio da tecla 'seta
 para cima', embora o efeito seja praticamente o mesmo, com a diferença de ser mais rápido
 desta forma."""

    pass


  def vaiParaPosicaoDireita(self) -> None:
    """Move o cursor para a posição que corresponde a uma posição à direita da posição
 atual. Diferentemente da função {@link Terminal#enviaSetaParaDireita() enviaSetaParaDireita}, 
 esta função altera diretamente a posição do cursor sem simular o envio da tecla 'seta
 para direita', embora o efeito seja praticamente o mesmo, com a diferença de ser mais rápido
 desta forma."""

    pass


  def vaiParaPosicaoEsquerda(self) -> None:
    """Move o cursor para a posição que corresponde a uma posição à esquerda da posição
 atual. Diferentemente da função {@link Terminal#enviaSetaParaEsquerda() enviaSetaParaEsquerda}, 
 esta função altera diretamente a posição do cursor sem simular o envio da tecla 'seta
 para esquerda', embora o efeito seja praticamente o mesmo, com a diferença de ser mais rápido
 desta forma."""

    pass


  def vaiParaUltimaLinha(self) -> None:
    """Envia uma sequência de comandos para posicionar o cursor na última linha
 do terminal"""

    pass


  def vaiParaUltimoCampo(self) -> None:
    """Move o cursor para o último campo da tela.<BR>"""

    pass

class TerminalIBM ():
  """Objeto que pode ser utilizado por uma linguagem de script para interagir com
 um terminal remoto (Telnet TN3270). Implementação fornecida pela própria IBM.
 <P>"""

  def autentica(self, endereco, chave, sistema) -> None:
    """Faz autenticação em um terminal remoto localizado em um determinado
 endereço de rede e com determinas credenciais de usuário."""

    pass


  def autentica(self, chave, sistema) -> None:
    """Faz autenticação em um terminal remoto localizado no endereço padrão
 10.3.254.1 e com determinas credenciais de usuário."""

    pass


  def desconectar(self) -> None:
    pass


  def enviarComandoSiscomex(self, comando) -> None:
    """Envia para o terminal o comando passado como argumento na linha COMANDO.....
 O proprio metodo procura na tela aonde esta a linha de comando
 e ao final aperta o [enter]"""

    pass


  def enviarTexto(self, texto) -> None:
    """Envia o texto passado por parâmetro para a tela do terminal, na posição em que o cursor se encontra"""

    pass


  def enviarTextoComPosicao(self, texto, row, col) -> None:
    """Envia o texto passado por parâmetro para a tela do terminal, na posição em que o cursor se encontra"""

    pass


  def esperarStringQualquerPosicao(self, s) -> None:
    pass


  def esperarTela(self) -> None:
    """Aguarda a tela do siscomex se estabilizar (terminar de carregar)
 para prosseguir"""

    pass


  def getTela(self) -> str:
    pass


  def lerTela(self, linha, coluna, tamanho) -> str:
    """Retorna uma string contendo o conteudo da tela que comeca na posicao (linha, coluna)
 e tem comprimento TAMANHO"""

    pass


  def procurarTextoNaTela(self, texto) -> bool:
    """Verifica se o texto passado como parametro esta escrito na tela em algum lugar"""

    pass


  def procurarTextoNaTela(self, texto, linha, col) -> bool:
    """Verifica se o texto passado como parametro esta escrito na tela comecando na posicao informada (linha, coluna)"""

    pass


  def toString(self) -> str:
    pass

class TerminalIBMChave ():
  """Implementação de "Chave" para autenticar um usuário ao servidor do HOD pelo protocolo telnet
 TN3270 e usando as bibliotecas da IBM. <br>
 A autenticação pode ser feita por certificado ou por um par de "login"/"senha".
 <p>
 Os métodos iniciados por 'authenticate' utilizam o browser para validar o usuário e iniciar os
 objetos de visualização de telas constantes das referidas bibliotecas.<br>
 Essa chave pode ser utilizada indiretamente ao ser passada como parâmetro para um outro método de
 uma outra classe do ContÁgil.
 <p>
 Observação: A "senha" não fica aparente no script e nem pode ser consultada pelo script. É o
 usuário quem deve digitar sua senha no momento da execução.
 <p>"""

  def actionPerformed(self, e) -> None:
    pass


  def addCampoAdicional(self, label, preenchimento, hint) -> None:
    """Adiciona campo adicional ao formulário de autenticação."""

    pass


  def addCampoAdicionalProtegido(self, label, preenchimento, hint) -> None:
    """Adiciona campo protegido adicional ao formulário de autenticação."""

    pass


  def changedUpdate(self, e) -> None:
    pass


  def getD(self) -> byte:
    """Detalhes da sessão."""

    pass


  def getMensagem(self) -> str:
    """Obtém "mensagem"."""

    pass


  def getOia(self) -> ECLOIA:
    """Obtém "oia"."""

    pass


  def getPs(self) -> ECLPS:
    """Obtém "ps"."""

    pass


  def getS(self) -> ECLSession:
    """Obtém "s"."""

    pass


  def insertUpdate(self, e) -> None:
    pass


  def isInvalida(self) -> bool:
    """Retorna a indicação de que a chave é inválida após a tentativa de autenticação.<BR>
 OBS: para saber se a chave é válida não basta criar a chave (isto é, não basta chamar o método
 getChaveImportacao). É preciso também que a chave seja utilizada em alguma rotina de
 autenticação (ex: na autenticação do sistema DW, ou na autenticação de uma rotina de
 importação, ou em outra situação qualquer envolvendo "Chave").<BR>
 Apenas depois de uma tentativa mal sucedida de autenticação é que é possível determinar se uma
 chave é inválida. Antes disso toda chave é considerada "válida", mesmo que ela não seja."""

    pass


  def isPin(self) -> bool:
    pass


  def isSair(self) -> bool:
    """Sai da chave."""

    pass


  def removeUpdate(self, e) -> None:
    pass


  def setCaptcha(self, utiliza) -> None:
    pass


  def setCertificado(self, certificado) -> None:
    """Atribui valor a "certificado"."""

    pass


  def setInvalida(self, b) -> None:
    pass


  def toString(self) -> str:
    pass


  def windowActivated(self, e) -> None:
    pass


  def windowClosed(self, e) -> None:
    pass


  def windowClosing(self, e) -> None:
    pass


  def windowDeactivated(self, e) -> None:
    pass


  def windowDeiconified(self, e) -> None:
    pass


  def windowIconified(self, e) -> None:
    pass


  def windowOpened(self, e) -> None:
    pass

class TerminalPagina ():
  """Objeto que pode ser utilizado por uma linguagem de scripting para obter o
 conteúdo de uma página consultada em um terminal remoto através do objeto
 {@link Terminal Terminal}.
 <P>"""

  def contem(self, texto) -> bool:
    """Verifica se esta página contém um determinado texto.<BR>
 Esta função procura a ocorrência do texto de diversas formas, em todas
 elas desprezando acentuação e caracteres de maiúsculas/minúsculas:<BR> -
 Considera o texto literalmente, sem considerar espaços em branco entre as
 palavras, dentro do conteúdo da página.<BR> - Considera o texto como se
 fosse uma "expressão regular", dentro do conteúdo da página.<BR>"""

    pass


  def extrai(self, padrao) -> str:
    """Extrai o conteúdo armazenado na página utilizando uma "expressão
 regular".<BR>
 Este método é análogo ao operador "EXTRAI" disponível no editor de
 fórmulas do MODELO ANALÍTICO DINÂMICO.<BR>
 Consulte o manual, livro GERAL, no capítulo referente à criação de
 atributos e métricas do MODELO ANALÍTICO DINÂMICO para obter mais
 informações sobre o operador "EXTRAI"."""

    pass


  def getCampo(self, termo) -> str:
    """Obtém o conteúdo que aparece na linha, começando na palavra identificada
 por "termo" e terminando no final da linha. Descarta o caractere "dois
 pontos" que aparece no início, caso exista esta possibilidade.<BR>
 Por exemplo, digamos que na tela aparece uma linha com o conteúdo:<BR>
 NOME: JOÃO DA SILVA<BR>
 Caso seja executado o método getCampo com o termo "NOME", obtém como
 resposta "JOÃO DA SILVA"."""

    pass


  def getColunaComTexto(self, expressao) -> int:
    """Retorna o número da coluna (começando em 0 se for terminal TN3270,
 começando em 1 se for terminal VT100) que contém uma determinada
 expressão regular.<BR>
 Se houver mais de uma ocorrência, retorna apenas a primeira delas."""

    pass


  def getInteiroTeor(self) -> str:
    """Retorna o conteúdo completo desta tela (isto é, todas as suas linhas e
 colunas). Este texto geralmente se inicia pelo caractere de nova linha. Há
 um caractere de nova linha em cada uma das linhas."""

    pass


  def getLinha(self, i) -> str:
    """Retorna o conteúdo da linha indicada como parâmetro."""

    pass


  def getLinhaComTexto(self, expressao) -> int:
    """Retorna o número da linha (começando em 0 se for terminal TN3270,
 começando em 1 se for terminal VT100) que contém uma determinada
 expressão regular.<BR>
 Se houver mais de uma ocorrência, retorna apenas a primeira delas."""

    pass


  def getLinhas(self) -> str:
    """Retorna um vetor com o conteúdo de cada linha do terminal."""

    pass


  def setCampo(self, termo, valor) -> bool:
    """Altera o conteúdo de um campo que aparece na linha. Isto é, este método realiza duas
 atividades:<BR>
 1) Procura na 'tela' atual por um determinado 'texto', o qual é indicado no primeiro
 parâmetro deste método.<BR>
 2) Se encontrou o texto, altera a posição do 'cursor' na tela para o final do texto encontrado (ex: se o texto procurado
 é "NOME", posiciona o cursor na (linha,coluna) localizada logo após a palavra "NOME". Se houver o caractere 'dois pontos',
 lembre-se de inclui-lo no 'texto' a ser pesquisado (ex: "NOME :").<BR>
 3) Preenche esta parte da tela com o conteúdo indicado no segundo parâmetro deste método."""

    pass


  def setCampo(self, termo, valor, fim) -> bool:
    """Altera o conteúdo de um campo que aparece na linha. Isto é, este método realiza duas
 atividades:<BR>
 1) Procura na 'tela' atual por um determinado 'texto', o qual é indicado no primeiro
 parâmetro deste método.<BR>
 2) Se encontrou o texto, altera a posição do 'cursor' na tela para o ínicio ou final do texto encontrado dependendo do parâmetro "fim".
 (ex: se o parâmetro "fim" for verdadeiro e o texto procurado for "NOME", posiciona o cursor na (linha,coluna) localizada logo após a
 palavra "NOME". Se houver o caractere 'dois pontos', lembre-se de inclui-lo no 'texto' a ser pesquisado (ex: "NOME :").<BR>
 3) Preenche esta parte da tela com o conteúdo indicado no segundo parâmetro deste método."""

    pass


  def setCamposAutenticacao(self, termoLogin, termoSenha, chave) -> bool:
    """Método utilizado para definir dois campos típicos de 'autenticação' (isto é, um 'login' e uma 'senha').<BR>
 Diferentemente do método {@link Terminal#autentica(Chave, String) autentica} do objeto {@link Terminal Terminal}, este
 método tem o objetivo de realizar uma 'segunda autenticação' nas hipóteses em que isso for necessário (usualmente em
 sistemas que requerem uma autenticação especial para realizar alguma 'transação' internamente).<BR>
 O conteúdo do 'login' e da 'senha' digitados pelo usuário não são indicados aqui de forma 'explícita', mas sim na forma 
 de um objeto {@link Chave Chave} que pode ser obtido através de {@link Chaves#getChaveImportacaoSemCPF(String, String) getChaveImportacaoSemCPF}
 ou de algum outro método de {@link Chaves Chaves}.<BR>
 Os primeiros dois parâmetros deste método apenas devem indicar os 'rótulos' que são apresentados na tela para preenchimento
 do login e da senha correspondentes. Por exemplo, se a tela apresenta os rótulos "Login :" e "Senha :", os primeiros dois parâmetros
 deste método são "Login :" e "Senha :"."""

    pass


  def toString(self) -> str:
    pass

class TesteHipoteses ():
  """Esta classe apresenta uma série de métodos que possibilitam realizar alguns
 testes estatísticos de hipóteses."""

  def getKolmogorovSmirnovEstatistica(self, valores1, valores2) -> float:
    """Aplica o teste 'Kolmogorov-Smirnov' para testar a hipótese de que uma relação de valores se
 distribui conforme a mesma distribuição que outra relação de valores.<BR>
 O valor retornado por esta função é a 'estatística' que pode ser depois comparada com uma
 tabela de distribuição D(n) conforme explicado em: http://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test.<BR>"""

    pass


  def getKolmogorovSmirnovEstatistica(self, formula, valores) -> float:
    """Aplica o teste 'Kolmogorov-Smirnov' para testar a hipótese de que uma relação de valores se
 distribui conforme uma determinada distribuição.<BR>
 O valor retornado por esta função é a 'estatística' que pode ser depois comparada com uma
 tabela de distribuição D(n) conforme explicado em: http://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test.<BR>
 ATENÇÃO: a fórmula indicada deve ser uma fórmula no padrão do ContÁgil sobre uma variável independente X que retorne algo
 compatível com uma 'função distribuição acumulada'. Por exemplo, "NORMAL.ACUM(X;0;1)" pode ser utilizado para comparar com
 a distribuição NORMAL de média 0 e desvio padrão 1."""

    pass


  def getKolmogorovSmirnovValorP(self, formula, valores) -> float:
    """Aplica o teste 'Kolmogorov-Smirnov' para testar a hipótese de que uma relação de valores se
 distribui conforme uma determinada distribuição.<BR>
 O valor retornado por esta função é o valor 'P' obtido após comparação da estatística com a tabela de distribuição D(n) conforme explicado em: http://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test.<BR>
 Geralmente um valor inferior a 0,05 indica que 'rejeitamos' a hipótese de que os valores seguem a distribuição informada no primeiro parâmetro com 95% de confiança, e um valor superior a 0,05
 indica que não rejeitamos (isto é, que mantemos a hipótese de que os valores seguem esta distribuição).<BR>
 ATENÇÃO: a fórmula indicada deve ser uma fórmula no padrão do ContÁgil sobre uma variável independente X que retorne algo
 compatível com uma 'função distribuição acumulada'. Por exemplo, "NORMAL.ACUM(X;0;1)" pode ser utilizado para comparar com
 a distribuição NORMAL de média 0 e desvio padrão 1."""

    pass


  def getKolmogorovSmirnovValorP(self, valores1, valores2) -> float:
    """Aplica o teste 'Kolmogorov-Smirnov' para testar a hipótese de que uma relação de valores se
 distribui conforme a mesma distribuição que outra relação de valores.<BR>
 O valor retornado por esta função é o valor 'P' obtido após comparação da estatística com a tabela de distribuição D(n) conforme explicado em: http://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test.<BR>
 Geralmente um valor inferior a 0,05 indica que 'rejeitamos' a hipótese de que os valores seguem a distribuição informada no primeiro parâmetro com 95% de confiança, e um valor superior a 0,05
 indica que não rejeitamos (isto é, que mantemos a hipótese de que os valores seguem esta distribuição).<BR>"""

    pass

class Textos ():
  """Disponibiliza diversos métodos que podem ser úteis no tratamento de textos."""

  def contarRepeticoes(self, texto, expressao) -> int:
    """Conta quantas vezes a expressão está repetida em um texto.<BR>"""

    pass


  def converteJsonToTabela(self, json) -> Tabela:
    """Converte um conteúdo JSON genérico em uma tabela genérica, onde as colunas expõem todas as colunas, incluindo
 relações 1:1 e 1:N<BR>
 Os nomes das colunas da tabela são escolhidos de acordo com os nomes dos campos apresentados no conteúdo JSON.<BR>
 Caso existam relações hierárquicas entre os campos apresentados no conteúdo JSON, os nomes das colunas correspondentes, na tabela,
 são gerados por concatenação dos nomes desses campos, conforme a hierarquia, separando-os pelo caractere ponto.<BR>
 Conteúdo booleano é convertido para os tipos booleanos correspondentes.<BR>
 Conteúdo numérico é convertido para o formato correspondente, dependendo se é inteiro ou ponto flutuante.<BR>
 Os demais conteúdos são convertidos para texto."""

    pass


  def converteJsonToXML(self, json) -> XMLTag:
    """Converte um conteúdo JSON genérico em XML, onde as relações 1:1 e 1:N do conteúdo JSON são representados em XML.
 Os campos simples são convertidos para 'atributos' e os campos complexos são convertidos para 'tags' internas.<BR>
 A primeira tag tem o nome 'JSON'.<BR>
 Caso o JSON corresponda a um array de elementos, cada elemento é representado na forma de uma tag chamada 'elemento'.
 Conteúdo booleano é convertido para os textos SIM e NÃO.<BR>
 Conteúdo numérico é convertido para o formato correspondente, dependendo se é inteiro ou ponto flutuante, apresentando a vírgula como separador de casas decimais.<BR>
 Os demais conteúdos são tratados como texto."""

    pass


  def converteTextoToJson(self, json) -> ElementoJson:
    """Converte um conteúdo JSON que está no formato TEXTO para um objeto {@link ElementoJson ElementoJson} que pode ser utilizado
 para interpretar seu conteúdo em um script."""

    pass


  def criptografaTexto(self, texto, formatoEntrada, formatoSaida) -> str:
    """Dado um conteúdo qualquer, criptografa o conteúdo utilizando o certificado digital do usuário autenticado.<BR>
 Tendo em vista que a criptografia trabalha sobre conteúdo binário, é necessário indicar o formato como o conteúdo binário é representado, seja no parâmetro de entrada,
 seja no retorno do método. O formato deve ser um dos seguintes:<BR>
 TEXTO: o conteúdo binário é extraído do texto utilizando codificação UTF8. Este é o padrão para um texto qualquer, arbitrário, que se quer criptografar. Esta opção de formato se aplica apenas ao parâmetro de entrada deste método.<BR>
 BASE64: o conteúdo binário é convertido para 'base64'.<BR>
 HEXA: o conteúdo binário é representado pela notação 'hexadecimal'.<BR>"""

    pass


  def descriptografaTexto(self, texto, formatoEntrada, formatoSaida) -> str:
    """Dado um conteúdo qualquer que foi criptografado com a função {@link #criptografaTexto(String) criptografaTexto}, descriptografa o conteúdo utilizando o 
 token do usuário autenticado.<BR>
 Tendo em vista que a criptografia trabalha sobre conteúdo binário, é necessário indicar o formato como o conteúdo binário é representado, seja no parâmetro de entrada,
 seja no retorno do método. O formato deve ser um dos seguintes:<BR>
 TEXTO: o conteúdo binário é inserido no texto utilizando codificação UTF8. Este é o padrão para um texto qualquer, arbitrário, que se quer descriptografar. Esta opção de formato se aplica apenas ao retorno deste método.<BR>
 BASE64: o conteúdo binário é convertido para 'base64'.<BR>
 HEXA: o conteúdo binário é representado pela notação 'hexadecimal'.<BR>"""

    pass


  def extraiEstruturaTexto(self, texto, expressao, trataExpressao) -> Tabela:
    """Alternativa do método {@link Textos#extraiEstruturaTexto(String, String) extraiEstruturaTexto} onde é possível
 indicar um terceiro parâmetro indicando se deseja ou não que o ContÁgil faça um 'tratamento prévio' sobre a
 expressão regular que está sendo utilizada. O padrão é fazer o tratamento prévio, o que significa que a expressão
 regular indicada no segundo parâmetro pode ser modificada de tal modo a considerar algumas situações adicionais
 que, de outro modo, demandariam atenção adicional do usuário, o que tornaria mais complexo o trabalho de criar expressões regulares.<BR>
 Porém, se não desejar que o ContÁgil faça este tratamento prévio sobre a expressão regular indicada no segundo parâmetro, indique FALSO
 no terceiro parâmetro."""

    pass


  def extraiEstruturaTexto(self, texto, expressao) -> Tabela:
    """Dado um texto qualquer, extrai sua "estrutura" interna na forma de uma
 "tabela".<BR>
 Neste método é solicitada uma "expressão", a qual é então utilizada para
 procurar padrões no texto considerado e reportar as ocorrências em linhas
 diferentes da tabela.<BR>
 A "expressão" pode ser codificada na forma de uma "expressão regular".<BR>
 Opcionalmente pode-se incluir nesta expressão regular a sintaxe adotada
 para "grupo de captura" (abre e fecha parêntesis em torno da expressão
 que deve ser capturada). Caso esteja presente, apenas o conteúdo dentro
 do grupo de captura (dentro do abre e fecha parentesis) é que é retornada
 dentro desta tabela.<BR>
 Caso o "grupo de captura" não seja informado dentro desta expressão
 regular, o ContÁgil recupera somente a informação que segue "após" a
 expressão regular, até o final de uma linha do texto (este é o conteúdo
 "capturado" do texto original na ausência de um grupo de captura).<BR>
 As linhas da tabela correspondem às ocorrências da expressão regular.<BR>
 A coluna da tabela corresponde ao conteúdo do texto que foi efetivamente
 "capturado". Caso a expressão regular inclua mais de um grupo de captura,
 mais de uma coluna é inserida na tabela.<BR>
 O caractere "nova linha", que é utilizado para quebrar linhas no texto, é
 representado pelo símbolo "\n" na expressão regular.<BR>
 <BR>
 Exemplos:<BR>
 Digamos que existe um texto da seguinte forma (UM TEXTO COM DIVERSAS
 LINHAS):<BR>
 <CODE> ===============================================================<BR>
 DENATRAN/PR &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; R E N A V A
 M &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20/03/12<BR>
 CHASSI/VIN: 12345656 PLACA: ABC1234 UF: PR &nbsp;&nbsp;&nbsp; ANO: 1990<BR>
 MARCA/MODELO: M.BENZ COR:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SITUACAO:
 CIRCULACAO<BR>
 <BR>
 CHASSI/VIN: 44445656 PLACA: DDD1111 UF: PR &nbsp;&nbsp;&nbsp; ANO: 1995<BR>
 MARCA/MODELO: M.BENZ COR:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SITUACAO:
 CIRCULACAO<BR>
 <BR>
 CHASSI/VIN: 55545656 PLACA: EEE2222 UF: PR &nbsp;&nbsp;&nbsp; ANO: 2010<BR>
 MARCA/MODELO: M.BENZ COR:
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SITUACAO:
 CIRCULACAO<BR>
 ===============================================================<BR>
 </CODE> Para extrair do texto acima somente os "anos", pode-se utilizar a
 seguinte expressão (sem grupo de captura):<BR>
 &nbsp;&nbsp;&nbsp;"ANO:"<BR>
 <BR>
 O resultado é uma tabela contendo 3 linhas e 1 coluna:<BR>
 1990<BR>
 1995<BR>
 2010<BR>
 <BR>
 Para extrair do texto acima somente as "placas", pode-se utilizar a
 seguinte expressão (com um grupo de captura):<BR>
 &nbsp;&nbsp;&nbsp;"PLACA: (.{7})"<BR>
 <BR>
 O resultado é uma tabela contendo 3 linhas e 1 coluna:<BR>
 ABC1234<BR>
 DDD1111<BR>
 EEE2222<BR>
 <BR>
 Para extrair do texto acima as "placas" e também os "anos", pode-se
 utilizar a seguinte expressão (com dois grupos de captura):<BR>
 &nbsp;&nbsp;&nbsp;"PLACA: (.{7}) .* ANO: (.{4})"<BR>
 <BR>
 O resultado é uma tabela contendo 3 linhas e 2 colunas:<BR>
 ABC1234&nbsp;&nbsp;&nbsp;1990<BR>
 DDD1111&nbsp;&nbsp;&nbsp;1995<BR>
 EEE2222&nbsp;&nbsp;&nbsp;2010<BR>
 <BR>
 Para extrair do texto acima os chassis, as placas, as UF's, os anos, as
 marcas, as cores e as situações (com vários grupos de captura):<BR>
 &nbsp;&nbsp;&nbsp;"CHASSI/VIN: (.*) PLACA: (.*) UF: (.*) ANO:
 (.*)\nMARCA/MODELO: (.*) COR: (.*) SITUACAO: (.*)"<BR>
 <RB> <BR>
 OBS: O caractere especial de código 13 (código ASCII para o "retorno") é
 sempre ignorado caso esteja presente no texto.<BR>
 OBS2: Na expressão regular utilizada neste método não é necessário
 especificar a "quantidade exata de espaços em branco" contidas dentro da
 expressão, pois em qualquer parte da expressão regular onde apareça um
 espaço em branco, este método considera a possibilidade de haver mais de
 um. Ou seja, ao invés de incluir algo do tipo "\s+" dentro da expressão
 para representar um ou mais espaços em branco, basta indicar " " (sem as
 aspas, isto é, um só espaço em branco). Este método interpreta isso como
 sendo "um ou mais espaços em branco" (trata-se de um comportamento
 especial deste método, não se trata do comportamento padrão para
 expressões regulares em geral). Veja os exemplos acima.<BR>"""

    pass


  def getAlgarismos(self, texto) -> str:
    """Dado um texto contendo algarismos, retorna apenas os algarismos. Por exemplo, um texto do tipo "12.345.678/0001-10" será
 convertido para "12345678000110"."""

    pass


  def getExpressaoRegular(self, texto, expressao) -> str:
    """Dado um texto qualquer, obtém uma parte dele com base em uma expressão
 regular. Se houver indicação de um grupo de captura dentro da expressão
 regular, somente ele é retornado. Caso contrário, retorna todo o trecho
 que se aplica à expressão regular.<br>
 Caso a inteção seja recuperar o conteúdo de várias linhas deve-se incluir
 o código "(?s)" no início da expressão regular. Isso fará com que todo o texto,
 incluindo quebras de linha, sejam retornados."""

    pass


  def getISO88591(self, texto) -> str:
    pass


  def getIndiceExpressaoRegular(self, texto, expressao, inicio, partindoDe) -> int:
    """Alternativa de busca de exressão regular, com inclusão de parâmetro adicional para indicar
 a posição no texto a partir da qual deve iniciar a busca, desprezando tudo que vem antes."""

    pass


  def getIndiceExpressaoRegular(self, texto, expressao, inicio) -> int:
    """Retorna o índice em que uma expressão regular pode ser localizada em um texto.<BR>
 O índice retornado é uma posição no texto, começando em 0.<BR>"""

    pass


  def getIndiceParteTexto(self, texto, trecho) -> int:
    """Retorna o índice em que um trecho pode ser localizado em um texto.<BR>
 O índice retornado é uma posição no texto, começando em 0.<BR> 
 A comparação é realizada de forma a diferenciar maiúsculas/minúsculas e
 acentuação."""

    pass


  def getIndiceParteTexto(self, texto, trecho, partindoDe) -> int:
    """Alternativa de busca de texto dentro de outro texto, com inclusão de parâmetro adicional para indicar
 a posição no texto a partir da qual deve iniciar a busca, desprezando tudo que vem antes."""

    pass


  def getIndicesExpressaoRegular(self, texto, expressao, inicio) -> int:
    """Retorna todos os índices em que uma expressão regular pode ser localizada em um texto.<BR>
 Os índices retornados são posições no texto, começando em 0 para a primeira posição.<BR>"""

    pass


  def getIndicesParteTexto(self, texto, trecho) -> int:
    """Retorna todos os índices em que um trecho pode ser localizado em um texto.<BR>
 O índice retornado é uma posição no texto, começando em 0.<BR>
 A comparação é realizada de forma a diferenciar maiúsculas/minúsculas e
 acentuação."""

    pass


  def getLinhas(self, texto) -> Lista:
    """Quebra um texto em linhas. Admite como quebra de linha as combinações de caracteres ASC 13 e ASC 10 ou somente o caractere ASC 10."""

    pass


  def getLinhasComecando(self, textoOndePesquisar, texto, ignoraAcentosDifTamanho) -> Lista:
    """Percorre o conteúdo de um texto que contém múltiplas linhas e coleta em uma lista todas as linhas que começam com um determinado texto."""

    pass


  def getLinhasContemTexto(self, textoOndePesquisar, texto, ignoraAcentosDifTamanho) -> Lista:
    """Percorre o conteúdo de um texto que contém múltiplas linhas e coleta em uma lista todas as linhas que possuem um determinado
 texto."""

    pass


  def getParteTexto(self, texto, inicio, tamanho) -> str:
    """Dado um texto qualquer, obtém uma parte dele."""

    pass


  def getTextoEntreAspasDuplas(self, texto) -> str:
    """Dado um texto contendo outro texto localizado entre aspas duplas (considerando diferentes possibilidades
 de representação do caractere de aspas duplas internamente), extrai este texto interno. Caso não encontre,
 retorna vazio."""

    pass


  def getTextoLetrasMaiusculas(self, texto) -> str:
    """Dado um texto qualquer, obtém um outro texto onde todas as letras estão
 em caixa alta (letras maiúsculas)."""

    pass


  def getTextoLetrasMinusculas(self, texto) -> str:
    """Dado um texto qualquer, obtém um outro texto onde todas as letras estão
 em caixa baixa (letras minúsculas)."""

    pass


  def getTextoSemAcentuacao(self, texto) -> str:
    """Dado um texto qualquer, obtém um outro texto onde os caracteres especiais
 de acentuação são removidos (ex: acento agudo, cedilha, etc.)."""

    pass


  def getTextoSemEspacos(self, texto) -> str:
    """Dado um texto qualquer, obtém um outro texto onde os espaços em branco
 no início e no final são removidos."""

    pass


  def getTextoSemEspacos(self, texto, removeEspacosIntermediarios) -> str:
    """Dado um texto qualquer, obtém um outro texto onde os espaços em branco
 no início e no final são removidos."""

    pass


  def getUTF16LE(self, texto) -> str:
    pass


  def getUTF8(self, texto) -> str:
    pass


  def hasExpressaoRegular(self, texto, expressao) -> bool:
    """Verifica se uma expressão regular pode ser localizada em um texto.<BR>"""

    pass


  def hasParteTexto(self, texto, trecho) -> bool:
    """Verifica se um trecho pode ser localizado em um texto.<BR>
 A comparação é realizada de forma a diferenciar maiúsculas/minúsculas e
 acentuação."""

    pass


  def quebraTexto(self, texto, expressao) -> Lista:
    """Dado um texto qualquer, faz a "quebra" do texto em partes, utilizando
 como critério de quebra uma expressão regular.<BR>
 O resultado é uma lista contendo os "pedaços" do texto original.<BR>
 Como o parâmetro é uma expressão regular, e não apenas caracteres,
 ao utilizar caracteres com significado especial em expressões regulares,
 como "|","(", ")", ".", é necessário tomar o cuidado de indicar que esses
 caracteres devem ser interpretados como caracteres normais, através do uso
 do caracter de escape "\" antes de cada um. <BR>
 Por exemplo, para quebrar um texto onde há separação de valores com o
 caractere barra vertical "|", basta especificar "\|" no
 parâmetro "expressao".<BR>
 Caso deseje utilizar a "tabulação" como critério de quebra, especifique
 "\t".<BR>
 Caso deseje utilizar o caractere indicativo de "nova linha" como critério
 de quebra, especifique "\n".<BR>
 É possível indicar uma expressão regular que aceite vários caracteres como
 separadores, como por exemplo ";|:|\t|\|", que aceita ";", ":", caracter de 
 tabulação ou "|".<BR>
 Note que diferentemente do método
 {@link Textos#extraiEstruturaTexto(String, String) extraiEstruturaTexto},
 este método aproveita todo o conteúdo do texto original, exceto apenas
 pelos caracteres utilizados como critério de quebra do texto."""

    pass


  def removeExpressaoRegular(self, texto, expressao) -> str:
    """Dado um texto qualquer, retorna um novo texto removendo todas as partes do texto que se aplicam à expressão regular.<BR>
 Neste método deve ser indicada uma expressão regular que é procurada no
 texto original, correspondendo à parte que deve ser removida. Se
 nenhuma parte do texto original atende à expressão regular, nenhuma
 exclusão é feita.<BR>
 OBS: se houver mais de uma ocorrência da mesma expressão regular no texto
 original, todas as ocorrências são removidas.<BR>"""

    pass


  def substituiExpressaoRegular(self, texto, expressao, novo) -> str:
    """Dado um texto qualquer, retorna um novo texto com uma parte substituída.<BR>
 Este método difere do método
 {@link Textos#substituiParteTexto(String, String, String) substituiParteTexto}
 no sentido que este utiliza uma "expressão regular", ao passo que o outro
 utiliza um texto normal.<BR>
 Neste método deve ser indicada uma expressão regular que é procurada no
 texto original, correspondendo à parte que deve ser substituída. Se
 nenhuma parte do texto original atende à expressão regular, nenhuma
 substituição é feita.<BR>
 No seguinte exemplo, o número "123" é substituído por "NOTA", resultando
 em "PAGAMENTO NOTA":<BR>
 substituiExpressaoRegular("PAGAMENTO 123","\d+","NOTA")<BR>
 OBS: se houver mais de uma ocorrência da mesma expressão regular no texto
 original, todas as ocorrências são substituídas pelo novo texto.<BR>
 Utilização avançada: opcionalmente pode ser indicado parêntesis na
 expressão regular, o que indica que o conteúdo interno a eles pode ser
 referenciado na expressão que a substitui. Trata-se também de uma
 convenção prevista na sintaxe da expressão regular. Para cada "grupo de
 captura" (isto é, para cada abre/fecha parêntesis) pode haver na
 expressão nova uma referência a ele, indicado através do caractere "$"
 seguido do número do grupo (o primeiro é o grupo de número 1, o segundo é
 o grupo de número 2, e assim sucessivamente).<BR>
 Exemplo:<BR>
 substituiExpressaoRegular("PAGAMENTO 123","(\d+)","NOTA $1")<BR>
 O exemplo acima substitui o texto "PAGAMENTO 123" por "PAGAMENTO NOTA
 123". Note que o conteúdo "123" é substituído por "NOTA 123", pois neste
 exemplo é utilizado o "grupo de captura"."""

    pass


  def substituiExpressaoRegular(self, texto, expressao, primeiro, intermediario, ultimo) -> str:
    """Função alternativa de 'substituiExpressaoRegular' que permite indicar uma substituição diferente para a primeira
 ocorrência da expressão regular encontrada, outra substituição diferente para a última ocorrência da expressão regular
 encontrada, substituindo as demais ocorrências por outros valores."""

    pass


  def substituiExpressaoRegular(self, texto, expressao, primeiro, intermediario, ultimo, ignoraPrimeiros) -> str:
    """Função alternativa de 'substituiExpressaoRegular' que permite indicar uma substituição diferente para a primeira
 ocorrência da expressão regular encontrada, outra substituição diferente para a última ocorrência da expressão regular
 encontrada, substituindo as demais ocorrências por outros valores."""

    pass


  def substituiExpressaoRegular(self, texto, expressao, primeiro, intermediario, ignoraPrimeiros) -> str:
    """Função alternativa de 'substituiExpressaoRegular' que permite indicar uma substituição diferente para a primeira
 ocorrência da expressão regular encontrada, substituindo as demais ocorrências por outros valores."""

    pass


  def substituiExpressaoRegular(self, texto, expressao, primeiro, intermediario) -> str:
    """Função alternativa de 'substituiExpressaoRegular' que permite indicar uma substituição diferente para a primeira
 ocorrência da expressão regular encontrada, substituindo as demais ocorrências por outros valores."""

    pass


  def substituiParteTexto(self, texto, trecho, novo) -> str:
    """Dado um texto qualquer, retorna um novo texto com uma parte substituída.<BR>
 Neste método deve ser indicado um trecho do texto original que deve ser
 substituído. Se este trecho não é localizado no texto original, nenhuma
 substituição é feita.<BR>
 A comparação é realizada de forma a diferenciar maiúsculas/minúsculas e
 acentuação.<BR>
 No seguinte exemplo, a palavra "SALARIO" é substituída por "FERIAS",
 resultando em "PAGAMENTO DE FERIAS":<BR>
 substituiParteTexto("PAGAMENTO DE SALARIO","SALARIO","FERIAS")<BR>
 OBS: se houver mais de uma ocorrência do mesmo trecho no texto original,
 todas as ocorrências são substituídas pelo novo texto."""

    pass


  def substituiParteTexto(self, texto, inicio, tamanho, novo) -> str:
    """Dado um texto qualquer, retorna um novo texto com uma parte substituída.<BR>
 No seguinte exemplo, a palavra "SALARIO" é substituída por "FERIAS",
 resultando em "PAGAMENTO DE FERIAS":<BR>
 substituiParteTexto("PAGAMENTO DE SALARIO",13,7,"FERIAS")"""

    pass


  def toString(self, lista) -> str:
    """Dada uma lista qualquer, converte em texto. Seu conteúdo é convertido em texto simples (por exemplo,
 datas são representadas na forma DD/MM/AAAA, valores decimais são representados com vírgula, etc.).<BR>
 Os diferentes valores são separados por vírgula.<BR>
 Para mais opções, consulte as alternativas deste método."""

    pass


  def toString(self, lista, separacaoCampos) -> str:
    """Dada uma lista qualquer, converte em texto. Seu conteúdo é convertido em texto simples (por exemplo,
 datas são representadas na forma DD/MM/AAAA, valores decimais são representados com vírgula, etc.).<BR>
 Os diferentes valores são separados pelo conteúdo do parâmetro informado neste método.<BR>
 Para mais opções, consulte as alternativas deste método."""

    pass


  def toString(self, lista, separacaoCamposIniciais, separacaoFinal) -> str:
    """Dada uma lista qualquer, converte em texto. Seu conteúdo é convertido em texto simples (por exemplo,
 datas são representadas na forma DD/MM/AAAA, valores decimais são representados com vírgula, etc.).<BR>
 Os diferentes valores são separados pelo conteúdo do parâmetro informado neste método, exceto com relação
 ao penúltimo e último campos, que são separados pelo último parâmetro informado.<BR>
 Para mais opções, consulte as alternativas deste método.<BR>
 <BR>
 OBS: este método é útil quando deseja apresentar uma lista na forma de um texto que pode ser utilizado
 como um 'parágrafo' em linguagem natural, com vírgula e um espaço em branco para separar os elementos iniciais e o conector 'e' para separar os
 dois últimos, tal como ocorre naturalmente na língua portuguesa."""

    pass

class TipoCFOP ():
  """Abstração de um TipoCFOP sob o ponto de vista de uma linguagem de script."""

  def getCfop(self) -> int:
    """Obtém o código CFOP."""

    pass


  def getDescricao(self) -> str:
    """Obtém a descrição para o código CFOP."""

    pass


  def isReceitaBruta(self) -> bool:
    """Indicador de CFOP referente a receita bruta."""

    pass


  def isRemessa(self) -> bool:
    """Indicador de CFOP referente a remessa."""

    pass

class Vetores ():
  """Objeto utilizado para criar no script um novo "VETOR" (ou "array", como é
 mais conhecido em linguagens de programação).<BR>
 
 Um "vetor" é como uma "matriz" que possui apenas uma "coluna". Isto é, uma
 relação de valores.<BR>
 
 Um "vetor" é diferente de uma "lista" no sentido que ele não pode "crescer"
 (isto é, uma vez estabelecido seu tamanho inicial, não é possível aumentar e
 nem diminuir).<BR>
 
 Na linguagem de script este objeto "Vetores" é chamado de "vetores". A partir
 dele pode-se criar novos vetores (ele não é por si só um vetor).<BR>
 
 Além de "vetores", podem ser trabalhados também no script do ContÁgil outras
 estruturas de dados, por exemplo:<BR> - {@link Tabela Tabela} criada pelo
 objeto {@link Tabelas Tabelas}<BR> - {@link Lista Lista} criada pelo objeto
 {@link Listas Listas}<BR> - {@link Agregador Agregador} criada pelo objeto
 {@link Agregador Agregador}<BR>"""

  def compara(self, vetor1, vetor2) -> bool:
    """Compara o conteúdo de dois vetores quaisquer para saber se são iguais.<BR>
 Dois vetores serão considerados iguais se possuírem o mesmo tamanho e se seus elementos
 nas posições equivalentes forem os mesmos (isto é, compara o primeiro elemento de um vetor
 com o primeiro elemento do segundo, depois o segundo elemento de um vetor com o segundo
 elemento do terceiro, e assim em diante). Note, portanto, que a ordem dos elementos no vetor
 é relevante."""

    pass


  def moveElementos(self, vetor, primeiroElemento, ultimoElemento, posicoes) -> None:
    """Move um conjunto de elementos do vetor algumas posições para frente ou para trás. Os 'espaços deixados para trás' são ocupados
 pelos elementos posteriores ou anteriores.<BR>
 Por exemplo, se o vetor possui os números "1", "2", "3" e "4" e se o segundo e o terceiro elementos são 'movidos'
 uma posição para frente (isto é, para o final do vetor), então o vetor passa a listar elementos com conteúdos "1", "4", "2" e "3".<BR>
 Se os elementos forem movidos para uma posição anterior ao primeiro, mantém na primeira posição. Se forem movidos para uma posição posterior
 à última, mantém na última posição. Para mover um único elemento, informe o mesmo número nos parâmetros 'primeiroElemento' e 'ultimoElemento'"""

    pass


  def novoVetor(self, primeiraData, ultimaData) -> Object:
    """Cria um novo "vetor" já preenchido com datas de um intervalo. A lista
 cronológica pode ser ascendente ou descendente dependendo se a primeira
 data é menor ou maior que a última."""

    pass


  def novoVetor(self, tamanho) -> Object:
    """Cria um novo "vetor" com o tamanho especificado no parâmetro.<BR>
 Para mais informações sobre o que são "vetores", consulte na documentação
 pela referência {@link Vetores Vetores}."""

    pass


  def novoVetor(self, valores) -> Object:
    """Cria um novo vetor com os valores passados por parâmetro"""

    pass


  def novoVetor(self, primeiroMes, ultimoMes) -> Object:
    """Cria um novo "vetor" já preenchido com meses de um intervalo. A lista
 cronológica pode ser ascendente ou descendente dependendo se o primeiro
 mês é menor ou maior que o último.<BR>
 A 13a competência nunca é incluída na relação."""

    pass


  def novoVetor(self, primeiroMes, ultimoMes, intervalo) -> Object:
    """Cria um novo "vetor" já preenchido com meses de um intervalo. A lista
 cronológica pode ser ascendente ou descendente dependendo se o primeiro
 mês é menor ou maior que o último.<BR>
 A 13a competência nunca é incluída na relação."""

    pass


  def novoVetor(self, primeiroNumero, ultimoNumero) -> Object:
    """Cria um novo "vetor" já preenchido com números de um intervalo. A lista
 numérica pode ser ascendente ou descendente dependendo se o primeiro
 número é menor ou maior que o último."""

    pass


  def novoVetor(self, primeiraData, ultimaData, intervalo) -> Object:
    """Cria um novo "vetor" já preenchido com datas de um intervalo. A lista
 cronológica pode ser ascendente ou descendente dependendo se a primeira
 data é menor ou maior que a última."""

    pass


  def novoVetor(self, primeiroNumero, ultimoNumero, intervalo) -> Object:
    """Cria um novo "vetor" já preenchido com números de um intervalo. A lista
 numérica pode ser ascendente ou descendente dependendo se o primeiro
 número é menor ou maior que o último."""

    pass


  def paraTexto(self, vetor, separador, encapsuladorTextos) -> str:
    """Converte um vetor em um texto, separando os elementos do vetor através de um caractere
 separador que é indicado no parâmetro."""

    pass


  def paraTexto(self, vetor, separador) -> str:
    """Converte um vetor em um texto, separando os elementos do vetor através de um caractere
 separador que é indicado no parâmetro."""

    pass

class WebCampo ():
  """Objeto que representa um campo de um formulário de uma página consultada na
 Web através do objeto {@link WebExtrator WebExtrator}.
 <P>
 
 Uma forma de obter objetos deste tipo é através da função
 {@link WebFormulario#getCampos() getCampos}."""

  def addValor(self, valor) -> None:
    """Adiciona um valor ao campo, assumindo que o campo admite múltiplos
 valores.<BR>
 OBS: qualquer valor informado anteriormente, seja pela função
 {@link WebCampo#setValor(String) setValor}, seja pela função
 {@link WebCampo#addValor(String) addValor}, é preservado."""

    pass


  def getHTML(self) -> str:
    """Retorna o conteúdo HTML da parte correspondente a este campo no
 formulário (exceto pela indicação do valor que tenha sido porventura
 alterado pela função {@link WebCampo#setValor(String) setValor}."""

    pass


  def getID(self) -> str:
    """Retorna o identificador do campo conforme definido no formulário"""

    pass


  def getNome(self) -> str:
    """Retorna o nome deste campo conforme definido no formulário."""

    pass


  def getTipo(self) -> str:
    """Retorna o tipo de campo (ex: "hidden", ou "text", ou "checkbox", ou
 "radio", etc.)"""

    pass


  def getValor(self) -> str:
    """Retorna o valor que está preenchido no campo do formulário (supondo a
 existência de um único valor no campo do formulário).<BR>
 OBS: se o campo admite múltiplos valores, retorna arbitrariamente um
 deles."""

    pass


  def getValores(self) -> list:
    """Retorna a relação de valores que estão preenchidos ou selecionados no
 campo do formulário (supondo a existência de múltiplos valores, tal como
 em um campo SELECT). OBS: se o campo tem um único valor, é retornada uma
 lista contendo um único valor. Se não há nada preenchido, retorna uma
 lista vazia."""

    pass


  def hasAlgumValor(self) -> bool:
    """Retorna a indicação se existe algum valor para o campo"""

    pass


  def hasMultiplosValores(self) -> bool:
    """Retorna a indicação de existência de mais de um valor no campo."""

    pass


  def isCampoOpcao(self) -> bool:
    """Indica se o campo é uma lista de opções, isto é, se é do tipo "radio", 
 "checkbox" ou "select""""

    pass


  def limparValores(self) -> None:
    pass


  def setID(self, id) -> None:
    """Define o identificador do campo"""

    pass


  def setValor(self, valor) -> None:
    """Preenche o valor deste campo no formulário (admitindo um único valor no
 campo do formulário).<BR>
 OBS: se o campo admite múltiplos valores, passa a valer apenas o valor
 informado nesta função."""

    pass


  def setValores(self, valores) -> None:
    """Preenche o campo com uma lista de valores"""

    pass


  def toString(self) -> str:
    pass

class WebElemento ():
  """Contém informação sobre um elemento de um documento HTML. <BR>
 Utiliza internamente a biblioteca JSoup."""

  def getAnterior(self) -> WebElemento:
    """Obtém o elemento anterior (previous sibling)"""

    pass


  def getAtributo(self, atributo) -> str:
    """Obtém o valor do atributo do elemento"""

    pass


  def getById(self, id) -> WebElemento:
    """Obtém o elemento com determinado ID"""

    pass


  def getClasse(self) -> str:
    """Obtém o nome da classe do elemento"""

    pass


  def getElement(self) -> Element:
    """Retorno o objeto element do JSoup"""

    pass


  def getFilhos(self) -> WebElementos:
    """Seleciona os elementos filhos do elemento atual"""

    pass


  def getHtml(self) -> str:
    """Obtém o código HTML externo do elemento"""

    pass


  def getHtmlInterno(self) -> str:
    """Obtém o código HTML interno do elemento, sem a informação do próprio tag"""

    pass


  def getId(self) -> str:
    """Obtém o ID do elemento"""

    pass


  def getProximo(self) -> WebElemento:
    """Obtém o próximo elemento (next sibling)"""

    pass


  def getRotulo(self) -> str:
    """Obtém o rótulo (nome do tag) do elemento"""

    pass


  def getSuperior(self) -> WebElemento:
    """Obtém o elemento hierarquicamente superior (pai)."""

    pass


  def getTabela(self) -> WebTabela:
    """Retorna um objeto WebTabela obtido a partir do elemento atual"""

    pass


  def getTexto(self) -> str:
    """Obtém o texto do elemento"""

    pass


  def getValor(self) -> str:
    """Obtém o valor para um elemento que represente um campo de formulário"""

    pass


  def porClasse(self, classe) -> WebElementos:
    """Seleciona os elementos de determinada classe"""

    pass


  def porExpressaoRegular(self, regexp) -> WebElementos:
    """Seleciona os elementos com texto que atende à expressão regular."""

    pass


  def porNomeAtributo(self, atributo) -> WebElementos:
    """Seleciona os elementos que possuem determinado atributo.  Procura apenas no nome do atributo."""

    pass


  def porRotulo(self, rotulo) -> WebElementos:
    """Seleciona os elementos que possuem determinado rótulo/tag"""

    pass


  def porValorAtributo(self, atributo, valor) -> WebElementos:
    """Seleciona os elementos que possuem o valor informado para determinado atributo."""

    pass


  def seleciona(self, cssSelector) -> WebElementos:
    """Seleciona os elementos que atendam a uma consulta de seleção CSS, de acordo com a biblioteca JSoup. <BR>
 <ul>
 <li>"a[href]" seleciona todos links que possuem o atributo href definido
 <li>"a[href*=example.com]" seleciona links que apontam para o site example.com
 <li>"img[src$=.png]" seleciona img em que o atributo src termine em png
 <li>"div.dados" seleciona div da classe dados
 </ul>"""

    pass


  def selecionaPrimeiro(self, cssSelector) -> WebElemento:
    """Obtém o primeiro elemento para uma consulta de seleção CSS, de acordo com a biblioteca Jsoup."""

    pass


  def setAtributo(self, atributo, valor) -> None:
    """Atribui 'valor' ao 'atributo' do elemento"""

    pass


  def setValor(self, valor) -> None:
    """Atribui 'valor' a um elemento que represente um campo de formulário
 param valor texto a atribuir"""

    pass

class WebElementos ():
  """Conjunto de elementos html selecionados"""

  def getElemento(self, posicao) -> WebElemento:
    """Obtém o elemento na posição indicada"""

    pass


  def getHtml(self) -> str:
    """Obtém Html concatenado de cada elemento"""

    pass


  def getListaHtml(self) -> list:
    """Obtém uma lista com o código Html de cada elemento selecionado"""

    pass


  def getListaRotulos(self) -> list:
    """Obtém uma lista dos rótulos de cada elemento selecionado."""

    pass


  def getListaTexto(self) -> list:
    """Obtém uma lista contendo o texto de cada elemento"""

    pass


  def getListaValorAtributo(self, atributo) -> list:
    """Obtém lista com o valor do atributo de cada elemento"""

    pass


  def getPrimeiro(self) -> WebElemento:
    """Obtém o primeiro elemento"""

    pass


  def getQtdElementos(self) -> int:
    """Obtém a quantidade de elementos"""

    pass


  def getTabela(self, atributos) -> Tabela:
    """Obtém uma Tabela com os atributos indicados, utilizando o método getListaSelecao para obter os valores
 das respectivas colunas. <BR>
 Informe o nome dos atributos ou um dos termos especiais abaixo incluindo o caracter #:
 <ul>
 <li>#rotulo - nome do rótulo (tag) html
 <li>#texto - o texto do elemento
 <li>#html - html do elemento"""

    pass


  def getTexto(self) -> str:
    """Obtém texto concatenado com o texto de cada elemento"""

    pass


  def getUltimo(self) -> WebElemento:
    """Obtém o último elemento"""

    pass


  def paraLista(self) -> Lista:
    """Converte para uma lista de WebElemento para ser trabalhado como lista."""

    pass


  def seleciona(self, cssSelector) -> WebElementos:
    """Seleciona os elementos que atendam a uma consulta de seleção CSS, de acordo com a biblioteca JSoup."""

    pass

class WebExtrator ():
  """Objeto que pode ser utilizado por uma linguagem de script para extrair dados
 de um serviço Web (HTTP).
 <P>

 Este objeto está disponível para uma linguagem de script através do nome
 "web". Isto é, já está definido para qualquer linguagem de script um objeto
 do tipo {@link WebExtrator WebExtrator} cujo nome é "web", bastando executar
 seus métodos.
 <P>

 Os métodos aqui descritos são genéricos, de modo que o programador deve
 realizar alguns testes com algum serviço específico, em cada oportunidade
 descobrindo novos meios de descobrir mais informações, até concluir um
 procedimento completo de extração desses dados.
 <P>

 Tendo em vista que esta classe é de uso genérico, ela não implementa de forma
 completa nenhum mecanismo de consulta específico.
 <P>

 Em linhas gerais um procedimento completo de extração de dados de um serviço
 Web é composto dos seguintes passos:<BR>
 1 - autenticação (enviar login e senha)<BR>
 2 - conferir a resposta da autenticação<BR>
 3 - enviar parâmetros de consulta (ex: CNPJ e período) através de
 formulários<BR>
 4 - conferir uma listagem com links para cada resultado individual<BR>
 5 - consultar o conteúdo em cada link, inclusive percorrendo alguma estrutura
 de menus para acessar demais detalhes sobre cada resultado da consulta.
 <P>

 OBS: Os diferentes serviços "Web" podem diferir uns dos outros nos detalhes
 de implementação dos passos abaixo. Por exemplo, é preciso conhecer em cada
 serviço Web quais são os "nomes" dos campos do "formulário" utilizado nas
 pesquisas. Este processo de descoberta pode também ser realizado com os
 métodos desta classe, fazendo sucessivos testes sobre um serviço existente,
 onde em cada teste observa-se o conteúdo que foi recebido do servidor (isto
 é, apresenta-se a relação de formulários, seus campos, e os nomes internos
 correspondentes). O programador deverá, a partir desta informação, reconhecer
 quais são os campos de interesse.
 <P>
 <BR>
 MODOS DE NAVEGAÇÃO<BR>
 ====================================================<BR>
 <BR>
 Existem basicamente duas formas de trabalhar com o "WebExtrator":<BR>
 <BR>
 - Navegação simples: é o método padrão de navegação. Nenhum conteúdo "ativo"
 da página, tal como "JavaScript" ou "Flash", é considerado durante este modo
 de utilização. Basicamente funciona assim: para cada endereço (link) que é
 apresentado ao extrator, obtém-se como resultado uma nova "página" ou uma
 situação de erro (ex: acesso "negado"). O conteúdo da página é o próprio
 conteúdo retornado pelo servidor em resposta à requisição. Se a página possui
 diversos outros "links" para outras páginas ou imagens, o extrator não
 "segue" esses outros "links", a menos que eles sejam utilizados em novas
 requisições de página ao extrator de forma explícita no código.<BR>
 <BR>
 - Navegação completa: é o método alternativo de navegação, que pode ou não
 estar disponível dependendo da versão do aplicativo onde está sendo
 executado. Neste caso, todo conteúdo "ativo" da página (códigos em
 JavaScript, entre outros) são executados localmente, na máquina do usuário,
 como se estivesse acessando a página através de um "navegador" comum. Isto é,
 nenhuma página é apresentada na tela, mas é como se estivesse sendo
 apresentada alguma página. Se a página possui diversos outros "links" para
 outras páginas ou imagens, o extrator pode ou não "seguir" esses outros
 "links" de forma automática, dependendo de como a página está estruturada.
 Por exemplo, uma página que está dividida em "frames" pode associar a cada
 "frame" um endereço diferente, de modo que o conteúdo desses outros endereços
 se "juntam" ao conteúdo da página. Através da navegação completa também é
 possível "executar" códigos em JavaScript definidos na própria página,
 fazendo com que o mecanismo de extração reproduza de forma mais fiel o
 comportamento esperado por um usuário do serviço.<BR>
 <BR>
 Para utilização da navegação de forma "completa", é necessário primeiro
 "habilitar" este modo de navegação. Isso precisa ser feito somente uma vez em
 alguma parte do script, de preferência antes de qualquer outra operação sobre
 o extrator. Para habilitar, execute o método
 {@link WebExtrator#habilitaNavegacaoCompleta() habilitaNavegacaoCompleta}.
 Lembre-se de conferir o resultado deste método para confirmar se o modo de
 navegação "completa" foi de fato habilitado (como foi dito acima, algumas
 versões do aplicativo podem não disponibilizar este modo de navegação, o que
 significa que o modo de navegação completa não pode ser habilitado em tais
 versões).<BR>
 <BR>
 <BR>
 NAVEGAÇÃO PARALELA<BR>
 ====================================================<BR>
 <BR>
 Caso esteja interessado em realizar navegação "paralela", isto é, permitir
 que o código navegue por páginas através de duas ou mais execuções
 simultâneas (como se estivesse com dois ou mais "navegadores" abertos ao
 mesmo tempo), utilize o método {@link WebExtrator#novoExtrator()
 novoExtrator} para criar novas instâncias de {@link WebExtrator WebExtrator}
 que são independentes umas das outras.<BR>"""

  def abrirArquivoHTML(self, diretorio, nome) -> WebPagina:
    """Abre um arquivo de conteúdo HTML previamente armazenado no computador local e
 apresenta-o na forma de um objeto {@link WebPagina WebPagina}.<BR>
 Se o arquivo não existe, retorna NULL.<BR>
 Este método é similar ao método
 {@link GerenciadorArquivos#abrirHTML(String, String) abrirHTML} do objeto
 {@link GerenciadorArquivos GerenciadorArquivos}, com a diferença que aqui a
 página fica associada ao {@link WebExtrator WebExtrator}, permitindo
 inclusive a execução de conteúdo JavaScript caso o modo de navegação completa
 esteja habilitado."""

    pass


  def abrirConteudoHTML(self, html, urlBase) -> WebPagina:
    """Abre diretamente um conteúdo HTML e apresenta-o na forma de um objeto
 {@link WebPagina WebPagina}.<BR>"""

    pass


  def abrirConteudoHTML(self, html) -> WebPagina:
    """Abre diretamente um conteúdo HTML e apresenta-o na forma de um objeto
 {@link WebPagina WebPagina}.<BR>"""

    pass


  def abrirPagina(self, url, campos, charset) -> None:
    """Acessa uma página qualquer indicando "campos" que são passados como se fossem
 campos de um formulário.<BR>
 Esta função faz um "HTTP-POST" para obter a página desejada.<BR>
 Os parâmetros do formulário que é passado para o servidor são indicados no
 parâmetro "campos" na forma de "duplas", onde o primeiro elemento de cada
 dupla é o nome do parâmetro e o segundo elemento de cada dupla é o seu
 correspondente valor.<BR>
 Ou seja, o parâmetro campo, caso especificado, deve ter um tamanho "par" de
 elementos.<BR>
 A URL passada como parâmetro deve conter o caminho completo para a página
 desejada, inclusive o nome do servidor e o nome do protocolo (podendo ser
 "http" ou "https").<BR>"""

    pass


  def abrirPagina(self, url) -> None:
    """Acessa uma página qualquer.<BR>
 Caso seja necessário passar parâmetros de consulta adicionais (tal como em um
 "formulário"), não utilize este método. Utilize o método
 {@link WebExtrator#submeterFormulario(String) submeterFormulario}, que recebe
 como parâmetro o nome do formulário preenchido ao invés da URL de acesso.<BR>
 Esta função faz um "HTTP-GET" para obter a página desejada.<BR>
 A URL passada como parâmetro deve conter o caminho completo para a página
 desejada, inclusive o nome do servidor e o nome do protocolo (podendo ser
 "http" ou "https").<BR>
 EX: http://servidor.em.algum.lugar.br/nome.do.servico/alguma.pagina.html
 <P>
 Após uma consulta bem sucedida, o conteúdo da página encontra-se disponível
 através da função {@link WebExtrator#getPaginaAtual() getPaginaAtual}."""

    pass


  def abrirPagina(self, url, campos) -> None:
    """Acessa uma página qualquer indicando "campos" que são passados como se fossem
 campos de um formulário.<BR>
 Esta função faz um "HTTP-POST" para obter a página desejada.<BR>
 Os parâmetros do formulário que é passado para o servidor são indicados no
 parâmetro "campos" na forma de "duplas", onde o primeiro elemento de cada
 dupla é o nome do parâmetro e o segundo elemento de cada dupla é o seu
 correspondente valor.<BR>
 Ou seja, o parâmetro campo, caso especificado, deve ter um tamanho "par" de
 elementos.<BR>
 A URL passada como parâmetro deve conter o caminho completo para a página
 desejada, inclusive o nome do servidor e o nome do protocolo (podendo ser
 "http" ou "https").<BR>"""

    pass


  def abrirPaginaAnterior(self) -> None:
    """Caso esteja utilizando o modo de navegação "completo", abre a página
 anteriormente navegada neste WebBrowser, conforme informações mantidas no
 'histórico' de navegação.<BR>
 Há um limite de 20 endereços (ou seja, pode 'retornar' até um dos últimos 20
 endereços solicitados)<BR>
 Caso não existam endereços no 'histórico' ou caso não esteja no modo de
 navegação 'completo', não faz nada."""

    pass


  def abrirPaginaTrataErro(self, url) -> bool:
    """Função equivalente a {@link WebExtrator#abrirPagina(String) abrirPagina}, mas
 com tratamento de erro.<BR>
 Isto é, se houver algum tipo de erro ao tentar acessar a página (ex: servidor
 não encontrado ou solicitação inválida), não joga exceção. Ao invés disso,
 simplesmente retorna FALSE.<BR>
 Note que a outra função, a {@link WebExtrator#abrirPagina(String)
 abrirPagina}, não trata erros no sentido de que, na eventualidade de um erro,
 uma exeção é jogada, e se a exceção não é tratada pelo código que a chamou, o
 programa pára de executar.<BR>
 Esta função alternativa é conveniente no sentido que o tratamento da exceção
 fica dispensado, bastando tratar o retorno da função."""

    pass


  def addCabecalhoExtra(self, nome, valor) -> None:
    """Adiciona um cabeçalho definido pelo usuário ao Header da requisição HTTP. Se
 o cabeçalho já existir, sobrescreve ele"""

    pass


  def addCookie(self, dominio, nome, valor, path) -> None:
    """Inclui um Cookie manualmente na sessão atual do WebExplorer"""

    pass


  def addSubrotinaCapturaMouse(self, subrotina, eventoSoltarBotao, eventoPressionarBotao) -> None:
    """Função que pode ser utilizada caso o modo de navegação completa esteja
 habilitado, possibilitando que uma subrotina do script seja executada sempre
 que houver um evento de mouse sobre a página exibida (ex: ao clicar ou ao
 soltar o botão do mouse).<BR>
 Em tais eventos, a subrotina é executada com um parâmetro do tipo
 {@link ElementoJson ElementoJson}, que encapsula diversas informações
 como:<BR>
 name: nome do componente HTML onde ocorreu o evento do mouse<BR>
 id: identificação do componente HTML onde ocorreu o evento do mouse<BR>
 href: propriedade 'href' do componente HTML onde ocorreu o evento do
 mouse<BR>
 value: propriedade 'value' do componente HTML onde ocorreu o evento do
 mouse<BR>
 type: tipo do componente HTML onde ocorreu o evento do mouse<BR>
 form: nome do formulário onde ocorreu o evento do mouse<BR>
 tag: nome da tag do componente HTML onde ocorreu o evento do mouse<BR>
 <BR>
 OBS: podem ser adicionadas diversas rotinas de monitoramento. Todas elas são
 executadas. A subrotina deve incluir alguma lógica adicional para filtrar os
 eventos de interesse com base nas informações indicadas no parâmetro do tipo
 {@link ElementoJson ElementoJson}<BR>
 OBS2: as rotinas programadas ficam atreladas a este objeto {@link WebExtrator
 WebExtrator}. Isto é, apenas irão monitorar os eventos que forem provocados
 com o uso deste objeto. Outras funções de script implementadas em outros
 objetos podem não ser alcançadas por esta funcionalidade."""

    pass


  def addSubrotinaCapturaTecla(self, subrotina) -> None:
    """Função que pode ser utilizada caso o modo de navegação completa esteja
 habilitado, possibilitando que uma subrotina do script seja executada sempre
 que houver um evento de pressionamento de tecla sobre a página exibida (ex:
 ao digitar alguma coisa).<BR>
 Em tais eventos, a subrotina é executada com um parâmetro do tipo
 {@link ElementoJson ElementoJson}, que encapsula diversas informações
 como:<BR>
 name: nome do componente HTML onde ocorreu o evento do teclado<BR>
 id: identificação do componente HTML onde ocorreu o evento do teclado<BR>
 href: propriedade 'href' do componente HTML onde ocorreu o evento do
 teclado<BR>
 value: propriedade 'value' do componente HTML onde ocorreu o evento do
 teclado<BR>
 type: tipo do componente HTML onde ocorreu o evento do teclado<BR>
 form: nome do formulário onde ocorreu o evento do teclado<BR>
 tag: nome da tag do componente HTML onde ocorreu o evento do teclado<BR>
 key: identifica a tecla que foi pressionada<BR>
 shift: booleano que indica se a tecla SHIFT estava pressionada<BR>
 alt: booleano que indica se a tecla ALT estava pressionada<BR>
 ctrl: booleano que indica se a tecla CTRL estava pressionada<BR>
 <BR>
 OBS: podem ser adicionadas diversas rotinas de monitoramento. Todas elas são
 executadas. A subrotina deve incluir alguma lógica adicional para filtrar os
 eventos de interesse com base nas informações indicadas no parâmetro do tipo
 {@link ElementoJson ElementoJson}<BR>
 OBS2: as rotinas programadas ficam atreladas a este objeto {@link WebExtrator
 WebExtrator}. Isto é, apenas irão monitorar os eventos que forem provocados
 com o uso deste objeto. Outras funções de script implementadas em outros
 objetos podem não ser alcançadas por esta funcionalidade."""

    pass


  def aguardaEndereco(self, endereco, tempoMaximoEspera) -> str:
    """Caso esteja utilizando o modo de navegação "completo", este método procura
 por um determinado endereço no 'histórico de endereços' visitados e mantidos
 localmente pelo navegador do ContÁgil (não são considerados os históricos de
 endereços de outros navegadores instalados no computador do usuário). <BR>
 <BR>
 Caso o endereço desejado não seja encontrado no histórico, este método
 permite aguardar um tempo até que ele seja encontrado. Durante este tempo, o
 método permanece parado. Isso é útil caso o navegador do ContÁgil esteja
 atualmente trabalhando com uma página de conteúdo dinâmico que possa realizar
 requisições a outros endereços enquanto o ContÁgil aguarda.<BR>
 <BR>
 Note que se o histórico já possui o endereço desejado, o método retorna
 imediatamente. Caso queira aguardar por uma nova ocorrência do endereço no
 histórico, você pode antes 'apagar' o conteúdo atual do histórico utilizando
 o método {@link WebExtrator#apagaHistoricoEnderecos()
 apagaHistoricoEnderecos}.<BR>
 <BR>
 Note também que o histórico local de endereços tem um limite de 20 endereços.
 São mantidos apenas os últimos 20 endereços solicitados pelo navegador.<BR>
 <BR>
 Este método apenas pode ser utilizado na hipótese do navegador estar
 trabalhando no modo de navegação "completo". Ou seja, é necessário que
 inicialmente tenha sido executado o método
 {@link WebExtrator#habilitaNavegacaoCompleta() habilitaNavegacaoCompleta}.
 Caso contrário, o conteúdo da página observado internamente pelo extrator não
 se altera, deixando o método sem utilidade."""

    pass


  def aguardaPagina(self, expressoesRegulares, tempoMaximoEspera, novasTentativas) -> bool:
    """Alternativa ao método de dois parâmetros
 {@link WebExtrator#aguardaPagina(String, int, int) aguardaPagina} onde é
 possível indicar mais de uma expressão regular a ser pesquisada.<BR>"""

    pass


  def aguardaPagina(self, expressaoRegular, tempoMaximoEspera) -> bool:
    """Caso esteja utilizando o modo de navegação "completo", este método faz com
 que o sistema "aguarde" um tempo até que uma determinada página, com um
 determinado conteúdo, seja observada internamente pelo extrator.<BR>
 <BR>
 Ou seja, este método presume que a página possui algum conteúdo que se altera
 dinamicamente, de modo que é desejável aguardar até que o conteúdo
 corresponda ao conteúdo indicado como parâmetro.<BR>
 <BR>
 Este método apenas pode ser utilizado na hipótese do navegador estar
 trabalhando no modo de navegação "completo". Ou seja, é necessário que
 inicialmente tenha sido executado o método
 {@link WebExtrator#habilitaNavegacaoCompleta() habilitaNavegacaoCompleta}.
 Caso contrário, o conteúdo da página observado internamente pelo extrator não
 se altera, deixando o método sem utilidade."""

    pass


  def aguardaPaginaComFrame(self, expressaoRegular, tempoMaximoEspera) -> bool:
    """Caso esteja utilizando o modo de navegação "completo", este método faz com
 que o sistema "aguarde" um tempo até que uma determinada página, com um
 determinado conteúdo, seja observada internamente pelo extrator.<BR>
 <BR>
 Deve-se utilizar este método quando a página contém frames. Nesses casos todo
 o conteúdo é trazido nos frames e essa carga demora mais que a carga do
 conteúdo inicial onde os frames estão inseridos. A expressão regular deve ser
 algo que existe na página apenas após a carga dos frames. <BR>
 Ou seja, este método presume que a página possui algum conteúdo que se altera
 dinamicamente, de modo que é desejável aguardar até que o conteúdo
 corresponda ao conteúdo indicado como parâmetro.<BR>
 <BR>
 Este método apenas pode ser utilizado na hipótese do navegador estar
 trabalhando no modo de navegação "completo". Ou seja, é necessário que
 inicialmente tenha sido executado o método
 {@link WebExtrator#habilitaNavegacaoCompleta() habilitaNavegacaoCompleta}.
 Caso contrário, o conteúdo da página observado internamente pelo extrator não
 se altera, deixando o método sem utilidade."""

    pass


  def aguardaPaginaComTitulo(self, titulo, tempoMaximoEspera) -> bool:
    """Caso esteja utilizando o modo de navegação "completo", este método faz com
 que o sistema "aguarde" um tempo até que uma determinada página, com um
 determinado título (informado na tag HTML &lt;TITLE&gt;), seja observada
 internamente pelo extrator.<BR>
 <BR>
 Ou seja, este método presume que a página possui algum conteúdo que se altera
 dinamicamente, de modo que é desejável aguardar até que o conteúdo
 corresponda ao conteúdo indicado como parâmetro.<BR>
 <BR>
 Este método apenas pode ser utilizado na hipótese do navegador estar
 trabalhando no modo de navegação "completo". Ou seja, é necessário que
 inicialmente tenha sido executado o método
 {@link WebExtrator#habilitaNavegacaoCompleta() habilitaNavegacaoCompleta}.
 Caso contrário, o conteúdo da página observado internamente pelo extrator não
 se altera, deixando o método sem utilidade."""

    pass


  def alteraCabecalho(self, method, nome, valor) -> None:
    pass


  def alteraCabecalho(self, method, nome, valor) -> None:
    pass


  def apagaHistoricoEnderecos(self) -> None:
    """Caso esteja utilizando o modo de navegação "completo", este método apaga todo
 o histórico de endereços visitados e mantidos localmente pelo navegador do
 ContÁgil (não afeta o histórico de endereços de outros navegadores instalados
 no computador do usuário)."""

    pass


  def assertURI(self, str, referer) -> URI:
    """Faz o tratamento da URL para evitar erros de 'encoding'."""

    pass


  def assertURI(self, url) -> URI:
    """Converte um objeto String em um objeto URI. Utiliza neste processo de
 conversão o último endereço navegado. Isto é, se a String indica uma URL
 incompleta (por exemplo, sem indicar o 'host'), complementa a informação com
 base no último endereço navegado por este WebExtrator."""

    pass


  def autentica(self, url, chave, campoLogin, campoSenha, campoAdicional, formulario) -> None:
    """Método alternativo ao método
 {@link WebExtrator#autentica(String, Chave, String, String) autentica}, onde
 há um parâmetro adicional para indicar um objeto formulário onde estão
 definidos os campos "login" e "senha" que se deseja preencher, além de outros
 campos que podem estar preenchidos.
 <P>
 OBS: Por razões de segurança, o objeto "formulário" passado como parâmetro
 não é diretamente alterado por esta função (isto é, ele não chega a receber o
 conteúdo do "login" e da "senha"), mas ao invés disso ele é utilizado como um
 "paradigma" para um "clone" que é utilizado temporariamente para este
 propósito.<BR>"""

    pass


  def autentica(self, url, chave, campoLogin, campoSenha, formulario) -> None:
    """Método alternativo ao método
 {@link WebExtrator#autentica(String, Chave, String, String) autentica}, onde
 há um parâmetro adicional para indicar um objeto formulário onde estão
 definidos os campos "login" e "senha" que se deseja preencher, além de outros
 campos que podem estar preenchidos.
 <P>
 OBS: Por razões de segurança, o objeto "formulário" passado como parâmetro
 não é diretamente alterado por esta função (isto é, ele não chega a receber o
 conteúdo do "login" e da "senha"), mas ao invés disso ele é utilizado como um
 "paradigma" para um "clone" que é utilizado temporariamente para este
 propósito.<BR>"""

    pass


  def autentica(self, url, chave, campoLogin, campoSenha) -> None:
    """Faz a autenticação do usuário no serviço Web.<BR>
 Tendo em vista que diferentes serviços Web podem implementar de diferentes
 formas seus campos para autenticação, esta rotina necessita dos nomes dos
 campos "login" e "senha", conforme identificados internamente no formulário
 de autenticação (se não souber quais campos são esses, pode-se tentar
 descobrir executando uma consulta prévia sobre a página de autenticação, com
 o método {@link WebExtrator#abrirPagina(String) abrirPagina}, e então
 consultando todos os formulários e campos existentes na página retornada pelo
 método {@link WebExtrator#getPaginaAtual() getPaginaAtual}).<BR>
 OBS: Este método pode falhar mesmo que as credenciais do usuário autenticado
 estejam corretas. Uma hipótese para este método falhar trata-se da situação
 em que os nomes dos campos informados não existem ou estão incorretos ou
 ainda na hipótese de haver mais campos além desses dois que precisam ser
 preenchidos. Se este método não for satisfatório, experimente utilizar os
 outros métodos genéricos de preenchimento de formulário existentes neste
 objeto.<BR>"""

    pass


  def autentica(self, url, chave) -> None:
    """Método alternativo de autenticação, utilizado quando a autenticação não é
 feita por formulário, mas sim quando o próprio navegador solicita o usuário e
 senha, como por exemplo ao acessar o Informar."""

    pass


  def autentica(self, url, chave, campoLogin, campoSenha, campoAdicional) -> None:
    """Faz a autenticação do usuário no serviço Web.<BR>
 Tendo em vista que diferentes serviços Web podem implementar de diferentes
 formas seus campos para autenticação, esta rotina necessita dos nomes dos
 campos "login" ,"senha" e "adicional", conforme identificados internamente no
 formulário de autenticação (se não souber quais campos são esses, pode-se
 tentar descobrir executando uma consulta prévia sobre a página de
 autenticação, com o método {@link WebExtrator#abrirPagina(String)
 abrirPagina}, e então consultando todos os formulários e campos existentes na
 página retornada pelo método {@link WebExtrator#getPaginaAtual()
 getPaginaAtual}).<BR>
 OBS: Este método pode falhar mesmo que as credenciais do usuário autenticado
 estejam corretas. Uma hipótese para este método falhar trata-se da situação
 em que os nomes dos campos informados não existem ou estão incorretos ou
 ainda na hipótese de haver mais campos além desses dois que precisam ser
 preenchidos. Se este método não for satisfatório, experimente utilizar os
 outros métodos genéricos de preenchimento de formulário existentes neste
 objeto.<BR>"""

    pass


  def clicaBotao(self, nomeFormulario, nomeBotao) -> bool:
    """Simula um clique sobre um botão do formulário que é exibido em uma
 página.<BR>
 Procura na página atual por um formulário que possua um determinado nome. Uma
 vez localizado o formulário, procura um botão que possua um determinado nome.
 Encontrado o botão, simula o 'clique' sobre ele utilizando um comando
 'javascript' equivalente.<BR>
 Se a página atual não contém o formulário com o nome indicado, este método
 aguarda até 2 segundos para que o formulário apareça (o que pode ocorrer
 eventualmente caso uma mudança de página tenha sido solicitada pelo script um
 pouco antes).<BR>
 <BR>
 Atenção: o 'nome do botão' que deve ser indicado como parâmetro é o nome
 'interno' do botão, conforme visto internamente no código HTML, o qual pode
 ser diferente do texto que é efetivamente exibido na página pelo
 navegador.<BR>
 <BR>
 Este método apenas pode ser utilizado na hipótese do navegador estar
 trabalhando no modo de navegação "completo". Ou seja, é necessário que
 inicialmente tenha sido executado o método
 {@link WebExtrator#habilitaNavegacaoCompleta() habilitaNavegacaoCompleta}.
 Caso contrário, retorna FALSE sempre."""

    pass


  def clicaHiperlinkSimilar(self, hiperlink) -> str:
    """Simula um clique sobre um hiperlink que é exibido em uma página. Este método
 na realidade faz algo além de simplesmente alternar a página. É possível que
 o endereço seguido seja diferente daquele indicado no parâmetro.<BR>
 Este método primeiro procura na página atual pela ocorrência de um endereço
 que seja 'similar' ao endereço que foi indicado no parâmetro. Para isso,
 considera-se inicialmente a parte inicial do endereço.<BR>
 Por exemplo, se o endereço indicado no parâmetro é
 "http://algum.lugar.com/alguma_coisa/alguma_parte?x=1283719837123", procura
 pela ocorrência daquilo que antecede o sinal de interrogação (isto é,
 "http://algum.lugar.com/alguma_coisa/alguma_parte").<BR>
 Se encontrar mais de uma ocorrência deste trecho inicial (isto é, se há mais
 de um hiperlink na mesma página cujo endereço comece exatamente da mesma
 forma), considera aquele que mais se parece com o endereço informado (isto é,
 confere também o restante do endereço).<BR>
 Ainda que o endereço encontrado não seja exatamente idêntico ao endereço
 informado no parâmetro, ele será o endereço escolhido. Se houver mais de um
 que seja considerado 'similar' pelo mesmo critério (isto é, em caso de
 'empate' na determinação do endereço mais 'próximo'), considera o primeiro
 deles.<BR>
 Este método é interessante para aquelas situações onde o hiperlink
 apresentado na página pode conter outros códigos que são muito específicos de
 uma determinada execução, quando se considera 'tolerável' que ele considere
 outro endereço que seja muito parecido.<BR>
 Se o único comportamento desejado é o de acessar uma determinada URL
 específica, sem ter o risco de acessar uma URL diferente que seja parecida,
 não utilize este método, mas sim o método
 {@link WebExtrator#abrirPagina(String) abrirPagina}.<BR>
 Caso algum endereço seja seguido, retorna TRUE.<BR>
 Caso nenhum endereço 'parecido' seja encontrado na página, aguarda um curto
 período de tempo. Se nada for encontrado após este curto período de tempo,
 abre o endereço que foi indicado no parâmetro, na forma como está indicado
 (isto é, faz o mesmo que o método {@link WebExtrator#abrirPagina(String)
 abrirPagina})."""

    pass


  def close(self) -> None:
    """Método executado com o objetivo de finalizar a utilização deste objeto.<BR>
 Isto é, todos os recursos alocados por este objeto são retirados na
 memória.<BR>
 O script não precisa executar diretamente este método. Ele é executado
 automaticamente pelo ContÁgil na finalização do script."""

    pass


  def desabilitaNavegacaoCompleta(self) -> None:
    """Caso a navegação de página de forma completa tenha sido habilitada através da
 ação {@link WebExtrator#habilitaNavegacaoCompleta()
 habilitaNavegacaoCompleta}, faz com que ela não ocorra mais desta forma.<BR>
 Isto é, a partir daqui a navegação em qualquer página na Web não fará com que
 o código JavaScript existente na página seja executado localmente."""

    pass


  def desabilitaNavegacaoCompleta(self, preservaCookies) -> None:
    """Caso a navegação de página de forma completa tenha sido habilitada através da
 ação {@link WebExtrator#habilitaNavegacaoCompleta()
 habilitaNavegacaoCompleta}, faz com que ela não ocorra mais desta forma.<BR>
 Isto é, a partir daqui a navegação em qualquer página na Web não fará com que
 o código JavaScript existente na página seja executado localmente.<BR>
 <BR>
 Esta alternativa permite preservar os 'cookies' caso estivesse anteriormente
 sendo executado em 'modo de navegação completa'."""

    pass


  def downloadArquivoCSV(self, url, nomeArquivo, separador) -> ArquivoCSV:
    """Faz o download de um conteúdo em formato texto que é identificado por uma
 URL.<BR>
 Espera que o conteúdo recebido já esteja no formato texto com campos
 separados por algum caractere especial, tal como vírgula, ponto e vírgula,
 etc.<BR>
 A URL passada como parâmetro deve conter o caminho completo para o conteúdo
 desejado, inclusive o nome do servidor e o nome do protocolo (podendo ser
 "http" ou "https").<BR>
 EX: http://servidor.em.algum.lugar.br/nome.do.servico/alguma.pagina.html
 <P>
 Após uma consulta bem sucedida, é retornado o conteúdo texto no formato de um
 objeto do tipo {@link ArquivoCSV ArquivoCSV}.<BR>
 <P>
 OBS: o caminho completo é dispensável no caso em que esta função é executada
 após outra função bem sucedida de acesso à páginas do mesmo servidor. Nesta
 hipótese, basta especificar o nome da página e o caminho relativo ao mesmo
 servidor.
 <P>
 OBS2: caso o conteúdo CSV não seja acessado diretamente por meio de uma URL,
 mas indiretamente por meio da submissão de algum formulário ou métodos
 javascript, utilize o método alternativo {@link #exportaConteudoCSV()
 exportaConteudoCSV} para obter o conteúdo CSV após a submissão do formulário
 ou da execução do código javascript."""

    pass


  def downloadArquivoExcel(self, url, nomeArquivo) -> ArquivoExcel:
    """Faz o download de um conteúdo em formato XLS ou XLSX que é identificado por
 uma URL.<BR>
 A URL passada como parâmetro deve conter o caminho completo para o conteúdo
 desejado, inclusive o nome do servidor e o nome do protocolo (podendo ser
 "http" ou "https").<BR>
 EX: http://servidor.em.algum.lugar.br/nome.do.servico/alguma.pagina.xlsx
 <P>
 Após uma consulta bem sucedida, é retornado o conteúdo no formato de um
 objeto do tipo {@link ArquivoExcel ArquivoExcel}.<BR>
 <P>
 OBS: o caminho completo é dispensável no caso em que esta função é executada
 após outra função bem sucedida de acesso à páginas do mesmo servidor. Nesta
 hipótese, basta especificar o nome da página e o caminho relativo ao mesmo
 servidor.<BR>
 <P>
 OBS2: caso o conteúdo Excel não seja acessado diretamente por meio de uma
 URL, mas indiretamente por meio da submissão de algum formulário ou métodos
 javascript, utilize o método alternativo {@link #exportaConteudoExcel()
 exportaConteudoExcel} para obter o conteúdo Excel após a submissão do
 formulário ou da execução do código javascript."""

    pass


  def downloadArquivoPDF(self, url, nomeArquivo) -> ArquivoPDF:
    """Faz o download de um conteúdo em formato PDF que é identificado por uma
 URL.<BR>
 A URL passada como parâmetro deve conter o caminho completo para o conteúdo
 desejado, inclusive o nome do servidor e o nome do protocolo (podendo ser
 "http" ou "https").<BR>
 EX: http://servidor.em.algum.lugar.br/nome.do.servico/alguma.pagina.pdf
 <P>
 Após uma consulta bem sucedida, é retornado o conteúdo no formato de um
 objeto do tipo {@link ArquivoPDF ArquivoPDF}.<BR>
 <P>
 OBS: o caminho completo é dispensável no caso em que esta função é executada
 após outra função bem sucedida de acesso à páginas do mesmo servidor. Nesta
 hipótese, basta especificar o nome da página e o caminho relativo ao mesmo
 servidor.<BR>
 <P>
 OBS2: caso o conteúdo PDF não seja acessado diretamente por meio de uma URL,
 mas indiretamente por meio da submissão de algum formulário ou métodos
 javascript, utilize o método alternativo {@link #exportaConteudoPDF()
 exportaConteudoPDF} para obter o conteúdo PDF após a submissão do formulário
 ou da execução do código javascript."""

    pass


  def downloadArquivoTexto(self, url, nomeArquivo) -> ArquivoTexto:
    """Faz o download de um conteúdo em formato texto que é identificado por uma
 URL.<BR>
 A URL passada como parâmetro deve conter o caminho completo para o conteúdo
 desejado, inclusive o nome do servidor e o nome do protocolo (podendo ser
 "http" ou "https").<BR>
 EX: http://servidor.em.algum.lugar.br/nome.do.servico/alguma.pagina.html
 <P>
 Após uma consulta bem sucedida, é retornado o conteúdo texto no formato de um
 objeto do tipo {@link ArquivoTexto ArquivoTexto}.<BR>
 <P>
 OBS: o caminho completo é dispensável no caso em que esta função é executada
 após outra função bem sucedida de acesso à páginas do mesmo servidor. Nesta
 hipótese, basta especificar o nome da página e o caminho relativo ao mesmo
 servidor."""

    pass


  def downloadImagem(self, url) -> Imagem:
    """Faz o download de uma imagem que é identificada por uma URL.<BR>
 A URL passada como parâmetro deve conter o caminho completo para a imagem
 desejada, inclusive o nome do servidor e o nome do protocolo (podendo ser
 "http" ou "https").<BR>
 EX: http://servidor.em.algum.lugar.br/nome.do.servico/alguma.pagina.html
 <P>
 Após uma consulta bem sucedida, é retornada a imagem (não fica armazenada em
 disco, mas sim em memória).
 <P>
 OBS: o caminho completo é dispensável no caso em que esta função é executada
 após outra função bem sucedida de acesso à páginas do mesmo servidor. Nesta
 hipótese, basta especificar o nome do arquivo de imagem e o caminho relativo
 ao mesmo servidor.
 <P>
 OBS-2: a imagem pode ser referente a qualquer coisa. Se for uma imagem do
 tipo "teste de CAPTCHA", você pode ainda utilizar o método
 {@link Janelas#pedeCAPTCHA(Imagem) pedeCAPTCHA} para descobrir o que ela
 representa (isto é, o usuário preenche o que ele mesmo vê).
 <P>"""

    pass


  def executaJavaScript(self, comando) -> Object:
    """Executa um comando em JavaScript diretamente sobre a página que está
 atualmente aberta internamente no ContÁgil.<BR>
 IMPORTANTE: Esta operação apenas está disponível caso inicialmente tenha sido
 habilitada a "navegação completa" através do método
 {@link WebExtrator#habilitaNavegacaoCompleta()
 habilitaNavegacaoCompleta}.<BR>
 Se isso não for feito, nada é executado."""

    pass


  def exibeJanelaEscondeDepois(self) -> None:
    """Exibe em uma janela o conteúdo atual da página (isto é, presumindo que alguma
 página foi solicitada anteriormente a esta função) e depois esconde
 automaticamente a janela caso o usuário tenha realizado alguma operação que
 cause a mudança de conteúdo da página (por exemplo, pressionando um botão de
 submissão de formulário).<BR>
 Durante este intervalo de tempo, esta método não retorna. Ou seja, o script
 fica em 'espera' até que a janela seja fechada.<BR>
 Trata-se de um recurso útil caso uma página possua muitos recursos visuais
 que requerem atenção do usuário. Fazendo desta forma, o script pode se tornar
 mais simples, deixando que o usuário interaja com a página através da janela
 que está sendo exibida, e assumindo o controle depois que a página é
 alterada.<BR>
 IMPORTANTE: Esta operação apenas está disponível caso inicialmente tenha sido
 habilitada a "navegação completa" através do método
 {@link WebExtrator#habilitaNavegacaoCompleta()
 habilitaNavegacaoCompleta}.<BR>
 Se isso não for feito, nada é apresentado."""

    pass


  def exportaConteudoBinario(self, nomeArquivo) -> bool:
    """Exporta o conteúdo binário que foi respondido na última requisição de
 página.<BR>
 Note que este é um método alternativo ao convencional
 {@link WebExtrator#getPaginaAtual() getPaginaAtual}.<BR>
 É recomendável para situações em que o resultado de uma consulta não é uma
 página HTML, mas sim o conteúdo de algum arquivo (como no caso de um arquivo
 PDF, por exemplo).<BR>
 Se a extensão do arquivo não for indicada, o sistema tenta inferir com base
 em outras informações da última requisição de página (isto é, utiliza
 internamente a função {@link WebExtrator#getExtensaoConteudoBinario()
 getExtensaoConteudoBinario})."""

    pass


  def exportaConteudoCSV(self) -> ArquivoCSV:
    """Exporta o conteúdo não-HTML que foi respondido na última requisição de página
 e que se refira a um conteúdo típico de arquivos CSV (arquivos texto com
 campos separados por algum caractere, usualmente a vírgula).<BR>
 Note que este é um método alternativo ao convencional
 {@link WebExtrator#getPaginaAtual() getPaginaAtual}.<BR>
 É recomendável para situações em que o resultado de uma consulta não é uma
 página HTML, mas sim o conteúdo de algum arquivo no padrão CSV.<BR>
 <BR>
 ATENÇÃO: Este método presume que o conteúdo no formato CSV já foi previamente
 requisitado através da submissão de algum formulário ou de uma URL
 requisitada. Você pode alternativamente utilizar o método
 {@link #downloadArquivoCSV(String, String, char) downloadArquivoCSV} para
 indicar a URL de um conteúdo CSV que deseja acessar."""

    pass


  def exportaConteudoExcel(self) -> ArquivoExcel:
    """Exporta o conteúdo não-HTML que foi respondido na última requisição de página
 e que se refira a um conteúdo típico de arquivos Excel (pode ser XLS ou
 XLSX).<BR>
 Note que este é um método alternativo ao convencional
 {@link WebExtrator#getPaginaAtual() getPaginaAtual}.<BR>
 É recomendável para situações em que o resultado de uma consulta não é uma
 página HTML, mas sim o conteúdo de algum arquivo no padrão XLS.<BR>
 <BR>
 ATENÇÃO: Este método presume que o conteúdo no formato XLS já foi previamente
 requisitado através da submissão de algum formulário ou de uma URL
 requisitada. Você pode alternativamente utilizar o método
 {@link #downloadArquivoExcel(String, String) downloadArquivoExcel} para
 indicar a URL de um conteúdo Excel que deseja acessar."""

    pass


  def exportaConteudoPDF(self, nomeArquivo) -> ArquivoPDF:
    """Exporta o conteúdo não-HTML que foi respondido na última requisição de página
 e que se refira a um conteúdo típico de arquivos PDF.<BR>
 Note que este é um método alternativo ao convencional
 {@link WebExtrator#getPaginaAtual() getPaginaAtual}.<BR>
 É recomendável para situações em que o resultado de uma consulta não é uma
 página HTML, mas sim o conteúdo de algum arquivo no padrão PDF.<BR>
 <BR>
 ATENÇÃO: Este método presume que o conteúdo no formato PDF já foi previamente
 requisitado através da submissão de algum formulário ou de uma URL
 requisitada. Você pode alternativamente utilizar o método
 {@link #downloadArquivoPDF(String, String) downloadArquivoPDF} para indicar a
 URL de um conteúdo PDF que deseja acessar."""

    pass


  def exportaConteudoZIP(self) -> ArquivoZIP:
    """Acessa o conteúdo que foi respondido na última requisição de página como se
 ele representasse um arquivo ZIP.<BR>
 Ou seja, se o resultado da consulta anterior não for um arquivo ZIP (por
 exemplo, se for uma página HTML), esta função resulta em erro.<BR>
 Por outro lado, se o resultado corresponde a um arquivo ZIP válido, esta
 função resulta em um objeto do tipo {@link ArquivoZIP ArquivoZIP} que permite
 acessar seu conteúdo compactado.<BR>
 OBS: o conteúdo acessado reside apenas em memória, e não em um arquivo
 gravado em um diretório local. Portanto não haverá de fato um arquivo ZIP
 (isto é, ele não tem nome, diretório ou extensão), mas haverão arquivos
 "internos" que podem ser acessados pelas funções {@link ArquivoZIP#proximo()
 proximo} e {@link ArquivoZIP#getConteudoTexto() getConteudoTexto}. Esses
 arquivos internos possuem cada qual um nome, diretório (relativo) e extensão."""

    pass


  def getCabecalhoNomes(self) -> list:
    """Retorna a relação de nomes de variáveis que foram definidas no "cabeçalho" da
 última reposta de consulta a uma página.<BR>
 Quando é utilizado o método {@link WebExtrator#abrirPagina(String)
 abrirPagina}, ou o método {@link WebExtrator#submeterFormulario(String)
 submeterFormulario}, ou o método
 {@link WebExtrator#autentica(String, Chave, String, String) autentica}, ou
 qualquer outro método que seja uma variação desses, o ContÁgil armazena além
 da "página de resposta" (aquela que é retornada pelo método
 {@link WebExtrator#getPaginaAtual() getPaginaAtual} também o "cabeçalho", o
 que inclui "Coockies" e outras variáveis.<BR>"""

    pass


  def getCabecalhoValor(self, nome) -> str:
    """Dado um nome de uma variável definida em um cabeçalho de resposta de consulta
 (isto é, dado um nome dentre aqueles retornados pela função
 {@link WebExtrator#getCabecalhoNomes() getCabecalhoNomes}), obtém o
 correspondente valor.<BR>
 Leia os comentários do método {@link WebExtrator#getCabecalhoNomes()
 getCabecalhoNomes} para mais informações sobre "cabeçalhos"."""

    pass


  def getCabecalhosRequisicao(self, method) -> list:
    """Retorna uma lista dos cabeçalhos (objetos org.apache.http.Header) de um
 método de requisição"""

    pass


  def getCabecalhosRequisicao(self, method) -> list:
    """Retorna uma lista dos cabeçalhos (objetos org.apache.http.Header) de um
 método de requisição"""

    pass


  def getCifrasHabilitadas(self) -> list:
    """Define uma lista de cifras (ciphers) que devem ser habilitadas para
 negociação SSL entre o cliente e o site Deve ser chamado antes de tentar
 abrir a página É necessário informar quando o site utiliza cifras obsoletas,
 caso contrário o cliente HTTP descarta elas A lista de nomes de cifras no
 Java 8 pode ser consultada em
 https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#Cipher
 no item JSSE Cipher Suite Names Para descobrir a cifra utilizada pelo site,
 com o site aberto no chrome digitar CTRL + SHIFT + I e clicar na aba Security"""

    pass


  def getCookie(self, nome) -> str:
    """Retorna o valor de um 'cookie' que está sendo mantido na sessão atual do
 WebExplorer."""

    pass


  def getCookies(self) -> list:
    """Retorna a relação de cookies que foram definidos até agora com o uso deste
 objeto WebExtrator.<BR>
 OBS: na medida que mais páginas vão sendo acessadas através do mesmo objeto
 WebExtrator, é possível que mais cookies vão sendo acumulados internamente.
 No entanto, quando se termina a execução de um script, todos os cookies
 recebidos durante sua execução são removidos.<BR>"""

    pass


  def getExtensaoConteudoBinario(self) -> str:
    """Retorna a extensão típica de arquivo associada ao conteúdo que foi respondido
 na última requisição de página.<BR>
 O critério para obter esta extensão é o seguinte:<BR>
 1º) Verifica se está presente o cabeçalho "Content-Disposition" na resposta
 do servidor. Se estiver, procura obter dali a extensão recomendada.<BR>
 2º) Caso não exista a indicação do item anterior, verifica-se o "tipo MIME"
 retornado pelo servidor no cabeçalho "Content-Type". Por exemplo, se o tipo
 MIME é "application/pdf", retorna "PDF".<BR>
 3º) Caso o "tipo MIME" se refira a mais de uma extensão possível, retorna
 aquela que esteja presente também na URL da última página requisitada (por
 exemplo, se tipo MIME é "application/octet-stream" e se a URL indica um
 arquivo de extensão "EXE", sugere a extensão "EXE").<BR>
 4º) Caso o tipo MIME se refira a mais de uma extensão possível, porém nenhuma
 delas corresponde àquela indicada na URL, desconsidera o que está na URL e
 considera uma das opções associadas ao tipo MIME. Por exemplo, se o tipo MIME
 é "application/vnd.ms-excel" e se a URL termina com a extensão "PHP",
 considera que é a extensão "XLS", que é a extensão comum de arquivos de
 planilha Excel, ignorando a extensão "PHP" indicada na URL.<BR>
 5º) Se todos os critérios acima falharem, tenta retornar a extensão indicada
 na URL, caso exista.<BR>
 6º) Se não for possível determinar a extensão do arquivo com base nos
 critérios acima, retorna NULL."""

    pass


  def getHistoricoEnderecos(self) -> list:
    """Caso esteja utilizando o modo de navegação "completo", este método retorna a
 lista de endereços URL que foram 'navegados' até agora. Há um limite de 20
 endereços (ou seja, retorna apenas os últimos 20 endereços solicitados). Note
 que os endereços podem incluir outros além daqueles expressamente solicitados
 por métodos do WebExtrator. Isso pode ocorrer, por exemplo, caso o
 WebExtrator esteja navegando por páginas com conteúdo dinâmico que consultam
 outras páginas, cada uma com endereço diferente."""

    pass


  def getImagemPagina(self) -> Imagem:
    """Caso esteja utilizando o modo de navegação "completo", captura o conteúdo da
 tela atual do navegador e retorna um objeto {@link Imagem Imagem} contendo a
 imagem capturada."""

    pass


  def getLastResponseHeaders(self) -> list:
    """Retorna a lista dos cabeçalhos da resposta da última requisição"""

    pass


  def getLastStatusCode(self) -> int:
    pass


  def getNomeArquivoConteudoBinario(self) -> str:
    """Retorna o nome de arquivo, conforme sugerido pelo site na resposta da última
 requisição de página.<BR>
 O critério para obter este nome "sugerido" é o seguinte:<BR>
 1º) Verifica se está presente o cabeçalho "Content-Disposition" na resposta
 do servidor. Se estiver, procura obter dali o nome de arquivo sugerido.<BR>
 2º) Se não existir a indicação do item anterior, tenta retornar o nome de
 arquivo indicado na URL, caso exista.<BR>
 3º) Se não for possível determinar o nome do arquivo com base nos critérios
 acima, retorna NULL.<BR>
 Atenção: é possível que o nome de arquivo obtido com uso deste método não
 seja do mesmo "tipo" ao qual se referem os dados. Isso pode ocorrer caso o
 site utilize páginas dinâmicamente construídas no servidor e não configure de
 forma correta os "cabeçalhos" dos dados retornados. Se isso ocorrer, é
 possível que este método sugira algum nome de arquivo com extensão "JSP" ou
 "ASP" ou "PHP", entre outras possibilidades, que são extensões geralmente
 utilizadas em "páginas ativas", não correspondendo ao tipo de conteúdo
 retornado. Se isso ocorrer, uma alternativa melhor é não utilizar este
 método, mas utilizar o método {@link WebExtrator#getExtensaoConteudoBinario()
 getExtensaoConteudoBinario}, que retorna somente uma "extensão". A partir
 desta informação pode-se "montar" um nome de arquivo que utilize a extensão
 correta e um nome novo criado pelo script."""

    pass


  def getNumTentativas(self) -> int:
    """Quantidade de vezes que deve tentar novamente em caso de erro por endereço
 inexistente ou por atraso na resposta, o que é comum em conexões envolvendo
 VPN. Parâmetro considerado apenas por alguns métodos de WebExtrator (ex: o
 método 'abrirPagina').<BR>
 O valor default é 0 (por padrão não tenta novamente em caso de erro), a menos
 que o usuário tenha configurado outro valor default nas configurações da
 aplicação ou do script.<BR>
 OBS: caso o endereço utilizado na consulta de fato não exista, ou caso tenha
 desconectado o computador da rede de forma intencional, a indicação de um
 número de 'vezes para tentar novamente' fará com que tais situações demorem
 mais para serem percebidas."""

    pass


  def getPaginaAtual(self, html) -> WebPagina:
    """Retorna o conteúdo da página atual a partir do conteúdo de um arquivo HTML.
 Útil para testes."""

    pass


  def getPaginaAtual(self) -> WebPagina:
    """Retorna o conteúdo da página atual (isto é, após a execução de algum dos
 métodos de comunicação com um serviço Web).<BR>
 <BR>
 Normalmente o conteúdo da página retornada por este método não é afetado por
 alterações no WebExtrator. Isto é, caso seja retornada a "página atual" e,
 depois, um novo endereço é consultado através do WebExtrator, a página
 retornada anteriormente, armazenada em WebPagina, não é modificada. Para se
 obter a nova "página atual", deve-se executar novamente este método.<BR>
 <BR>
 Porém, caso esteja utilizando o "modo de navegação completo", habilitado
 através de {@link WebExtrator#habilitaNavegacaoCompleta()
 habilitaNavegacaoCompleta}, o comportamento é outro: qualquer modificação
 realizada em WebExtrator afeta o conteúdo do objeto WebPagina retornado, e
 vice-versa (qualquer alteração em WebPagina, inclusive em algum de seus
 formulários, afeta o estado interno de WebExtrator).<BR>"""

    pass


  def getPaginaAtualForcaAtualizacao(self) -> WebPagina:
    """Retorna o conteúdo da página atual (isto é, após a execução de algum dos<BR>
 métodos de comunicação com um serviço Web) forçando a atualização do conteúdo
 interno.<BR>
 <BR>"""

    pass


  def getProtocolosSSLHabilitados(self) -> list:
    """Obtém uma relação de protocolos que podem ser utilizados em uma conexão SSL.
 Por padrão são utilizados diversos protocolos, mas pode-se restringir por
 este método uma relação específica (ex: "TLSv1.0", "TLSv1.1", "TLSv1.2")."""

    pass


  def getRSS(self, url) -> XMLTag:
    """Consulta uma fonte de dados RSS e baixa suas informações.<BR>
 Por exemplo, para consultar os dados do canal de "Economia" do portal "O
 GLOBO", pode-se utilizar a função:<BR>
 web.getRSS("http://oglobo2.globo.com/rss/plantaoeconomia.xml");<BR>
 O resultado disso é um objeto {@link XMLTag XMLTag} que dá acesso às diversas
 notícias relacionadas ao canal "Economia" deste portal.<BR>
 Para uma definição de "RSS", consulte: http://pt.wikipedia.org/wiki/RSS"""

    pass


  def getSubrotinasCapturaMouse(self) -> list:
    """Retorna a relação de subrotinas que foram indicadas através de
 {@link #addSubrotinaCapturaMouse(String, boolean, boolean)
 addSubrotinaCapturaMouse}"""

    pass


  def getSubrotinasCapturaTecla(self) -> list:
    """Retorna a relação de subrotinas que foram indicadas através de
 {@link #addSubrotinaCapturaTecla(String) addSubrotinaCapturaTecla}"""

    pass


  def getTempoEsperaTentativasMS(self) -> long:
    """Tempo de espera em milisegundos entre uma tentativa e outra caso o parâmetro
 'numTentativas' tenha sido configurado e caso tenha presenciado um erro do
 tipo 'endereço inexistente' ou atraso na resposta. Por padrão espera 1000 ms
 (1s).<BR>
 Este parâmetro é ignorado caso não tenha sido configurado um número de
 tentativas através do parâmetro 'numTentativas'.<BR>
 Um valor 'default' para este parâmetro pode ser configurado através das
 configurações gerais da aplicação ou do script."""

    pass


  def getTimeout(self) -> int:
    """Retorna a configuração do tempo máximo de espera para obter resposta do
 servidor"""

    pass


  def getTimeoutConexao(self) -> int:
    """Retorna a configuração do tempo máxima de espera para se conectar ao servidor"""

    pass


  def getUltimoResultadoBinario(self) -> byte:
    """Retorna o último conteúdo binário retornado pelo servidor."""

    pass


  def habilitaNavegacaoCompleta(self) -> bool:
    """Caso exista esta possibilidade na versão atual do aplicativo, esta ação faz
 com que a navegação nas páginas ocorra de forma "completa". Isto é, se houver
 algum código JavaScript ou qualquer outro recurso de execução "local" na
 página consultada, ele será executado localmente, como se estivesse sendo
 executado em um navegador normal (nada será apresentado na janela, mas é como
 se estivesse sendo apresentado).<BR>
 Apenas as navegações realizadas a partir deste ponto é que são afetadas por
 este método. Ou seja, utilize este método antes de abrir alguma página.<BR>
 <BR>
 Importante: dependendo da versão atual do aplicativo, este recurso pode não
 estar disponível. Verifique o resultado deste método para saber se foi bem
 sucedido. Caso não tenha sido bem sucedido, talvez seja o caso de alertar ao
 usuário sobre a necessidade de se utilizar outra versão do aplicativo.<BR>
 <BR>
 Note também que neste tipo de navegação gasta-se mais tempo navegando entre
 as páginas, pois é possível que a página contenha muitos recursos de exibição
 visual. Embora nada seja apresentado na janela, é como se estivesse sendo
 apresentado na janela.<BR>
 <BR>
 Utilize este tipo de navegação apenas quando houver necessidade de utilizar
 algum recurso disponível via JavaScript na página que está sendo
 navegada.<BR>
 <BR>
 <B>ATENÇÃO: Não utilize este recurso em páginas de servidores não
 confiáveis!!!</B>"""

    pass


  def habilitaNavegacaoCompletaComExibicao(self) -> bool:
    """Método alternativo a {@link WebExtrator#habilitaNavegacaoCompleta()
 habilitaNavegacaoCompleta} possibilitando que seja exibida uma 'janela' em
 segundo plano apresentando o conteúdo do 'navegador'.<BR>
 O padrão é não exibir esta janela. Porém, esta janela pode ser útil para
 'depuração' (isto é, quando se deseja visualizar na tela o que está ocorrendo
 por dentro do script, durante a navegação pelas páginas na Web).<BR>
 Além disso, é possível que alguma página possua componentes visuais 'ativos'
 que apenas são executados caso algo seja exibido na tela. <BR>
 OBS: além de exibir a janela, este método também faz com que o "modo de
 navegação completa' seja 'habilitado'. Note, porém, que para que o 'modo de
 navegação completa' seja 'habilitado', não é estritamente necessário que
 alguma janela de navegação esteja sendo exibida. Trata-se de um recurso
 adicional.<BR>"""

    pass


  def hasNavegacaoCompleta(self) -> bool:
    """Verifica se foi habilitada a navegação de forma "completa". Isto é, se houver
 algum código JavaScript na página que está sendo executada, este código é
 executado localmente, assim como ocorreria em um navegador comum."""

    pass


  def isPermiteRedirecionamentoCircular(self) -> bool:
    """Indica se está configurado para permitir o redirecionamento circular"""

    pass


  def isUseSmartcard(self) -> bool:
    """Retorna a indicação de que deve utilizar o smartcard em conexões seguras
 quando o servidor requisitar um certificado de usuário.<BR>
 O padrão é FALSE, o que significa que o smartcard não será requisitado.<BR>
 Você pode alterar esta configuração através do método
 {@link WebExtrator#setUseSmartcard(boolean) setUseSmartcard}."""

    pass


  def limparCabecalhoExtra(self, nome) -> None:
    """Remove determinado cabeçalho extra definido pelo usuário."""

    pass


  def limparCabecalhosExtras(self) -> None:
    """Apaga os cabeçalhos extras definidos pelo usuário."""

    pass


  def novoExtrator(self) -> WebExtrator:
    """Retorna um novo objeto "extrator" que é independente do objeto atual. Isto é,
 pode-se navegar de forma paralela em páginas da Web utilizando ambos
 extratores."""

    pass


  def novoFormulario(self, url, nome, id, metodo) -> WebFormulario:
    """Alternativa ao método {@link WebExtrator#novoFormulario(String)
 novoFormulario} com parâmetros adicionais para configurar algumas
 propriedades do formulário.<BR>
 Nem todos os campos deste método precisam ser preenchidos."""

    pass


  def novoFormulario(self, url) -> WebFormulario:
    """Cria um novo formulário que não tem relação a página alguma.<BR>
 Trata-se de um método útil quando se deseja submeter para consulta um
 formulário que é criado pelo próprio script (isto é, a relação de campos não
 é proveniente de uma página na Web, mas é formada pelo script).<BR>
 Depois de preenchido, este formulário pode ser submetido através da função
 {@link WebExtrator#submeterFormulario(WebFormulario) submeterFormulario}.<BR>
 OBS: Sempre que for possível, não utilize este método, mas sim o método
 {@link WebPagina#getFormulario(String) getFormulario}, ou o método
 {@link WebPagina#getFormularioComCampo(String) getFormularioComCampo}, ou
 ainda o método {@link WebPagina#getFormularios() getFormularios}. Este método
 deve ser reservado para situações em que não é possível conhecer o formulário
 desejado a partir de uma página conhecida."""

    pass


  def removeCabecalhoRequisicao(self, method, nome) -> None:
    pass


  def removeCabecalhoRequisicao(self, method, nome) -> None:
    pass


  def removeSubrotinaCapturaMouse(self, subrotina) -> None:
    """Desfaz o vínculo a uma determinada subrotina que foi indicada através de
 {@link #addSubrotinaCapturaMouse(String, boolean, boolean)
 addSubrotinaCapturaMouse}"""

    pass


  def removeSubrotinaCapturaTecla(self, subrotina) -> None:
    """Desfaz o vínculo a uma determinada subrotina que foi indicada através de
 {@link #addSubrotinaCapturaTecla(String) addSubrotinaCapturaTecla}"""

    pass


  def removeSubrotinasCapturaMouse(self) -> None:
    """Desfaz o vínculo a todas as subrotinas que foram indicadas através de
 {@link #addSubrotinaCapturaMouse(String, boolean, boolean)
 addSubrotinaCapturaMouse}"""

    pass


  def removeSubrotinasCapturaTecla(self) -> None:
    """Desfaz o vínculo a todas as subrotinas que foram indicadas através de
 {@link #addSubrotinaCapturaTecla(String) addSubrotinaCapturaTecla}"""

    pass


  def runMetodoDELETE(self, url, queryParams, formato, charset, valor) -> str:
    """Utiliza o padrão RESTful para enviar uma requisição HTTP-DELETE sobre uma
 URI."""

    pass


  def runMetodoGET(self, url, queryParams, formato, charset) -> str:
    """Utiliza o padrão RESTful para enviar uma requisição HTTP-GET sobre uma URI."""

    pass


  def runMetodoGETDownloadArquivo(self, url, queryParams, formato, charset, nomeArquivo) -> None:
    """Utiliza o padrão RESTful para enviar uma requisição HTTP-GET sobre uma
 URI.<BR>
 O resultado é baixado diretamente para o arquivo indicado no último
 parâmetro."""

    pass


  def runMetodoPATCH(self, url, queryParams, formato, charset, valor) -> str:
    """Utiliza o padrão RESTful para enviar uma requisição HTTP-PATCH sobre uma URI."""

    pass


  def runMetodoPOST(self, url, queryParams, formato, charset, valor) -> str:
    """Utiliza o padrão RESTful para enviar uma requisição HTTP-POST sobre uma URI."""

    pass


  def runMetodoPOSTDownloadArquivo(self, url, queryParams, formatoEnvio, formatoResposta, charset, valor, nomeArquivo) -> None:
    """Utiliza o padrão RESTful para enviar uma requisição HTTP-POST sobre uma
 URI.<BR>
 O resultado é baixado diretamente para o arquivo indicado no último
 parâmetro."""

    pass


  def runMetodoPUT(self, url, queryParams, formato, charset, valor) -> str:
    """Utiliza o padrão RESTful para enviar uma requisição HTTP-PUT sobre uma URI."""

    pass


  def setAutoRedirecionamento(self, b) -> None:
    """Configura se deve fazer ou não o "auto redirecionamento" sempre que for
 necessário.<BR>
 A configuração padrão é "true" (isto é, faz o auto redirecionamento).<BR>
 O "auto redirecionamento" consiste em deixar que o WebExtrator
 automaticamente siga um novo endereço que é retornado como resposta de uma
 outra requisição.<BR>
 Caso o "auto redirecionamento" seja FALSE, o WebExtrator não irá
 automaticamente seguir um novo endereço. Ao invés disso, quando for observada
 uma situação de redirecionamento, será devolvida a resposta HTTP 302 (MOVED
 TEMPORARILY) e o cabeçalho "Location" deve indicar qual seria o novo endereço
 a ser seguido."""

    pass


  def setCampo(self, nomeFormulario, nomeCampo, valor) -> bool:
    """Procura na página atual por um formulário que possua um determinado nome. Uma
 vez localizado o formulário, procura um campo que possua um determinado nome.
 Encontrado o campo, altera seu valor para o valor indicado no parâmetro.<BR>
 Se a página atual não contém o formulário com o nome indicado, este método
 aguarda até 2 segundos para que o formulário apareça (o que pode ocorrer
 eventualmente caso uma mudança de página tenha sido solicitada pelo script um
 pouco antes).<BR>
 Note que é possível realizar o mesmo procedimento através da execução de
 vários métodos alternativos:<BR>
 
 <PRE>
 // Um só comando:
 web.setCampo(nomeForm, nomeCampo, valorCampo);

 // Equivale a todos esses comandos:
 var pag = web.getPaginaAtual();
 var form = pag.getFormulario(nomeForm);
 form.setCampo(nomeCampo, valorCampo);

 </PRE>"""

    pass


  def setCampoSenha(self, nomeFormulario, nomeCampoLogin, nomeCampoSenha) -> bool:
    """Faz o mesmo que {@link WebExtrator#setCampo(String, String, String)
 setCampo}, com a diferença que aqui se refere a um campo do tipo 'senha' e
 seu conteúdo é solicitado ao usuário, durante execução de script, em uma
 janela própria de senha.<BR>
 Este método é diferente do método
 {@link WebExtrator#autentica(String, Chave, String, String) autentica} pois
 aqui não se indica nenhuma URL (isto é, nenhuma requisição é feita ao
 servidor neste ato). É necessário que o script submeta o formulário de login
 em alguma etapa posterior."""

    pass


  def setCifrasHabilitadas(self, cifrasHabilitadas) -> None:
    pass


  def setConfiguracaoInternetExplorer(self, nome, opcao) -> bool:
    """Altera configurações internas que são específicas ao INTERNET EXPLORER.<BR>
 Essas configurações podem ter impacto enquanto estiver utilizando o 'modo de
 navegação completa'.<BR>
 OBS: as configurações aqui representadas são as mesmas utilizadas pelo
 navegador quando não estiver utilizando o ContÁgil.<BR>
 <BR>
 OBS: dependendo de como estão configuradas as políticas de segurança na
 máquina local e de quais são as prerrogativas de acesso do usuário atual,
 este método pode não funcionar.<BR>
 <BR>
 OPÇÕES DE CONFIGURAÇÃO:<BR>
 =====================================================<BR>
 Atualmente você poderá alterar por este método apenas uma das seguintes
 opções de configurações do Internet Explorer relativas à 'zona Internet':<BR>
 <LI>Deseja exibir conteúdo misto</LI><BR>
 Opção relacionada ao alerta de segurança que pode ser exibido em páginas que
 misturam conteúdo seguro (HTTPS) com conteúdo não seguro (HTTP)<BR>
 <BR>
 <LI>Navegar por subquadros em diferentes domínios</LI><BR>
 <BR>
 <LI>Enviar dados de formulário não criptografados</LI><BR>
 <BR>
 <LI>Instalação de itens da área de trabalho</LI><BR>
 <BR>"""

    pass


  def setEstrategiaProxySerpro(self, url, estrategia) -> None:
    """Método descontinuado - mantido apenas para não causar problemas em scripts
 que usavam
 
 Define uma estratégia de acesso usando ou não o proxy Serpro para um site. O
 usuário pode indicar que um site deve ser acessado usando o proxy Serpro, sem
 uso do proxy ou com redirecionamento manual (no caso do portal CNIS por
 exemplo)"""

    pass


  def setLogMudancaEndereco(self, flag) -> None:
    """Caso esteja utilizando o modo de navegação "completo", este método permite
 indicar se deve ou não deve relatar no LOG qualquer mudança de endereço (URL)
 que houver, sendo solicitado pelo navegador do ContÁgil. Este método afeta
 somente as requisições posteriores a ele (ou seja, não mostrará aquilo que já
 ocorreu antes deste método ser utilizado).<BR>
 Note que os endereços podem incluir outros além daqueles expressamente
 solicitados por métodos do WebExtrator. Isso pode ocorrer, por exemplo, caso
 o WebExtrator esteja navegando por páginas com conteúdo dinâmico que
 consultam outras páginas, cada uma com endereço diferente."""

    pass


  def setNumTentativas(self, numTentativas) -> None:
    """Quantidade de vezes que deve tentar novamente em caso de erro por endereço
 inexistente ou por atraso na resposta, o que é comum em conexões envolvendo
 VPN. Parâmetro considerado apenas por alguns métodos de WebExtrator (ex: o
 método 'abrirPagina').<BR>
 O valor default é 0 (por padrão não tenta novamente em caso de erro), a menos
 que o usuário tenha configurado outro valor default nas configurações da
 aplicação ou do script.<BR>
 OBS: caso o endereço utilizado na consulta de fato não exista, ou caso tenha
 desconectado o computador da rede de forma intencional, a indicação de um
 número de 'vezes para tentar novamente' fará com que tais situações demorem
 mais para serem percebidas."""

    pass


  def setPermiteRedirecionamentoCircular(self, permiteRedirecionamentoCircular) -> None:
    """Altera a configuração de permitir o redirecionamento circular"""

    pass


  def setPoliticaCookies(self, politica) -> None:
    """Defini a politica de Cookies há ser utilizada. Não funciona para o modo
 Navegação Completa. As politicas disponíveis são: "default" , "ignore",
 "netscape", "standard" e "standard_strict""""

    pass


  def setProtocolosSSLHabilitados(self, protocolosSSLHabilitados) -> None:
    """Define uma relação de protocolos que podem ser utilizados em uma conexão SSL.
 Por padrão são utilizados diversos protocolos, mas pode-se restringir por
 este método uma relação específica (ex: "TLSv1.0", "TLSv1.1", "TLSv1.2").<BR>
 OBS: para ser efetivo, deve-se também executar o método
 {@link #setUseSmartcard(boolean) setUseSmartcard}."""

    pass


  def setProtocolosSSLHabilitadosSemZerarConexao(self, protocolosSSLHabilitados) -> None:
    """Define uma relação de protocolos que podem ser utilizados em uma conexão SSL.
 Não zera a conexão para poder ser usado em paralelismo. Por padrão são
 utilizados diversos protocolos, mas pode-se restringir por este método uma
 relação específica (ex: "TLSv1.0", "TLSv1.1", "TLSv1.2").<BR>"""

    pass


  def setProxy(self, endereco, porta) -> None:
    pass


  def setTempoEsperaTentativasMS(self, tempoEsperaTentativasMS) -> None:
    """Tempo de espera em milisegundos entre uma tentativa e outra caso o parâmetro
 'numTentativas' tenha sido configurado e caso tenha presenciado um erro do
 tipo 'endereço inexistente' ou atraso na resposta. Por padrão espera 1000 ms
 (1s).<BR>
 Este parâmetro é ignorado caso não tenha sido configurado um número de
 tentativas através do parâmetro 'numTentativas'.<BR>
 Um valor 'default' para este parâmetro pode ser configurado através das
 configurações gerais da aplicação ou do script."""

    pass


  def setTimeout(self, timeoutLeitura, timeoutConexao) -> None:
    """Configura os tempos máximos de espera para conexão com o servidor e para
 obter respostas a solicitações enviadas."""

    pass


  def setTimeout(self, timeout) -> None:
    """Configura o tempo máximo de espera para conectar ao servidor e obter resposta
 do servidor em solicitações de abrir página e submeter formulário."""

    pass


  def setUseSmartcard(self, useSmartcard) -> None:
    """Configura o WebExtrator para utilizar o smartcard em conexões seguras quando
 o servidor requisitar um certificado de usuário.<BR>
 OBS: se estiver utilizando o "MODO DE NAVEGAÇÃO COMPLETA", este método é
 ignorado, pois nesta hipótese a determinação pela utilização ou não do
 certificado digital é determinada integralmente pelo componente de navegação,
 o qual, por sua vez, se utiliza das mesmas configurações realizadas no
 navegador de páginas do sistema."""

    pass


  def setUseSmartcardSemZerarConexao(self) -> None:
    """Sem funcionalidade (faz o mesmo que setUseSmartcard)
 
 Não é possível setar o smartcard sem refazer o cliente (reiniciar toda a
 conexão)
 
 Mantido por enquanto até que scripts que usam o método possam ser alterados
 
 Configura o WebExtrator para utilizar o smartcard em conexões seguras quando
 o servidor requisitar um certificado de usuário. <BR>
 O sem zerar conexão é para não atrapalhar WebExtrator paralelos."""

    pass


  def setUtilizaSNI(self, utilizaSNI) -> None:
    """Define se utiliza a funcionalidade SNI (Server Name Indication) em handshake
 SSL, necessária para acessar servidores virtuais (true), ou se evita fazer a
 conexão utilizando o nome do servidor (false)."""

    pass


  def submeterFormulario(self, form) -> None:
    """Submete um formulário com seus campos já preenchidos, obtendo assim uma nova
 página do servidor em resposta a esta requisição.<BR>
 Esta função faz um "HTTP-POST" para obter a página desejada.<BR>
 Após uma consulta bem sucedida, o conteúdo da página encontra-se disponível
 através da função {@link WebExtrator#getPaginaAtual() getPaginaAtual}. <BR>
 OBS: caso o 'modo de navegação completa' esteja 'habilitado', o comportamento
 desta função é diferente: ao invés de enviar diretamente um novo "HTTP-POST",
 simplesmente se executa o comando JavaScript 'submit' associado ao formulário
 indicado como parâmetro. Porém, para este comportamento ocorrer, além do
 'modo de navegação completa' estar 'habilitado', também é necessário que o
 formulário tenha sido obtido a partir da 'página atual' (isto é, não pode ter
 sido gerado um novo objeto 'WebFormulario' a partir do nada)."""

    pass


  def submeterFormulario(self, form, nomeBotao) -> None:
    """Submete um formulário com seus campos já preenchidos, obtendo assim uma nova
 página do servidor em resposta a esta requisição.<BR>
 Esta função faz um "HTTP-POST" para obter a página desejada.<BR>
 Após uma consulta bem sucedida, o conteúdo da página encontra-se disponível
 através da função {@link WebExtrator#getPaginaAtual() getPaginaAtual}.<BR>
 <BR>
 OBS: caso o 'modo de navegação completa' esteja 'habilitado', o comportamento
 desta função é diferente: ao invés de enviar diretamente um novo "HTTP-POST",
 simplesmente se executa o comando JavaScript 'submit' associado ao formulário
 indicado como parâmetro. Porém, para este comportamento ocorrer, além do
 'modo de navegação completa' estar 'habilitado', também é necessário que o
 formulário tenha sido obtido a partir da 'página atual' (isto é, não pode ter
 sido gerado um novo objeto 'WebFormulario' a partir do nada)."""

    pass


  def submeterFormulario(self, nomeFormulario) -> None:
    """Submete um formulário com seus campos já preenchidos, obtendo assim uma nova
 página do servidor em resposta a esta requisição.<BR>
 Esta função faz um "HTTP-POST" para obter a página desejada.<BR>
 O formulário é pesquisado a partir de seu nome, conforme os formulários
 definidos na página atual (isto é, conforme os formulários obtidos na página
 retornada por {@link WebExtrator#getPaginaAtual() getPaginaAtual}.<BR>
 Após uma consulta bem sucedida, o conteúdo da nova página encontra-se
 disponível através da função {@link WebExtrator#getPaginaAtual()
 getPaginaAtual}. <BR>
 OBS: caso o 'modo de navegação completa' esteja 'habilitado', o comportamento
 desta função é diferente: ao invés de enviar diretamente um novo "HTTP-POST",
 simplesmente se executa o comando JavaScript 'submit' associado ao formulário
 indicado como parâmetro. Porém, para este comportamento ocorrer, além do
 'modo de navegação completa' estar 'habilitado', também é necessário que o
 formulário tenha sido obtido a partir da 'página atual' (isto é, não pode ter
 sido gerado um novo objeto 'WebFormulario' a partir do nada)."""

    pass


  def submeterFormularioTrataErro(self, form) -> bool:
    """Função equivalente a {@link WebExtrator#submeterFormulario(WebFormulario)
 submeterFormulario}, mas com tratamento de erro.<br>
 <br>
 Isto é, se houver algum tipo de erro ao tentar acessar a página (ex: servidor
 não encontrado ou solicitação inválida), não joga exceção. Ao invés disso,
 simplesmente retorna FALSE.<br>
 <br>
 Note que a outra função, a {@link WebExtrator#abrirPagina(String)
 abrirPagina}, não trata erros no sentido de que, na eventualidade de um erro,
 uma exeção é jogada, e se a exceção não é tratada pelo código que a chamou, o
 programa pára de executar.<br>
 <br>
 Esta função alternativa é conveniente no sentido que o tratamento da exceção
 fica dispensado, bastando tratar o retorno da função."""

    pass


  def toString(self) -> str:
    pass

class WebFormulario ():
  """Objeto que pode ser utilizado por uma linguagem de scripting para obter o
 conteúdo de um formulário existente em uma página consultada na Web através
 do objeto {@link WebExtrator WebExtrator}.
 <P>
 
 Uma forma de obter objetos deste tipo é através da função
 {@link WebPagina#getFormularios() getFormularios}.
 <P>
 
 Os campos de um formulário podem ser alterados executando a função
 {@link WebCampo#setValor(String) setValor} dos objetos
 {@link WebCampo WebCampo} correspondentes a cada campo retornado pela função
 {@link WebFormulario#getCampo(String) getCampo} ou pela função
 {@link WebFormulario#getCampos() getCampos}.
 <P>
 
 Uma alternativa mais simples para se alterar o valor de um campo é através da
 função {@link WebFormulario#setCampo(String, String) setCampo}.<BR>"""

  def addArquivo(self, nomeCampo, arquivo, conteudo, contentType, charset) -> None:
    """Inclui um arquivo para ser enviado pelo formulário quando o método é
 MULTIPART.<BR>
 Esta alternativa permite enviar um conteúdo em memória como sendo
 um arquivo em disco.<BR>
 Nos demais métodos essa informação é ignorada."""

    pass


  def addArquivo(self, nomeCampo, arquivo) -> None:
    """Inclui um arquivo para ser enviado pelo formulário quando o método é
 MULTIPART.<BR>
 Nos demais métodos essa informação é ignorada."""

    pass


  def addArquivo(self, nomeCampo, arquivo, conteudo, contentType, charset) -> None:
    """Inclui um arquivo para ser enviado pelo formulário quando o método é
 MULTIPART.<BR>
 Esta alternativa permite enviar um texto em memória como sendo
 um arquivo em disco.<BR>
 Nos demais métodos essa informação é ignorada."""

    pass


  def addArquivo(self, nomeCampo, arquivo, contentType, charset) -> None:
    """Inclui um arquivo para ser enviado pelo formulário quando o método é
 MULTIPART.<BR>
 Nos demais métodos essa informação é ignorada."""

    pass


  def addCabecalho(self, nome, valor) -> None:
    """Cadastra um cabeçalho de conexão a ser utilizado na execução do
 formulário"""

    pass


  def addCampo(self, nome) -> WebCampo:
    """Cria um novo campo no formulário com um determinado nome.<BR>
 OBS: Geralmente não é uma boa idéia adicionar novos campos a um
 formulário existente em uma página, pois normalmente um servidor de
 páginas não espera receber coisas novas.<BR>
 Utilize este método em situações onde o formulário não é obtido a partir
 de uma página, mas é construído internamente pelo próprio script."""

    pass


  def addCookie(self, nome, valor) -> None:
    pass


  def getCabecalhos(self) -> list:
    """Retorna os cabecalhos de conexão cadastrados"""

    pass


  def getCampo(self, nome) -> WebCampo:
    """Retorna um campo do formulário dada a indicação do nome deste campo."""

    pass


  def getCampos(self) -> list:
    """Retorna a relação de todos os campos definidos neste formulário."""

    pass


  def getCharset(self) -> str:
    """Retorna o charset a ser utilizado no envio dos dados do formulário.<BR/>
 O padrão é ISO-8859-1."""

    pass


  def getHTML(self) -> str:
    """Retorna o código HTML referente a este formulário (o qual faz parte do
 código HTML de uma página que contém o formulário)."""

    pass


  def getID(self) -> str:
    """Retorna o nome de identificação única deste formulário (códigos HTML
 novos utilizam este campo "id" no lugar do campo "nome")."""

    pass


  def getMetodo(self) -> str:
    """Indica qual método "HTTP" deve ser utilizado no momento da submissão
 deste relatório para o servidor.<BR>
 Conforme especificado no padrão "HTTP", pode ser o método "GET", "POST"
 ou "MULTIPART".<BR>
 Seja qual for o método, o programador de script pode trabalhar com o
 formulário exatamente da mesma forma. Isto é, não é necessários e
 preocupar com isso.<BR>"""

    pass


  def getNome(self) -> str:
    """Retorna o nome deste formulário conforme definido no código HTML da
 página que o contém.<BR>
 OBS: códigos HTML novos utilizam o campo "id" no lugar do campo "name",
 portanto para códigos HTML novos deve-se utilizar a função
 {@link WebFormulario#getID() getID}."""

    pass


  def getOpcoesComboBox(self, nomeCampo) -> Tabela:
    """Caso este formulário tenha sido obtido de uma página HTML, este método permite retornar na forma
 de uma tabela as opções que podem ser escolhidas em um campo do formulário do tipo "combo-box" (caixa de seleção).<BR>"""

    pass


  def getPosicao(self) -> int:
    """Posição do formulário dentro da página. A primeira posição é a de número 1, a segunda é a de número 2,
 e assim sucessivamente. O número 0 indica ausência desta informação."""

    pass


  def getReferer(self) -> str:
    """Retorna o endereço completo utilizado na obtenção do formulário e serve
 para compor o endereço de envio quando a URL do formulário não indica o
 caminho completo"""

    pass


  def getURL(self) -> str:
    """Retorna a URL para onde deve ser enviado este formulário no momento de
 sua submissão."""

    pass


  def println(self) -> None:
    """Escreve o conteúdo do formulário no LOG.<BR>
 Útil para fazer depuração.<BR>
 OBS: escreve apenas relação de campos e valores, sem escrever o conteúdo
 HTML do formulário."""

    pass


  def removeCampo(self, nome) -> None:
    """Remove um campo do formulário dada a indicação do nome deste campo."""

    pass


  def removeCampos(self) -> None:
    """Remove todos os campos do formulário."""

    pass


  def setCampo(self, nome, valor) -> None:
    """Altera o valor de um campo do formulário.<BR>
 Este método é equivalente a executar esses outros dois em sequência:<BR>
 <BR> // Obtém um objeto do tipo WebCampo deste formulário associado a um
 nome<BR>
 campo = formulario.getCampo(nome)<BR> // Altera o valor do campo<BR>
 campo.setValor(valor)<BR>
 <BR>
 OBS: se não existe um campo com este nome no formulário, um novo campo é
 adicionado ao formulário.<BR>"""

    pass


  def setCampoTextoComTratamento(self, nome, valor) -> None:
    """Altera o valor de um campo do formulário que é apresentado na forma de um "texto".<BR>
 Isto é, um campo do tipo "texto" onde é possível inserir múltiplas linhas de texto (normalmente ele
 apresenta "barras de rolagem" para permitir a visualização de partes do texto que não estão visíveis).<BR>
 Internamente este tipo de campo é chamado de "textarea".<BR>
 Diferentemente dos demais campos, este campo requer um tratamento especial dos caracteres (isto é, conversão para uma sintaxe típica
 do "HTML", como ocorre com caracteres acentuados, por exemplo).<BR>"""

    pass


  def setCharset(self, charset) -> None:
    """Altera o charset a ser utilizado no envio dos dados do formulário"""

    pass


  def setHTML(self, html) -> None:
    """Define o código HTML referente a este formulário"""

    pass


  def setID(self, id) -> None:
    """Define a identificação única deste formulário."""

    pass


  def setMetodoGET(self) -> None:
    """Altera o "método" de submissão deste formulário para "GET". Ou seja, os
 parâmetros do formulário são passados juntamente com a URL. Indicado para
 situações com poucos campos e onde os campos possuem pouco conteúdo.<BR>
 OBS: Geralmente não é uma boa idéia alterar o "método" de submissão de um
 formulário existente em uma página, pois normalmente um servidor de
 páginas não espera receber um formulário através de um método diferente
 daquele para o qual foi programado.<BR>
 Utilize este método em situações onde o formulário não é obtido a partir
 de uma página, mas é construído internamente pelo próprio script."""

    pass


  def setMetodoMULTIPART(self) -> None:
    """Altera o "método" de submissão deste formulário para "MULTIPART". Esse
 método é similar ao "POST", exceto que os parâmetros são enviados de uma
 forma diferente, além de permitir o envio de arquivos para o servidor.<BR>
 OBS: Geralmente não é uma boa idéia alterar o "método" de submissão de um
 formulário existente em uma página, pois normalmente um servidor de
 páginas não espera receber um formulário através de um método diferente
 daquele para o qual foi programado.<BR>
 Utilize este método em situações onde o formulário não é obtido a partir
 de uma página, mas é construído internamente pelo próprio script."""

    pass


  def setMetodoPOST(self) -> None:
    """Altera o "método" de submissão deste formulário para "POST". Ou seja, os
 parâmetros do formulário são passados internamente na requisição HTTP
 (não aparecem na URL). Indicado para situações com muitos campos ou com
 campos contendo muitos dados.<BR>
 OBS: Geralmente não é uma boa idéia alterar o "método" de submissão de um
 formulário existente em uma página, pois normalmente um servidor de
 páginas não espera receber um formulário através de um método diferente
 daquele para o qual foi programado.<BR>
 Utilize este método em situações onde o formulário não é obtido a partir
 de uma página, mas é construído internamente pelo próprio script."""

    pass


  def setNome(self, nome) -> None:
    """Define o nome deste formulário (isto é, seu atributo 'name').<BR>
 OBS: códigos HTML novos utilizam o campo "id" no lugar do campo "name",
 portanto para códigos HTML novos deve-se utilizar a função
 {@link WebFormulario#setID(String) setID}."""

    pass


  def setPosicao(self, posicao) -> None:
    """Posição do formulário dentro da página. A primeira posição é a de número 1, a segunda é a de número 2,
 e assim sucessivamente. O número 0 indica ausência desta informação."""

    pass


  def setReferer(self, referer) -> None:
    """Configura o endereço completo da página utilizado na obteção do
 formulário"""

    pass


  def setURL(self, action) -> None:
    """Define ou altera a URL para onde deve ser enviado este formulário no
 momento de sua submissão.<BR>
 OBS: normalmente não há necessidade de utilizar esta função, a menos que
 seja necessário alterar o comportamento de um formulário existente em uma
 página."""

    pass


  def toString(self) -> str:
    pass

class WebPagina ():
  """Objeto que pode ser utilizado por uma linguagem de scripting para obter o
 conteúdo de uma página consultada na Web através do objeto
 {@link WebExtrator WebExtrator}.
 <P>
 
 Uma forma de obter um objeto deste tipo é através da função
 {@link WebExtrator#getPaginaAtual() getPaginaAtual}.
 <P>
 
 Pode-se relacionar os formulários existentes na página através do método
 {@link WebPagina#getFormulario(String) getFormulario} ou do método
 {@link WebPagina#getFormularios() getFormularios} e daí alterar o conteúdo de
 seus campos conforme a necessidade.
 <P>"""

  def contem(self, texto) -> bool:
    """Verifica se esta página contém um determinado texto.<BR>
 Esta função procura a ocorrência do texto de diversas formas, em todas
 elas desprezando acentuação e caracteres de maiúsculas/minúsculas:<BR> -
 Considera o texto literalmente, sem considerar espaços em branco entre as
 palavras, dentro do conteúdo HTML da página.<BR> - Considera o texto
 literalmente, sem considerar espaços em branco entre as palavras, dentro
 do conteúdo formatado da página (isto é, não HTML).<BR> - Considera o
 texto como se fosse uma "expressão regular", dentro do conteúdo HTML da
 página.<BR> - Considera o texto como se fosse uma "expressão regular",
 dentro do conteúdo formatado da página (isto é, não HTML).<BR>"""

    pass


  def exportaHTML(self, nomeArquivo) -> None:
    """Exporta o conteúdo desta página para um novo arquivo do tipo HTML,
 sobrescrevendo o arquivo que porventura já exista.<BR>"""

    pass


  def getArquivosJavaScriptEnderecos(self) -> str:
    """Retorna uma relação de endereços URL para outros arquivos contendo código JavaScript que
 são utilizados por esta página."""

    pass


  def getDivisorias(self) -> list:
    """Retorna a lista de 'divisórias' internas à página atual. Cada 'divisória' é apresentado na forma de um novo
 objeto {@link WebPagina WebPagina}, como se fossem pequenas páginas dentro de outra página maior.<BR>
 <BR>
 IMPORTANTE: este método apenas pode ser utilizado caso o 'modo de navegação completa' tenha sido
 previamente habilitado através do método {@link WebExtrator#habilitaNavegacaoCompleta() habilitaNavegacaoCompleta}. Se não
 fizer isso, o resultado não será o esperado."""

    pass


  def getElementoPrincipal(self) -> WebElemento:
    """Obtém o WebElemento principal da página, a partir do qual é possível selecionar elementos individuais da página
 utilizando a sintaxe da biblioteca JSoup."""

    pass


  def getFormulario(self, nome) -> WebFormulario:
    """Retorna o formulário identificado por um determinado nome interno (isto
 é, conforme definido no atributo "name" da tag &lt;FORM&gt;
 correspondente).<BR>
 Formulários sem nome não podem ser localizados com o uso deste método."""

    pass


  def getFormularioComCampo(self, campo) -> WebFormulario:
    """Retorna o formulário que contém um determinado campo (o qual, por sua
 vez, é identificado por seu nome interno, isto é, conforme definido no
 atributo "name" da tag &lt;INPUT&gt; ou &lt;SELECT&gt;, dependendo do
 tipo do campo).<BR>
 Se nenhum formulário for encontrado com o campo especificado, a função
 retorna NULL.<BR>
 Se há mais de um formulário na mesma página com o mesmo campo, retorna
 arbitrariamente qualquer um deles.<BR>"""

    pass


  def getFormularios(self) -> list:
    """Retorna a relação de formulários existentes nesta página."""

    pass


  def getFrame(self, id) -> WebPagina:
    """Retorna um determinado 'frame' interno à página atual que é identificado por um determinado 'id'.<BR>
 O 'frame' é retornado na forma de um novo objeto {@link WebPagina WebPagina}, apresentando apenas o conteúdo
 do 'frame' como se fosse uma 'página'.<BR>
 Se não for encontrado um 'frame' com o 'id' identificado no parâmetro, retorna NULL.<BR>
 IMPORTANTE: este método apenas pode ser utilizado caso o 'modo de navegação completa' tenha sido
 previamente habilitado através do método {@link WebExtrator#habilitaNavegacaoCompleta() habilitaNavegacaoCompleta}. Se não
 fizer isso, o resultado não será o esperado."""

    pass


  def getFrame(self, n) -> WebPagina:
    """Retorna o conteúdo do primeiro n-ésimo 'frame' interno desta página, assumindo que esta página possui múltiplos 'frames'. Cada 'frame' é apresentado na forma de um novo
 objeto {@link WebPagina WebPagina}, como se fossem pequenas páginas dentro de outra página maior.<BR>
 <BR>
 IMPORTANTE: este método apenas pode ser utilizado caso o 'modo de navegação completa' tenha sido
 previamente habilitado através do método {@link WebExtrator#habilitaNavegacaoCompleta() habilitaNavegacaoCompleta}. Se não
 fizer isso, o resultado não será o esperado."""

    pass


  def getFrames(self) -> list:
    """Retorna a lista de 'frames' internos à página atual. Cada 'frame' é apresentado na forma de um novo
 objeto {@link WebPagina WebPagina}, como se fossem pequenas páginas dentro de outra página maior.<BR>
 <BR>
 IMPORTANTE: este método apenas pode ser utilizado caso o 'modo de navegação completa' tenha sido
 previamente habilitado através do método {@link WebExtrator#habilitaNavegacaoCompleta() habilitaNavegacaoCompleta}. Se não
 fizer isso, o resultado não será o esperado."""

    pass


  def getHTML(self) -> str:
    """Retorna o conteúdo HTML desta página."""

    pass


  def getHTMLCompleto(self, divisorias, frames) -> str:
    """Retorna o contéudo HTML desta página e também de todas
 as suas 'partes' (isto é, de todas as suas 'divisórias'
 e de todos os seus 'frames').<BR>
 O outro método {@link WebPagina#getHTML() getHTML} retorna apenas
 o conteúdo HTML da própria página (o que pode não incluir o conteúdo
 HTML de suas partes).<BR>
 <BR>
 Caso não existam 'frames' ou 'divisórias' na página atual, o resultado
 é o mesmo daquele obtido pelo método  {@link WebPagina#getHTML() getHTML}.<BR>
 Caso existam 'frames' ou 'divisórias' na página atual, os conteúdos HTML correspondentes
 a todas essas partes são 'concatenados' entre si, um após o outro. Isto é, após um abre/fecha
 de tag &lt;HTML&gt; correspondente à página atual, segue-se o conteúdo de uma parte, depois de outra 
 parte, e assim sucessivamente.<BR>
 Trata-se de um método conveniente quando se pretende depois buscar algum conteúdo considerando
 não apenas a página, mas também os conteúdos internos a cada uma de suas 'partes'.<BR>
 <BR>
 IMPORTANTE: este método apenas pode ser utilizado caso o 'modo de navegação completa' tenha sido
 previamente habilitado através do método {@link WebExtrator#habilitaNavegacaoCompleta() habilitaNavegacaoCompleta}. Se não
 fizer isso, o resultado não será o esperado."""

    pass


  def getID(self) -> str:
    """Se este objeto WebPagina se refere a uma DIVISÓRIA ou a um FRAME, retorna aqui o 'id' correspondente. Caso contrário, retorna NULL."""

    pass


  def getImagem(self, nome) -> Imagem:
    """Retorna uma imagem que é identificada por um determinado nome dentro da página.<BR>
 Isto é, procura por todas as tags do tipo "img" dentro do código HTML da página. Dentre as tags
 encontradas, considera apenas aquela cujo atributo "id" corresponde ao parâmetro "nome" indicado
 neste método. Se encontrar alguma, retorna o objeto que representa esta imagem. Se encontrar mais 
 de uma imagem com o mesmo nome na página, retorna a primeira ocorrência."""

    pass


  def getImagemEndereco(self, nome) -> str:
    """Retorna o endereço de uma imagem que é identificada por um determinado nome dentro da página.<BR>
 Isto é, procura por todas as tags do tipo "img" dentro do código HTML da página. Dentre as tags
 encontradas, considera apenas aquela cujo atributo "id" corresponde ao parâmetro "nome" indicado
 neste método. Se encontrar alguma, retorna o conteúdo do atributo "src" desta imagem. Se não encontrar
 nenhuma, retorna NULL. Se encontrar mais de uma imagem com o mesmo nome na página, retorna a primeira
 ocorrência."""

    pass


  def getImagensEnderecos(self) -> Tabela:
    """Retorna uma tabela contendo os endereços e os nomes de todas as imagens existentes na página.<BR>
 A primeira coluna da tabela corresponde aos endereços (isto é, o atributo "src" da tag "img").<BR>
 A segunda coluna da tabela corresponde aos correspondentes nomes (isto é, o atributo "id" da tag "img").<BR>
 OBS: algumas páginas do tipo "dinâmica" possuem um código em JavaScript que faz a apresentação de imagens. Se isso
 ocorrer, tal imagem não será considerada por este método.<BR>"""

    pass


  def getTabela(self, posicao, completo) -> WebTabela:
    """Retorna uma tabela que supostamente existe na página.<BR>
 O parâmetro "posicao" é utilizado em situações onde há mais de uma tabela
 em uma mesma página. Ele indica qual dessas tabelas deve retornar
 (indicar 0 para a primeira tabela, e daí em diante).<BR>
 Caso a tabela solicitada não seja encontrada, retorna NULL."""

    pass


  def getTabela(self, posicao) -> WebTabela:
    """Retorna uma tabela que supostamente existe na página.<BR>
 O parâmetro "posicao" é utilizado em situações onde há mais de uma tabela
 em uma mesma página. Ele indica qual dessas tabelas deve retornar
 (indicar 0 para a primeira tabela, e daí em diante).<BR>
 Caso a tabela solicitada não seja encontrada, retorna NULL."""

    pass


  def getTabelaComExpressaoRegular(self, expressao, completo) -> WebTabela:
    """Retorna uma tabela que supostamente existe na página, desde que dentro
 dela (isto é, em alguma de suas células) exista um conteúdo que atenda a
 uma expressão regular.<BR>
 Caso exista mais de uma tabela na página, procura pela primeira
 ocorrência de uma tabela que atenda à expressão regular.<BR>"""

    pass


  def getTabelaComExpressaoRegular(self, expressao) -> WebTabela:
    """Retorna uma tabela que supostamente existe na página, desde que dentro
 dela (isto é, em alguma de suas células) exista um conteúdo que atenda a
 uma expressão regular.<BR>
 Caso exista mais de uma tabela na página, procura pela primeira
 ocorrência de uma tabela que atenda à expressão regular.<BR>"""

    pass


  def getTabelaComTamanho(self, linhas, colunas, completo) -> WebTabela:
    """Retorna uma tabela que supostamente existe na página com um determinado
 tamanho definido em quantidade de linhas e colunas.<BR>
 Caso exista mais de uma tabela na página, procura pela primeira
 ocorrência de uma tabela com o tamanho especificado.<BR>
 Para obter uma tabela indicando apenas um número de colunas, mas com
 qualquer quantidade de linhas, basta especificar 0 no parâmetro "linhas".<BR>
 Para obter uma tabela indicando apenas um número de linhas, mas com
 qualquer quantidade de colunas, basta especificar 0 no parâmetro
 "colunas".<BR>"""

    pass


  def getTabelaComTamanho(self, linhas, colunas) -> WebTabela:
    """Retorna uma tabela que supostamente existe na página com um determinado
 tamanho definido em quantidade de linhas e colunas.<BR>
 Caso exista mais de uma tabela na página, procura pela primeira
 ocorrência de uma tabela com o tamanho especificado.<BR>
 Para obter uma tabela indicando apenas um número de colunas, mas com
 qualquer quantidade de linhas, basta especificar 0 no parâmetro "linhas".<BR>
 Para obter uma tabela indicando apenas um número de linhas, mas com
 qualquer quantidade de colunas, basta especificar 0 no parâmetro
 "colunas".<BR>"""

    pass


  def getTabelaComTexto(self, texto) -> WebTabela:
    """Retorna uma tabela que supostamente existe na página, desde que dentro
 dela (isto é, em alguma de suas células) conste um texto que é indicado
 no parâmetro.<BR>
 Caso exista mais de uma tabela na página, procura pela primeira
 ocorrência de uma tabela que contenha o texto especificado.<BR>"""

    pass


  def getTabelaComTexto(self, texto, completo) -> WebTabela:
    """Retorna uma tabela que supostamente existe na página, desde que dentro
 dela (isto é, em alguma de suas células) conste um texto que é indicado
 no parâmetro.<BR>
 Caso exista mais de uma tabela na página, procura pela primeira
 ocorrência de uma tabela que contenha o texto especificado.<BR>"""

    pass


  def getTabelas(self) -> list:
    """Retorna em uma lista a relação de tabelas encontradas na página HTML.<BR>
 Cada tabela é um objeto do tipo WebTabela.<BR>
 Caso na página uma tabela contenha outras tabelas internas a ela (tabelas
 aninhadas), os dados destas são incluídos naquela (isto é, não retorna
 múltiplas tabelas, mas sim uma tabela contendo os dados de todas as
 tabelas aninhadas a ela)."""

    pass


  def getTabelas(self, completo) -> list:
    """Retorna em uma lista a relação de tabelas encontradas na página HTML.<BR>
 Cada tabela é um objeto do tipo WebTabela.<BR>."""

    pass


  def getTexto(self) -> str:
    """Retorna o conteúdo TEXTO desta página (isto é, o conteúdo da tag
 &lt;BODY&gt;, e depois de remover todas as tags, deixando apenas o texto
 que aparece entre as tags)."""

    pass


  def getTitulo(self) -> str:
    """Caso a página contenha um título (isto é, algo informado internamente através
 da tag &lt;TITLE&gt;), retorna seu conteúdo."""

    pass


  def getURL(self) -> str:
    """Retorna a URL da última página consultada."""

    pass


  def importaHTML(self, nomeArquivo) -> str:
    """Importa o conteúdo de uma página armazena em um arquivo do tipo HTML.<BR>"""

    pass


  def imprimeParaPDF(self, nome_arquivo) -> ArquivoPDF:
    """Imprime a página em arquivo HTML, utilizando os recursos referenciados na página."""

    pass


  def imprimeParaPDF(self, nome_arquivo, css_interno, url_pagina) -> ArquivoPDF:
    """Imprime a página em arquivo HTML, utilizando os recursos referenciados na página. <br>
 Pelo CSS, ode-se configurar tamanho da página, margins, fonte, etc. <br>
 O parâmetro url_pagina serve de referência para obter os demais recursos, como imagens, arquivos CSS, etc
 mas deve ser utilizado apenas quando não se consegue obtê-los automaticamente. Para indicar uma referência local, deve-se utilizar
 o formato "file:/D:/pasta/subpasta/pagina.html" que é o aceito como URL."""

    pass


  def imprimeParaPDF(self, nome_arquivo, css_interno) -> ArquivoPDF:
    """Imprime a página em arquivo HTML, utilizando os recursos referenciados na página.<br>
 Pelo CSS, ode-se configurar tamanho da página, margins, fonte, etc. <br>"""

    pass


  def marcaCheckBox(self, campo, opcao, desmarcaOutros) -> bool:
    """Simula a ação do usuário de 'marcar' uma 'caixa de seleção' ('check-box' ou 'radio-button').<BR>
 <BR>
 É executado internamente sobre a página um código 'javascript' que é responsável por localizar
 todos os campos identificados com o nome indicado no primeiro parâmetro, cujo 'valor' é aquele indicado
 no segundo parâmetro. O terceiro parâmetro indica se deve ou não desmarcar todos os demais campos
 que possuam o mesmo 'nome', mas 'valor' distinto.<BR>
 <BR>
 Exemplo de um código HTML com múltiplas opções de 'marcar':<BR>
 <CODE>
 &lt;input type="radio" name="myradios" value="opcao1"/&gt;<BR>
 &lt;input type="radio" name="myradios" value="opcao2"/&gt;<BR>
 </CODE>
 Exemplo de como 'marcar' a opção 'opcao2' e desmarcar a 'opcao1':<BR>
 <CODE>
 marcaCheckBox("myradios","opcao2",true);<BR>
 </CODE>
 <BR>
 IMPORTANTE: este método apenas pode ser utilizado caso o 'modo de navegação completa' tenha sido
 previamente habilitado através do método {@link WebExtrator#habilitaNavegacaoCompleta() habilitaNavegacaoCompleta}. Se não
 fizer isso, o resultado não será o esperado."""

    pass


  def println(self) -> None:
    """Escreve o conteúdo da página no LOG.<BR>
 Útil para fazer depuração.<BR>
 OBS: escreve apenas relação de formulários e tabelas, sem escrever o
 conteúdo HTML da página."""

    pass


  def toString(self) -> str:
    pass

class WebTabela ():
  """Objeto que representa uma tabela de uma página consultada na Web através do
 objeto {@link WebExtrator WebExtrator}.
 <P>
 
 Uma forma de obter objetos deste tipo é através da função
 {@link WebPagina#getTabelas() getTabelas}.
 <P>
 
 Caso uma determinada célula da tabela HTML contenha um hyperlink (algo que é
 definido pela tag &lt;A HREF&gt;), a célula correspondente neste objeto
 possuirá um "atributo" cujo nome é "<B>LINK</B>" contendo o hyperlink, o
 qual pode ser acessado através do método
 {@link Tabela#getAtributo(int, int, String) getAtributo}.
 <P>
 
 O conteúdo HTML de cada célula é indicado pelo "atributo" de célula cujo nome
 é "<B>HTML</B>", o qual pode ser acessado através do método
 {@link Tabela#getAtributo(int, int, String) getAtributo}.
 <P>
 
 Observação: este objeto herda todos os métodos de um objeto
 {@link Tabela Tabela}, portanto ele pode ser lido e também pode ser
 modificado, assim como uma tabela. Pode também ter seu conteúdo exportado
 para um arquivo (Excel, CSV), exportado para uma
 {@link TabelaUsuario TabelaUsuario}, ou ainda apresentado em uma janela
 através do método {@link Janelas#mostraTabela(Tabela) mostraTabela}.
 <P>"""

  def criaTabelaTransformaSubtabelas(self, html, idTabela, nome, acrescenta, separador) -> None:
    """Cria uma tabela a partir de uma tabela HTML e transforma subtabelas dentro de colunas
 da tabela HTML em uma única linha na tabela
 <BR>Por exemplo, a coluna... <br>
 	{@literal <td>}
 		Fulano de tal <br>
 		{@literal <table> <tr> <td> beltrano da silva </td> </tr> </table> } <br>
  {@literal</td>}<br>
  ... seria convertida para o valor abaixo de o separado usado fosse '|' <br>
  
  Fulano de tal|beltrano da silva"""

    pass


  def getHTML(self) -> str:
    """Retorna o código HTML referente a esta tabela (o qual faz parte do código
 HTML de uma página que contém a tabela).<BR>
 OBS: Se esta tabela for alterada utilizando algum dos métodos do objeto
 {@link Tabela Tabela}, o conteúdo HTML original não é alterado. Ou seja,
 o resultado desta função permanece sempre o mesmo."""

    pass


  def getLink(self, linha, coluna) -> str:
    """Caso uma determinada célula da tabela esteja relacionada a um HIPERLINK, retorna o endereço indicado
 neste hiperlink."""

    pass


  def println(self) -> None:
    """Escreve o conteúdo da tabela no LOG.<BR>
 Útil para fazer depuração.<BR>
 OBS: escreve apenas relação de linhas e colunas, sem escrever o conteúdo
 HTML da tabela."""

    pass

class XMLTag ():
  """Objeto que representa uma "tag" de um arquivo XML, incluindo todas as suas propriedades e também outras "tags" internas a ela.<BR>
 
 OBS: caso o mesmo arquivo XML possua diversas ocorrências de uma mesma tag, para cada ocorrência deve existir uma instância diferente deste objeto (por exemplo, se a tag "prod" aparece três vezes
 em um arquivo XML, teremos três objetos do tipo "XMLTag", um para cada ocorrência de "prod").<BR>
 
 Atenção: caso o conteúdo XML seja inválido por algum motivo (por exemplo, se há abertura de "tag" mas não há o correspondente fechamento), este objeto pode ainda assim ser criado, mas com a
 indicação do erro que foi detectado. Os métodos que indicam erros são os seguintes:<BR>
 {@link XMLTag#hasErros() hasErros}<BR>
 {@link XMLTag#getErros() getErros}<BR>
 
 Note porém que, em caso de erro, é possível que nenhuma informação útil sobre "tags", conteúdos ou atributos, seja retornada pelos métodos (nada mais além das mensagens de erro).<BR>"""

  def adicionaTag(self, nomeFilha, conteudoFilha, secaoCDATA) -> XMLTag:
    """Adiciona, à tag atual, uma nova tag dados seu nome e seu conteúdo."""

    pass


  def adicionaTag(self, tagNova) -> XMLTag:
    """Adiciona, à tag atual, uma nova tag."""

    pass


  def atualizaTag(self, nomeFilha, conteudoFilha, secaoCDATA) -> XMLTag:
    """Atualiza uma tag filha existente na tag atual."""

    pass


  def getArvoreXML(self) -> str:
    """Cria uma árvore XML em formato texto a partir do nó atual."""

    pass


  def getAtributo(self, nome) -> str:
    """Retorna o valor de um "atributo" relacionado à tag.<BR>
 Por exemplo, considere o seguinte conteúdo XML:<BR>
 <CODE> &lt;table titulo="Um título" cor="VERMELHO"&gt;<BR>
 &nbsp;&nbsp;&nbsp;TABELA<BR>
 &lt;/table&gt;<BR>
 </CODE> Neste exemplo, a tag "table" possui dois atributos. Um dos atributos chama-se "titulo" e possui o valor "Um título". O outro atributo chama-se "cor" e possui o valor "VERMELHO"."""

    pass


  def getComentario(self) -> str:
    """Caso esta tag possua algum "comentário", ele é retornado por esta função. Caso contrário, retorna um texto vazio."""

    pass


  def getConteudo(self) -> str:
    """Retorna o conteúdo informado dentro da tag (isto é, após a abertura da tag e antes do fechamento dela).<BR>
 Por exemplo, considere o seguinte conteúdo XML:<BR>
 <CODE> &lt;table titulo="Um título" cor="VERMELHO"&gt;<BR>
 &nbsp;&nbsp;&nbsp;TABELA<BR>
 &lt;/table&gt;<BR>
 </CODE> Neste exemplo, a tag "table" possui o conteúdo "TABELA". Vale observar que nem toda tag possui algum conteúdo. O exemplo abaixo ilustra uma situação de uma tag sem conteúdo.<BR>
 <CODE> &lt;table titulo="Um título" cor="VERMELHO"/&gt;<BR>
 </CODE>"""

    pass


  def getErros(self) -> list:
    """Caso algum erro tenha ocorrido no tratamento do conteúdo XML, retorna as mensagens de erro correspondentes. Se nenhum erro ocorreu, retorna uma lista vazia."""

    pass


  def getNome(self) -> str:
    """Retorna o nome desta "tag". O nome inclui o "prefixo", caso exista algum.<BR>
 Caso esta seja a tag "RAIZ" do documento (o primeiro objeto de todos), o nome é sempre "#document"."""

    pass


  def getNomesAtributos(self) -> list:
    """Retorna os nomes de todos os atributos definidos nesta tag.<BR>
 Retorna uma lista vazia se não há atributos."""

    pass


  def getTag(self, nome) -> XMLTag:
    """Procura dentro da "tag" atual por outra "tag" localizada em nível hierárquico imediatamente inferior ao atual, utilizando como critério de pesquisa o nome da "tag".<BR>
 OBS: é possível que exista mais de uma ocorrência de tags com mesmo nome. Nesta hipótese, este método retorna apenas a primeira ocorrência. Se desejar obter todas as ocorrências de tags com
 mesmo nome, utilize o método {@link XMLTag#getTags() getTags}."""

    pass


  def getTagPai(self) -> XMLTag:
    """Caso este objeto tenha sido obtido a partir de outra "tag", retorna a "tag" de onde ela veio (isto é, a tag "pai").<BR>
 Caso contrário, se não há uma tag "pai" em relação a esta, retorna NULL."""

    pass


  def getTags(self, nome) -> list:
    """Procura dentro da "tag" atual por outras "tags" localizadas em níveis hierárquicos imediatamente inferiores ao atual, utilizando como critério de pesquisa o nome da "tag".<BR>
 OBS: é possível que exista mais de uma ocorrência de tags com mesmo nome, por isso este método retorna uma lista e não apenas um único objeto."""

    pass


  def getTags(self) -> list:
    """Obtém a relação das "tags" localizadas dentro da "tag" atual (apenas no nível hierárquico imediatamente inferior a esta).<BR>
 Se não há nenhuma outra "tag" localizada dentro da "tag" atual, retorna uma lista vazia. <BR>
 Para consultar outras "tags" localizadas em níveis hierárquicos mais baixos, é necessário executar este mesmo método sobre cada elemento retornado por este método.<BR>
 Por exemplo, considere o seguinte conteúdo XML:<BR>
 <CODE> &lt;table titulo="Um título" cor="VERMELHO"&gt;<BR>
 &nbsp;&nbsp;&nbsp;&lt;linha&gt;<BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;coluna&gt;<BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CELULA 1<BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/coluna&gt;<BR>
 &nbsp;&nbsp;&nbsp;&lt;/linha&gt;<BR>
 &nbsp;&nbsp;&nbsp;&lt;linha&gt;<BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;coluna&gt;<BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CELULA 2<BR>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/coluna&gt;<BR>
 &nbsp;&nbsp;&nbsp;&lt;/linha&gt;<BR>
 &lt;/table&gt;<BR>
 </CODE> Neste exemplo, a tag "table" possui duas "tags" com nome "linha" imediatamente subordinadas a ela.<BR>
 Cada uma das tags "linha", por sua vez, possui uma tag "coluna" imediatamente subordinada a ela.<BR>"""

    pass


  def getTagsExpressaoRegular(self, expressao) -> list:
    """Procura dentro da "tag" atual por outras "tags" localizadas em níveis hierárquicos imediatamente inferiores ao atual, utilizando como critério de pesquisa o nome da "tag".<BR>
 OBS: é possível que exista mais de uma ocorrência de tags com mesmo nome, por isso este método retorna uma lista e não apenas um único objeto.<BR>
 Esta alternativa possibilita pesquisar utilizando expressão regular sobre os nomes das tags."""

    pass


  def getTextoEsquematico(self) -> str:
    """Retorna o conteúdo inteiro da "tag" (o que inclui todas as "tags" interiores que podem haver) na forma de um texto "esquemático".<BR>
 Cada "tag" interior é informada em uma linha diferente do texto, fazendo a "identação" com espaços em branco conforme o "nível" em que a "tag" interior é localizada (isto é, "tags" mais
 internas são mais deslocadas à direita).<BR>
 Qualquer conteúdo "texto" que houver é apresentado em uma linha separada.<BR>
 Os atributos são apresentados aos pares: nome=valor.<BR>
 O texto refere-se a esta "tag" e a todo o conteúdo localizado dentro dela (incluindo outras "tags"). Caso este método seja executado sobre alguma "tag" interior a ela, apenas o conteúdo daquela
 "tag" é apresentado, e assim sucessivamente.<BR>
 OBS: o conteúdo retornado por este método não é necessariamente o mesmo conteúdo texto XML que foi consultado originalmente, pois é possível que o conteúdo original não tenha quebra de linhas
 ou não siga a convenção adotada por este método."""

    pass


  def hasErros(self) -> bool:
    """Retorna a indicação de que algum erro ocorreu durante o tratamento do conteúdo XML"""

    pass


  def insereAntesTag(self, referencia, tagFilha) -> XMLTag:
    """Insere uma tag, filha da tag atual, antes de uma tag filha existente."""

    pass


  def insereAntesTag(self, referencia, nomeFilho, conteudoFilho, secaoCDATA) -> XMLTag:
    """Insere uma tag, filha da tag atual, antes de uma tag filha existente."""

    pass


  def insereAtributo(self, nome, conteudo) -> None:
    """Insere, na tag atual, um atributo e seu conteúdo."""

    pass


  def procuraTag(self, nome) -> XMLTag:
    """Procura recursivamente dentro da "tag" atual por uma ocorrência da "tag" indicada como parâmetro.<BR>
 Esta função difere da função {@link XMLTag#getTag(String) getTag} no sentido que aqui não se limita a buscar apenas no nível hierárquico imediatamente inferior, mas também em todos os níveis
 inferiores a este.<BR>
 Caso exista mais de uma ocorrência, retorna apenas a primeira delas."""

    pass


  def procuraTags(self, nome) -> list:
    """Procura recursivamente dentro da "tag" atual por uma ou mais ocorrências da "tag" indicada como parâmetro.<BR>
 Esta função difere da função {@link XMLTag#getTags(String) getTags} no sentido que aqui não se limita a buscar apenas no nível hierárquico imediatamente inferior, mas também em todos os níveis
 inferiores a este.<BR>
 Caso exista mais de uma ocorrência, todas elas são retornadas (exceto se existem outras ocorrências da mesma "tag" dentro de outra com mesmo nome).<BR>"""

    pass


  def removeAtributo(self, nome) -> None:
    """Insere, na tag atual, um atributo e seu conteúdo."""

    pass


  def removeTag(self, tagRemover) -> None:
    """Remove, da tag atual, uma de suas tags filhas."""

    pass


  def renomeiaTag(self, nomeNovo) -> XMLTag:
    """Renomeia a tag atual."""

    pass


  def setConteudo(self, conteudo) -> None:
    """Adiciona, à tag atual, um conteúdo texto"""

    pass


  def toString(self) -> str:
    pass
